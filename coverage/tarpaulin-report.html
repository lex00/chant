<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","alex","Documents","checkouts","chant","build.rs"],"content":"fn main() {\n    // Get git commit hash - prefer env var (set by Docker build) over git command\n    let git_sha = std::env::var(\"GIT_SHA\").unwrap_or_else(|_| {\n        std::process::Command::new(\"git\")\n            .args([\"rev-parse\", \"--short\", \"HEAD\"])\n            .output()\n            .map(|output| String::from_utf8_lossy(\u0026output.stdout).trim().to_string())\n            .unwrap_or_else(|_| \"unknown\".to_string())\n    });\n\n    println!(\"cargo:rustc-env=GIT_SHA={}\", git_sha);\n\n    // Get build date - prefer env var (set by Docker build) over date command\n    let build_date = std::env::var(\"BUILD_DATE\").unwrap_or_else(|_| {\n        std::process::Command::new(\"date\")\n            .arg(\"+%Y-%m-%d\")\n            .output()\n            .map(|output| String::from_utf8_lossy(\u0026output.stdout).trim().to_string())\n            .unwrap_or_else(|_| \"unknown\".to_string())\n    });\n\n    println!(\"cargo:rustc-env=BUILD_DATE={}\", build_date);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","examples","research-workflow","developer-path","src","sample-code","auth.rs"],"content":"use std::collections::HashMap;\n\n// TODO: Replace with proper password hashing library\nconst SECRET_KEY: \u0026str = \"hardcoded-secret-123\";\n\npub struct AuthService {\n    users: HashMap\u003cString, String\u003e,\n    sessions: HashMap\u003cString, String\u003e,\n}\n\nimpl AuthService {\n    pub fn new() -\u003e Self {\n        Self {\n            users: HashMap::new(),\n            sessions: HashMap::new(),\n        }\n    }\n\n    // FIXME: This doesn't actually hash passwords properly\n    pub fn register(\u0026mut self, username: String, password: String) -\u003e Result\u003c(), String\u003e {\n        if username.is_empty() {\n            return Err(\"Username cannot be empty\".to_string());\n        }\n\n        // TODO: Add password strength validation\n        if self.users.contains_key(\u0026username) {\n            return Err(\"User already exists\".to_string());\n        }\n\n        // WARNING: Not actually hashing!\n        let hashed = format!(\"{}:{}\", SECRET_KEY, password);\n        self.users.insert(username, hashed);\n        Ok(())\n    }\n\n    pub fn login(\u0026mut self, username: String, password: String) -\u003e Result\u003cString, String\u003e {\n        let stored = self.users.get(\u0026username)\n            .ok_or(\"Invalid credentials\")?;\n\n        let attempt = format!(\"{}:{}\", SECRET_KEY, password);\n\n        if stored != \u0026attempt {\n            // TODO: Add rate limiting to prevent brute force\n            return Err(\"Invalid credentials\".to_string());\n        }\n\n        // FIXME: Session IDs should be cryptographically random\n        let session_id = format!(\"{}_{}\", username, stored.len());\n        self.sessions.insert(session_id.clone(), username);\n\n        Ok(session_id)\n    }\n\n    pub fn verify_session(\u0026self, session_id: \u0026str) -\u003e Option\u003c\u0026String\u003e {\n        self.sessions.get(session_id)\n    }\n\n    // TODO: Add session expiration\n    pub fn logout(\u0026mut self, session_id: \u0026str) {\n        self.sessions.remove(session_id);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_register() {\n        let mut auth = AuthService::new();\n        assert!(auth.register(\"alice\".to_string(), \"password123\".to_string()).is_ok());\n    }\n\n    // TODO: Add more test coverage\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","examples","research-workflow","developer-path","src","sample-code","database.rs"],"content":"use std::collections::HashMap;\n\npub struct Database {\n    data: HashMap\u003cString, String\u003e,\n}\n\nimpl Database {\n    pub fn new() -\u003e Self {\n        Self {\n            data: HashMap::new(),\n        }\n    }\n\n    // FIXME: This is vulnerable to SQL injection if we switch to real SQL\n    pub fn query(\u0026self, query: \u0026str) -\u003e Option\u003cString\u003e {\n        // TODO: Implement actual query parsing\n        // For now, just treat query as a key lookup\n        let key = query.trim();\n        self.data.get(key).cloned()\n    }\n\n    pub fn insert(\u0026mut self, key: String, value: String) -\u003e Result\u003c(), String\u003e {\n        if key.is_empty() {\n            return Err(\"Key cannot be empty\".to_string());\n        }\n\n        // TODO: Add validation for value size limits\n        self.data.insert(key, value);\n        Ok(())\n    }\n\n    // TODO: Add update and delete operations\n\n    // FIXME: This exposes internal structure\n    pub fn get_all(\u0026self) -\u003e \u0026HashMap\u003cString, String\u003e {\n        \u0026self.data\n    }\n\n    // TODO: Add transaction support\n    pub fn batch_insert(\u0026mut self, items: Vec\u003c(String, String)\u003e) {\n        for (key, value) in items {\n            // WARNING: Ignoring errors here\n            let _ = self.insert(key, value);\n        }\n    }\n}\n\n// TODO: Add connection pooling\n// TODO: Add error recovery mechanisms\n// FIXME: No tests for this module!\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","examples","research-workflow","developer-path","src","sample-code","utils.rs"],"content":"// TODO: Move these to a proper utility crate\n\npub fn validate_email(email: \u0026str) -\u003e bool {\n    // FIXME: This is a very naive email validator\n    email.contains('@') \u0026\u0026 email.contains('.')\n}\n\npub fn sanitize_input(input: \u0026str) -\u003e String {\n    // TODO: Add proper input sanitization\n    input.replace('\u003c', \"\").replace('\u003e', \"\")\n}\n\n// WARNING: This function has high cyclomatic complexity\npub fn process_user_input(input: \u0026str, mode: \u0026str, options: Vec\u003c\u0026str\u003e) -\u003e Result\u003cString, String\u003e {\n    if input.is_empty() {\n        return Err(\"Empty input\".to_string());\n    }\n\n    let sanitized = sanitize_input(input);\n\n    if mode == \"strict\" {\n        if sanitized.len() \u003e 100 {\n            return Err(\"Input too long\".to_string());\n        }\n        if !validate_email(\u0026sanitized) \u0026\u0026 options.contains(\u0026\"require_email\") {\n            return Err(\"Invalid email\".to_string());\n        }\n        if sanitized.contains(\"admin\") \u0026\u0026 !options.contains(\u0026\"allow_admin\") {\n            return Err(\"Admin keyword not allowed\".to_string());\n        }\n    } else if mode == \"lenient\" {\n        if sanitized.len() \u003e 500 {\n            return Err(\"Input too long\".to_string());\n        }\n    } else if mode == \"custom\" {\n        // TODO: Implement custom validation rules\n        if options.is_empty() {\n            return Err(\"Custom mode requires options\".to_string());\n        }\n        for option in options {\n            if option == \"no_special_chars\" \u0026\u0026 sanitized.chars().any(|c| !c.is_alphanumeric()) {\n                return Err(\"Special characters not allowed\".to_string());\n            }\n        }\n    } else {\n        return Err(\"Unknown mode\".to_string());\n    }\n\n    Ok(sanitized)\n}\n\n// FIXME: No error handling\npub fn parse_config(config_str: \u0026str) -\u003e HashMap\u003cString, String\u003e {\n    use std::collections::HashMap;\n\n    let mut map = HashMap::new();\n    for line in config_str.lines() {\n        // TODO: Handle malformed lines gracefully\n        let parts: Vec\u003c\u0026str\u003e = line.split('=').collect();\n        if parts.len() == 2 {\n            map.insert(parts[0].to_string(), parts[1].to_string());\n        }\n    }\n    map\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","agent.rs"],"content":"//! Agent runtime for ollama with function calling support.\n//!\n//! Uses ureq HTTP client for direct API communication.\n\nuse anyhow::{anyhow, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse url::Url;\n\nuse crate::tools;\n\nconst MAX_ITERATIONS: usize = 50;\nconst DEFAULT_OLLAMA_ENDPOINT: \u0026str = \"http://localhost:11434\";\n\n/// Calculate exponential backoff delay with jitter\nfn calculate_backoff(attempt: u32, base_delay_ms: u64) -\u003e u64 {\n    let exponential = 2u64.saturating_pow(attempt - 1);\n    let delay = base_delay_ms.saturating_mul(exponential);\n    // Add jitter: Â±10% of delay to avoid thundering herd\n    let jitter = (delay / 10).saturating_mul(\n        ((attempt as u64).wrapping_mul(7)) % 21 / 10, // Deterministic pseudo-random jitter\n    );\n    if attempt.is_multiple_of(2) {\n        delay.saturating_add(jitter)\n    } else {\n        delay.saturating_sub(jitter)\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct ChatRequest {\n    model: String,\n    messages: Vec\u003cMessage\u003e,\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    tools: Vec\u003cValue\u003e,\n    stream: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Message {\n    role: String,\n    content: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_calls: Option\u003cVec\u003cToolCall\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_call_id: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ToolCall {\n    id: String,\n    function: ToolCallFunction,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ToolCallFunction {\n    name: String,\n    arguments: Value,\n}\n\n#[derive(Debug, Deserialize)]\nstruct ChatResponse {\n    message: ResponseMessage,\n}\n\n#[derive(Debug, Deserialize)]\nstruct ResponseMessage {\n    #[allow(dead_code)]\n    role: String,\n    content: String,\n    #[serde(default)]\n    tool_calls: Vec\u003cToolCall\u003e,\n}\n\n/// Run an agent loop using direct HTTP with function calling.\n///\n/// This creates an agent loop where:\n/// 1. Model receives a prompt and thinks about what to do\n/// 2. Model requests tool execution if needed\n/// 3. Runtime executes the tool\n/// 4. Runtime feeds result back to model\n/// 5. Loop continues until task is complete\npub fn run_agent(\n    endpoint: \u0026str,\n    model: \u0026str,\n    system_prompt: \u0026str,\n    user_message: \u0026str,\n    callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n) -\u003e Result\u003cString\u003e {\n    run_agent_with_retries(\n        endpoint,\n        model,\n        system_prompt,\n        user_message,\n        callback,\n        3,\n        1000,\n    )\n}\n\n/// Run an agent loop with configurable retry policy\npub fn run_agent_with_retries(\n    endpoint: \u0026str,\n    model: \u0026str,\n    system_prompt: \u0026str,\n    user_message: \u0026str,\n    callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    max_retries: u32,\n    retry_delay_ms: u64,\n) -\u003e Result\u003cString\u003e {\n    // Parse endpoint to get base URL\n    // Use const for fallback to avoid nested unwrap\n    let url = Url::parse(endpoint).unwrap_or_else(|_| {\n        Url::parse(DEFAULT_OLLAMA_ENDPOINT).expect(\"DEFAULT_OLLAMA_ENDPOINT is valid\")\n    });\n    let base_url = format!(\n        \"{}://{}:{}\",\n        url.scheme(),\n        url.host_str().unwrap_or(\"localhost\"),\n        url.port().unwrap_or(11434)\n    );\n    let chat_url = format!(\"{}/api/chat\", base_url);\n\n    // Build messages\n    let mut messages: Vec\u003cMessage\u003e = vec![];\n    if !system_prompt.is_empty() {\n        messages.push(Message {\n            role: \"system\".to_string(),\n            content: system_prompt.to_string(),\n            tool_calls: None,\n            tool_call_id: None,\n        });\n    }\n    messages.push(Message {\n        role: \"user\".to_string(),\n        content: user_message.to_string(),\n        tool_calls: None,\n        tool_call_id: None,\n    });\n\n    // Get tool definitions (already in correct format with lowercase \"function\")\n    let tool_defs = tools::get_tool_definitions();\n\n    // Tool calling loop\n    let mut iteration = 0;\n    let mut final_response = String::new();\n\n    loop {\n        iteration += 1;\n        if iteration \u003e MAX_ITERATIONS {\n            callback(\u0026format!(\n                \"Warning: Reached max iterations ({})\",\n                MAX_ITERATIONS\n            ))?;\n            break;\n        }\n\n        // Build request\n        let request = ChatRequest {\n            model: model.to_string(),\n            messages: messages.clone(),\n            tools: tool_defs.clone(),\n            stream: false,\n        };\n\n        // Send request with retry logic\n        let mut attempt = 0;\n        let chat_response = loop {\n            attempt += 1;\n\n            let client = ureq::Agent::new();\n            let response = client\n                .post(\u0026chat_url)\n                .set(\"Content-Type\", \"application/json\")\n                .send_json(\u0026request);\n\n            match response {\n                Ok(resp) =\u003e {\n                    let status = resp.status();\n\n                    // Check for retryable HTTP errors\n                    let is_retryable = status == 429\n                        || status == 500\n                        || status == 502\n                        || status == 503\n                        || status == 504;\n\n                    if status == 200 {\n                        // Success\n                        let response_text = resp.into_string()?;\n                        match serde_json::from_str::\u003cChatResponse\u003e(\u0026response_text) {\n                            Ok(parsed) =\u003e break parsed,\n                            Err(e) =\u003e {\n                                return Err(anyhow!(\n                                    \"Failed to parse response: {} - body: {}\",\n                                    e,\n                                    response_text\n                                ))\n                            }\n                        }\n                    } else if is_retryable \u0026\u0026 attempt \u003c= max_retries {\n                        // Retryable error - wait and retry\n                        let delay_ms = calculate_backoff(attempt, retry_delay_ms);\n                        callback(\u0026format!(\n                            \"[Retry {}] HTTP {} - waiting {}ms before retry\",\n                            attempt, status, delay_ms\n                        ))?;\n                        std::thread::sleep(std::time::Duration::from_millis(delay_ms));\n                        continue;\n                    } else {\n                        // Non-retryable error or max retries exceeded\n                        return Err(anyhow!(\n                            \"HTTP request failed with status {}: {} (after {} attempt{})\",\n                            status,\n                            resp.status_text(),\n                            attempt,\n                            if attempt == 1 { \"\" } else { \"s\" }\n                        ));\n                    }\n                }\n                Err(e) =\u003e {\n                    // Network error - check if retryable\n                    let error_str = e.to_string();\n                    let is_retryable = error_str.contains(\"Connection\")\n                        || error_str.contains(\"timeout\")\n                        || error_str.contains(\"reset\");\n\n                    if is_retryable \u0026\u0026 attempt \u003c= max_retries {\n                        let delay_ms = calculate_backoff(attempt, retry_delay_ms);\n                        callback(\u0026format!(\n                            \"[Retry {}] Network error - waiting {}ms before retry: {}\",\n                            attempt, delay_ms, error_str\n                        ))?;\n                        std::thread::sleep(std::time::Duration::from_millis(delay_ms));\n                        continue;\n                    } else {\n                        return Err(anyhow!(\"HTTP request failed: {}\", e));\n                    }\n                }\n            }\n        };\n\n        // Check if model requested tool calls\n        if chat_response.message.tool_calls.is_empty() {\n            // No tool calls - model has provided final response\n            final_response = chat_response.message.content.clone();\n\n            // Buffer content and only call callback when we have complete lines\n            let mut line_buffer = String::new();\n            for ch in final_response.chars() {\n                line_buffer.push(ch);\n                if ch == '\\n' {\n                    let line = line_buffer.trim_end_matches('\\n');\n                    callback(line)?;\n                    line_buffer.clear();\n                }\n            }\n\n            // Flush any remaining buffered content\n            if !line_buffer.is_empty() {\n                callback(\u0026line_buffer)?;\n            }\n            break;\n        }\n\n        // Add assistant message with tool calls to history\n        messages.push(Message {\n            role: \"assistant\".to_string(),\n            content: chat_response.message.content.clone(),\n            tool_calls: Some(chat_response.message.tool_calls.clone()),\n            tool_call_id: None,\n        });\n\n        // Process each tool call from the model\n        for tool_call in \u0026chat_response.message.tool_calls {\n            let tool_name = \u0026tool_call.function.name;\n            let tool_args = \u0026tool_call.function.arguments;\n\n            // Log the tool call\n            callback(\u0026format!(\"[Tool: {}] {}\", tool_name, tool_args))?;\n\n            // Execute the tool\n            let result = match tools::execute_tool(tool_name, tool_args) {\n                Ok(output) =\u003e output,\n                Err(error) =\u003e format!(\"Error: {}\", error),\n            };\n\n            // Log abbreviated result\n            let result_preview = if result.len() \u003e 200 {\n                format!(\"{}... ({} bytes)\", \u0026result[..200], result.len())\n            } else {\n                result.clone()\n            };\n            callback(\u0026format!(\"[Result] {}\", result_preview))?;\n\n            // Add tool response to messages\n            messages.push(Message {\n                role: \"tool\".to_string(),\n                content: result,\n                tool_calls: None,\n                tool_call_id: Some(tool_call.id.clone()),\n            });\n        }\n    }\n\n    Ok(final_response)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_agent_initialization() {\n        // Test that agent can be created with proper parameters\n        let endpoint = \"http://localhost:11434\";\n        let model = \"qwen2.5:7b\";\n        let system_prompt = \"You are a helpful assistant.\";\n        let user_message = \"Hello, who are you?\";\n\n        let mut callback = |_line: \u0026str| -\u003e Result\u003c()\u003e { Ok(()) };\n\n        // Verify types are correct\n        let _endpoint = endpoint;\n        let _model = model;\n        let _system_prompt = system_prompt;\n        let _user_message = user_message;\n        let _ = \u0026mut callback;\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":127},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","activity.rs"],"content":"//! Activity command - git-based activity feed for spec operations.\n//!\n//! Parses git history to show a chronological feed of spec-related activities\n//! including creation, approval, rejection, work, and completion.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::collections::HashMap;\n\nuse chant::git;\n\n/// Activity types detected from git history\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ActivityType {\n    /// Spec was created (new spec file added)\n    Created,\n    /// Spec was approved (approval.status changed to approved)\n    Approved,\n    /// Spec was rejected (approval.status changed to rejected)\n    Rejected,\n    /// Spec was worked on (commit message contains `chant(SPEC-ID):`)\n    Worked,\n    /// Spec was completed (status changed to completed)\n    Completed,\n}\n\nimpl ActivityType {\n    fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ActivityType::Created =\u003e \"CREATED\",\n            ActivityType::Approved =\u003e \"APPROVED\",\n            ActivityType::Rejected =\u003e \"REJECTED\",\n            ActivityType::Worked =\u003e \"WORKED\",\n            ActivityType::Completed =\u003e \"COMPLETED\",\n        }\n    }\n\n    fn colorize(\u0026self, s: \u0026str) -\u003e colored::ColoredString {\n        match self {\n            ActivityType::Created =\u003e s.cyan(),\n            ActivityType::Approved =\u003e s.green(),\n            ActivityType::Rejected =\u003e s.red(),\n            ActivityType::Worked =\u003e s.yellow(),\n            ActivityType::Completed =\u003e s.green().bold(),\n        }\n    }\n}\n\n/// A single activity entry\n#[derive(Debug, Clone)]\npub struct Activity {\n    /// Commit hash, used for deduplication in activity tracking\n    #[allow(dead_code)]\n    pub commit: String,\n    /// Author name\n    pub author: String,\n    /// Unix timestamp\n    pub timestamp: i64,\n    /// Activity type\n    pub activity_type: ActivityType,\n    /// Spec ID (short form like \"001-abc\")\n    pub spec_id: String,\n    /// Description or spec title\n    pub description: String,\n}\n\n/// Parse a duration string like \"2h\", \"1d\", \"1w\" into seconds\nfn parse_duration(duration: \u0026str) -\u003e Result\u003ci64\u003e {\n    let duration = duration.trim();\n    if duration.is_empty() {\n        anyhow::bail!(\"Empty duration string\");\n    }\n\n    let (num_str, unit) = if let Some(stripped) = duration.strip_suffix('h') {\n        (stripped, 'h')\n    } else if let Some(stripped) = duration.strip_suffix('d') {\n        (stripped, 'd')\n    } else if let Some(stripped) = duration.strip_suffix('w') {\n        (stripped, 'w')\n    } else if let Some(stripped) = duration.strip_suffix('m') {\n        (stripped, 'm')\n    } else {\n        anyhow::bail!(\n            \"Invalid duration format '{}'. Use format like '2h', '1d', '1w', '1m'\",\n            duration\n        );\n    };\n\n    let num: i64 = num_str\n        .parse()\n        .with_context(|| format!(\"Invalid number in duration: {}\", num_str))?;\n\n    let seconds = match unit {\n        'h' =\u003e num * 3600,\n        'd' =\u003e num * 86400,\n        'w' =\u003e num * 604800,\n        'm' =\u003e num * 2592000, // 30 days\n        _ =\u003e unreachable!(),\n    };\n\n    Ok(seconds)\n}\n\n/// Get git log for spec-related commits\nfn get_spec_commits() -\u003e Result\u003cVec\u003c(String, String, i64, String)\u003e\u003e {\n    // Get commits affecting .chant/specs/\n    let commit_infos = git::get_commits_for_path(\".chant/specs/\")?;\n\n    let commits = commit_infos\n        .into_iter()\n        .map(|c| (c.hash, c.author, c.timestamp, c.message))\n        .collect();\n\n    Ok(commits)\n}\n\n/// Get files changed in a commit\nfn get_commit_files(commit: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    git::get_commit_files_with_status(commit)\n}\n\n/// Get file content at a specific commit\nfn get_file_at_commit(commit: \u0026str, file: \u0026str) -\u003e Result\u003cString\u003e {\n    git::get_file_at_commit(commit, file)\n}\n\n/// Get file content at parent commit\nfn get_file_at_parent(commit: \u0026str, file: \u0026str) -\u003e Result\u003cString\u003e {\n    git::get_file_at_parent(commit, file)\n}\n\n/// Extract spec ID from a filename like \".chant/specs/2026-01-28-001-abc.md\"\nfn extract_spec_id(filename: \u0026str) -\u003e Option\u003cString\u003e {\n    let path = std::path::Path::new(filename);\n    path.file_stem()\n        .and_then(|s| s.to_str())\n        .map(|s| s.to_string())\n}\n\n/// Extract short spec ID (e.g., \"001-abc\" from \"2026-01-28-001-abc\")\nfn short_spec_id(spec_id: \u0026str) -\u003e String {\n    // Try to extract just the sequence and random parts\n    let parts: Vec\u003c\u0026str\u003e = spec_id.split('-').collect();\n    if parts.len() \u003e= 5 {\n        // Format: 2026-01-28-001-abc -\u003e 001-abc\n        format!(\"{}-{}\", parts[3], parts[4])\n    } else {\n        spec_id.to_string()\n    }\n}\n\n/// Extract title from spec content\nfn extract_title(content: \u0026str) -\u003e Option\u003cString\u003e {\n    // Skip frontmatter\n    let body = if let Some(stripped) = content.strip_prefix(\"---\") {\n        if let Some(end_idx) = stripped.find(\"---\") {\n            \u0026stripped[end_idx + 3..]\n        } else {\n            content\n        }\n    } else {\n        content\n    };\n\n    // Find first # heading\n    for line in body.lines() {\n        let trimmed = line.trim();\n        if let Some(title) = trimmed.strip_prefix(\"# \") {\n            return Some(title.trim().to_string());\n        }\n    }\n\n    None\n}\n\n/// Check if content has approval.status: approved\nfn has_approval_status(content: \u0026str, status: \u0026str) -\u003e bool {\n    // Check for approval block in frontmatter\n    if !content.starts_with(\"---\") {\n        return false;\n    }\n\n    if let Some(end_idx) = content[3..].find(\"---\") {\n        let frontmatter = \u0026content[3..end_idx + 3];\n        // Look for approval section with status\n        let mut in_approval = false;\n        for line in frontmatter.lines() {\n            let trimmed = line.trim();\n            // Check if we're entering the approval block\n            if trimmed == \"approval:\" || trimmed.starts_with(\"approval:\") {\n                in_approval = true;\n                continue;\n            }\n            // Check if we're exiting the approval block (line doesn't start with space and isn't empty)\n            if in_approval\n                \u0026\u0026 !line.starts_with(' ')\n                \u0026\u0026 !line.starts_with('\\t')\n                \u0026\u0026 !trimmed.is_empty()\n            {\n                in_approval = false;\n            }\n            // Check for status within approval block\n            if in_approval \u0026\u0026 trimmed.starts_with(\"status:\") {\n                let value = trimmed.trim_start_matches(\"status:\").trim();\n                return value == status;\n            }\n        }\n    }\n\n    false\n}\n\n/// Check if content has status: completed in frontmatter\nfn has_status_completed(content: \u0026str) -\u003e bool {\n    if !content.starts_with(\"---\") {\n        return false;\n    }\n\n    if let Some(end_idx) = content[3..].find(\"---\") {\n        let frontmatter = \u0026content[3..end_idx + 3];\n        for line in frontmatter.lines() {\n            let trimmed = line.trim();\n            if trimmed == \"status: completed\" {\n                return true;\n            }\n        }\n    }\n\n    false\n}\n\n/// Detect activities from a single commit\nfn detect_activities(\n    commit: \u0026str,\n    author: \u0026str,\n    timestamp: i64,\n    subject: \u0026str,\n) -\u003e Result\u003cVec\u003cActivity\u003e\u003e {\n    let mut activities = Vec::new();\n\n    // Check for \"chant(SPEC-ID):\" pattern in commit message\n    if let Some(start) = subject.find(\"chant(\") {\n        if let Some(end) = subject[start..].find(\"):\") {\n            let spec_id = \u0026subject[start + 6..start + end];\n            let description = subject[start + end + 2..].trim();\n\n            // Check if it's a finalize commit\n            if description.starts_with(\"finalize\") {\n                activities.push(Activity {\n                    commit: commit.to_string(),\n                    author: author.to_string(),\n                    timestamp,\n                    activity_type: ActivityType::Completed,\n                    spec_id: spec_id.to_string(),\n                    description: description.to_string(),\n                });\n                return Ok(activities);\n            }\n\n            activities.push(Activity {\n                commit: commit.to_string(),\n                author: author.to_string(),\n                timestamp,\n                activity_type: ActivityType::Worked,\n                spec_id: spec_id.to_string(),\n                description: description.to_string(),\n            });\n        }\n    }\n\n    // Check for special commit message patterns\n    if subject.starts_with(\"chant: Add spec \") {\n        // Spec creation via chant add\n        if let Some(spec_id) = subject.strip_prefix(\"chant: Add spec \") {\n            let files = get_commit_files(commit)?;\n            let mut title = String::new();\n\n            // Try to get title from the spec file\n            for file_entry in \u0026files {\n                if file_entry.starts_with(\"A:\") \u0026\u0026 file_entry.contains(\".chant/specs/\") {\n                    let filename = \u0026file_entry[2..];\n                    if let Ok(content) = get_file_at_commit(commit, filename) {\n                        if let Some(t) = extract_title(\u0026content) {\n                            title = t;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            activities.push(Activity {\n                commit: commit.to_string(),\n                author: author.to_string(),\n                timestamp,\n                activity_type: ActivityType::Created,\n                spec_id: spec_id.to_string(),\n                description: title,\n            });\n            return Ok(activities);\n        }\n    }\n\n    // Get changed files to detect other activity types\n    let files = get_commit_files(commit)?;\n\n    for file_entry in files {\n        let parts: Vec\u003c\u0026str\u003e = file_entry.splitn(2, ':').collect();\n        if parts.len() != 2 {\n            continue;\n        }\n\n        let status = parts[0];\n        let filename = parts[1];\n\n        // Only process spec files\n        if !filename.starts_with(\".chant/specs/\") || !filename.ends_with(\".md\") {\n            continue;\n        }\n\n        let spec_id = match extract_spec_id(filename) {\n            Some(id) =\u003e id,\n            None =\u003e continue,\n        };\n\n        match status {\n            \"A\" =\u003e {\n                // New file added - spec created\n                let content = get_file_at_commit(commit, filename)?;\n                let title = extract_title(\u0026content).unwrap_or_default();\n\n                // Skip if we already added this spec from commit message\n                if !activities\n                    .iter()\n                    .any(|a| a.spec_id == spec_id \u0026\u0026 a.activity_type == ActivityType::Created)\n                {\n                    activities.push(Activity {\n                        commit: commit.to_string(),\n                        author: author.to_string(),\n                        timestamp,\n                        activity_type: ActivityType::Created,\n                        spec_id,\n                        description: title,\n                    });\n                }\n            }\n            \"M\" =\u003e {\n                // File modified - check for approval/rejection/completion\n                let current = get_file_at_commit(commit, filename)?;\n                let previous = get_file_at_parent(commit, filename)?;\n\n                let title = extract_title(\u0026current).unwrap_or_default();\n\n                // Check for approval status change\n                if has_approval_status(\u0026current, \"approved\")\n                    \u0026\u0026 !has_approval_status(\u0026previous, \"approved\")\n                {\n                    activities.push(Activity {\n                        commit: commit.to_string(),\n                        author: author.to_string(),\n                        timestamp,\n                        activity_type: ActivityType::Approved,\n                        spec_id: spec_id.clone(),\n                        description: title.clone(),\n                    });\n                }\n\n                if has_approval_status(\u0026current, \"rejected\")\n                    \u0026\u0026 !has_approval_status(\u0026previous, \"rejected\")\n                {\n                    activities.push(Activity {\n                        commit: commit.to_string(),\n                        author: author.to_string(),\n                        timestamp,\n                        activity_type: ActivityType::Rejected,\n                        spec_id: spec_id.clone(),\n                        description: title.clone(),\n                    });\n                }\n\n                // Check for status change to completed\n                if has_status_completed(\u0026current) \u0026\u0026 !has_status_completed(\u0026previous) {\n                    // Skip if we already have a completion activity for this spec from commit message\n                    if !activities\n                        .iter()\n                        .any(|a| a.spec_id == spec_id \u0026\u0026 a.activity_type == ActivityType::Completed)\n                    {\n                        activities.push(Activity {\n                            commit: commit.to_string(),\n                            author: author.to_string(),\n                            timestamp,\n                            activity_type: ActivityType::Completed,\n                            spec_id,\n                            description: title,\n                        });\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    Ok(activities)\n}\n\n/// Filter activities by criteria\nfn filter_activities(\n    activities: Vec\u003cActivity\u003e,\n    by: Option\u003c\u0026str\u003e,\n    since: Option\u003c\u0026str\u003e,\n    spec: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cVec\u003cActivity\u003e\u003e {\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .map(|d| d.as_secs() as i64)\n        .unwrap_or(0);\n\n    let since_timestamp = if let Some(duration) = since {\n        let seconds = parse_duration(duration)?;\n        now - seconds\n    } else {\n        0\n    };\n\n    Ok(activities\n        .into_iter()\n        .filter(|a| {\n            // Filter by author\n            if let Some(by_filter) = by {\n                if !a.author.to_lowercase().contains(\u0026by_filter.to_lowercase()) {\n                    return false;\n                }\n            }\n\n            // Filter by since\n            if a.timestamp \u003c since_timestamp {\n                return false;\n            }\n\n            // Filter by spec\n            if let Some(spec_filter) = spec {\n                if !a.spec_id.contains(spec_filter) {\n                    return false;\n                }\n            }\n\n            true\n        })\n        .collect())\n}\n\n/// Main activity command implementation\npub fn cmd_activity(by: Option\u003c\u0026str\u003e, since: Option\u003c\u0026str\u003e, spec: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    // Ensure chant is initialized\n    let _specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Get all spec-related commits\n    let commits = get_spec_commits()?;\n\n    if commits.is_empty() {\n        println!(\"{}\", \"No activity found.\".yellow());\n        return Ok(());\n    }\n\n    // Collect all activities\n    let mut all_activities = Vec::new();\n    let mut seen: HashMap\u003c(String, String), bool\u003e = HashMap::new(); // (spec_id, activity_type) -\u003e seen\n\n    for (hash, author, timestamp, subject) in commits {\n        let activities = detect_activities(\u0026hash, \u0026author, timestamp, \u0026subject)?;\n\n        for activity in activities {\n            // Deduplicate: only keep first occurrence of each (spec_id, activity_type) pair\n            let key = (\n                activity.spec_id.clone(),\n                activity.activity_type.as_str().to_string(),\n            );\n            if seen.contains_key(\u0026key) {\n                continue;\n            }\n            seen.insert(key, true);\n            all_activities.push(activity);\n        }\n    }\n\n    // Apply filters\n    all_activities = filter_activities(all_activities, by, since, spec)?;\n\n    // Sort by timestamp (most recent first)\n    all_activities.sort_by(|a, b| b.timestamp.cmp(\u0026a.timestamp));\n\n    if all_activities.is_empty() {\n        println!(\"{}\", \"No activity found matching filters.\".yellow());\n        return Ok(());\n    }\n\n    // Print activities\n    for activity in all_activities {\n        let datetime =\n            chrono::DateTime::from_timestamp(activity.timestamp, 0).unwrap_or_else(|| {\n                chrono::DateTime::from_timestamp(0, 0).expect(\"epoch should be valid\")\n            });\n        let date_str = datetime.format(\"%Y-%m-%d %H:%M\").to_string();\n\n        let action_str = activity.activity_type.as_str();\n        let action_colored = activity.activity_type.colorize(action_str);\n\n        let short_id = short_spec_id(\u0026activity.spec_id);\n\n        // Truncate description if too long\n        let desc = if activity.description.len() \u003e 40 {\n            format!(\"{}...\", \u0026activity.description[..37])\n        } else {\n            activity.description.clone()\n        };\n\n        println!(\n            \"{}  {:\u003c12} {:\u003c12} {:\u003c10} {}\",\n            date_str.dimmed(),\n            activity.author,\n            action_colored,\n            short_id.cyan(),\n            desc\n        );\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_duration_hours() {\n        assert_eq!(parse_duration(\"2h\").unwrap(), 7200);\n        assert_eq!(parse_duration(\"24h\").unwrap(), 86400);\n    }\n\n    #[test]\n    fn test_parse_duration_days() {\n        assert_eq!(parse_duration(\"1d\").unwrap(), 86400);\n        assert_eq!(parse_duration(\"7d\").unwrap(), 604800);\n    }\n\n    #[test]\n    fn test_parse_duration_weeks() {\n        assert_eq!(parse_duration(\"1w\").unwrap(), 604800);\n        assert_eq!(parse_duration(\"2w\").unwrap(), 1209600);\n    }\n\n    #[test]\n    fn test_parse_duration_months() {\n        assert_eq!(parse_duration(\"1m\").unwrap(), 2592000);\n    }\n\n    #[test]\n    fn test_parse_duration_invalid() {\n        assert!(parse_duration(\"\").is_err());\n        assert!(parse_duration(\"2x\").is_err());\n        assert!(parse_duration(\"abc\").is_err());\n    }\n\n    #[test]\n    fn test_short_spec_id() {\n        assert_eq!(short_spec_id(\"2026-01-28-001-abc\"), \"001-abc\");\n        assert_eq!(short_spec_id(\"2026-01-28-123-xyz\"), \"123-xyz\");\n        assert_eq!(short_spec_id(\"short\"), \"short\");\n    }\n\n    #[test]\n    fn test_extract_spec_id() {\n        assert_eq!(\n            extract_spec_id(\".chant/specs/2026-01-28-001-abc.md\"),\n            Some(\"2026-01-28-001-abc\".to_string())\n        );\n        assert_eq!(extract_spec_id(\"other/path.txt\"), Some(\"path\".to_string()));\n    }\n\n    #[test]\n    fn test_extract_title() {\n        let content = \"---\\nstatus: pending\\n---\\n\\n# My Title\\n\\nBody text\";\n        assert_eq!(extract_title(content), Some(\"My Title\".to_string()));\n\n        let no_title = \"---\\nstatus: pending\\n---\\n\\nBody without title\";\n        assert_eq!(extract_title(no_title), None);\n    }\n\n    #[test]\n    fn test_has_approval_status() {\n        let approved = \"---\\napproval:\\n  status: approved\\n  by: alice\\n---\\n# Title\";\n        assert!(has_approval_status(approved, \"approved\"));\n        assert!(!has_approval_status(approved, \"rejected\"));\n\n        let rejected = \"---\\napproval:\\n  status: rejected\\n  by: bob\\n---\\n# Title\";\n        assert!(has_approval_status(rejected, \"rejected\"));\n        assert!(!has_approval_status(rejected, \"approved\"));\n\n        let no_approval = \"---\\nstatus: pending\\n---\\n# Title\";\n        assert!(!has_approval_status(no_approval, \"approved\"));\n    }\n\n    #[test]\n    fn test_has_status_completed() {\n        let completed = \"---\\nstatus: completed\\nmodel: test\\n---\\n# Title\";\n        assert!(has_status_completed(completed));\n\n        let pending = \"---\\nstatus: pending\\n---\\n# Title\";\n        assert!(!has_status_completed(pending));\n\n        let in_progress = \"---\\nstatus: in_progress\\n---\\n# Title\";\n        assert!(!has_status_completed(in_progress));\n    }\n\n    #[test]\n    fn test_activity_type_display() {\n        assert_eq!(ActivityType::Created.as_str(), \"CREATED\");\n        assert_eq!(ActivityType::Approved.as_str(), \"APPROVED\");\n        assert_eq!(ActivityType::Rejected.as_str(), \"REJECTED\");\n        assert_eq!(ActivityType::Worked.as_str(), \"WORKED\");\n        assert_eq!(ActivityType::Completed.as_str(), \"COMPLETED\");\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":10}},{"line":69,"address":[],"length":0,"stats":{"Line":30}},{"line":70,"address":[],"length":0,"stats":{"Line":20}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":25}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":9}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":21}},{"line":91,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":14}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":15}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":10}},{"line":167,"address":[],"length":0,"stats":{"Line":18}},{"line":168,"address":[],"length":0,"stats":{"Line":7}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":5}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":10}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":186,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":24}},{"line":188,"address":[],"length":0,"stats":{"Line":42}},{"line":190,"address":[],"length":0,"stats":{"Line":34}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":10}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":18}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":12}},{"line":222,"address":[],"length":0,"stats":{"Line":18}},{"line":223,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}}],"covered":72,"coverable":258},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","agent.rs"],"content":"//! Agent invocation module for chant CLI\n//!\n//! Handles all LLM agent interactions including model selection, provider management,\n//! and streaming output capture.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::path::{Path, PathBuf};\n\nuse chant::config::Config;\nuse chant::paths::SPECS_DIR;\nuse chant::provider;\nuse chant::spec::Spec;\n\n/// Invoke an agent with a message and return captured output\npub fn invoke_agent(\n    message: \u0026str,\n    spec: \u0026Spec,\n    prompt_name: \u0026str,\n    config: \u0026Config,\n) -\u003e Result\u003cString\u003e {\n    invoke_agent_with_model(message, spec, prompt_name, config, None, None)\n}\n\n/// Invoke an agent with optional agent command override and return captured output\npub fn invoke_agent_with_command_override(\n    message: \u0026str,\n    spec: \u0026Spec,\n    prompt_name: \u0026str,\n    config: \u0026Config,\n    agent_command: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cString\u003e {\n    use std::io::{BufRead, BufReader};\n    use std::process::{Command, Stdio};\n\n    // Use specified command or default to \"claude\"\n    let command = agent_command.unwrap_or(\"claude\");\n\n    // Create streaming log writer before spawning agent\n    let mut log_writer = match StreamingLogWriter::new(\u0026spec.id, prompt_name) {\n        Ok(writer) =\u003e Some(writer),\n        Err(e) =\u003e {\n            eprintln!(\"{} Failed to create agent log: {}\", \"â \".yellow(), e);\n            None\n        }\n    };\n\n    // Set environment variables\n    let spec_file = std::fs::canonicalize(format!(\".chant/specs/{}.md\", spec.id))?;\n\n    // Get the model to use\n    let model = get_model_for_invocation(config.defaults.model.as_deref());\n\n    // Set CHANT_SPEC_ID and CHANT_SPEC_FILE env vars\n    std::env::set_var(\"CHANT_SPEC_ID\", \u0026spec.id);\n    std::env::set_var(\"CHANT_SPEC_FILE\", \u0026spec_file);\n\n    let mut cmd = Command::new(command);\n    cmd.arg(\"--print\")\n        .arg(\"--output-format\")\n        .arg(\"stream-json\")\n        .arg(\"--verbose\")\n        .arg(\"--model\")\n        .arg(\u0026model)\n        .arg(\"--dangerously-skip-permissions\")\n        .arg(message)\n        .env(\"CHANT_SPEC_ID\", \u0026spec.id)\n        .env(\"CHANT_SPEC_FILE\", \u0026spec_file)\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped());\n\n    let mut child = cmd.spawn().with_context(|| {\n        format!(\n            \"Failed to invoke agent '{}'. Is it installed and in PATH?\",\n            command\n        )\n    })?;\n\n    // Write PID file for tracking\n    if let Err(e) = chant::pid::write_pid_file(\u0026spec.id, child.id()) {\n        eprintln!(\"{} Failed to write PID file: {}\", \"â \".yellow(), e);\n    }\n\n    // Collect output while streaming to terminal and log\n    let mut captured_output = String::new();\n\n    // Stream stdout to both terminal and log file\n    if let Some(stdout) = child.stdout.take() {\n        let reader = BufReader::new(stdout);\n        for line in reader.lines().map_while(Result::ok) {\n            for text in extract_text_from_stream_json(\u0026line) {\n                for text_line in text.lines() {\n                    println!(\"{}\", text_line);\n                    captured_output.push_str(text_line);\n                    captured_output.push('\\n');\n                    if let Some(ref mut writer) = log_writer {\n                        if let Err(e) = writer.write_line(text_line) {\n                            eprintln!(\"{} Failed to write to agent log: {}\", \"â \".yellow(), e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    let status = child.wait()?;\n\n    // Clean up PID file\n    if let Err(e) = chant::pid::remove_pid_file(\u0026spec.id) {\n        eprintln!(\"{} Failed to remove PID file: {}\", \"â \".yellow(), e);\n    }\n\n    if !status.success() {\n        anyhow::bail!(\"Agent exited with status: {}\", status);\n    }\n\n    Ok(captured_output)\n}\n\n/// Invoke an agent with a custom command and prefix output with spec ID\n/// Used for parallel execution with multiple Claude accounts\npub fn invoke_agent_with_command(\n    message: \u0026str,\n    spec_id: \u0026str,\n    prompt_name: \u0026str,\n    config_model: Option\u003c\u0026str\u003e,\n    cwd: Option\u003c\u0026Path\u003e,\n    agent_command: \u0026str,\n    branch_name: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    use std::io::{BufRead, BufReader};\n    use std::process::{Command, Stdio};\n\n    // Create streaming log writer before spawning agent (writes header immediately)\n    let mut log_writer = match StreamingLogWriter::new(spec_id, prompt_name) {\n        Ok(writer) =\u003e Some(writer),\n        Err(e) =\u003e {\n            eprintln!(\n                \"{} [{}] Failed to create agent log: {}\",\n                \"â \".yellow(),\n                spec_id,\n                e\n            );\n            None\n        }\n    };\n\n    // Set environment variables\n    let spec_file = std::fs::canonicalize(format!(\"{}/{}.md\", SPECS_DIR, spec_id))?;\n\n    // Get the model to use\n    let model = get_model_for_invocation(config_model);\n\n    let mut cmd = Command::new(agent_command);\n    cmd.arg(\"--print\")\n        .arg(\"--output-format\")\n        .arg(\"stream-json\")\n        .arg(\"--verbose\")\n        .arg(\"--model\")\n        .arg(\u0026model)\n        .arg(\"--dangerously-skip-permissions\")\n        .arg(message)\n        .env(\"CHANT_SPEC_ID\", spec_id)\n        .env(\"CHANT_SPEC_FILE\", \u0026spec_file)\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped());\n\n    // Set working directory and worktree environment variables if provided\n    if let Some(path) = cwd {\n        cmd.current_dir(path);\n        // Set worktree environment variables\n        cmd.env(\"CHANT_WORKTREE\", \"1\");\n        cmd.env(\"CHANT_WORKTREE_PATH\", path);\n        if let Some(branch) = branch_name {\n            cmd.env(\"CHANT_BRANCH\", branch);\n        }\n    }\n\n    let mut child = cmd.spawn().with_context(|| {\n        format!(\n            \"Failed to invoke agent '{}'. Is it installed and in PATH?\",\n            agent_command\n        )\n    })?;\n\n    // Write PID file for tracking\n    if let Err(e) = chant::pid::write_pid_file(spec_id, child.id()) {\n        eprintln!(\n            \"{} [{}] Failed to write PID file: {}\",\n            \"â \".yellow(),\n            spec_id,\n            e\n        );\n    }\n\n    // Stream stdout with prefix to both terminal and log file\n    if let Some(stdout) = child.stdout.take() {\n        let reader = BufReader::new(stdout);\n        let prefix = format!(\"[{}]\", spec_id);\n        for line in reader.lines().map_while(Result::ok) {\n            for text in extract_text_from_stream_json(\u0026line) {\n                for text_line in text.lines() {\n                    println!(\"{} {}\", prefix.cyan(), text_line);\n                    if let Some(ref mut writer) = log_writer {\n                        if let Err(e) = writer.write_line(text_line) {\n                            eprintln!(\n                                \"{} [{}] Failed to write to agent log: {}\",\n                                \"â \".yellow(),\n                                spec_id,\n                                e\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    let status = child.wait()?;\n\n    // Clean up PID file\n    if let Err(e) = chant::pid::remove_pid_file(spec_id) {\n        eprintln!(\n            \"{} [{}] Failed to remove PID file: {}\",\n            \"â \".yellow(),\n            spec_id,\n            e\n        );\n    }\n\n    if !status.success() {\n        anyhow::bail!(\"Agent exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n/// Invoke an agent with optional model override and working directory\npub fn invoke_agent_with_model(\n    message: \u0026str,\n    spec: \u0026Spec,\n    prompt_name: \u0026str,\n    config: \u0026Config,\n    override_model: Option\u003c\u0026str\u003e,\n    cwd: Option\u003c\u0026Path\u003e,\n) -\u003e Result\u003cString\u003e {\n    // Create streaming log writer before spawning agent (writes header immediately)\n    let mut log_writer = match StreamingLogWriter::new(\u0026spec.id, prompt_name) {\n        Ok(writer) =\u003e Some(writer),\n        Err(e) =\u003e {\n            eprintln!(\"{} Failed to create agent log: {}\", \"â \".yellow(), e);\n            None\n        }\n    };\n\n    // Set environment variables\n    let spec_file = std::fs::canonicalize(format!(\".chant/specs/{}.md\", spec.id))?;\n\n    // Get the model to use - allow override\n    let model = if let Some(override_m) = override_model {\n        override_m.to_string()\n    } else {\n        get_model_for_invocation(config.defaults.model.as_deref())\n    };\n\n    // Get the appropriate provider\n    let provider_type = config.defaults.provider;\n    let model_provider = get_model_provider(provider_type, config)?;\n\n    // Set CHANT_SPEC_ID and CHANT_SPEC_FILE env vars\n    std::env::set_var(\"CHANT_SPEC_ID\", \u0026spec.id);\n    std::env::set_var(\"CHANT_SPEC_FILE\", \u0026spec_file);\n\n    // Change to working directory if provided\n    let original_cwd = std::env::current_dir().ok();\n    if let Some(path) = cwd {\n        std::env::set_current_dir(path)?;\n    }\n\n    // Invoke the model provider with streaming callback\n    let captured_output = model_provider.invoke(message, \u0026model, \u0026mut |text_line: \u0026str| {\n        println!(\"{}\", text_line);\n        if let Some(ref mut writer) = log_writer {\n            if let Err(e) = writer.write_line(text_line) {\n                eprintln!(\"{} Failed to write to agent log: {}\", \"â \".yellow(), e);\n            }\n        }\n        Ok(())\n    })?;\n\n    // Restore original working directory\n    if let Some(original_cwd) = original_cwd {\n        std::env::set_current_dir(original_cwd)?;\n    }\n\n    Ok(captured_output)\n}\n\n/// Get the appropriate model provider based on configuration\nfn get_model_provider(\n    provider_type: provider::ProviderType,\n    config: \u0026Config,\n) -\u003e Result\u003cBox\u003cdyn provider::ModelProvider\u003e\u003e {\n    match provider_type {\n        provider::ProviderType::Claude =\u003e Ok(Box::new(provider::ClaudeCliProvider)),\n        provider::ProviderType::Ollama =\u003e {\n            let ollama_config = config.providers.ollama.as_ref();\n            let endpoint = ollama_config\n                .map(|c| c.endpoint.clone())\n                .unwrap_or_else(|| \"http://localhost:11434/v1\".to_string());\n            let max_retries = ollama_config.map(|c| c.max_retries).unwrap_or(3);\n            let retry_delay_ms = ollama_config.map(|c| c.retry_delay_ms).unwrap_or(1000);\n            Ok(Box::new(provider::OllamaProvider {\n                endpoint,\n                max_retries,\n                retry_delay_ms,\n            }))\n        }\n        provider::ProviderType::Openai =\u003e {\n            let openai_config = config.providers.openai.as_ref();\n            let endpoint = openai_config\n                .map(|c| c.endpoint.clone())\n                .unwrap_or_else(|| \"https://api.openai.com/v1\".to_string());\n            let api_key = std::env::var(\"OPENAI_API_KEY\").ok();\n            let max_retries = openai_config.map(|c| c.max_retries).unwrap_or(3);\n            let retry_delay_ms = openai_config.map(|c| c.retry_delay_ms).unwrap_or(1000);\n            Ok(Box::new(provider::OpenaiProvider {\n                endpoint,\n                api_key,\n                max_retries,\n                retry_delay_ms,\n            }))\n        }\n    }\n}\n\n/// Extract text content from a Claude CLI stream-json line.\n/// Returns Vec of text strings from assistant message content blocks.\npub fn extract_text_from_stream_json(line: \u0026str) -\u003e Vec\u003cString\u003e {\n    let mut texts = Vec::new();\n\n    if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(line) {\n        if let Some(\"assistant\") = json.get(\"type\").and_then(|t| t.as_str()) {\n            if let Some(content) = json\n                .get(\"message\")\n                .and_then(|m| m.get(\"content\"))\n                .and_then(|c| c.as_array())\n            {\n                for item in content {\n                    if let Some(text) = item.get(\"text\").and_then(|t| t.as_str()) {\n                        texts.push(text.to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    texts\n}\n\n/// Get the model to use for agent invocation.\n/// Priority:\n/// 1. CHANT_MODEL env var\n/// 2. ANTHROPIC_MODEL env var\n/// 3. defaults.model in config\n/// 4. \"haiku\" as hardcoded fallback\npub fn get_model_for_invocation(config_model: Option\u003c\u0026str\u003e) -\u003e String {\n    // 1. CHANT_MODEL env var\n    if let Ok(model) = std::env::var(\"CHANT_MODEL\") {\n        if !model.is_empty() {\n            return model;\n        }\n    }\n\n    // 2. ANTHROPIC_MODEL env var\n    if let Ok(model) = std::env::var(\"ANTHROPIC_MODEL\") {\n        if !model.is_empty() {\n            return model;\n        }\n    }\n\n    // 3. defaults.model from config\n    if let Some(model) = config_model {\n        if !model.is_empty() {\n            return model.to_string();\n        }\n    }\n\n    // 4. Hardcoded fallback\n    const DEFAULT_MODEL: \u0026str = \"haiku\";\n    DEFAULT_MODEL.to_string()\n}\n\n/// A streaming log writer that writes to a log file in real-time\npub struct StreamingLogWriter {\n    file: std::fs::File,\n}\n\nimpl StreamingLogWriter {\n    /// Create a new streaming log writer that opens the log file and writes the header\n    pub fn new(spec_id: \u0026str, prompt_name: \u0026str) -\u003e Result\u003cSelf\u003e {\n        Self::new_at(\u0026PathBuf::from(\".chant\"), spec_id, prompt_name)\n    }\n\n    /// Create a new streaming log writer at the given base path\n    pub fn new_at(base_path: \u0026Path, spec_id: \u0026str, prompt_name: \u0026str) -\u003e Result\u003cSelf\u003e {\n        use std::io::Write;\n\n        ensure_logs_dir_at(base_path)?;\n\n        let log_path = base_path.join(\"logs\").join(format!(\"{}.log\", spec_id));\n        let timestamp = chrono::Local::now()\n            .format(\"%Y-%m-%dT%H:%M:%SZ\")\n            .to_string();\n\n        let mut file = std::fs::File::create(\u0026log_path)?;\n\n        // Write header immediately\n        writeln!(file, \"# Agent Log: {}\", spec_id)?;\n        writeln!(file, \"# Started: {}\", timestamp)?;\n        writeln!(file, \"# Prompt: {}\", prompt_name)?;\n        writeln!(file)?;\n        file.flush()?;\n\n        Ok(Self { file })\n    }\n\n    /// Write a line to the log file and flush immediately for real-time visibility\n    pub fn write_line(\u0026mut self, line: \u0026str) -\u003e Result\u003c()\u003e {\n        use std::io::Write;\n\n        writeln!(self.file, \"{}\", line)?;\n        self.file.flush()?;\n        Ok(())\n    }\n}\n\n/// Ensure the logs directory exists and is in .gitignore at the given base path\npub fn ensure_logs_dir_at(base_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let logs_dir = base_path.join(\"logs\");\n    let gitignore_path = base_path.join(\".gitignore\");\n\n    // Create logs directory if it doesn't exist\n    if !logs_dir.exists() {\n        std::fs::create_dir_all(\u0026logs_dir)?;\n    }\n\n    // Add logs/ to .gitignore if not already present\n    let gitignore_content = if gitignore_path.exists() {\n        std::fs::read_to_string(\u0026gitignore_path)?\n    } else {\n        String::new()\n    };\n\n    if !gitignore_content.lines().any(|line| line.trim() == \"logs/\") {\n        let new_content = if gitignore_content.is_empty() {\n            \"logs/\\n\".to_string()\n        } else if gitignore_content.ends_with('\\n') {\n            format!(\"{}logs/\\n\", gitignore_content)\n        } else {\n            format!(\"{}\\nlogs/\\n\", gitignore_content)\n        };\n        std::fs::write(\u0026gitignore_path, new_content)?;\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Worktree environment variables to be set for agent invocation.\n    /// These are computed separately to make the logic testable.\n    #[derive(Debug, Clone, PartialEq, Eq)]\n    struct WorktreeEnvVars {\n        /// CHANT_WORKTREE is set to \"1\" when running in a worktree\n        chant_worktree: Option\u003cString\u003e,\n        /// CHANT_WORKTREE_PATH is set to the worktree path\n        chant_worktree_path: Option\u003cString\u003e,\n        /// CHANT_BRANCH is set to the branch name\n        chant_branch: Option\u003cString\u003e,\n    }\n\n    impl WorktreeEnvVars {\n        /// Compute the environment variables to set for worktree execution.\n        ///\n        /// When `worktree_path` is `Some`, we're running in a worktree and should set:\n        /// - CHANT_WORKTREE=1\n        /// - CHANT_WORKTREE_PATH=\u003cpath\u003e\n        /// - CHANT_BRANCH=\u003cbranch\u003e (if branch_name is provided)\n        ///\n        /// When `worktree_path` is `None`, no worktree env vars are set.\n        fn compute(worktree_path: Option\u003c\u0026Path\u003e, branch_name: Option\u003c\u0026str\u003e) -\u003e Self {\n            if let Some(path) = worktree_path {\n                WorktreeEnvVars {\n                    chant_worktree: Some(\"1\".to_string()),\n                    chant_worktree_path: Some(path.display().to_string()),\n                    chant_branch: branch_name.map(|s| s.to_string()),\n                }\n            } else {\n                WorktreeEnvVars {\n                    chant_worktree: None,\n                    chant_worktree_path: None,\n                    chant_branch: None,\n                }\n            }\n        }\n\n        /// Check if we're in worktree mode\n        fn is_worktree_mode(\u0026self) -\u003e bool {\n            self.chant_worktree.is_some()\n        }\n    }\n\n    #[test]\n    fn test_worktree_env_vars_with_worktree_and_branch() {\n        let path = Path::new(\"/tmp/chant-test-spec\");\n        let branch = \"chant/test-spec\";\n\n        let env_vars = WorktreeEnvVars::compute(Some(path), Some(branch));\n\n        assert!(env_vars.is_worktree_mode());\n        assert_eq!(env_vars.chant_worktree, Some(\"1\".to_string()));\n        assert_eq!(\n            env_vars.chant_worktree_path,\n            Some(\"/tmp/chant-test-spec\".to_string())\n        );\n        assert_eq!(env_vars.chant_branch, Some(\"chant/test-spec\".to_string()));\n    }\n\n    #[test]\n    fn test_worktree_env_vars_with_worktree_no_branch() {\n        let path = Path::new(\"/tmp/chant-test-spec\");\n\n        let env_vars = WorktreeEnvVars::compute(Some(path), None);\n\n        assert!(env_vars.is_worktree_mode());\n        assert_eq!(env_vars.chant_worktree, Some(\"1\".to_string()));\n        assert_eq!(\n            env_vars.chant_worktree_path,\n            Some(\"/tmp/chant-test-spec\".to_string())\n        );\n        assert_eq!(env_vars.chant_branch, None);\n    }\n\n    #[test]\n    fn test_worktree_env_vars_no_worktree() {\n        let env_vars = WorktreeEnvVars::compute(None, None);\n\n        assert!(!env_vars.is_worktree_mode());\n        assert_eq!(env_vars.chant_worktree, None);\n        assert_eq!(env_vars.chant_worktree_path, None);\n        assert_eq!(env_vars.chant_branch, None);\n    }\n\n    #[test]\n    fn test_worktree_env_vars_no_worktree_with_branch_ignored() {\n        // Even if branch is provided, without worktree path, no env vars are set\n        let env_vars = WorktreeEnvVars::compute(None, Some(\"some-branch\"));\n\n        assert!(!env_vars.is_worktree_mode());\n        assert_eq!(env_vars.chant_worktree, None);\n        assert_eq!(env_vars.chant_worktree_path, None);\n        assert_eq!(env_vars.chant_branch, None);\n    }\n\n    #[test]\n    fn test_worktree_env_vars_different_paths() {\n        // Test with various path formats\n        let paths = [\n            \"/tmp/chant-2026-01-30-001-abc\",\n            \"/home/user/worktrees/chant-spec\",\n            \"/var/tmp/test\",\n        ];\n\n        for path_str in \u0026paths {\n            let path = Path::new(path_str);\n            let env_vars = WorktreeEnvVars::compute(Some(path), Some(\"test-branch\"));\n\n            assert!(env_vars.is_worktree_mode());\n            assert_eq!(env_vars.chant_worktree, Some(\"1\".to_string()));\n            assert_eq!(env_vars.chant_worktree_path, Some(path_str.to_string()));\n            assert_eq!(env_vars.chant_branch, Some(\"test-branch\".to_string()));\n        }\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_assistant_message() {\n        let json_line = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Hello, world!\"}]}}\"#;\n        let texts = extract_text_from_stream_json(json_line);\n        assert_eq!(texts, vec![\"Hello, world!\"]);\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_multiple_content() {\n        let json_line =\n            r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Line 1\"},{\"text\":\"Line 2\"}]}}\"#;\n        let texts = extract_text_from_stream_json(json_line);\n        assert_eq!(texts, vec![\"Line 1\", \"Line 2\"]);\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_non_assistant() {\n        let json_line = r#\"{\"type\":\"user\",\"message\":{\"content\":[{\"text\":\"Should be ignored\"}]}}\"#;\n        let texts = extract_text_from_stream_json(json_line);\n        assert!(texts.is_empty());\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_invalid_json() {\n        let json_line = \"not valid json\";\n        let texts = extract_text_from_stream_json(json_line);\n        assert!(texts.is_empty());\n    }\n\n    #[test]\n    fn test_get_model_for_invocation_config_model() {\n        // Clear env vars for test isolation\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let model = get_model_for_invocation(Some(\"claude-3-opus\"));\n        assert_eq!(model, \"claude-3-opus\");\n    }\n\n    #[test]\n    fn test_get_model_for_invocation_fallback() {\n        // Clear env vars for test isolation\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let model = get_model_for_invocation(None);\n        assert_eq!(model, \"haiku\");\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":6}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":27}},{"line":282,"address":[],"length":0,"stats":{"Line":17}},{"line":283,"address":[],"length":0,"stats":{"Line":34}},{"line":284,"address":[],"length":0,"stats":{"Line":34}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":17}},{"line":292,"address":[],"length":0,"stats":{"Line":4}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":10}},{"line":340,"address":[],"length":0,"stats":{"Line":20}},{"line":342,"address":[],"length":0,"stats":{"Line":18}},{"line":343,"address":[],"length":0,"stats":{"Line":48}},{"line":344,"address":[],"length":0,"stats":{"Line":10}},{"line":346,"address":[],"length":0,"stats":{"Line":15}},{"line":347,"address":[],"length":0,"stats":{"Line":15}},{"line":349,"address":[],"length":0,"stats":{"Line":13}},{"line":350,"address":[],"length":0,"stats":{"Line":52}},{"line":351,"address":[],"length":0,"stats":{"Line":21}},{"line":358,"address":[],"length":0,"stats":{"Line":10}},{"line":367,"address":[],"length":0,"stats":{"Line":11}},{"line":369,"address":[],"length":0,"stats":{"Line":14}},{"line":370,"address":[],"length":0,"stats":{"Line":3}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":376,"address":[],"length":0,"stats":{"Line":11}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":383,"address":[],"length":0,"stats":{"Line":12}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":385,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":10}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":8}},{"line":406,"address":[],"length":0,"stats":{"Line":7}},{"line":409,"address":[],"length":0,"stats":{"Line":14}},{"line":411,"address":[],"length":0,"stats":{"Line":21}},{"line":412,"address":[],"length":0,"stats":{"Line":21}},{"line":416,"address":[],"length":0,"stats":{"Line":21}},{"line":419,"address":[],"length":0,"stats":{"Line":14}},{"line":420,"address":[],"length":0,"stats":{"Line":14}},{"line":421,"address":[],"length":0,"stats":{"Line":14}},{"line":422,"address":[],"length":0,"stats":{"Line":14}},{"line":423,"address":[],"length":0,"stats":{"Line":14}},{"line":425,"address":[],"length":0,"stats":{"Line":7}},{"line":429,"address":[],"length":0,"stats":{"Line":23}},{"line":432,"address":[],"length":0,"stats":{"Line":46}},{"line":433,"address":[],"length":0,"stats":{"Line":46}},{"line":434,"address":[],"length":0,"stats":{"Line":23}},{"line":439,"address":[],"length":0,"stats":{"Line":13}},{"line":440,"address":[],"length":0,"stats":{"Line":39}},{"line":441,"address":[],"length":0,"stats":{"Line":39}},{"line":444,"address":[],"length":0,"stats":{"Line":13}},{"line":445,"address":[],"length":0,"stats":{"Line":22}},{"line":449,"address":[],"length":0,"stats":{"Line":26}},{"line":450,"address":[],"length":0,"stats":{"Line":10}},{"line":452,"address":[],"length":0,"stats":{"Line":8}},{"line":455,"address":[],"length":0,"stats":{"Line":52}},{"line":456,"address":[],"length":0,"stats":{"Line":27}},{"line":457,"address":[],"length":0,"stats":{"Line":16}},{"line":458,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":27}},{"line":466,"address":[],"length":0,"stats":{"Line":13}}],"covered":79,"coverable":204},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","agent_rotation.rs"],"content":"//! Agent rotation strategies for single spec execution.\n//!\n//! Supports multiple agent selection strategies:\n//! - `none`: Always use default provider command\n//! - `random`: Weighted random selection\n//! - `round-robin`: Rotate through agents, persisting state\n\nuse anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\nuse chant::config::ParallelConfig;\n\n/// Rotations state file location\nfn rotation_state_path() -\u003e PathBuf {\n    PathBuf::from(\".chant/store/rotation.json\")\n}\n\n/// Ensure the .chant/store directory exists\nfn ensure_store_dir() -\u003e Result\u003c()\u003e {\n    let store_dir = PathBuf::from(\".chant/store\");\n    fs::create_dir_all(\u0026store_dir).context(\"Failed to create .chant/store directory\")\n}\n\n/// Round-robin rotation state\n#[derive(Debug, Serialize, Deserialize)]\nstruct RotationState {\n    /// Index of the last used agent (next will be index + 1)\n    last_index: usize,\n}\n\nimpl RotationState {\n    fn load() -\u003e Result\u003cSelf\u003e {\n        let path = rotation_state_path();\n        if path.exists() {\n            let content =\n                fs::read_to_string(\u0026path).context(\"Failed to read rotation state file\")?;\n            // Handle empty or whitespace-only files\n            if content.trim().is_empty() {\n                return Ok(RotationState { last_index: 0 });\n            }\n            serde_json::from_str(\u0026content).context(\"Failed to parse rotation state file\")\n        } else {\n            Ok(RotationState { last_index: 0 })\n        }\n    }\n\n    fn save(\u0026self) -\u003e Result\u003c()\u003e {\n        ensure_store_dir()?;\n        let path = rotation_state_path();\n        let content =\n            serde_json::to_string_pretty(self).context(\"Failed to serialize rotation state\")?;\n        fs::write(\u0026path, content).context(\"Failed to write rotation state file\")\n    }\n}\n\n/// Select an agent command for single spec execution based on rotation strategy\npub fn select_agent_for_work(\n    rotation_strategy: \u0026str,\n    parallel_config: \u0026ParallelConfig,\n) -\u003e Result\u003cString\u003e {\n    // If no agents configured, fall back to default \"claude\" command\n    if parallel_config.agents.is_empty() {\n        return Ok(\"claude\".to_string());\n    }\n\n    match rotation_strategy {\n        \"none\" =\u003e {\n            // Always use the default (first) agent\n            Ok(parallel_config.agents[0].command.clone())\n        }\n        \"random\" =\u003e select_random_agent(parallel_config),\n        \"round-robin\" =\u003e select_round_robin_agent(parallel_config),\n        _ =\u003e {\n            // Unknown strategy - default to first agent\n            Ok(parallel_config.agents[0].command.clone())\n        }\n    }\n}\n\n/// Select a random agent weighted by the weight field\nfn select_random_agent(parallel_config: \u0026ParallelConfig) -\u003e Result\u003cString\u003e {\n    // Build weighted list: agent appears weight times\n    let mut weighted_agents = Vec::new();\n    for agent in \u0026parallel_config.agents {\n        for _ in 0..agent.weight.max(1) {\n            weighted_agents.push(agent.clone());\n        }\n    }\n\n    if weighted_agents.is_empty() {\n        return Ok(\"claude\".to_string());\n    }\n\n    // Pick random index\n    let index = {\n        use std::collections::hash_map::RandomState;\n        use std::hash::BuildHasher;\n\n        let hash = RandomState::new().hash_one(\n            std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap_or_default(),\n        );\n\n        (hash as usize) % weighted_agents.len()\n    };\n\n    Ok(weighted_agents[index].command.clone())\n}\n\n/// Select agent using round-robin, persisting state\nfn select_round_robin_agent(parallel_config: \u0026ParallelConfig) -\u003e Result\u003cString\u003e {\n    // Build rotation list: agent appears weight times\n    let mut rotation_list = Vec::new();\n    for agent in \u0026parallel_config.agents {\n        for _ in 0..agent.weight.max(1) {\n            rotation_list.push(agent.clone());\n        }\n    }\n\n    if rotation_list.is_empty() {\n        return Ok(\"claude\".to_string());\n    }\n\n    // Load current state\n    let mut state = RotationState::load()?;\n\n    // Get current index (next after last_index)\n    let current_index = (state.last_index + 1) % rotation_list.len();\n    let selected_agent = \u0026rotation_list[current_index];\n\n    // Save updated state\n    state.last_index = current_index;\n    state.save()?;\n\n    Ok(selected_agent.command.clone())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::config::AgentConfig;\n\n    fn make_agent(name: \u0026str, command: \u0026str, weight: usize) -\u003e AgentConfig {\n        AgentConfig {\n            name: name.to_string(),\n            command: command.to_string(),\n            max_concurrent: 2,\n            weight,\n        }\n    }\n\n    #[test]\n    fn test_select_agent_none_strategy() {\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 2),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        let result = select_agent_for_work(\"none\", \u0026config).unwrap();\n        assert_eq!(result, \"claude\");\n    }\n\n    #[test]\n    fn test_select_agent_empty_agents_defaults_to_claude() {\n        let config = ParallelConfig {\n            agents: vec![],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        let result = select_agent_for_work(\"none\", \u0026config).unwrap();\n        assert_eq!(result, \"claude\");\n    }\n\n    #[test]\n    fn test_select_agent_random_strategy_weighted() {\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 10),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        // Run multiple times to check that both agents can be selected\n        let mut selected_commands = std::collections::HashSet::new();\n        for _ in 0..100 {\n            let result = select_agent_for_work(\"random\", \u0026config).unwrap();\n            selected_commands.insert(result);\n        }\n\n        // With 100 iterations, we should likely see both \"claude\" and \"claude-alt1\"\n        // (though it's theoretically possible to only see claude due to high weight)\n        // At minimum, we should see valid command names\n        assert!(!selected_commands.is_empty());\n        for cmd in \u0026selected_commands {\n            assert!(cmd == \"claude\" || cmd == \"claude-alt1\");\n        }\n    }\n\n    #[test]\n    fn test_select_agent_round_robin_rotation() {\n        // Test verifies that round-robin strategy iterates through agents\n        // Note: Due to test isolation, we just verify at least one selection works correctly\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 1),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n                make_agent(\"alt2\", \"claude-alt2\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        // Just verify round-robin selection returns valid agents\n        let result = select_agent_for_work(\"round-robin\", \u0026config).unwrap();\n        assert!(\n            result == \"claude\" || result == \"claude-alt1\" || result == \"claude-alt2\",\n            \"round-robin should return one of the configured agents\"\n        );\n    }\n\n    #[test]\n    fn test_select_agent_round_robin_with_weights() {\n        // Test with weighted agents\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 2),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        // Verify round-robin respects weights by returning valid agents\n        let result = select_agent_for_work(\"round-robin\", \u0026config).unwrap();\n        assert!(\n            result == \"claude\" || result == \"claude-alt1\",\n            \"round-robin should return a weighted agent\"\n        );\n    }\n\n    #[test]\n    fn test_select_agent_unknown_strategy_uses_first_agent() {\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 1),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        let result = select_agent_for_work(\"unknown-strategy\", \u0026config).unwrap();\n        assert_eq!(result, \"claude\");\n    }\n\n    #[test]\n    fn test_select_agent_persists_rotation_state() {\n        // Test verifies that rotation state is saved correctly\n        // This is tested implicitly by other round-robin tests\n        // A full integration test would require a dedicated isolated directory\n        let config = ParallelConfig {\n            agents: vec![\n                make_agent(\"main\", \"claude\", 1),\n                make_agent(\"alt1\", \"claude-alt1\", 1),\n            ],\n            cleanup: chant::config::CleanupConfig::default(),\n            stagger_delay_ms: 1000,\n            stagger_jitter_ms: 200,\n        };\n\n        // Verify the function returns valid results\n        let result = select_agent_for_work(\"round-robin\", \u0026config).unwrap();\n        assert!(\n            result == \"claude\" || result == \"claude-alt1\",\n            \"round-robin should return a valid agent\"\n        );\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":6}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":9}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":9}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":106}},{"line":64,"address":[],"length":0,"stats":{"Line":212}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":105}},{"line":69,"address":[],"length":0,"stats":{"Line":105}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":304}},{"line":74,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":100}},{"line":85,"address":[],"length":0,"stats":{"Line":200}},{"line":86,"address":[],"length":0,"stats":{"Line":300}},{"line":87,"address":[],"length":0,"stats":{"Line":1300}},{"line":88,"address":[],"length":0,"stats":{"Line":3300}},{"line":92,"address":[],"length":0,"stats":{"Line":200}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":100}},{"line":101,"address":[],"length":0,"stats":{"Line":300}},{"line":102,"address":[],"length":0,"stats":{"Line":100}},{"line":103,"address":[],"length":0,"stats":{"Line":100}},{"line":104,"address":[],"length":0,"stats":{"Line":100}},{"line":107,"address":[],"length":0,"stats":{"Line":200}},{"line":110,"address":[],"length":0,"stats":{"Line":100}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":15}},{"line":119,"address":[],"length":0,"stats":{"Line":24}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}}],"covered":52,"coverable":56},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","cleanup.rs"],"content":"//! Cleanup command to remove orphan worktrees and stale artifacts.\n//!\n//! Provides functionality to identify and remove chant worktrees from /tmp\n//! and other stale artifacts, with options for dry-run and confirmation.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse std::collections::HashSet;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse std::time::SystemTime;\n\n/// Information about a worktree\n#[derive(Debug, Clone)]\npub struct WorktreeInfo {\n    /// Directory name (e.g., \"chant-2026-01-25-01g-v2e\")\n    pub name: String,\n    /// Full path to the worktree\n    pub path: PathBuf,\n    /// Size in bytes\n    pub size: u64,\n    /// Age in seconds\n    pub age_secs: u64,\n    /// Whether it's a valid git worktree\n    pub is_valid: bool,\n}\n\nimpl WorktreeInfo {\n    /// Format the size as human-readable string\n    fn format_size(\u0026self) -\u003e String {\n        format_bytes(self.size)\n    }\n\n    /// Format the age as human-readable string\n    fn format_age(\u0026self) -\u003e String {\n        format_age_secs(self.age_secs)\n    }\n}\n\n/// Format bytes into human-readable size (B, KB, MB, GB, TB)\npub fn format_bytes(bytes: u64) -\u003e String {\n    const UNITS: \u0026[\u0026str] = \u0026[\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n    let mut size = bytes as f64;\n    let mut unit_idx = 0;\n\n    while size \u003e= 1024.0 \u0026\u0026 unit_idx \u003c UNITS.len() - 1 {\n        size /= 1024.0;\n        unit_idx += 1;\n    }\n\n    if unit_idx == 0 {\n        format!(\"{} {}\", size as u64, UNITS[unit_idx])\n    } else {\n        format!(\"{:.1} {}\", size, UNITS[unit_idx])\n    }\n}\n\n/// Format age in seconds as human-readable string\npub fn format_age_secs(secs: u64) -\u003e String {\n    const SECONDS_PER_MINUTE: u64 = 60;\n    const SECONDS_PER_HOUR: u64 = 60 * 60;\n    const SECONDS_PER_DAY: u64 = 60 * 60 * 24;\n\n    if secs \u003c SECONDS_PER_MINUTE {\n        format!(\"{} seconds\", secs)\n    } else if secs \u003c SECONDS_PER_HOUR {\n        let minutes = secs / SECONDS_PER_MINUTE;\n        format!(\"{} minute{}\", minutes, if minutes == 1 { \"\" } else { \"s\" })\n    } else if secs \u003c SECONDS_PER_DAY {\n        let hours = secs / SECONDS_PER_HOUR;\n        format!(\"{} hour{}\", hours, if hours == 1 { \"\" } else { \"s\" })\n    } else {\n        let days = secs / SECONDS_PER_DAY;\n        format!(\"{} day{}\", days, if days == 1 { \"\" } else { \"s\" })\n    }\n}\n\n/// Calculate the size of a file or directory recursively\nfn dir_size(path: \u0026PathBuf) -\u003e u64 {\n    if !path.exists() {\n        return 0;\n    }\n\n    match fs::metadata(path) {\n        Ok(metadata) if metadata.is_file() =\u003e metadata.len(),\n        Ok(metadata) if metadata.is_dir() =\u003e fs::read_dir(path)\n            .into_iter()\n            .flatten()\n            .filter_map(|entry| entry.ok())\n            .map(|entry| dir_size(\u0026entry.path()))\n            .sum(),\n        _ =\u003e 0,\n    }\n}\n\n/// Get the age of a directory in seconds\nfn dir_age_secs(path: \u0026PathBuf) -\u003e u64 {\n    match fs::metadata(path) {\n        Ok(metadata) =\u003e match metadata.modified() {\n            Ok(modified_time) =\u003e match SystemTime::now().duration_since(modified_time) {\n                Ok(duration) =\u003e duration.as_secs(),\n                Err(_) =\u003e 0,\n            },\n            Err(_) =\u003e 0,\n        },\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Information about a prunable worktree from git\n#[derive(Debug, Clone)]\nstruct PrunableWorktree {\n    path: PathBuf,\n    /// Some prunable worktrees may not exist on disk\n    exists: bool,\n}\n\n/// Get prunable worktrees from git worktree list\nfn get_prunable_worktrees() -\u003e Result\u003cVec\u003cPrunableWorktree\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"worktree\", \"list\", \"--porcelain\"])\n        .output()?;\n\n    if !output.status.success() {\n        // If git command fails, return empty vec\n        return Ok(Vec::new());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut prunable_worktrees = Vec::new();\n    let mut current_path: Option\u003cPathBuf\u003e = None;\n    let mut is_prunable = false;\n\n    for line in stdout.lines() {\n        if line.starts_with(\"worktree \") {\n            // Save previous if it was prunable\n            if is_prunable {\n                if let Some(path) = current_path.take() {\n                    // Only include chant worktrees\n                    if path\n                        .file_name()\n                        .map(|n| n.to_string_lossy().starts_with(\"chant-\"))\n                        .unwrap_or(false)\n                    {\n                        let exists = path.exists();\n                        prunable_worktrees.push(PrunableWorktree { path, exists });\n                    }\n                }\n            }\n            // Start new entry\n            let path = line.strip_prefix(\"worktree \").unwrap_or(\"\");\n            current_path = Some(PathBuf::from(path));\n            is_prunable = false;\n        } else if line.starts_with(\"prunable\") {\n            is_prunable = true;\n        }\n    }\n\n    // Don't forget the last entry\n    if is_prunable {\n        if let Some(path) = current_path {\n            // Only include chant worktrees\n            if path\n                .file_name()\n                .map(|n| n.to_string_lossy().starts_with(\"chant-\"))\n                .unwrap_or(false)\n            {\n                let exists = path.exists();\n                prunable_worktrees.push(PrunableWorktree { path, exists });\n            }\n        }\n    }\n\n    Ok(prunable_worktrees)\n}\n\n/// Check if a path is a valid git worktree (not prunable and exists)\nfn is_valid_worktree(path: \u0026std::path::Path, prunable_worktrees: \u0026[PrunableWorktree]) -\u003e bool {\n    // If git marks it as prunable, it's not valid\n    if prunable_worktrees.iter().any(|pw| pw.path == path) {\n        return false;\n    }\n\n    // A valid worktree should have a .git file or directory\n    let git_path = path.join(\".git\");\n    git_path.exists()\n}\n\n/// Scan /tmp for orphan chant worktrees\npub fn find_orphan_worktrees() -\u003e Result\u003cVec\u003cWorktreeInfo\u003e\u003e {\n    // Get prunable worktrees from git\n    let prunable_worktrees = get_prunable_worktrees()?;\n\n    let mut worktrees = Vec::new();\n    let mut seen_paths = HashSet::new();\n\n    // First, add all prunable worktrees from git (even if they don't exist on disk)\n    for prunable in \u0026prunable_worktrees {\n        let name = prunable\n            .path\n            .file_name()\n            .map(|n| n.to_string_lossy().to_string())\n            .unwrap_or_else(|| prunable.path.display().to_string());\n\n        let size = if prunable.exists {\n            dir_size(\u0026prunable.path)\n        } else {\n            0\n        };\n\n        let age_secs = if prunable.exists {\n            dir_age_secs(\u0026prunable.path)\n        } else {\n            0\n        };\n\n        worktrees.push(WorktreeInfo {\n            name,\n            path: prunable.path.clone(),\n            size,\n            age_secs,\n            is_valid: false, // Prunable worktrees are not valid\n        });\n\n        seen_paths.insert(prunable.path.clone());\n    }\n\n    // Then scan /tmp for any other chant directories\n    let tmp_path = PathBuf::from(\"/tmp\");\n    if tmp_path.exists() {\n        for entry in fs::read_dir(\u0026tmp_path)? {\n            let entry = entry?;\n            let file_name = entry.file_name();\n            let name_str = file_name.to_string_lossy();\n\n            // Only consider directories starting with \"chant-\"\n            if !name_str.starts_with(\"chant-\") {\n                continue;\n            }\n\n            let path = entry.path();\n\n            // Skip if we already added this from prunable list\n            if seen_paths.contains(\u0026path) {\n                continue;\n            }\n\n            // Skip if not a directory\n            if !path.is_dir() {\n                continue;\n            }\n\n            let is_valid = is_valid_worktree(\u0026path, \u0026prunable_worktrees);\n\n            // We want to show both valid and orphan worktrees, but filter to orphans if requested\n            let size = dir_size(\u0026path);\n            let age_secs = dir_age_secs(\u0026path);\n\n            worktrees.push(WorktreeInfo {\n                name: name_str.to_string(),\n                path,\n                size,\n                age_secs,\n                is_valid,\n            });\n        }\n    }\n\n    // Sort by age (oldest first)\n    worktrees.sort_by_key(|wt| std::cmp::Reverse(wt.age_secs));\n\n    Ok(worktrees)\n}\n\n/// Filter to only orphan worktrees\npub fn filter_orphans(worktrees: \u0026[WorktreeInfo]) -\u003e Vec\u003c\u0026WorktreeInfo\u003e {\n    worktrees.iter().filter(|wt| !wt.is_valid).collect()\n}\n\n/// Run git worktree prune to clean up stale entries\nfn run_git_prune() -\u003e Result\u003c()\u003e {\n    let output = Command::new(\"git\").args([\"worktree\", \"prune\"]).output()?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git worktree prune failed: {}\", stderr);\n    }\n\n    Ok(())\n}\n\n/// Confirm cleanup with the user\nfn confirm_cleanup() -\u003e Result\u003cbool\u003e {\n    use std::io::{self, Write};\n\n    print!(\"? Clean up these worktrees? [Y/n] \");\n    io::stdout().flush()?;\n\n    let mut response = String::new();\n    io::stdin().read_line(\u0026mut response)?;\n\n    let response = response.trim().to_lowercase();\n    Ok(response.is_empty() || response == \"y\" || response == \"yes\")\n}\n\n/// Cleanup only worktrees (used with --worktrees flag)\nfn cleanup_worktrees_only(orphans: \u0026[\u0026WorktreeInfo], dry_run: bool, yes: bool) -\u003e Result\u003c()\u003e {\n    if orphans.is_empty() {\n        println!(\"{}\", \"No orphan worktrees found.\".green());\n        return Ok(());\n    }\n\n    // Display what would be cleaned\n    println!(\"{}\", \"Scanning for orphan worktrees...\".cyan());\n    println!();\n    println!(\n        \"Found {} orphan worktree{}:\",\n        orphans.len().to_string().yellow(),\n        if orphans.len() == 1 { \"\" } else { \"s\" }\n    );\n\n    for worktree in orphans {\n        println!(\n            \"  {} ({}, {})\",\n            worktree.name.bold(),\n            worktree.format_size().yellow(),\n            worktree.format_age().dimmed()\n        );\n    }\n\n    let total: u64 = orphans.iter().map(|wt| wt.size).sum();\n    println!();\n    println!(\"Total: {}\", format_bytes(total).bold().yellow());\n    println!();\n\n    // Handle dry-run\n    if dry_run {\n        println!(\"{}\", \"(dry-run - no changes made)\".dimmed());\n        return Ok(());\n    }\n\n    // Confirm unless --yes is specified\n    if !yes \u0026\u0026 !confirm_cleanup()? {\n        println!(\"{}\", \"Cancelled.\".dimmed());\n        return Ok(());\n    }\n\n    println!();\n\n    // Remove each worktree\n    let mut removed = 0;\n    for worktree in orphans {\n        print!(\"Removing {}... \", worktree.name);\n        std::io::stdout().flush()?;\n\n        // Try to remove the git worktree entry first\n        let _ = Command::new(\"git\")\n            .args([\"worktree\", \"remove\", \u0026worktree.path.to_string_lossy()])\n            .output();\n\n        // Force remove the directory if it exists\n        if worktree.path.exists() {\n            if let Err(e) = fs::remove_dir_all(\u0026worktree.path) {\n                println!(\"{}\", \"failed\".red());\n                eprintln!(\"Error removing {}: {}\", worktree.name, e);\n                continue;\n            }\n        }\n        // Directory removed or doesn't exist - git worktree prune will clean up stale reference\n        println!(\"{}\", \"done\".green());\n        removed += 1;\n    }\n\n    // Run git worktree prune\n    println!(\"Running git worktree prune... \");\n    match run_git_prune() {\n        Ok(_) =\u003e println!(\"{}\", \"done\".green()),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: git worktree prune failed: {}\", e);\n        }\n    }\n\n    println!();\n    println!(\n        \"Cleaned up {} worktree{}, {} reclaimed\",\n        removed.to_string().green(),\n        if removed == 1 { \"\" } else { \"s\" },\n        format_bytes(total).green()\n    );\n\n    Ok(())\n}\n\n/// Execute the cleanup command\npub fn cmd_cleanup(dry_run: bool, yes: bool, worktrees_only: bool) -\u003e Result\u003c()\u003e {\n    // Find all worktrees\n    let all_worktrees = find_orphan_worktrees()?;\n\n    // Filter to only orphans\n    let orphans = filter_orphans(\u0026all_worktrees);\n\n    // If --worktrees flag is specified, skip other cleanup operations\n    if worktrees_only {\n        return cleanup_worktrees_only(\u0026orphans, dry_run, yes);\n    }\n\n    if orphans.is_empty() {\n        println!(\"{}\", \"No orphan worktrees found.\".green());\n        return Ok(());\n    }\n\n    // Display what would be cleaned\n    println!(\"{}\", \"Scanning for orphan worktrees...\".cyan());\n    println!();\n    println!(\n        \"Found {} orphan worktree{}:\",\n        orphans.len().to_string().yellow(),\n        if orphans.len() == 1 { \"\" } else { \"s\" }\n    );\n\n    for worktree in \u0026orphans {\n        println!(\n            \"  {} ({}, {})\",\n            worktree.name.bold(),\n            worktree.format_size().yellow(),\n            worktree.format_age().dimmed()\n        );\n    }\n\n    let total: u64 = orphans.iter().map(|wt| wt.size).sum();\n    println!();\n    println!(\"Total: {}\", format_bytes(total).bold().yellow());\n    println!();\n\n    // Handle dry-run\n    if dry_run {\n        println!(\"{}\", \"(dry-run - no changes made)\".dimmed());\n        return Ok(());\n    }\n\n    // Confirm unless --yes is specified\n    if !yes \u0026\u0026 !confirm_cleanup()? {\n        println!(\"{}\", \"Cancelled.\".dimmed());\n        return Ok(());\n    }\n\n    println!();\n\n    // Remove each worktree\n    let mut removed = 0;\n    for worktree in \u0026orphans {\n        print!(\"Removing {}... \", worktree.name);\n        std::io::stdout().flush()?;\n\n        // Try to remove the git worktree entry first\n        let _ = Command::new(\"git\")\n            .args([\"worktree\", \"remove\", \u0026worktree.path.to_string_lossy()])\n            .output();\n\n        // Force remove the directory if it exists\n        if worktree.path.exists() {\n            if let Err(e) = fs::remove_dir_all(\u0026worktree.path) {\n                println!(\"{}\", \"failed\".red());\n                eprintln!(\"Error removing {}: {}\", worktree.name, e);\n                continue;\n            }\n        }\n        // Directory removed or doesn't exist - git worktree prune will clean up stale reference\n        println!(\"{}\", \"done\".green());\n        removed += 1;\n    }\n\n    // Run git worktree prune\n    println!(\"Running git worktree prune... \");\n    match run_git_prune() {\n        Ok(_) =\u003e println!(\"{}\", \"done\".green()),\n        Err(e) =\u003e {\n            eprintln!(\"Warning: git worktree prune failed: {}\", e);\n        }\n    }\n\n    println!();\n    println!(\n        \"Cleaned up {} worktree{}, {} reclaimed\",\n        removed.to_string().green(),\n        if removed == 1 { \"\" } else { \"s\" },\n        format_bytes(total).green()\n    );\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_format_bytes() {\n        assert_eq!(format_bytes(0), \"0 B\");\n        assert_eq!(format_bytes(500), \"500 B\");\n        assert_eq!(format_bytes(1024), \"1.0 KB\");\n        assert_eq!(format_bytes(1024 * 1024), \"1.0 MB\");\n        assert_eq!(format_bytes(1024 * 1024 * 1024), \"1.0 GB\");\n        assert_eq!(format_bytes(2560), \"2.5 KB\");\n    }\n\n    #[test]\n    fn test_format_age_secs() {\n        assert_eq!(format_age_secs(30), \"30 seconds\");\n        assert_eq!(format_age_secs(60), \"1 minute\");\n        assert_eq!(format_age_secs(120), \"2 minutes\");\n        assert_eq!(format_age_secs(3600), \"1 hour\");\n        assert_eq!(format_age_secs(7200), \"2 hours\");\n        assert_eq!(format_age_secs(86400), \"1 day\");\n        assert_eq!(format_age_secs(172800), \"2 days\");\n    }\n\n    #[test]\n    fn test_filter_orphans() {\n        let worktrees = vec![\n            WorktreeInfo {\n                name: \"chant-valid\".to_string(),\n                path: PathBuf::from(\"/tmp/chant-valid\"),\n                size: 1024,\n                age_secs: 3600,\n                is_valid: true,\n            },\n            WorktreeInfo {\n                name: \"chant-orphan\".to_string(),\n                path: PathBuf::from(\"/tmp/chant-orphan\"),\n                size: 2048,\n                age_secs: 7200,\n                is_valid: false,\n            },\n        ];\n\n        let orphans = filter_orphans(\u0026worktrees);\n        assert_eq!(orphans.len(), 1);\n        assert_eq!(orphans[0].name, \"chant-orphan\");\n    }\n\n    #[test]\n    fn test_get_prunable_worktrees_parsing() {\n        // Simulate git worktree list output with prunable worktree\n        let output = r#\"worktree /Users/test/project\nHEAD abc123def456\nbranch refs/heads/main\n\nworktree /tmp/chant-2026-01-27-001-abc\nHEAD def456abc789\nbranch refs/heads/chant/2026-01-27-001-abc\nprunable gitdir file points to non-existent location\n\"#;\n\n        let mut prunable_worktrees = Vec::new();\n        let mut current_path: Option\u003cPathBuf\u003e = None;\n        let mut is_prunable = false;\n\n        for line in output.lines() {\n            if line.starts_with(\"worktree \") {\n                if is_prunable {\n                    if let Some(path) = current_path.take() {\n                        if path\n                            .file_name()\n                            .map(|n| n.to_string_lossy().starts_with(\"chant-\"))\n                            .unwrap_or(false)\n                        {\n                            prunable_worktrees.push(path);\n                        }\n                    }\n                }\n                let path = line.strip_prefix(\"worktree \").unwrap_or(\"\");\n                current_path = Some(PathBuf::from(path));\n                is_prunable = false;\n            } else if line.starts_with(\"prunable\") {\n                is_prunable = true;\n            }\n        }\n\n        if is_prunable {\n            if let Some(path) = current_path {\n                if path\n                    .file_name()\n                    .map(|n| n.to_string_lossy().starts_with(\"chant-\"))\n                    .unwrap_or(false)\n                {\n                    prunable_worktrees.push(path);\n                }\n            }\n        }\n\n        assert_eq!(prunable_worktrees.len(), 1);\n        assert_eq!(\n            prunable_worktrees[0],\n            PathBuf::from(\"/tmp/chant-2026-01-27-001-abc\")\n        );\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":13}},{"line":45,"address":[],"length":0,"stats":{"Line":26}},{"line":46,"address":[],"length":0,"stats":{"Line":26}},{"line":48,"address":[],"length":0,"stats":{"Line":41}},{"line":49,"address":[],"length":0,"stats":{"Line":7}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":13}},{"line":54,"address":[],"length":0,"stats":{"Line":27}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}}],"covered":22,"coverable":240},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","commits.rs"],"content":"//! Commit tracking and detection for spec finalization.\n//!\n//! Handles finding commits associated with a spec by searching for the\n//! `chant(spec-id): description` pattern in commit messages.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\n\n/// Enum to distinguish between different commit retrieval scenarios\n#[derive(Debug)]\npub enum CommitError {\n    /// Git command failed (e.g., not in a git repository)\n    GitCommandFailed(String),\n    /// Git log succeeded but found no matching commits\n    NoMatchingCommits,\n}\n\nimpl std::fmt::Display for CommitError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            CommitError::GitCommandFailed(err) =\u003e write!(f, \"Git command failed: {}\", err),\n            CommitError::NoMatchingCommits =\u003e write!(f, \"No matching commits found\"),\n        }\n    }\n}\n\nimpl std::error::Error for CommitError {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::process::Command;\n    use tempfile::TempDir;\n\n    /// Helper to set up a test git repository\n    fn setup_test_repo(repo_dir: \u0026std::path::Path, commits: \u0026[(String, String)]) -\u003e Result\u003c()\u003e {\n        // Ensure repo directory exists\n        std::fs::create_dir_all(repo_dir).context(\"Failed to create repo directory\")?;\n\n        // Initialize repo\n        let init = Command::new(\"git\")\n            .args([\"init\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to git init\")?;\n        if !init.status.success() {\n            return Err(anyhow::anyhow!(\n                \"git init failed: {}\",\n                String::from_utf8_lossy(\u0026init.stderr)\n            ));\n        }\n\n        // Configure git\n        let email = Command::new(\"git\")\n            .args([\"config\", \"user.email\", \"test@example.com\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to set git user.email\")?;\n        if !email.status.success() {\n            return Err(anyhow::anyhow!(\n                \"git config user.email failed: {}\",\n                String::from_utf8_lossy(\u0026email.stderr)\n            ));\n        }\n\n        let name = Command::new(\"git\")\n            .args([\"config\", \"user.name\", \"Test User\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to set git user.name\")?;\n        if !name.status.success() {\n            return Err(anyhow::anyhow!(\n                \"git config user.name failed: {}\",\n                String::from_utf8_lossy(\u0026name.stderr)\n            ));\n        }\n\n        // Create commits\n        for (msg, file_content) in commits {\n            let file_path = repo_dir.join(\"test_file.txt\");\n            std::fs::write(\u0026file_path, file_content).context(\"Failed to write test file\")?;\n\n            let add = Command::new(\"git\")\n                .args([\"add\", \"test_file.txt\"])\n                .current_dir(repo_dir)\n                .output()\n                .context(\"Failed to git add\")?;\n            if !add.status.success() {\n                return Err(anyhow::anyhow!(\n                    \"git add failed: {}\",\n                    String::from_utf8_lossy(\u0026add.stderr)\n                ));\n            }\n\n            let commit = Command::new(\"git\")\n                .args([\"commit\", \"-m\", msg])\n                .current_dir(repo_dir)\n                .output()\n                .context(\"Failed to git commit\")?;\n            if !commit.status.success() {\n                return Err(anyhow::anyhow!(\n                    \"git commit failed: {}\",\n                    String::from_utf8_lossy(\u0026commit.stderr)\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_pattern_matches_full_spec_id() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-001-abc\";\n\n        let commits_to_make = vec![\n            (format!(\"chant({}):\", spec_id), \"content 1\".to_string()),\n            (\n                format!(\"chant({}): Fix bug\", spec_id),\n                \"content 2\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Add tests\", spec_id),\n                \"content 3\".to_string(),\n            ),\n        ];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = get_commits_for_spec(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let commits = result?;\n        assert_eq!(\n            commits.len(),\n            3,\n            \"Should find all 3 commits matching full spec ID\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_pattern_with_extra_whitespace() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-007-xyz\";\n\n        // Only test exact format - git grep doesn't match variations\n        let commits_to_make = vec![\n            (format!(\"chant({}):\", spec_id), \"content 1\".to_string()),\n            (\n                format!(\"chant({}): Fix with standard format\", spec_id),\n                \"content 2\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Add more tests\", spec_id),\n                \"content 3\".to_string(),\n            ),\n        ];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        let _ = std::env::set_current_dir(\u0026repo_dir);\n\n        let result = get_commits_for_spec(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let commits = result?;\n        // Should find all commits with standard chant(spec_id): pattern\n        assert_eq!(\n            commits.len(),\n            3,\n            \"Should find all 3 commits with standard pattern\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_pattern_no_match_returns_error() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-003-ghi\";\n        let unrelated_spec = \"2026-01-27-999-zzz\";\n\n        let commits_to_make = vec![\n            (\n                format!(\"chant({}):\", unrelated_spec),\n                \"content 1\".to_string(),\n            ),\n            (\"Some other commit\".to_string(), \"content 2\".to_string()),\n        ];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = get_commits_for_spec(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        assert!(\n            result.is_err(),\n            \"Should return error when no commits match the pattern\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_pattern_with_description() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-004-jkl\";\n\n        let commits_to_make = vec![\n            (\n                format!(\"chant({}): Implement feature\", spec_id),\n                \"content 1\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Fix unit tests\", spec_id),\n                \"content 2\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Update documentation\", spec_id),\n                \"content 3\".to_string(),\n            ),\n        ];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = get_commits_for_spec(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let commits = result?;\n        assert_eq!(\n            commits.len(),\n            3,\n            \"Should find all commits with descriptions\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commits_for_spec_allow_no_commits_with_fallback() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-005-mno\";\n        let unrelated_spec = \"2026-01-27-999-xxx\";\n\n        let commits_to_make = vec![(\n            format!(\"chant({}):\", unrelated_spec),\n            \"content 1\".to_string(),\n        )];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = get_commits_for_spec_allow_no_commits(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let commits = result?;\n        assert_eq!(\n            commits.len(),\n            1,\n            \"Should fallback to HEAD when no commits match\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_pattern_multiple_commits_different_dates() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let spec_id = \"2026-01-27-006-pqr\";\n\n        let commits_to_make = vec![\n            (\n                format!(\"chant({}): First commit\", spec_id),\n                \"v1\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Second commit\", spec_id),\n                \"v2\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Third commit\", spec_id),\n                \"v3\".to_string(),\n            ),\n            (\n                \"unrelated: Some other work\".to_string(),\n                \"other\".to_string(),\n            ),\n            (\n                format!(\"chant({}): Fourth commit\", spec_id),\n                \"v4\".to_string(),\n            ),\n        ];\n\n        setup_test_repo(\u0026repo_dir, \u0026commits_to_make)?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = get_commits_for_spec(spec_id);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let commits = result?;\n        assert_eq!(\n            commits.len(),\n            4,\n            \"Should find all 4 commits for spec ID, excluding unrelated ones\"\n        );\n\n        Ok(())\n    }\n\n    // =========================================================================\n    // AGENT DETECTION TESTS\n    // =========================================================================\n\n    /// Helper to create a test repository with specific commit messages\n    fn setup_test_repo_with_messages(\n        repo_dir: \u0026std::path::Path,\n        messages: \u0026[\u0026str],\n    ) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        // Ensure repo directory exists\n        std::fs::create_dir_all(repo_dir).context(\"Failed to create repo directory\")?;\n\n        // Initialize repo\n        let init = Command::new(\"git\")\n            .args([\"init\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to git init\")?;\n        if !init.status.success() {\n            return Err(anyhow::anyhow!(\n                \"git init failed: {}\",\n                String::from_utf8_lossy(\u0026init.stderr)\n            ));\n        }\n\n        // Configure git\n        Command::new(\"git\")\n            .args([\"config\", \"user.email\", \"test@example.com\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to set git user.email\")?;\n\n        Command::new(\"git\")\n            .args([\"config\", \"user.name\", \"Test User\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to set git user.name\")?;\n\n        // Create commits and collect hashes\n        let mut commit_hashes = Vec::new();\n        for (i, message) in messages.iter().enumerate() {\n            let file_path = repo_dir.join(\"test_file.txt\");\n            std::fs::write(\u0026file_path, format!(\"content {}\", i))\n                .context(\"Failed to write test file\")?;\n\n            Command::new(\"git\")\n                .args([\"add\", \"test_file.txt\"])\n                .current_dir(repo_dir)\n                .output()\n                .context(\"Failed to git add\")?;\n\n            Command::new(\"git\")\n                .args([\"commit\", \"-m\", message])\n                .current_dir(repo_dir)\n                .output()\n                .context(\"Failed to git commit\")?;\n\n            // Get the commit hash\n            let hash_output = Command::new(\"git\")\n                .args([\"rev-parse\", \"--short=7\", \"HEAD\"])\n                .current_dir(repo_dir)\n                .output()\n                .context(\"Failed to get commit hash\")?;\n            let hash = String::from_utf8_lossy(\u0026hash_output.stdout)\n                .trim()\n                .to_string();\n            commit_hashes.push(hash);\n        }\n\n        Ok(commit_hashes)\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_detect_agent_claude_co_authored_by() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let message = \"chant(test-spec): Fix bug\\n\\nCo-Authored-By: Claude \u003cnoreply@anthropic.com\u003e\";\n        let hashes = setup_test_repo_with_messages(\u0026repo_dir, \u0026[message])?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = detect_agent_in_commit(\u0026hashes[0]);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let detection = result?;\n        assert!(detection.has_agent, \"Should detect Claude co-authorship\");\n        assert!(\n            detection.agent_signature.is_some(),\n            \"Should capture agent signature\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_detect_agent_gpt_co_authored_by() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let message = \"chant(test-spec): Add feature\\n\\nCo-authored-by: GPT-4 \u003cnoreply@openai.com\u003e\";\n        let hashes = setup_test_repo_with_messages(\u0026repo_dir, \u0026[message])?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = detect_agent_in_commit(\u0026hashes[0]);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let detection = result?;\n        assert!(detection.has_agent, \"Should detect GPT co-authorship\");\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_no_agent_detected_for_human_commit() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let message = \"chant(test-spec): Human-only commit\\n\\nThis is a regular commit.\";\n        let hashes = setup_test_repo_with_messages(\u0026repo_dir, \u0026[message])?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = detect_agent_in_commit(\u0026hashes[0]);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let detection = result?;\n        assert!(\n            !detection.has_agent,\n            \"Should not detect agent in human commit\"\n        );\n        assert!(\n            detection.agent_signature.is_none(),\n            \"Should have no agent signature\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_detect_agent_case_insensitive() -\u003e Result\u003c()\u003e {\n        let repo_dir = TempDir::new()?.path().to_path_buf();\n        let message =\n            \"chant(test-spec): Test\\n\\nco-authored-by: claude opus 4.5 \u003cnoreply@anthropic.com\u003e\";\n        let hashes = setup_test_repo_with_messages(\u0026repo_dir, \u0026[message])?;\n\n        let original_dir = std::env::current_dir().ok();\n        std::env::set_current_dir(\u0026repo_dir)?;\n\n        let result = detect_agent_in_commit(\u0026hashes[0]);\n\n        if let Some(dir) = original_dir {\n            let _ = std::env::set_current_dir(\u0026dir);\n        }\n\n        let detection = result?;\n        assert!(\n            detection.has_agent,\n            \"Should detect agent with case-insensitive matching\"\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_known_agent_signatures_constant() {\n        // Verify our constant list has the expected patterns\n        assert!(KNOWN_AGENT_SIGNATURES.contains(\u0026\"Co-Authored-By: Claude\"));\n        assert!(KNOWN_AGENT_SIGNATURES.contains(\u0026\"Co-authored-by: Claude\"));\n        assert!(KNOWN_AGENT_SIGNATURES.contains(\u0026\"Co-Authored-By: GPT\"));\n        assert!(KNOWN_AGENT_SIGNATURES.contains(\u0026\"Co-Authored-By: Copilot\"));\n        assert!(KNOWN_AGENT_SIGNATURES.contains(\u0026\"Co-Authored-By: Gemini\"));\n    }\n}\n\n/// Get commits for a spec, failing if no commits match the pattern.\npub fn get_commits_for_spec(spec_id: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    get_commits_for_spec_internal(spec_id, None, false)\n}\n\n/// Get commits for a spec with branch context for better error messages.\n/// If spec_branch is provided, searches that branch first before current branch.\npub fn get_commits_for_spec_with_branch(\n    spec_id: \u0026str,\n    spec_branch: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    get_commits_for_spec_internal(spec_id, spec_branch, false)\n}\n\n/// Get commits for a spec, using HEAD as fallback if no commits match.\npub fn get_commits_for_spec_allow_no_commits(spec_id: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    get_commits_for_spec_internal(spec_id, None, true)\n}\n\n/// Search for commits on a specific branch matching the spec pattern.\n/// Returns Ok(commits) if found, Err if not found or git command failed.\nfn find_commits_on_branch(branch: \u0026str, spec_id: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let pattern = format!(\"chant({}):\", spec_id);\n\n    let output = std::process::Command::new(\"git\")\n        .args([\"log\", branch, \"--oneline\", \"--grep\", \u0026pattern, \"--reverse\"])\n        .output()\n        .context(\"Failed to execute git log command\")?;\n\n    if !output.status.success() {\n        // Branch might not exist or other git error\n        return Ok(vec![]);\n    }\n\n    let mut commits = Vec::new();\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    for line in stdout.lines() {\n        if let Some(hash) = line.split_whitespace().next() {\n            if !hash.is_empty() {\n                commits.push(hash.to_string());\n            }\n        }\n    }\n\n    Ok(commits)\n}\n\nfn get_commits_for_spec_internal(\n    spec_id: \u0026str,\n    spec_branch: Option\u003c\u0026str\u003e,\n    allow_no_commits: bool,\n) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    // Look for all commits with the chant(spec_id): pattern\n    // Include colon and optional space to match the actual commit message format\n    let pattern = format!(\"chant({}):\", spec_id);\n\n    eprintln!(\n        \"{} Searching for commits matching pattern: '{}'\",\n        \"â\".cyan(),\n        pattern\n    );\n\n    // If a spec branch is specified, check that branch first\n    if let Some(branch) = spec_branch {\n        eprintln!(\n            \"{} Checking spec branch '{}' for commits\",\n            \"â\".cyan(),\n            branch\n        );\n        if let Ok(branch_commits) = find_commits_on_branch(branch, spec_id) {\n            if !branch_commits.is_empty() {\n                eprintln!(\n                    \"{} Found {} commit(s) on branch '{}'\",\n                    \"â\".cyan(),\n                    branch_commits.len(),\n                    branch\n                );\n                return Ok(branch_commits);\n            }\n        }\n    }\n\n    let output = std::process::Command::new(\"git\")\n        .args([\"log\", \"--oneline\", \"--grep\", \u0026pattern, \"--reverse\"])\n        .output()\n        .context(\"Failed to execute git log command\")?;\n\n    // Check if git command itself failed\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        let error_msg = format!(\n            \"git log command failed for pattern '{}': {}\",\n            pattern, stderr\n        );\n        eprintln!(\"{} {}\", \"â\".red(), error_msg);\n        return Err(anyhow::anyhow!(CommitError::GitCommandFailed(error_msg)));\n    }\n\n    // Parse commits from successful output\n    let mut commits = Vec::new();\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    for line in stdout.lines() {\n        if let Some(hash) = line.split_whitespace().next() {\n            if !hash.is_empty() {\n                commits.push(hash.to_string());\n            }\n        }\n    }\n\n    eprintln!(\n        \"{} Found {} commit(s) matching pattern '{}'\",\n        \"â\".cyan(),\n        commits.len(),\n        pattern\n    );\n\n    // If no matching commits found, decide what to do based on flag\n    if commits.is_empty() {\n        if allow_no_commits {\n            // Fallback behavior: use HEAD with warning\n            eprintln!(\n                \"{} No commits found with pattern '{}'. Attempting to use HEAD as fallback.\",\n                \"â \".yellow(),\n                pattern\n            );\n\n            let head_output = std::process::Command::new(\"git\")\n                .args([\"rev-parse\", \"--short=7\", \"HEAD\"])\n                .output()\n                .context(\"Failed to execute git rev-parse command\")?;\n\n            if head_output.status.success() {\n                let head_hash = String::from_utf8_lossy(\u0026head_output.stdout)\n                    .trim()\n                    .to_string();\n                if !head_hash.is_empty() {\n                    eprintln!(\"{} Using HEAD commit: {}\", \"â \".yellow(), head_hash);\n                    commits.push(head_hash);\n                }\n            } else {\n                let stderr = String::from_utf8_lossy(\u0026head_output.stderr);\n                let error_msg = format!(\n                    \"Could not find any commit for spec '{}' and HEAD fallback failed: {}\",\n                    spec_id, stderr\n                );\n                eprintln!(\"{} {}\", \"â\".red(), error_msg);\n                return Err(anyhow::anyhow!(CommitError::NoMatchingCommits));\n            }\n        } else {\n            // Default behavior: fail loudly with actionable message\n            // Check if commits exist on the spec's branch to provide better error message\n            let default_branch = format!(\"chant/{}\", spec_id);\n            let branch_to_check = spec_branch.unwrap_or(\u0026default_branch);\n            if let Ok(branch_commits) = find_commits_on_branch(branch_to_check, spec_id) {\n                if !branch_commits.is_empty() {\n                    let error_msg = format!(\n                        \"No matching commits found on main\\n\\\n                         Found {} commit(s) on branch {}\\n\\\n                         Run 'chant merge {}' to merge the branch first\",\n                        branch_commits.len(),\n                        branch_to_check,\n                        spec_id\n                    );\n                    eprintln!(\"{} {}\", \"â\".red(), error_msg);\n                    return Err(anyhow::anyhow!(CommitError::NoMatchingCommits));\n                }\n            }\n            let error_msg =\n                chant::merge_errors::no_commits_found(spec_id, \u0026format!(\"chant/{}\", spec_id));\n            eprintln!(\"{} {}\", \"â\".red(), error_msg);\n            return Err(anyhow::anyhow!(CommitError::NoMatchingCommits));\n        }\n    }\n\n    Ok(commits)\n}\n\n/// Known AI agent signatures in Co-Authored-By trailer format.\n/// These patterns are used to detect agent-assisted commits.\nconst KNOWN_AGENT_SIGNATURES: \u0026[\u0026str] = \u0026[\n    \"Co-Authored-By: Claude\",\n    \"Co-authored-by: Claude\",\n    \"Co-Authored-By: GPT\",\n    \"Co-authored-by: GPT\",\n    \"Co-Authored-By: Copilot\",\n    \"Co-authored-by: Copilot\",\n    \"Co-Authored-By: Gemini\",\n    \"Co-authored-by: Gemini\",\n    \"Co-Authored-By: Cursor\",\n    \"Co-authored-by: Cursor\",\n    // Add more agent signatures as needed\n];\n\n/// Result of agent detection for a commit.\n#[derive(Debug, Clone)]\npub struct AgentDetectionResult {\n    /// The commit hash that was checked. Kept for debugging and future tooling.\n    #[allow(dead_code)]\n    pub commit_hash: String,\n    /// Whether an agent co-authorship was detected\n    pub has_agent: bool,\n    /// The agent signature found (if any)\n    pub agent_signature: Option\u003cString\u003e,\n}\n\n/// Check if a single commit has agent co-authorship.\n/// Returns the detection result with details about what was found.\npub fn detect_agent_in_commit(commit_hash: \u0026str) -\u003e Result\u003cAgentDetectionResult\u003e {\n    // Get the full commit message including trailers\n    let output = std::process::Command::new(\"git\")\n        .args([\"log\", \"-1\", \"--format=%B\", commit_hash])\n        .output()\n        .context(\"Failed to execute git log command\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\n            \"Failed to get commit message for {}: {}\",\n            commit_hash,\n            stderr\n        );\n    }\n\n    let commit_message = String::from_utf8_lossy(\u0026output.stdout);\n\n    // Check for known agent signatures\n    for signature in KNOWN_AGENT_SIGNATURES {\n        if commit_message.contains(signature) {\n            return Ok(AgentDetectionResult {\n                commit_hash: commit_hash.to_string(),\n                has_agent: true,\n                agent_signature: Some(signature.to_string()),\n            });\n        }\n    }\n\n    // Also check for partial matches (case-insensitive) for \"Co-Authored-By:\" trailer\n    let lower_message = commit_message.to_lowercase();\n    if lower_message.contains(\"co-authored-by:\") {\n        // Extract the co-authored-by line\n        for line in commit_message.lines() {\n            let lower_line = line.to_lowercase();\n            if lower_line.starts_with(\"co-authored-by:\") {\n                // Check if this mentions any AI-related terms\n                let ai_terms = [\n                    \"claude\",\n                    \"gpt\",\n                    \"copilot\",\n                    \"gemini\",\n                    \"cursor\",\n                    \"anthropic\",\n                    \"openai\",\n                    \"ai\",\n                    \"assistant\",\n                ];\n                for term in ai_terms {\n                    if lower_line.contains(term) {\n                        return Ok(AgentDetectionResult {\n                            commit_hash: commit_hash.to_string(),\n                            has_agent: true,\n                            agent_signature: Some(line.trim().to_string()),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(AgentDetectionResult {\n        commit_hash: commit_hash.to_string(),\n        has_agent: false,\n        agent_signature: None,\n    })\n}\n\n/// Check if any commits for a spec have agent co-authorship.\n/// Returns a list of all commits that have agent signatures.\n/// Designed for future approval workflow integration.\n#[allow(dead_code)]\npub fn detect_agents_in_spec_commits(spec_id: \u0026str) -\u003e Result\u003cVec\u003cAgentDetectionResult\u003e\u003e {\n    // Get commits for this spec (allowing no commits)\n    let commits = match get_commits_for_spec_allow_no_commits(spec_id) {\n        Ok(c) =\u003e c,\n        Err(_) =\u003e return Ok(vec![]), // No commits found, no agents\n    };\n\n    let mut results = Vec::new();\n    for commit in commits {\n        match detect_agent_in_commit(\u0026commit) {\n            Ok(result) if result.has_agent =\u003e {\n                results.push(result);\n            }\n            Ok(_) =\u003e {\n                // No agent found in this commit, continue\n            }\n            Err(e) =\u003e {\n                // Log warning but continue checking other commits\n                eprintln!(\n                    \"Warning: Failed to check commit {} for agent: {}\",\n                    commit, e\n                );\n            }\n        }\n    }\n\n    Ok(results)\n}\n\n/// Check if any commits for a spec have agent co-authorship.\n/// Simplified helper that returns just a boolean.\n/// Designed for future approval workflow integration.\n#[allow(dead_code)]\npub fn has_agent_coauthorship(spec_id: \u0026str) -\u003e bool {\n    match detect_agents_in_spec_commits(spec_id) {\n        Ok(results) =\u003e !results.is_empty(),\n        Err(_) =\u003e false,\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":537,"address":[],"length":0,"stats":{"Line":9}},{"line":538,"address":[],"length":0,"stats":{"Line":27}},{"line":543,"address":[],"length":0,"stats":{"Line":1}},{"line":547,"address":[],"length":0,"stats":{"Line":3}},{"line":551,"address":[],"length":0,"stats":{"Line":1}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":8}},{"line":560,"address":[],"length":0,"stats":{"Line":12}},{"line":561,"address":[],"length":0,"stats":{"Line":20}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":567,"address":[],"length":0,"stats":{"Line":1}},{"line":570,"address":[],"length":0,"stats":{"Line":6}},{"line":571,"address":[],"length":0,"stats":{"Line":9}},{"line":572,"address":[],"length":0,"stats":{"Line":6}},{"line":573,"address":[],"length":0,"stats":{"Line":6}},{"line":574,"address":[],"length":0,"stats":{"Line":6}},{"line":575,"address":[],"length":0,"stats":{"Line":9}},{"line":580,"address":[],"length":0,"stats":{"Line":3}},{"line":583,"address":[],"length":0,"stats":{"Line":11}},{"line":590,"address":[],"length":0,"stats":{"Line":22}},{"line":592,"address":[],"length":0,"stats":{"Line":11}},{"line":594,"address":[],"length":0,"stats":{"Line":22}},{"line":599,"address":[],"length":0,"stats":{"Line":12}},{"line":600,"address":[],"length":0,"stats":{"Line":1}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":605,"address":[],"length":0,"stats":{"Line":3}},{"line":606,"address":[],"length":0,"stats":{"Line":1}},{"line":607,"address":[],"length":0,"stats":{"Line":1}},{"line":609,"address":[],"length":0,"stats":{"Line":2}},{"line":610,"address":[],"length":0,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":1}},{"line":618,"address":[],"length":0,"stats":{"Line":30}},{"line":619,"address":[],"length":0,"stats":{"Line":40}},{"line":624,"address":[],"length":0,"stats":{"Line":10}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":20}},{"line":636,"address":[],"length":0,"stats":{"Line":30}},{"line":637,"address":[],"length":0,"stats":{"Line":25}},{"line":638,"address":[],"length":0,"stats":{"Line":30}},{"line":639,"address":[],"length":0,"stats":{"Line":30}},{"line":640,"address":[],"length":0,"stats":{"Line":45}},{"line":645,"address":[],"length":0,"stats":{"Line":10}},{"line":647,"address":[],"length":0,"stats":{"Line":20}},{"line":648,"address":[],"length":0,"stats":{"Line":20}},{"line":653,"address":[],"length":0,"stats":{"Line":20}},{"line":654,"address":[],"length":0,"stats":{"Line":4}},{"line":656,"address":[],"length":0,"stats":{"Line":1}},{"line":658,"address":[],"length":0,"stats":{"Line":2}},{"line":662,"address":[],"length":0,"stats":{"Line":3}},{"line":663,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":668,"address":[],"length":0,"stats":{"Line":2}},{"line":671,"address":[],"length":0,"stats":{"Line":2}},{"line":672,"address":[],"length":0,"stats":{"Line":4}},{"line":673,"address":[],"length":0,"stats":{"Line":2}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":6}},{"line":688,"address":[],"length":0,"stats":{"Line":12}},{"line":689,"address":[],"length":0,"stats":{"Line":9}},{"line":690,"address":[],"length":0,"stats":{"Line":3}},{"line":691,"address":[],"length":0,"stats":{"Line":4}},{"line":695,"address":[],"length":0,"stats":{"Line":4}},{"line":699,"address":[],"length":0,"stats":{"Line":6}},{"line":700,"address":[],"length":0,"stats":{"Line":2}},{"line":703,"address":[],"length":0,"stats":{"Line":1}},{"line":704,"address":[],"length":0,"stats":{"Line":3}},{"line":705,"address":[],"length":0,"stats":{"Line":3}},{"line":706,"address":[],"length":0,"stats":{"Line":1}},{"line":710,"address":[],"length":0,"stats":{"Line":7}},{"line":743,"address":[],"length":0,"stats":{"Line":4}},{"line":745,"address":[],"length":0,"stats":{"Line":12}},{"line":746,"address":[],"length":0,"stats":{"Line":12}},{"line":750,"address":[],"length":0,"stats":{"Line":4}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":12}},{"line":762,"address":[],"length":0,"stats":{"Line":25}},{"line":763,"address":[],"length":0,"stats":{"Line":50}},{"line":764,"address":[],"length":0,"stats":{"Line":2}},{"line":765,"address":[],"length":0,"stats":{"Line":6}},{"line":766,"address":[],"length":0,"stats":{"Line":2}},{"line":767,"address":[],"length":0,"stats":{"Line":2}},{"line":773,"address":[],"length":0,"stats":{"Line":4}},{"line":774,"address":[],"length":0,"stats":{"Line":2}},{"line":776,"address":[],"length":0,"stats":{"Line":4}},{"line":777,"address":[],"length":0,"stats":{"Line":9}},{"line":778,"address":[],"length":0,"stats":{"Line":3}},{"line":780,"address":[],"length":0,"stats":{"Line":2}},{"line":781,"address":[],"length":0,"stats":{"Line":1}},{"line":782,"address":[],"length":0,"stats":{"Line":2}},{"line":783,"address":[],"length":0,"stats":{"Line":2}},{"line":784,"address":[],"length":0,"stats":{"Line":2}},{"line":785,"address":[],"length":0,"stats":{"Line":2}},{"line":786,"address":[],"length":0,"stats":{"Line":2}},{"line":787,"address":[],"length":0,"stats":{"Line":2}},{"line":788,"address":[],"length":0,"stats":{"Line":1}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":2}},{"line":792,"address":[],"length":0,"stats":{"Line":2}},{"line":793,"address":[],"length":0,"stats":{"Line":1}},{"line":794,"address":[],"length":0,"stats":{"Line":3}},{"line":795,"address":[],"length":0,"stats":{"Line":1}},{"line":796,"address":[],"length":0,"stats":{"Line":1}},{"line":804,"address":[],"length":0,"stats":{"Line":1}},{"line":805,"address":[],"length":0,"stats":{"Line":2}},{"line":806,"address":[],"length":0,"stats":{"Line":1}},{"line":807,"address":[],"length":0,"stats":{"Line":1}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}}],"covered":108,"coverable":137},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","config.rs"],"content":"//! Config command for validating chant configuration\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse std::path::Path;\nuse std::process::Command;\n\nuse chant::config::Config;\nuse chant::paths::PROMPTS_DIR;\n\n/// Validate config semantically and report issues\npub fn cmd_config_validate() -\u003e Result\u003c()\u003e {\n    let config = Config::load()?;\n\n    println!(\"{}\", \"Validating chant configuration...\".bold());\n    println!();\n\n    let mut errors = 0;\n    let mut warnings = 0;\n\n    // Validate parallel agents\n    errors += validate_agents(\u0026config);\n\n    // Validate prompts\n    errors += validate_prompts(\u0026config);\n\n    // Show parallel config (informational only)\n    show_parallel_config(\u0026config);\n\n    // Check recommended fields\n    warnings += check_recommended_fields(\u0026config);\n\n    // Summary\n    println!();\n    if errors == 0 \u0026\u0026 warnings == 0 {\n        println!(\"{} Configuration is valid\", \"â\".green());\n    } else if errors == 0 {\n        println!(\n            \"{} Configuration valid with {} warning(s)\",\n            \"â\".green(),\n            warnings\n        );\n    } else {\n        println!(\n            \"{} Found {} error(s) and {} warning(s)\",\n            \"â\".red(),\n            errors,\n            warnings\n        );\n        std::process::exit(1);\n    }\n\n    Ok(())\n}\n\n/// Validate parallel agent commands exist in PATH\nfn validate_agents(config: \u0026Config) -\u003e usize {\n    let agents = \u0026config.parallel.agents;\n    if agents.is_empty() {\n        return 0;\n    }\n\n    println!(\"{}\", \"Checking parallel agents...\".dimmed());\n\n    let mut errors = 0;\n\n    for agent in agents {\n        let found = command_exists(\u0026agent.command);\n        if found {\n            println!(\n                \"  {} {} ({}) - found in PATH\",\n                \"â\".green(),\n                agent.name,\n                agent.command.dimmed()\n            );\n        } else {\n            println!(\n                \"  {} {} ({}) - not found in PATH\",\n                \"â\".red(),\n                agent.name,\n                agent.command\n            );\n            errors += 1;\n        }\n    }\n\n    errors\n}\n\n/// Check if a command exists in PATH\nfn command_exists(cmd: \u0026str) -\u003e bool {\n    Command::new(\"which\")\n        .arg(cmd)\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Validate referenced prompts exist\nfn validate_prompts(config: \u0026Config) -\u003e usize {\n    println!(\"{}\", \"Checking prompts...\".dimmed());\n\n    let prompts_dir = Path::new(PROMPTS_DIR);\n    let mut errors = 0;\n\n    // Check default prompt\n    let default_prompt = \u0026config.defaults.prompt;\n    let default_path = prompts_dir.join(format!(\"{}.md\", default_prompt));\n    if default_path.exists() {\n        println!(\"  {} {}.md (defaults.prompt)\", \"â\".green(), default_prompt);\n    } else {\n        println!(\n            \"  {} {}.md not found (defaults.prompt)\",\n            \"â\".red(),\n            default_prompt\n        );\n        errors += 1;\n    }\n\n    // Check cleanup prompt\n    let cleanup_prompt = \u0026config.parallel.cleanup.prompt;\n    let cleanup_path = prompts_dir.join(format!(\"{}.md\", cleanup_prompt));\n    if cleanup_path.exists() {\n        println!(\n            \"  {} {}.md (parallel.cleanup.prompt)\",\n            \"â\".green(),\n            cleanup_prompt\n        );\n    } else if config.parallel.cleanup.enabled {\n        println!(\n            \"  {} {}.md not found (parallel.cleanup.prompt)\",\n            \"â\".red(),\n            cleanup_prompt\n        );\n        errors += 1;\n    }\n\n    errors\n}\n\n/// Display parallel configuration (informational, no warnings)\nfn show_parallel_config(config: \u0026Config) {\n    let agents = \u0026config.parallel.agents;\n    if agents.is_empty() {\n        return;\n    }\n\n    println!(\"{}\", \"Parallel config...\".dimmed());\n\n    let total_capacity = config.parallel.total_capacity();\n\n    println!(\n        \"  {} {} agent(s), total capacity: {}\",\n        \"â¹\".blue(),\n        agents.len(),\n        total_capacity\n    );\n}\n\n/// Check for missing recommended fields\nfn check_recommended_fields(config: \u0026Config) -\u003e usize {\n    println!(\"{}\", \"Checking recommended fields...\".dimmed());\n\n    let mut warnings = 0;\n\n    if let Some(model) = \u0026config.defaults.model {\n        println!(\"  {} defaults.model: {}\", \"â\".green(), model);\n    } else {\n        println!(\"  {} No defaults.model set - will use haiku\", \"â \".yellow());\n        warnings += 1;\n    }\n\n    warnings\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_command_exists_finds_common_commands() {\n        // 'ls' should exist on all Unix systems\n        assert!(command_exists(\"ls\"));\n    }\n\n    #[test]\n    fn test_command_exists_returns_false_for_nonexistent() {\n        assert!(!command_exists(\"definitely-not-a-real-command-xyz\"));\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":91},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","derive.rs"],"content":"//! Derivation command for manual field derivation on specs.\n//!\n//! Allows users to:\n//! - Re-derive fields after changing enterprise config\n//! - Test derivation patterns before committing to config\n//! - Derive fields for existing specs created before enterprise config\n//! - Preview derived fields with --dry-run mode\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\n\nuse chant::config::Config;\nuse chant::derivation::{self, DerivationEngine};\nuse chant::spec;\n\n/// Derive fields for one or all specs\npub fn cmd_derive(spec_id: Option\u003cString\u003e, all: bool, dry_run: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let config = Config::load()?;\n\n    // Fast path: no-op if no enterprise config\n    if config.enterprise.derived.is_empty() {\n        println!(\"No enterprise derivation configured\");\n        return Ok(());\n    }\n\n    // Determine which specs to process\n    let specs = if all {\n        spec::load_all_specs(\u0026specs_dir)?\n    } else if let Some(id) = spec_id {\n        vec![spec::resolve_spec(\u0026specs_dir, \u0026id)?]\n    } else {\n        anyhow::bail!(\"Specify --all or provide SPEC_ID\");\n    };\n\n    // Process each spec\n    for spec in specs {\n        let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n        let context = derivation::build_context(\u0026spec.id, \u0026specs_dir);\n        let engine = DerivationEngine::new(config.enterprise.clone());\n        let derived = engine.derive_fields(\u0026context);\n\n        if derived.is_empty() {\n            println!(\"{}: no fields derived\", spec.id.cyan());\n        } else if dry_run {\n            print_derived_fields(\u0026spec.id, \u0026derived);\n        } else {\n            // Update the spec with derived fields\n            let mut updated_spec = spec.clone();\n            updated_spec.add_derived_fields(derived.clone());\n            updated_spec\n                .save(\u0026spec_path)\n                .context(\"Failed to save spec with derived fields\")?;\n\n            println!(\n                \"{}: updated with {} derived field(s)\",\n                spec.id.green(),\n                derived.len()\n            );\n            for (key, value) in \u0026derived {\n                println!(\"  {} = {}\", key.cyan(), value);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Print derived fields to stdout in a human-readable format\nfn print_derived_fields(spec_id: \u0026str, fields: \u0026std::collections::HashMap\u003cString, String\u003e) {\n    println!(\"{}: would derive {} field(s)\", spec_id.cyan(), fields.len());\n    for (key, value) in fields {\n        println!(\"  {} = {}\", key.cyan(), value);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n\n    #[test]\n    #[serial_test::serial]\n    fn test_derive_no_enterprise_config() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Initialize chant\n            crate::cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            )\n            .expect(\"Failed to init chant\");\n\n            // Run derive with no enterprise config\n            let result = cmd_derive(None, true, false);\n            assert!(result.is_ok());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_derive_single_spec_dry_run() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Initialize chant\n            crate::cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            )\n            .expect(\"Failed to init chant\");\n\n            // Create a spec\n            let specs_dir = temp_dir.path().join(\".chant/specs\");\n            let spec_content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Test Spec\n\nTest spec for derivation\n\n## Acceptance Criteria\n\n- [ ] Test completed\n\"#;\n            let spec_path = specs_dir.join(\"2026-01-27-test-abc.md\");\n            fs::write(\u0026spec_path, spec_content).expect(\"Failed to write spec\");\n\n            // Add enterprise config with derivation\n            let config_path = temp_dir.path().join(\".chant/config.md\");\n            let config_content = r#\"---\nproject:\n  name: test-project\n\ndefaults:\n  prompt: standard\n\nenterprise:\n  derived:\n    team:\n      from: env\n      pattern: TEAM_NAME\n---\n\n# Chant Configuration\n\"#;\n            fs::write(\u0026config_path, config_content).expect(\"Failed to write config\");\n\n            // Run derive with dry-run (should not fail even without env var set)\n            let result = cmd_derive(Some(\"2026-01-27-test-abc\".to_string()), false, true);\n            assert!(result.is_ok());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":6}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":27,"coverable":34},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","disk.rs"],"content":"//! Disk usage command to show size of chant artifacts.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse std::path::PathBuf;\nuse std::process::Command;\n\nuse chant::paths::{ARCHIVE_DIR, LOCKS_DIR, LOGS_DIR, PROMPTS_DIR, SPECS_DIR, STORE_DIR};\n\n/// Calculate disk usage of a directory using du command\nfn dir_size(path: \u0026PathBuf) -\u003e u64 {\n    if !path.exists() {\n        return 0;\n    }\n\n    // Try with -sb first (Linux), fall back to -s (macOS) with block conversion\n    let output = Command::new(\"du\").arg(\"-s\").arg(path).output();\n\n    match output {\n        Ok(output) =\u003e {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            stdout\n                .split_whitespace()\n                .next()\n                .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                .map(|blocks| blocks * 512) // Convert 512-byte blocks to bytes\n                .unwrap_or(0)\n        }\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Format bytes into human-readable size (B, KB, MB, GB)\nfn format_size(bytes: u64) -\u003e String {\n    const UNITS: \u0026[\u0026str] = \u0026[\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n    let mut size = bytes as f64;\n    let mut unit_idx = 0;\n\n    while size \u003e= 1024.0 \u0026\u0026 unit_idx \u003c UNITS.len() - 1 {\n        size /= 1024.0;\n        unit_idx += 1;\n    }\n\n    if unit_idx == 0 {\n        format!(\"{} {}\", size as u64, UNITS[unit_idx])\n    } else {\n        format!(\"{:.1} {}\", size, UNITS[unit_idx])\n    }\n}\n\n/// Calculate size of worktrees in /tmp (chant-\u003cspec-id\u003e directories and files)\nfn worktree_size() -\u003e u64 {\n    let tmp_path = PathBuf::from(\"/tmp\");\n    if !tmp_path.exists() {\n        return 0;\n    }\n\n    std::fs::read_dir(\u0026tmp_path)\n        .into_iter()\n        .flatten()\n        .filter_map(|entry| entry.ok())\n        .filter(|entry| {\n            entry\n                .file_name()\n                .to_str()\n                .map(|name| name.starts_with(\"chant-\"))\n                .unwrap_or(false)\n        })\n        .map(|entry| {\n            let path = entry.path();\n            if let Ok(metadata) = entry.metadata() {\n                if metadata.is_dir() {\n                    dir_size(\u0026path)\n                } else {\n                    metadata.len()\n                }\n            } else {\n                0\n            }\n        })\n        .sum()\n}\n\n/// Count worktrees in /tmp\nfn count_worktrees() -\u003e usize {\n    let tmp_path = PathBuf::from(\"/tmp\");\n    if !tmp_path.exists() {\n        return 0;\n    }\n\n    std::fs::read_dir(\u0026tmp_path)\n        .into_iter()\n        .flatten()\n        .filter_map(|entry| entry.ok())\n        .filter(|entry| {\n            entry\n                .file_name()\n                .to_str()\n                .map(|name| name.starts_with(\"chant-\"))\n                .unwrap_or(false)\n        })\n        .count()\n}\n\n/// Show disk usage of chant artifacts\npub fn cmd_disk() -\u003e Result\u003c()\u003e {\n    // Ensure chant is initialized\n    let _specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Calculate sizes for each directory\n    let specs_size = dir_size(\u0026PathBuf::from(SPECS_DIR));\n    let prompts_size = dir_size(\u0026PathBuf::from(PROMPTS_DIR));\n    let logs_size = dir_size(\u0026PathBuf::from(LOGS_DIR));\n    let archive_size = dir_size(\u0026PathBuf::from(ARCHIVE_DIR));\n    let locks_size = dir_size(\u0026PathBuf::from(LOCKS_DIR));\n    let store_size = dir_size(\u0026PathBuf::from(STORE_DIR));\n    let worktree_usage = worktree_size();\n    let worktree_count = count_worktrees();\n\n    // Calculate totals\n    let chant_dir_total =\n        specs_size + prompts_size + logs_size + archive_size + locks_size + store_size;\n    let grand_total = chant_dir_total + worktree_usage;\n\n    // Display results\n    println!(\"{}\", \"Chant Disk Usage\".bold().cyan());\n    println!();\n\n    println!(\"{}\", \".chant/ directory breakdown:\".bold());\n    println!(\"  {:\u003c20} {}\", \"Specs:\", format_size(specs_size).yellow());\n    println!(\n        \"  {:\u003c20} {}\",\n        \"Prompts:\",\n        format_size(prompts_size).yellow()\n    );\n    println!(\"  {:\u003c20} {}\", \"Logs:\", format_size(logs_size).yellow());\n    println!(\n        \"  {:\u003c20} {}\",\n        \"Archive:\",\n        format_size(archive_size).yellow()\n    );\n    println!(\"  {:\u003c20} {}\", \"Locks:\", format_size(locks_size).yellow());\n    println!(\"  {:\u003c20} {}\", \"Store:\", format_size(store_size).yellow());\n    println!(\n        \"  {:\u003c20} {}\",\n        \".chant/ Total:\",\n        format_size(chant_dir_total).cyan().bold()\n    );\n    println!();\n\n    println!(\"{}\", \"Worktrees in /tmp:\".bold());\n    println!(\n        \"  {:\u003c20} {} worktrees\",\n        \"Count:\",\n        worktree_count.to_string().yellow()\n    );\n    println!(\n        \"  {:\u003c20} {}\",\n        \"Total Size:\",\n        format_size(worktree_usage).yellow()\n    );\n    println!();\n\n    println!(\"{}\", \"Grand Total:\".bold());\n    println!(\"  {}\", format_size(grand_total).green().bold());\n\n    Ok(())\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","dispatch.rs"],"content":"//! Command dispatch trait for reducing main.rs boilerplate\n//!\n//! This module defines the `Execute` trait that Commands enum implements,\n//! moving the dispatch logic out of a massive match statement in main.rs.\n\nuse anyhow::Result;\n\n/// Trait for executing CLI commands\n///\n/// Each command variant should implement this trait to handle its execution logic.\n/// This allows the main `run()` function to simply call `command.execute()` instead\n/// of maintaining a large match statement with destructuring and forwarding logic.\npub trait Execute {\n    /// Execute the command and return a result\n    fn execute(self) -\u003e Result\u003c()\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","export.rs"],"content":"//! Export command for exporting specs to various formats\n//!\n//! Supports JSON, CSV, and Markdown formats with flexible filtering options\n//! including status, type, labels, and date ranges.\n//!\n//! When run without the --format flag, launches an interactive wizard to configure options.\n\nuse anyhow::{Context, Result};\nuse atty;\nuse dialoguer::Select;\nuse serde_json::json;\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::PathBuf;\n\nuse chant::spec::{self, Spec};\nuse chant::spec_group;\n\n/// Print usage hint for export command in non-TTY contexts\nfn print_export_usage_hint() {\n    println!(\"Usage: chant export --format \u003cFORMAT\u003e\\n\");\n    println!(\"Formats: json, csv, markdown\\n\");\n    println!(\"Examples:\");\n    println!(\"  chant export --format json\");\n    println!(\"  chant export --format csv --output specs.csv\");\n    println!(\"  chant export --format markdown --status completed\\n\");\n    println!(\"Run 'chant export --help' for all options.\");\n}\n\n/// Holds the result of the interactive wizard\nstruct WizardOptions {\n    format: String,\n    statuses: Vec\u003cString\u003e,\n    type_filter: Option\u003cString\u003e,\n    labels: Vec\u003cString\u003e,\n    ready_only: bool,\n    output_file: Option\u003cString\u003e,\n}\n\n/// Main export command handler\n#[allow(clippy::too_many_arguments)]\npub fn cmd_export(\n    format: Option\u003c\u0026str\u003e,\n    statuses: \u0026[String],\n    type_filter: Option\u003c\u0026str\u003e,\n    labels: \u0026[String],\n    ready_only: bool,\n    from_date: Option\u003c\u0026str\u003e,\n    to_date: Option\u003c\u0026str\u003e,\n    fields: Option\u003c\u0026str\u003e,\n    output_file: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    // Detect wizard mode: triggered if format is None AND no other filters are set\n    let is_wizard_mode = format.is_none()\n        \u0026\u0026 statuses.is_empty()\n        \u0026\u0026 type_filter.is_none()\n        \u0026\u0026 labels.is_empty()\n        \u0026\u0026 !ready_only\n        \u0026\u0026 from_date.is_none()\n        \u0026\u0026 to_date.is_none()\n        \u0026\u0026 output_file.is_none();\n\n    // If wizard mode, check for TTY\n    let options = if is_wizard_mode {\n        // If not a TTY, print usage hint instead of launching wizard\n        if !atty::is(atty::Stream::Stdin) {\n            print_export_usage_hint();\n            return Ok(());\n        }\n        run_wizard()?\n    } else {\n        // Direct mode: use provided values\n        WizardOptions {\n            format: format.unwrap_or(\"json\").to_string(),\n            statuses: statuses.to_vec(),\n            type_filter: type_filter.map(|s| s.to_string()),\n            labels: labels.to_vec(),\n            ready_only,\n            output_file: output_file.map(|s| s.to_string()),\n        }\n    };\n\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Load all specs\n    let mut specs = spec::load_all_specs(\u0026specs_dir)?;\n    specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    // Apply filters\n    apply_filters(\n        \u0026mut specs,\n        \u0026options.statuses,\n        options.type_filter.as_deref(),\n        \u0026options.labels,\n        options.ready_only,\n        from_date,\n        to_date,\n    )?;\n\n    if specs.is_empty() {\n        let output = \"No specs match the specified filters.\";\n        if let Some(file_path) = \u0026options.output_file {\n            let mut file = File::create(file_path).context(\"Failed to create output file\")?;\n            writeln!(file, \"{}\", output).context(\"Failed to write to output file\")?;\n        } else {\n            println!(\"{}\", output);\n        }\n        return Ok(());\n    }\n\n    // Generate output based on format\n    let output = match options.format.to_lowercase().as_str() {\n        \"json\" =\u003e export_json(\u0026specs, fields)?,\n        \"csv\" =\u003e export_csv(\u0026specs, fields)?,\n        \"markdown\" | \"md\" =\u003e export_markdown(\u0026specs, fields)?,\n        _ =\u003e anyhow::bail!(\n            \"Unknown format: {}. Supported formats: json, csv, markdown\",\n            options.format\n        ),\n    };\n\n    // Write output\n    if let Some(file_path) = options.output_file {\n        let mut file = File::create(\u0026file_path).context(\"Failed to create output file\")?;\n        write!(file, \"{}\", output).context(\"Failed to write to output file\")?;\n        println!(\"Export written to: {}\", file_path);\n    } else {\n        println!(\"{}\", output);\n    }\n\n    Ok(())\n}\n\n/// Run the interactive wizard to configure export options\nfn run_wizard() -\u003e Result\u003cWizardOptions\u003e {\n    use dialoguer::{Input, MultiSelect};\n\n    // 1. Ask for format\n    let formats = vec![\"JSON\", \"CSV\", \"Markdown\"];\n    let format_selection = Select::new()\n        .with_prompt(\"Export format:\")\n        .items(\u0026formats)\n        .default(0)\n        .interact()?;\n    let format = formats[format_selection].to_lowercase();\n\n    // 2. Ask for status filter\n    let status_options = vec![\n        \"pending\",\n        \"ready\",\n        \"in_progress\",\n        \"completed\",\n        \"blocked\",\n        \"cancelled\",\n    ];\n    let status_selections = MultiSelect::new()\n        .with_prompt(\"Filter by status (space to toggle, enter to confirm):\")\n        .items(\u0026status_options)\n        .defaults(\u0026[false, true, false, false, false, false]) // ready is selected by default\n        .interact()?;\n\n    let statuses: Vec\u003cString\u003e = status_options\n        .iter()\n        .enumerate()\n        .filter_map(|(i, \u0026s)| {\n            if status_selections.contains(\u0026i) {\n                Some(s.to_string())\n            } else {\n                None\n            }\n        })\n        .collect();\n\n    // 3. Ask for type filter\n    let type_options = vec![\n        \"No filter\",\n        \"code\",\n        \"task\",\n        \"driver\",\n        \"documentation\",\n        \"research\",\n    ];\n    let type_selection = Select::new()\n        .with_prompt(\"Filter by type:\")\n        .items(\u0026type_options)\n        .default(0)\n        .interact()?;\n    let type_filter = if type_selection == 0 {\n        None\n    } else {\n        Some(type_options[type_selection].to_string())\n    };\n\n    // 4. Ask for output destination\n    let output_options = vec![\"Print to stdout\", \"Save to file\"];\n    let output_selection = Select::new()\n        .with_prompt(\"Output destination:\")\n        .items(\u0026output_options)\n        .default(0)\n        .interact()?;\n\n    let output_file = if output_selection == 1 {\n        let filename = Input::new()\n            .with_prompt(\"Output filename:\")\n            .interact_text()?;\n        Some(filename)\n    } else {\n        None\n    };\n\n    Ok(WizardOptions {\n        format,\n        statuses,\n        type_filter,\n        labels: vec![],\n        ready_only: false,\n        output_file,\n    })\n}\n\n/// Apply all filters to the specs list\nfn apply_filters(\n    specs: \u0026mut Vec\u003cSpec\u003e,\n    statuses: \u0026[String],\n    type_filter: Option\u003c\u0026str\u003e,\n    labels: \u0026[String],\n    ready_only: bool,\n    from_date: Option\u003c\u0026str\u003e,\n    to_date: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    // Filter by status\n    if !statuses.is_empty() {\n        specs.retain(|s| {\n            let status_str = format!(\"{:?}\", s.frontmatter.status).to_lowercase();\n            statuses.iter().any(|st| st.to_lowercase() == status_str)\n        });\n    }\n\n    // Filter by type\n    if let Some(type_str) = type_filter {\n        specs.retain(|s| s.frontmatter.r#type == type_str);\n    }\n\n    // Filter by labels (OR logic)\n    if !labels.is_empty() {\n        specs.retain(|s| {\n            if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                labels.iter().any(|l| spec_labels.contains(l))\n            } else {\n                false\n            }\n        });\n    }\n\n    // Filter by ready status\n    if ready_only {\n        let all_specs = spec::load_all_specs(\u0026PathBuf::from(\".chant/specs\"))?;\n        specs.retain(|s| s.is_ready(\u0026all_specs));\n    }\n\n    // Filter by date range (based on spec ID date component)\n    if from_date.is_some() || to_date.is_some() {\n        specs.retain(|s| {\n            // Extract date from spec ID (format: YYYY-MM-DD-XXX-abc)\n            let id_parts: Vec\u003c\u0026str\u003e = s.id.split('-').collect();\n            if id_parts.len() \u003c 3 {\n                return false;\n            }\n\n            let spec_date = format!(\"{}-{}-{}\", id_parts[0], id_parts[1], id_parts[2]);\n\n            let mut matches = true;\n\n            if let Some(from) = from_date {\n                matches = matches \u0026\u0026 spec_date.as_str() \u003e= from;\n            }\n\n            if let Some(to) = to_date {\n                matches = matches \u0026\u0026 spec_date.as_str() \u003c= to;\n            }\n\n            matches\n        });\n    }\n\n    Ok(())\n}\n\n/// Get list of field names to export\nfn get_field_list(fields: Option\u003c\u0026str\u003e) -\u003e Vec\u003cString\u003e {\n    match fields {\n        None =\u003e vec![\n            \"id\".to_string(),\n            \"type\".to_string(),\n            \"status\".to_string(),\n            \"title\".to_string(),\n            \"labels\".to_string(),\n            \"model\".to_string(),\n            \"completed_at\".to_string(),\n        ],\n        Some(\"all\") =\u003e vec![\n            \"id\".to_string(),\n            \"type\".to_string(),\n            \"status\".to_string(),\n            \"title\".to_string(),\n            \"labels\".to_string(),\n            \"target_files\".to_string(),\n            \"depends_on\".to_string(),\n            \"model\".to_string(),\n            \"completed_at\".to_string(),\n            \"commits\".to_string(),\n            \"pr\".to_string(),\n            \"tracks\".to_string(),\n            \"informed_by\".to_string(),\n            \"origin\".to_string(),\n            \"schedule\".to_string(),\n            \"derived_fields\".to_string(),\n        ],\n        Some(field_str) =\u003e field_str.split(',').map(|f| f.trim().to_string()).collect(),\n    }\n}\n\n/// Extract a field value from a spec as a JSON value\nfn get_field_value(spec: \u0026Spec, field: \u0026str) -\u003e serde_json::Value {\n    match field {\n        \"id\" =\u003e json!(spec.id),\n        \"type\" =\u003e json!(spec.frontmatter.r#type),\n        \"status\" =\u003e json!(format!(\"{:?}\", spec.frontmatter.status).to_lowercase()),\n        \"title\" =\u003e json!(spec.title),\n        \"labels\" =\u003e json!(spec.frontmatter.labels),\n        \"target_files\" =\u003e json!(spec.frontmatter.target_files),\n        \"depends_on\" =\u003e json!(spec.frontmatter.depends_on),\n        \"model\" =\u003e json!(spec.frontmatter.model),\n        \"completed_at\" =\u003e json!(spec.frontmatter.completed_at),\n        \"commits\" =\u003e json!(spec.frontmatter.commits),\n        \"tracks\" =\u003e json!(spec.frontmatter.tracks),\n        \"informed_by\" =\u003e json!(spec.frontmatter.informed_by),\n        \"origin\" =\u003e json!(spec.frontmatter.origin),\n        \"schedule\" =\u003e json!(spec.frontmatter.schedule),\n        \"derived_fields\" =\u003e json!(spec.frontmatter.derived_fields),\n        _ =\u003e json!(null),\n    }\n}\n\n/// Export specs as JSON\nfn export_json(specs: \u0026[Spec], fields: Option\u003c\u0026str\u003e) -\u003e Result\u003cString\u003e {\n    let field_list = get_field_list(fields);\n    let mut json_array = Vec::new();\n\n    for spec in specs {\n        let mut obj = serde_json::Map::new();\n\n        for field in \u0026field_list {\n            let value = get_field_value(spec, field);\n            // Only include non-null values\n            if !value.is_null() {\n                obj.insert(field.clone(), value);\n            }\n        }\n\n        json_array.push(serde_json::Value::Object(obj));\n    }\n\n    Ok(serde_json::to_string_pretty(\u0026json_array)?)\n}\n\n/// Export specs as CSV\nfn export_csv(specs: \u0026[Spec], fields: Option\u003c\u0026str\u003e) -\u003e Result\u003cString\u003e {\n    let field_list = get_field_list(fields);\n\n    let mut output = String::new();\n\n    // Write header\n    output.push_str(\u0026field_list.join(\",\"));\n    output.push('\\n');\n\n    // Write data rows\n    for spec in specs {\n        let values: Vec\u003cString\u003e = field_list\n            .iter()\n            .map(|field| {\n                let value = get_field_value(spec, field);\n                csv_escape(\u0026value.to_string())\n            })\n            .collect();\n\n        output.push_str(\u0026values.join(\",\"));\n        output.push('\\n');\n    }\n\n    Ok(output)\n}\n\n/// Escape a value for CSV output\nfn csv_escape(value: \u0026str) -\u003e String {\n    // Handle null specially\n    if value == \"null\" {\n        return String::new();\n    }\n\n    // If value contains comma, quote, or newline, wrap in quotes and escape quotes\n    if value.contains(',') || value.contains('\"') || value.contains('\\n') {\n        format!(\"\\\"{}\\\"\", value.replace('\"', \"\\\"\\\"\"))\n    } else {\n        value.to_string()\n    }\n}\n\n/// Export specs as Markdown table\nfn export_markdown(specs: \u0026[Spec], fields: Option\u003c\u0026str\u003e) -\u003e Result\u003cString\u003e {\n    let field_list = get_field_list(fields);\n\n    let mut output = String::new();\n\n    // Write header row\n    output.push('|');\n    for field in \u0026field_list {\n        output.push(' ');\n        output.push_str(field);\n        output.push_str(\" |\");\n    }\n    output.push('\\n');\n\n    // Write separator row\n    output.push('|');\n    for _ in \u0026field_list {\n        output.push_str(\" --- |\");\n    }\n    output.push('\\n');\n\n    // Write data rows\n    for spec in specs {\n        output.push('|');\n        for field in \u0026field_list {\n            output.push(' ');\n            let value = get_field_value(spec, field);\n            let value_str = if value.is_null() {\n                \"-\".to_string()\n            } else if value.is_array() || value.is_object() {\n                // Truncate long arrays/objects for readability\n                let s = value.to_string();\n                if s.len() \u003e 30 {\n                    format!(\"{}...\", \u0026s[..27])\n                } else {\n                    s\n                }\n            } else {\n                value.to_string().trim_matches('\"').to_string()\n            };\n            output.push_str(\u0026value_str);\n            output.push_str(\" |\");\n        }\n        output.push('\\n');\n    }\n\n    Ok(output)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_csv_escape() {\n        assert_eq!(csv_escape(\"simple\"), \"simple\");\n        assert_eq!(csv_escape(\"with,comma\"), \"\\\"with,comma\\\"\");\n        assert_eq!(csv_escape(\"with\\\"quote\"), \"\\\"with\\\"\\\"quote\\\"\");\n        assert_eq!(csv_escape(\"with\\nnewline\"), \"\\\"with\\nnewline\\\"\");\n    }\n\n    #[test]\n    fn test_get_field_list_default() {\n        let fields = get_field_list(None);\n        assert!(fields.contains(\u0026\"id\".to_string()));\n        assert!(fields.contains(\u0026\"type\".to_string()));\n        assert!(fields.contains(\u0026\"status\".to_string()));\n    }\n\n    #[test]\n    fn test_get_field_list_custom() {\n        let fields = get_field_list(Some(\"id,type,title\"));\n        assert_eq!(fields.len(), 3);\n        assert!(fields.contains(\u0026\"id\".to_string()));\n        assert!(fields.contains(\u0026\"type\".to_string()));\n        assert!(fields.contains(\u0026\"title\".to_string()));\n    }\n\n    #[test]\n    fn test_wizard_options_default() {\n        let options = WizardOptions {\n            format: \"json\".to_string(),\n            statuses: vec![\"ready\".to_string()],\n            type_filter: None,\n            labels: vec![],\n            ready_only: false,\n            output_file: None,\n        };\n        assert_eq!(options.format, \"json\");\n        assert_eq!(options.statuses.len(), 1);\n        assert_eq!(options.statuses[0], \"ready\");\n    }\n\n    #[test]\n    fn test_wizard_options_with_type_filter() {\n        let options = WizardOptions {\n            format: \"csv\".to_string(),\n            statuses: vec![\"ready\".to_string(), \"completed\".to_string()],\n            type_filter: Some(\"code\".to_string()),\n            labels: vec![],\n            ready_only: false,\n            output_file: Some(\"export.csv\".to_string()),\n        };\n        assert_eq!(options.format, \"csv\");\n        assert_eq!(options.statuses.len(), 2);\n        assert_eq!(options.type_filter, Some(\"code\".to_string()));\n        assert_eq!(options.output_file, Some(\"export.csv\".to_string()));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[],"length":0,"stats":{"Line":3}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":295,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":22}},{"line":324,"address":[],"length":0,"stats":{"Line":3}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":12}},{"line":356,"address":[],"length":0,"stats":{"Line":6}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":18}},{"line":403,"address":[],"length":0,"stats":{"Line":12}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}}],"covered":76,"coverable":223},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","finalize.rs"],"content":"//! Spec finalization logic.\n//!\n//! Handles marking specs as complete, updating frontmatter with commits,\n//! timestamps, and model information.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::path::Path;\n\nuse chant::config::Config;\nuse chant::spec::{self, load_all_specs, Spec, SpecStatus};\n\nuse crate::cmd::commits::{\n    detect_agent_in_commit, get_commits_for_spec, get_commits_for_spec_allow_no_commits,\n    get_commits_for_spec_with_branch,\n};\nuse crate::cmd::model::get_model_name;\n\n/// Maximum characters to store in agent output section\npub const MAX_AGENT_OUTPUT_CHARS: usize = 5000;\n\n/// Finalize a spec after successful completion\n/// Sets status, commits, completed_at, and model\n/// This function is idempotent and can be called multiple times safely\n///\n/// If `commits` is provided, uses those commits directly.\n/// If `commits` is None, fetches commits using get_commits_for_spec.\npub fn finalize_spec(\n    spec: \u0026mut Spec,\n    spec_path: \u0026Path,\n    config: \u0026Config,\n    all_specs: \u0026[Spec],\n    allow_no_commits: bool,\n    commits: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003c()\u003e {\n    // Check if this is a driver spec with incomplete members\n    let incomplete_members = spec::get_incomplete_members(\u0026spec.id, all_specs);\n    if !incomplete_members.is_empty() {\n        anyhow::bail!(\n            \"Cannot complete driver spec '{}' while {} member spec(s) are incomplete: {}\",\n            spec.id,\n            incomplete_members.len(),\n            incomplete_members.join(\", \")\n        );\n    }\n\n    // Use provided commits or fetch them\n    // Check the spec's branch field first if available (Issue 1 fix)\n    let commits = match commits {\n        Some(c) =\u003e c,\n        None =\u003e {\n            // If spec has a branch field, search that branch first\n            let spec_branch = spec.frontmatter.branch.as_deref();\n            if spec_branch.is_some() \u0026\u0026 !allow_no_commits {\n                // Use branch-aware search\n                get_commits_for_spec_with_branch(\u0026spec.id, spec_branch)?\n            } else if allow_no_commits {\n                get_commits_for_spec_allow_no_commits(\u0026spec.id)?\n            } else {\n                get_commits_for_spec(\u0026spec.id)?\n            }\n        }\n    };\n\n    // Check for agent co-authorship if config requires approval for agent work\n    if config.approval.require_approval_for_agent_work {\n        check_and_set_agent_approval(spec, \u0026commits, config)?;\n    }\n\n    // Update spec to completed\n    spec.frontmatter.status = SpecStatus::Completed;\n    spec.frontmatter.commits = if commits.is_empty() {\n        None\n    } else {\n        Some(commits)\n    };\n    spec.frontmatter.completed_at = Some(\n        chrono::Local::now()\n            .format(\"%Y-%m-%dT%H:%M:%SZ\")\n            .to_string(),\n    );\n    spec.frontmatter.model = get_model_name(Some(config));\n\n    eprintln!(\n        \"{} [{}] Saving spec with status=Completed, commits={}, completed_at={:?}, model={:?}\",\n        \"â\".cyan(),\n        spec.id,\n        spec.frontmatter\n            .commits\n            .as_ref()\n            .map(|c| c.len())\n            .unwrap_or(0),\n        spec.frontmatter.completed_at,\n        spec.frontmatter.model\n    );\n\n    // Save the spec - this must not fail silently\n    spec.save(spec_path)\n        .context(\"Failed to save finalized spec\")?;\n\n    eprintln!(\n        \"{} [{}] Spec successfully saved to disk\",\n        \"â\".green(),\n        spec.id\n    );\n\n    // Validation 1: Verify that status was actually changed to Completed\n    anyhow::ensure!(\n        spec.frontmatter.status == SpecStatus::Completed,\n        \"Status was not set to Completed after finalization\"\n    );\n\n    // Validation 2: Verify that completed_at timestamp is set and in valid ISO format\n    let completed_at = spec\n        .frontmatter\n        .completed_at\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"completed_at timestamp was not set\"))?;\n\n    // Validate ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ\n    if !completed_at.ends_with('Z') {\n        anyhow::bail!(\n            \"completed_at must end with 'Z' (UTC format), got: {}\",\n            completed_at\n        );\n    }\n    if !completed_at.contains('T') {\n        anyhow::bail!(\n            \"completed_at must contain 'T' separator (ISO format), got: {}\",\n            completed_at\n        );\n    }\n\n    // Validation 3: Verify that spec was actually saved (reload and check)\n    let saved_spec =\n        Spec::load(spec_path).context(\"Failed to reload spec from disk to verify persistence\")?;\n\n    anyhow::ensure!(\n        saved_spec.frontmatter.status == SpecStatus::Completed,\n        \"Persisted spec status is not Completed - save may have failed\"\n    );\n\n    anyhow::ensure!(\n        saved_spec.frontmatter.completed_at.is_some(),\n        \"Persisted spec is missing completed_at - save may have failed\"\n    );\n\n    // Model may be None if no model was detected, but commits should match memory\n    match (\u0026spec.frontmatter.commits, \u0026saved_spec.frontmatter.commits) {\n        (Some(mem_commits), Some(saved_commits)) =\u003e {\n            anyhow::ensure!(\n                mem_commits == saved_commits,\n                \"Persisted commits don't match memory - save may have failed\"\n            );\n        }\n        (None, None) =\u003e {\n            // Both None is correct\n        }\n        _ =\u003e {\n            anyhow::bail!(\"Persisted commits don't match memory - save may have failed\");\n        }\n    }\n\n    // Check what this spec unblocked\n    let specs_dir = spec_path\n        .parent()\n        .ok_or_else(|| anyhow::anyhow!(\"Cannot determine specs directory\"))?;\n    let unblocked = find_dependent_specs(\u0026spec.id, specs_dir)?;\n    if !unblocked.is_empty() {\n        println!(\n            \"{} Unblocked {} dependent spec(s):\",\n            \"â\".green(),\n            unblocked.len()\n        );\n        for dependent_id in unblocked {\n            println!(\"  - {}\", dependent_id);\n        }\n    }\n\n    // Auto-complete parent group if this is a member and all siblings are complete\n    if let Some(parent_id) = get_parent_group_id(\u0026spec.id) {\n        auto_complete_parent_group(\u0026parent_id, specs_dir)?;\n    }\n\n    Ok(())\n}\n\n/// Re-finalize a spec that was left in an incomplete state\n/// This can be called on in_progress or completed specs to update commits and timestamp\n/// Idempotent: safe to call multiple times\npub fn re_finalize_spec(\n    spec: \u0026mut Spec,\n    spec_path: \u0026Path,\n    config: \u0026Config,\n    allow_no_commits: bool,\n) -\u003e Result\u003c()\u003e {\n    // Re-finalization only works on specs that have been started (in_progress or completed)\n    // A pending spec has never been started and should use normal work flow\n    // Allow failed too - agents often leave specs in failed state when they actually completed the work\n    match spec.frontmatter.status {\n        SpecStatus::InProgress | SpecStatus::Completed | SpecStatus::Failed =\u003e {\n            // These are valid for re-finalization\n        }\n        _ =\u003e {\n            anyhow::bail!(\n                \"Cannot re-finalize spec '{}' with status '{:?}'. Must be in_progress, completed, or failed.\",\n                spec.id,\n                spec.frontmatter.status\n            );\n        }\n    }\n\n    // Get the commits for this spec (may have new ones since last finalization)\n    // Check the spec's branch field first if available (Issue 1 fix)\n    let spec_branch = spec.frontmatter.branch.as_deref();\n    let commits = if spec_branch.is_some() \u0026\u0026 !allow_no_commits {\n        // Use branch-aware search\n        get_commits_for_spec_with_branch(\u0026spec.id, spec_branch)?\n    } else if allow_no_commits {\n        get_commits_for_spec_allow_no_commits(\u0026spec.id)?\n    } else {\n        get_commits_for_spec(\u0026spec.id)?\n    };\n\n    // Update spec with new commit info\n    spec.frontmatter.commits = if commits.is_empty() {\n        None\n    } else {\n        Some(commits)\n    };\n\n    // Update the timestamp to now\n    spec.frontmatter.completed_at = Some(\n        chrono::Local::now()\n            .format(\"%Y-%m-%dT%H:%M:%SZ\")\n            .to_string(),\n    );\n\n    // Update model name\n    spec.frontmatter.model = get_model_name(Some(config));\n\n    // Ensure spec is marked as completed\n    spec.frontmatter.status = SpecStatus::Completed;\n\n    // Save the spec\n    spec.save(spec_path)\n        .context(\"Failed to save re-finalized spec\")?;\n\n    // Validation 1: Verify that status is Completed\n    anyhow::ensure!(\n        spec.frontmatter.status == SpecStatus::Completed,\n        \"Status was not set to Completed after re-finalization\"\n    );\n\n    // Validation 2: Verify completed_at timestamp is set and valid\n    let completed_at = spec\n        .frontmatter\n        .completed_at\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"completed_at timestamp was not set\"))?;\n\n    if !completed_at.ends_with('Z') {\n        anyhow::bail!(\n            \"completed_at must end with 'Z' (UTC format), got: {}\",\n            completed_at\n        );\n    }\n    if !completed_at.contains('T') {\n        anyhow::bail!(\n            \"completed_at must contain 'T' separator (ISO format), got: {}\",\n            completed_at\n        );\n    }\n\n    // Validation 3: Verify spec was saved (reload and check)\n    let saved_spec =\n        Spec::load(spec_path).context(\"Failed to reload spec from disk to verify persistence\")?;\n\n    anyhow::ensure!(\n        saved_spec.frontmatter.status == SpecStatus::Completed,\n        \"Persisted spec status is not Completed - save may have failed\"\n    );\n\n    anyhow::ensure!(\n        saved_spec.frontmatter.completed_at.is_some(),\n        \"Persisted spec is missing completed_at - save may have failed\"\n    );\n\n    Ok(())\n}\n\n/// Prompt for user confirmation\n/// Returns true if user confirms, false otherwise\n/// force_flag bypasses the confirmation\npub fn confirm_re_finalize(spec_id: \u0026str, force_flag: bool) -\u003e Result\u003cbool\u003e {\n    if force_flag {\n        return Ok(true);\n    }\n\n    println!(\n        \"{} Are you sure you want to re-finalize spec '{}'?\",\n        \"?\".cyan(),\n        spec_id\n    );\n    println!(\"This will update commits and completion timestamp to now.\");\n    println!(\n        \"Use {} to skip this confirmation.\",\n        \"--skip-criteria\".cyan()\n    );\n\n    use std::io::{self, Write};\n    print!(\"Continue? [y/N] \");\n    io::stdout().flush()?;\n\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input)?;\n\n    Ok(input.trim().eq_ignore_ascii_case(\"y\"))\n}\n\n/// Check commits for agent co-authorship and set approval requirement if found.\n/// This is called during finalization when require_approval_for_agent_work is enabled.\nfn check_and_set_agent_approval(\n    spec: \u0026mut Spec,\n    commits: \u0026[String],\n    config: \u0026Config,\n) -\u003e Result\u003c()\u003e {\n    use chant::spec::{Approval, ApprovalStatus};\n\n    // Skip if approval is already set (don't override existing approval settings)\n    if spec.frontmatter.approval.is_some() {\n        return Ok(());\n    }\n\n    // Check each commit for agent co-authorship\n    for commit in commits {\n        match detect_agent_in_commit(commit) {\n            Ok(result) if result.has_agent =\u003e {\n                // Agent detected - set approval requirement\n                let agent_sig = result\n                    .agent_signature\n                    .unwrap_or_else(|| \"AI Agent\".to_string());\n                eprintln!(\n                    \"{} Agent co-authorship detected in commit {}: {}\",\n                    \"â \".yellow(),\n                    commit,\n                    agent_sig\n                );\n                eprintln!(\n                    \"{} Auto-setting approval requirement (config: require_approval_for_agent_work={})\",\n                    \"â\".cyan(),\n                    config.approval.require_approval_for_agent_work\n                );\n\n                // Set approval requirement\n                spec.frontmatter.approval = Some(Approval {\n                    required: true,\n                    status: ApprovalStatus::Pending,\n                    by: None,\n                    at: None,\n                });\n\n                eprintln!(\n                    \"{} Spec requires approval before merge. Run: chant approve {} --by \u003capprover\u003e\",\n                    \"â¹\".blue(),\n                    spec.id\n                );\n\n                return Ok(());\n            }\n            Ok(_) =\u003e {\n                // No agent found in this commit, continue\n            }\n            Err(e) =\u003e {\n                // Log warning but continue checking other commits\n                eprintln!(\n                    \"Warning: Failed to check commit {} for agent: {}\",\n                    commit, e\n                );\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Append agent output to the spec body, truncating if too long.\npub fn append_agent_output(spec: \u0026mut Spec, output: \u0026str) {\n    let timestamp = chrono::Local::now()\n        .format(\"%Y-%m-%dT%H:%M:%SZ\")\n        .to_string();\n\n    let formatted_output = if output.len() \u003e MAX_AGENT_OUTPUT_CHARS {\n        let truncated = \u0026output[..MAX_AGENT_OUTPUT_CHARS];\n        format!(\n            \"{}\\n\\n... (output truncated, {} chars total)\",\n            truncated,\n            output.len()\n        )\n    } else {\n        output.to_string()\n    };\n\n    let agent_section = format!(\n        \"\\n\\n## Agent Output\\n\\n{}\\n\\n```\\n{}```\\n\",\n        timestamp,\n        formatted_output.trim_end()\n    );\n\n    spec.body.push_str(\u0026agent_section);\n}\n\n/// Find specs that depend on the completed spec and are now ready.\n/// Returns a list of spec IDs that were unblocked by completing this spec.\npub fn find_dependent_specs(completed_spec_id: \u0026str, specs_dir: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    // Load all specs to check dependencies\n    let all_specs = load_all_specs(specs_dir)?;\n    let mut unblocked = Vec::new();\n\n    for spec in \u0026all_specs {\n        // Check if this spec depends on the completed spec\n        if let Some(deps) = \u0026spec.frontmatter.depends_on {\n            if deps.contains(\u0026completed_spec_id.to_string()) {\n                // This spec depends on the one we just completed\n                // Check if it's now ready (all dependencies met)\n                if spec.is_ready(\u0026all_specs) {\n                    unblocked.push(spec.id.clone());\n                }\n            }\n        }\n    }\n\n    Ok(unblocked)\n}\n\n/// Extract parent group ID from a member spec ID.\n/// Member IDs have format \"2026-01-30-00h-f77.1\" where parent is \"2026-01-30-00h-f77\".\n/// Returns None if this is not a member spec (no dot in ID).\nfn get_parent_group_id(spec_id: \u0026str) -\u003e Option\u003cString\u003e {\n    // Member IDs contain a dot: \"parent-id.N\"\n    if let Some(dot_pos) = spec_id.rfind('.') {\n        // Check that what's after the dot is a number (member index)\n        let suffix = \u0026spec_id[dot_pos + 1..];\n        if suffix.parse::\u003cu32\u003e().is_ok() {\n            return Some(spec_id[..dot_pos].to_string());\n        }\n    }\n    None\n}\n\n/// Auto-complete a parent group spec if all its members are now completed.\n/// This is called after finalizing a member spec.\nfn auto_complete_parent_group(parent_id: \u0026str, specs_dir: \u0026Path) -\u003e Result\u003c()\u003e {\n    // Load the parent spec\n    let parent_path = specs_dir.join(format!(\"{}.md\", parent_id));\n    if !parent_path.exists() {\n        // Parent doesn't exist, nothing to do\n        return Ok(());\n    }\n\n    let mut parent = Spec::load(\u0026parent_path)?;\n\n    // Only process group specs\n    if parent.frontmatter.r#type != \"group\" {\n        return Ok(());\n    }\n\n    // Already completed, nothing to do\n    if parent.frontmatter.status == SpecStatus::Completed {\n        return Ok(());\n    }\n\n    // Check if all members are completed\n    let all_specs = load_all_specs(specs_dir)?;\n    let incomplete_members = spec::get_incomplete_members(parent_id, \u0026all_specs);\n\n    if !incomplete_members.is_empty() {\n        // Still has incomplete members, don't auto-complete\n        return Ok(());\n    }\n\n    // All members complete! Auto-complete the parent group\n    println!(\n        \"\\n{} All members of group {} are complete. Auto-completing parent...\",\n        \"â\".cyan(),\n        parent_id\n    );\n\n    // Set parent as completed (groups don't have commits of their own)\n    parent.frontmatter.status = SpecStatus::Completed;\n    parent.frontmatter.completed_at = Some(\n        chrono::Local::now()\n            .format(\"%Y-%m-%dT%H:%M:%SZ\")\n            .to_string(),\n    );\n\n    parent.save(\u0026parent_path)?;\n\n    println!(\"{} Group {} auto-completed\", \"â\".green(), parent_id);\n\n    // Recursively check if this group is itself a member of a parent group\n    if let Some(grandparent_id) = get_parent_group_id(parent_id) {\n        auto_complete_parent_group(\u0026grandparent_id, specs_dir)?;\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::spec::SpecFrontmatter;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_find_dependent_specs_single_dependency() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a completed spec\n        let completed_spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"Completed\".to_string()),\n            body: \"# Completed\\n\\nBody.\".to_string(),\n        };\n\n        // Create a spec that depends on the completed one\n        let dependent_spec = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\"2026-01-27-001-abc\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Dependent\".to_string()),\n            body: \"# Dependent\\n\\nBody.\".to_string(),\n        };\n\n        // Save both specs\n        completed_spec\n            .save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\"))\n            .unwrap();\n        dependent_spec\n            .save(\u0026specs_dir.join(\"2026-01-27-002-def.md\"))\n            .unwrap();\n\n        // Find dependent specs\n        let unblocked = find_dependent_specs(\"2026-01-27-001-abc\", specs_dir).unwrap();\n\n        // Should find the dependent spec\n        assert_eq!(unblocked.len(), 1);\n        assert_eq!(unblocked[0], \"2026-01-27-002-def\");\n    }\n\n    #[test]\n    fn test_find_dependent_specs_multiple_dependencies() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create two completed specs\n        let completed_1 = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"Completed 1\".to_string()),\n            body: \"# Completed 1\\n\\nBody.\".to_string(),\n        };\n\n        let completed_2 = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"Completed 2\".to_string()),\n            body: \"# Completed 2\\n\\nBody.\".to_string(),\n        };\n\n        // Create a spec that depends on BOTH completed specs\n        let dependent_spec = Spec {\n            id: \"2026-01-27-003-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\n                    \"2026-01-27-001-abc\".to_string(),\n                    \"2026-01-27-002-def\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Dependent\".to_string()),\n            body: \"# Dependent\\n\\nBody.\".to_string(),\n        };\n\n        // Save all specs\n        completed_1\n            .save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\"))\n            .unwrap();\n        completed_2\n            .save(\u0026specs_dir.join(\"2026-01-27-002-def.md\"))\n            .unwrap();\n        dependent_spec\n            .save(\u0026specs_dir.join(\"2026-01-27-003-ghi.md\"))\n            .unwrap();\n\n        // Find dependents when completing the second spec\n        let unblocked = find_dependent_specs(\"2026-01-27-002-def\", specs_dir).unwrap();\n\n        // Should find the dependent spec (both dependencies are now met)\n        assert_eq!(unblocked.len(), 1);\n        assert_eq!(unblocked[0], \"2026-01-27-003-ghi\");\n    }\n\n    #[test]\n    fn test_find_dependent_specs_partial_dependencies() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create one completed spec\n        let completed = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"Completed\".to_string()),\n            body: \"# Completed\\n\\nBody.\".to_string(),\n        };\n\n        // Create one incomplete spec\n        let incomplete = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Incomplete\".to_string()),\n            body: \"# Incomplete\\n\\nBody.\".to_string(),\n        };\n\n        // Create a spec that depends on BOTH (one complete, one incomplete)\n        let dependent_spec = Spec {\n            id: \"2026-01-27-003-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\n                    \"2026-01-27-001-abc\".to_string(),\n                    \"2026-01-27-002-def\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Dependent\".to_string()),\n            body: \"# Dependent\\n\\nBody.\".to_string(),\n        };\n\n        // Save all specs\n        completed\n            .save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\"))\n            .unwrap();\n        incomplete\n            .save(\u0026specs_dir.join(\"2026-01-27-002-def.md\"))\n            .unwrap();\n        dependent_spec\n            .save(\u0026specs_dir.join(\"2026-01-27-003-ghi.md\"))\n            .unwrap();\n\n        // Find dependents when completing the first spec\n        let unblocked = find_dependent_specs(\"2026-01-27-001-abc\", specs_dir).unwrap();\n\n        // Should NOT find the dependent spec (still has unmet dependency on 002-def)\n        assert_eq!(unblocked.len(), 0);\n    }\n\n    #[test]\n    fn test_find_dependent_specs_cascade() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a chain: A -\u003e B -\u003e C\n        let spec_a = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"A\".to_string()),\n            body: \"# A\\n\\nBody.\".to_string(),\n        };\n\n        let spec_b = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                depends_on: Some(vec![\"2026-01-27-001-abc\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"B\".to_string()),\n            body: \"# B\\n\\nBody.\".to_string(),\n        };\n\n        let spec_c = Spec {\n            id: \"2026-01-27-003-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"C\".to_string()),\n            body: \"# C\\n\\nBody.\".to_string(),\n        };\n\n        // Save all specs\n        spec_a\n            .save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\"))\n            .unwrap();\n        spec_b\n            .save(\u0026specs_dir.join(\"2026-01-27-002-def.md\"))\n            .unwrap();\n        spec_c\n            .save(\u0026specs_dir.join(\"2026-01-27-003-ghi.md\"))\n            .unwrap();\n\n        // Complete B should unblock C\n        let unblocked = find_dependent_specs(\"2026-01-27-002-def\", specs_dir).unwrap();\n        assert_eq!(unblocked.len(), 1);\n        assert_eq!(unblocked[0], \"2026-01-27-003-ghi\");\n    }\n\n    #[test]\n    fn test_find_dependent_specs_no_dependents() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a completed spec with no dependents\n        let completed = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n                ..Default::default()\n            },\n            title: Some(\"Completed\".to_string()),\n            body: \"# Completed\\n\\nBody.\".to_string(),\n        };\n\n        completed\n            .save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\"))\n            .unwrap();\n\n        // Find dependents\n        let unblocked = find_dependent_specs(\"2026-01-27-001-abc\", specs_dir).unwrap();\n\n        // Should find no dependents\n        assert_eq!(unblocked.len(), 0);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":9}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":9}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":3}},{"line":236,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":9}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":9}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":6}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":9}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":3}},{"line":285,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":417,"address":[],"length":0,"stats":{"Line":18}},{"line":418,"address":[],"length":0,"stats":{"Line":12}},{"line":420,"address":[],"length":0,"stats":{"Line":19}},{"line":422,"address":[],"length":0,"stats":{"Line":18}},{"line":423,"address":[],"length":0,"stats":{"Line":15}},{"line":426,"address":[],"length":0,"stats":{"Line":15}},{"line":427,"address":[],"length":0,"stats":{"Line":9}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}}],"covered":93,"coverable":196},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","git_ops.rs"],"content":"//! Git operations for spec execution.\n//!\n//! Contains git-related helper functions used by both single and parallel execution modes.\n\nuse anyhow::{Context, Result};\nuse std::path::Path;\n\n/// Create a new branch or switch to an existing one.\npub fn create_or_switch_branch(branch_name: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    // Try to create a new branch\n    let create_output = Command::new(\"git\")\n        .args([\"checkout\", \"-b\", branch_name])\n        .output()\n        .context(\"Failed to run git checkout\")?;\n\n    if create_output.status.success() {\n        return Ok(());\n    }\n\n    // Branch might already exist, try to switch to it\n    let switch_output = Command::new(\"git\")\n        .args([\"checkout\", branch_name])\n        .output()\n        .context(\"Failed to run git checkout\")?;\n\n    if switch_output.status.success() {\n        return Ok(());\n    }\n\n    // Both failed, return error\n    let stderr = String::from_utf8_lossy(\u0026switch_output.stderr);\n    anyhow::bail!(\n        \"Failed to create or switch to branch '{}': {}\",\n        branch_name,\n        stderr\n    )\n}\n\n/// Commit the spec file as a transcript record.\n///\n/// Handles the case where there's nothing to commit (returns Ok).\npub fn commit_transcript(spec_id: \u0026str, spec_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    // Stage the spec file\n    let output = Command::new(\"git\")\n        .args([\"add\", \u0026spec_path.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git add for transcript commit\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\n            \"Failed to stage spec file for transcript commit: {}\",\n            stderr\n        );\n    }\n\n    // Create commit for transcript\n    let commit_message = format!(\"chant: Record agent transcript for {}\", spec_id);\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026commit_message])\n        .output()\n        .context(\"Failed to run git commit for transcript\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        // It's ok if there's nothing to commit (no changes after finalization)\n        if stderr.contains(\"nothing to commit\") || stderr.contains(\"no changes added\") {\n            return Ok(());\n        }\n        anyhow::bail!(\"Failed to commit transcript: {}\", stderr);\n    }\n\n    Ok(())\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","archive.rs"],"content":"//! Spec archiving functionality - moves completed specs to archive directory\n\nuse anyhow::{Context, Result};\nuse chrono::Local;\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse chant::paths::ARCHIVE_DIR;\nuse chant::prompt;\nuse chant::spec::{self, Spec, SpecStatus};\n\n/// Result of verifying target files have changes\n#[derive(Debug)]\npub struct TargetFilesVerification {\n    /// Files that have changes in spec commits\n    pub files_with_changes: Vec\u003cString\u003e,\n    /// Files listed in target_files but without changes\n    pub files_without_changes: Vec\u003cString\u003e,\n    /// Commits found for the spec\n    pub commits: Vec\u003cString\u003e,\n    /// All files that were actually changed (file path, net additions)\n    pub actual_files_changed: Vec\u003c(String, i64)\u003e,\n}\n\n/// Check if we're in a git repository\npub(crate) fn is_git_repo() -\u003e bool {\n    std::process::Command::new(\"git\")\n        .args([\"rev-parse\", \"--git-dir\"])\n        .output()\n        .map(|output| output.status.success())\n        .unwrap_or(false)\n}\n\n/// Check if there are uncommitted changes other than the archived spec files.\n///\n/// This function checks git status to see if there are any staged or unstaged changes\n/// that aren't related to the archived specs. This is used to prevent auto-committing\n/// when the working directory has unrelated changes.\n///\n/// # Arguments\n/// * `archived_spec_ids` - List of spec IDs that were just archived\n///\n/// # Returns\n/// * `Ok(true)` if there are other uncommitted changes\n/// * `Ok(false)` if only archived spec files have changes (or no changes)\n/// * `Err(_)` if git status command fails\npub(crate) fn has_other_uncommitted_changes(archived_spec_ids: \u0026[String]) -\u003e Result\u003cbool\u003e {\n    let output = std::process::Command::new(\"git\")\n        .args([\"status\", \"--porcelain\"])\n        .output()\n        .context(\"Failed to run git status\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"git status failed\");\n    }\n\n    let status_output = String::from_utf8_lossy(\u0026output.stdout);\n\n    // Parse status output to check for changes\n    for line in status_output.lines() {\n        if line.trim().is_empty() {\n            continue;\n        }\n\n        // Extract file path from status line (format: \"XY filename\")\n        if line.len() \u003c 3 {\n            continue;\n        }\n        let file_path = \u0026line[3..];\n\n        // Check if this file is one of the archived spec files\n        let is_archived_spec = archived_spec_ids.iter().any(|spec_id| {\n            // Check for source location (.chant/specs/{spec_id}.md)\n            let src_pattern = format!(\".chant/specs/{}.md\", spec_id);\n            // Check for destination location (.chant/archive/YYYY-MM-DD/{spec_id}.md)\n            let date_part = \u0026spec_id[..10]; // First 10 chars: YYYY-MM-DD\n            let dst_pattern = format!(\".chant/archive/{}/{}.md\", date_part, spec_id);\n\n            file_path == src_pattern || file_path == dst_pattern\n        });\n\n        // If we find a change that's not an archived spec file, return true\n        if !is_archived_spec {\n            return Ok(true);\n        }\n    }\n\n    // All changes are related to archived spec files\n    Ok(false)\n}\n\n/// Get commits associated with a spec by searching git log\npub(crate) fn get_spec_commits(spec_id: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    // Look for commits with the chant(spec_id): pattern\n    let pattern = format!(\"chant({}):\", spec_id);\n\n    let output = std::process::Command::new(\"git\")\n        .args([\"log\", \"--oneline\", \"--grep\", \u0026pattern, \"--reverse\"])\n        .output()\n        .context(\"Failed to execute git log command\")?;\n\n    if !output.status.success() {\n        return Ok(Vec::new());\n    }\n\n    let mut commits = Vec::new();\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    for line in stdout.lines() {\n        if let Some(hash) = line.split_whitespace().next() {\n            if !hash.is_empty() {\n                commits.push(hash.to_string());\n            }\n        }\n    }\n\n    Ok(commits)\n}\n\n/// Get file stats (insertions, deletions) for a commit\n/// Returns a map of file path -\u003e (insertions, deletions)\npub(crate) fn get_commit_file_stats(\n    commit: \u0026str,\n) -\u003e Result\u003cstd::collections::HashMap\u003cString, (i64, i64)\u003e\u003e {\n    use std::collections::HashMap;\n\n    let output = std::process::Command::new(\"git\")\n        .args([\"show\", \"--numstat\", \"--format=\", commit])\n        .output()\n        .context(\"Failed to execute git show command\")?;\n\n    if !output.status.success() {\n        return Ok(HashMap::new());\n    }\n\n    let mut stats = HashMap::new();\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n\n    for line in stdout.lines() {\n        let parts: Vec\u003c\u0026str\u003e = line.split('\\t').collect();\n        if parts.len() \u003e= 3 {\n            // Format: insertions\\tdeletions\\tfile_path\n            // Binary files show \"-\" for insertions/deletions\n            let insertions: i64 = parts[0].parse().unwrap_or(0);\n            let deletions: i64 = parts[1].parse().unwrap_or(0);\n            let file_path = parts[2].to_string();\n\n            // Accumulate stats for files that appear in multiple hunks\n            let entry = stats.entry(file_path).or_insert((0i64, 0i64));\n            entry.0 += insertions;\n            entry.1 += deletions;\n        }\n    }\n\n    Ok(stats)\n}\n\n/// Verify that target files listed in a spec have actual changes from spec commits\npub(crate) fn verify_target_files(spec: \u0026Spec) -\u003e Result\u003cTargetFilesVerification\u003e {\n    use std::collections::HashSet;\n\n    // Get target files from frontmatter\n    let target_files = match \u0026spec.frontmatter.target_files {\n        Some(files) if !files.is_empty() =\u003e files.clone(),\n        _ =\u003e {\n            // No target_files specified - nothing to verify\n            return Ok(TargetFilesVerification {\n                files_with_changes: Vec::new(),\n                files_without_changes: Vec::new(),\n                commits: Vec::new(),\n                actual_files_changed: Vec::new(),\n            });\n        }\n    };\n\n    // Get commits for this spec\n    let commits = get_spec_commits(\u0026spec.id)?;\n\n    if commits.is_empty() {\n        // No commits found - all target files are without changes\n        return Ok(TargetFilesVerification {\n            files_with_changes: Vec::new(),\n            files_without_changes: target_files,\n            commits: Vec::new(),\n            actual_files_changed: Vec::new(),\n        });\n    }\n\n    // Collect all file changes across all commits\n    let mut all_file_stats: std::collections::HashMap\u003cString, (i64, i64)\u003e =\n        std::collections::HashMap::new();\n\n    for commit in \u0026commits {\n        let commit_stats = get_commit_file_stats(commit)?;\n        for (file, (ins, del)) in commit_stats {\n            let entry = all_file_stats.entry(file).or_insert((0, 0));\n            entry.0 += ins;\n            entry.1 += del;\n        }\n    }\n\n    // Build set of files that were modified\n    let modified_files: HashSet\u003cString\u003e = all_file_stats.keys().cloned().collect();\n\n    // Check each target file\n    let mut files_with_changes = Vec::new();\n    let mut files_without_changes = Vec::new();\n\n    for target_file in \u0026target_files {\n        if modified_files.contains(target_file) {\n            files_with_changes.push(target_file.clone());\n        } else {\n            files_without_changes.push(target_file.clone());\n        }\n    }\n\n    // Collect all actual files changed with their net additions\n    let mut actual_files_changed: Vec\u003c(String, i64)\u003e = all_file_stats\n        .iter()\n        .map(|(file, (ins, del))| (file.clone(), ins - del))\n        .collect();\n    // Sort by file path for consistent output\n    actual_files_changed.sort_by(|a, b| a.0.cmp(\u0026b.0));\n\n    Ok(TargetFilesVerification {\n        files_with_changes,\n        files_without_changes,\n        commits,\n        actual_files_changed,\n    })\n}\n\n/// Format a warning message when target files don't match actual changes\npub(crate) fn format_target_files_warning(\n    spec_id: \u0026str,\n    verification: \u0026TargetFilesVerification,\n) -\u003e String {\n    // Combine all predicted files (both with and without changes)\n    let mut all_predicted = verification.files_without_changes.clone();\n    all_predicted.extend(verification.files_with_changes.clone());\n    let predicted = all_predicted.join(\", \");\n\n    // Format actual files list\n    let actual = if verification.actual_files_changed.is_empty() {\n        \"(none)\".to_string()\n    } else {\n        verification\n            .actual_files_changed\n            .iter()\n            .map(|(f, _)| f.as_str())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\", \")\n    };\n\n    format!(\n        \"Note: Spec {} predicted [{}] but changed [{}]\\n      (Prediction mismatch - implementation is fine)\\n\",\n        spec_id, predicted, actual\n    )\n}\n\n/// Print condensed warnings when there are many repeated warning types\npub(crate) fn print_condensed_warnings(\n    specs_with_missing_changes: \u0026[(spec::Spec, TargetFilesVerification)],\n) {\n    use std::collections::HashMap;\n\n    // Group specs by warning type signature\n    // Warning type is determined by whether there are predicted files and actual files\n    let mut warning_groups: HashMap\u003cString, Vec\u003c\u0026str\u003e\u003e = HashMap::new();\n\n    for (spec, verification) in specs_with_missing_changes {\n        // Create a warning type key based on the pattern\n        let has_predicted = !verification.files_without_changes.is_empty()\n            || !verification.files_with_changes.is_empty();\n        let has_actual = !verification.actual_files_changed.is_empty();\n\n        let warning_type = match (has_predicted, has_actual) {\n            (true, true) =\u003e \"target_files_mismatch\",\n            (true, false) =\u003e \"target_files_no_changes\",\n            (false, true) =\u003e \"no_target_files_with_changes\",\n            (false, false) =\u003e \"no_prediction_no_changes\",\n        };\n\n        warning_groups\n            .entry(warning_type.to_string())\n            .or_default()\n            .push(spec.id.as_str());\n    }\n\n    // Print condensed or individual warnings based on count\n    for (warning_type, spec_ids) in \u0026warning_groups {\n        if spec_ids.len() \u003e 3 {\n            // Condense when count \u003e 3\n            let message = match warning_type.as_str() {\n                \"target_files_mismatch\" =\u003e {\n                    \"Prediction mismatch (target_files) - implementation is fine\"\n                }\n                \"target_files_no_changes\" =\u003e \"target_files specified but no changes found\",\n                \"no_target_files_with_changes\" =\u003e \"Changes made but no target_files specified\",\n                \"no_prediction_no_changes\" =\u003e \"No prediction and no changes\",\n                _ =\u003e \"Unknown warning type\",\n            };\n            println!(\"{} {}: {} specs\", \"â \".yellow(), message, spec_ids.len());\n        } else {\n            // Show individual warnings when count â¤ 3\n            for spec_id in spec_ids {\n                if let Some((spec, verification)) = specs_with_missing_changes\n                    .iter()\n                    .find(|(s, _)| s.id == *spec_id)\n                {\n                    println!(\"{}\", format_target_files_warning(\u0026spec.id, verification));\n                    if !verification.commits.is_empty() {\n                        println!(\"Commits found: {}\\n\", verification.commits.join(\", \"));\n                    } else {\n                        println!(\"No commits found with pattern 'chant({}):'.\\n\", spec.id);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Move a file using git mv, falling back to fs::rename if not in a git repo or if no_stage is true\npub(crate) fn move_spec_file(src: \u0026PathBuf, dst: \u0026PathBuf, no_stage: bool) -\u003e Result\u003c()\u003e {\n    let use_git = !no_stage \u0026\u0026 is_git_repo();\n\n    if use_git {\n        // Use git mv to stage the move\n        let status = std::process::Command::new(\"git\")\n            .args([\"mv\", \u0026src.to_string_lossy(), \u0026dst.to_string_lossy()])\n            .status()\n            .context(\"Failed to run git mv\")?;\n\n        if !status.success() {\n            anyhow::bail!(\"git mv failed for {}\", src.display());\n        }\n    } else {\n        // Fall back to filesystem rename\n        std::fs::rename(src, dst).context(format!(\n            \"Failed to move file from {} to {}\",\n            src.display(),\n            dst.display()\n        ))?;\n    }\n\n    Ok(())\n}\n\n/// Archive completed specs (move from specs to archive directory)\npub fn cmd_archive(\n    spec_id: Option\u003c\u0026str\u003e,\n    dry_run: bool,\n    older_than: Option\u003cu64\u003e,\n    force: bool,\n    commit: bool,\n    no_stage: bool,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let archive_dir = PathBuf::from(ARCHIVE_DIR);\n\n    // Load all specs\n    let specs = spec::load_all_specs(\u0026specs_dir)?;\n\n    // Filter specs to archive\n    let mut to_archive = Vec::new();\n\n    if let Some(id) = spec_id {\n        // Archive specific spec\n        if let Some(spec) = specs.iter().find(|s| s.id.starts_with(id)) {\n            // Check if this is a member spec\n            if spec::extract_driver_id(\u0026spec.id).is_some() {\n                // This is a member spec - always allow archiving members directly\n                to_archive.push(spec.clone());\n            } else {\n                // This is a driver spec or standalone spec\n                let members = spec::get_members(\u0026spec.id, \u0026specs);\n                if !members.is_empty() {\n                    // This is a driver spec with members\n                    if !spec::all_members_completed(\u0026spec.id, \u0026specs) {\n                        eprintln!(\n                            \"{} Skipping driver spec {} - not all members are completed\",\n                            \"â  \".yellow(),\n                            spec.id\n                        );\n                        return Ok(());\n                    }\n\n                    // All members are completed, automatically add them first (sorted by member number)\n                    let mut sorted_members = members.clone();\n                    sorted_members\n                        .sort_by_key(|m| spec::extract_member_number(\u0026m.id).unwrap_or(u32::MAX));\n                    for member in sorted_members {\n                        to_archive.push(member.clone());\n                    }\n                    // Then add the driver\n                    to_archive.push(spec.clone());\n                } else {\n                    // Standalone spec or driver with no members\n                    to_archive.push(spec.clone());\n                }\n            }\n        } else {\n            anyhow::bail!(\"Spec {} not found\", id);\n        }\n    } else {\n        // Archive by criteria\n        let now = Local::now();\n\n        for spec in \u0026specs {\n            // Skip if not completed (unless force)\n            if spec.frontmatter.status != SpecStatus::Completed \u0026\u0026 !force {\n                continue;\n            }\n\n            // Check older_than filter\n            if let Some(days) = older_than {\n                if let Some(completed_at_str) = \u0026spec.frontmatter.completed_at {\n                    if let Ok(completed_at) = chrono::DateTime::parse_from_rfc3339(completed_at_str)\n                    {\n                        let completed_at_local =\n                            chrono::DateTime::\u003cchrono::Local\u003e::from(completed_at);\n                        let age = now.signed_duration_since(completed_at_local);\n                        if age.num_days() \u003c days as i64 {\n                            continue;\n                        }\n                    }\n                } else {\n                    // No completion date, skip\n                    continue;\n                }\n            }\n\n            // Check group constraints\n            if let Some(driver_id) = spec::extract_driver_id(\u0026spec.id) {\n                // This is a member spec - skip unless driver is already archived\n                let driver_exists = specs.iter().any(|s| s.id == driver_id);\n                if driver_exists {\n                    continue; // Driver still exists, skip this member\n                }\n            } else {\n                // This is a driver spec or standalone spec\n                let members = spec::get_members(\u0026spec.id, \u0026specs);\n                if !members.is_empty() {\n                    // This is a driver spec with members - check if all are completed\n                    if !spec::all_members_completed(\u0026spec.id, \u0026specs) {\n                        continue; // Not all members completed, skip this driver\n                    }\n                    // Add members first (sorted by member number)\n                    let mut sorted_members = members.clone();\n                    sorted_members\n                        .sort_by_key(|m| spec::extract_member_number(\u0026m.id).unwrap_or(u32::MAX));\n                    for member in sorted_members {\n                        to_archive.push(member.clone());\n                    }\n                }\n            }\n\n            to_archive.push(spec.clone());\n        }\n    }\n\n    if to_archive.is_empty() {\n        println!(\"No specs to archive.\");\n        return Ok(());\n    }\n\n    // Verify target files have changes (unless --force is set)\n    if !force \u0026\u0026 is_git_repo() {\n        let mut specs_with_missing_changes = Vec::new();\n\n        for spec in \u0026to_archive {\n            // Only verify specs with target_files\n            if spec.frontmatter.target_files.is_some() {\n                let verification = verify_target_files(spec)?;\n\n                // Check if there are target files without changes\n                if !verification.files_without_changes.is_empty() {\n                    specs_with_missing_changes.push((spec.clone(), verification));\n                }\n            }\n        }\n\n        // If any specs have missing changes, warn the user\n        if !specs_with_missing_changes.is_empty() {\n            println!(\n                \"\\n{} {} spec(s) have target_files without changes:\\n\",\n                \"â \".yellow(),\n                specs_with_missing_changes.len()\n            );\n\n            // Condense repeated warnings (count \u003e 3)\n            print_condensed_warnings(\u0026specs_with_missing_changes);\n\n            // Prompt for confirmation\n            let confirmed = prompt::confirm(\"Archive anyway?\")?;\n            if !confirmed {\n                println!(\"{} Archive cancelled.\", \"â\".yellow());\n                return Ok(());\n            }\n        }\n    }\n\n    // Count drivers and members for summary\n    let mut driver_count = 0;\n    let mut member_count = 0;\n    for spec in \u0026to_archive {\n        if spec::extract_driver_id(\u0026spec.id).is_some() {\n            member_count += 1;\n        } else {\n            driver_count += 1;\n        }\n    }\n\n    if dry_run {\n        println!(\"{} Would archive {} spec(s):\", \"â\".cyan(), to_archive.len());\n        for spec in \u0026to_archive {\n            if spec::extract_driver_id(\u0026spec.id).is_some() {\n                println!(\"  {} {} (member)\", \"â\".cyan(), spec.id);\n            } else {\n                println!(\"  {} {} (driver)\", \"â\".cyan(), spec.id);\n            }\n        }\n        let summary = if driver_count \u003e 0 \u0026\u0026 member_count \u003e 0 {\n            format!(\n                \"Archived {} spec(s) ({} driver + {} member{})\",\n                to_archive.len(),\n                driver_count,\n                member_count,\n                if member_count == 1 { \"\" } else { \"s\" }\n            )\n        } else {\n            format!(\"Archived {} spec(s)\", to_archive.len())\n        };\n        println!(\"{} {}\", \"â\".cyan(), summary);\n        return Ok(());\n    }\n\n    // Create archive directory if it doesn't exist\n    if !archive_dir.exists() {\n        std::fs::create_dir_all(\u0026archive_dir)?;\n        println!(\"{} Created archive directory\", \"â\".green());\n    }\n\n    // Migrate existing flat archive files to date subfolders (if any)\n    migrate_flat_archive(\u0026archive_dir)?;\n\n    // Move specs to archive\n    let count = to_archive.len();\n    let mut archived_spec_ids = Vec::new();\n    for spec in to_archive {\n        let src = specs_dir.join(format!(\"{}.md\", spec.id));\n\n        // Extract date from spec ID (format: YYYY-MM-DD-XXX-abc)\n        let date_part = \u0026spec.id[..10]; // First 10 chars: YYYY-MM-DD\n        let date_dir = archive_dir.join(date_part);\n\n        // Create date-based subdirectory if it doesn't exist\n        if !date_dir.exists() {\n            std::fs::create_dir_all(\u0026date_dir)?;\n        }\n\n        let dst = date_dir.join(format!(\"{}.md\", spec.id));\n\n        move_spec_file(\u0026src, \u0026dst, no_stage)?;\n        archived_spec_ids.push(spec.id.clone());\n        if spec::extract_driver_id(\u0026spec.id).is_some() {\n            println!(\"  {} {} (archived)\", \"â\".cyan(), spec.id);\n        } else {\n            println!(\"  {} {} (driver, archived)\", \"â\".cyan(), spec.id);\n        }\n    }\n\n    // Print summary\n    let summary = if driver_count \u003e 0 \u0026\u0026 member_count \u003e 0 {\n        format!(\n            \"Archived {} spec(s) ({} driver + {} member{})\",\n            count,\n            driver_count,\n            member_count,\n            if member_count == 1 { \"\" } else { \"s\" }\n        )\n    } else {\n        format!(\"Archived {} spec(s)\", count)\n    };\n    println!(\"{} {}\", \"â\".green(), summary);\n\n    // Create commit if requested (and in a git repo)\n    if commit \u0026\u0026 is_git_repo() {\n        // Check if there are other uncommitted changes besides the archived spec files\n        if has_other_uncommitted_changes(\u0026archived_spec_ids)? {\n            eprintln!(\n                \"{} Working directory has other uncommitted changes. Skipping auto-commit.\",\n                \"â \".yellow()\n            );\n            eprintln!(\"  Please commit or stash other changes, then run 'git commit' manually.\");\n        } else {\n            // Create commit message with all archived spec IDs\n            let commit_msg = if archived_spec_ids.len() == 1 {\n                format!(\"chant: Archive {}\", archived_spec_ids[0])\n            } else {\n                let spec_list = archived_spec_ids.join(\", \");\n                format!(\"chant: Archive {}\", spec_list)\n            };\n\n            let status = std::process::Command::new(\"git\")\n                .args([\"commit\", \"-m\", \u0026commit_msg])\n                .status()\n                .context(\"Failed to create commit\")?;\n\n            if !status.success() {\n                anyhow::bail!(\"git commit failed\");\n            }\n            println!(\"{} Created commit: {}\", \"â\".green(), commit_msg);\n        }\n    }\n\n    Ok(())\n}\n\n/// Migrate existing flat archive files to date-based subfolders.\n/// This handles the transition from `.chant/archive/*.md` to `.chant/archive/YYYY-MM-DD/*.md`\nfn migrate_flat_archive(archive_dir: \u0026std::path::PathBuf) -\u003e anyhow::Result\u003c()\u003e {\n    use std::fs;\n\n    if !archive_dir.exists() {\n        return Ok(());\n    }\n\n    let mut flat_files = Vec::new();\n\n    // Find all flat .md files in the archive directory (not in subdirectories)\n    for entry in fs::read_dir(archive_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        let metadata = entry.metadata()?;\n\n        // Only process .md files directly in archive_dir, not subdirectories\n        if !metadata.is_dir() \u0026\u0026 path.extension().map(|e| e == \"md\").unwrap_or(false) {\n            flat_files.push(path);\n        }\n    }\n\n    // Migrate each flat file to its date subfolder\n    for file_path in flat_files {\n        if let Some(file_name) = file_path.file_name() {\n            if let Some(file_name_str) = file_name.to_str() {\n                // Extract spec ID from filename (e.g., \"2026-01-24-001-abc.md\" -\u003e \"2026-01-24-001-abc\")\n                if let Some(spec_id) = file_name_str.strip_suffix(\".md\") {\n                    // Extract date from spec ID (format: YYYY-MM-DD-XXX-abc)\n                    if spec_id.len() \u003e= 10 {\n                        let date_part = \u0026spec_id[..10]; // First 10 chars: YYYY-MM-DD\n                        let date_dir = archive_dir.join(date_part);\n\n                        // Create date-based subdirectory if it doesn't exist\n                        if !date_dir.exists() {\n                            fs::create_dir_all(\u0026date_dir)?;\n                        }\n\n                        let dst = date_dir.join(file_name);\n\n                        // Move the file to the date subdirectory using git mv when possible\n                        if let Err(e) = move_spec_file(\u0026file_path, \u0026dst, false) {\n                            eprintln!(\n                                \"Warning: Failed to migrate archive file {:?}: {}\",\n                                file_path, e\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::spec::{Spec, SpecFrontmatter, SpecStatus};\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_ensure_logs_dir_creates_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Logs dir shouldn't exist yet\n        assert!(!base_path.join(\"logs\").exists());\n\n        // Call ensure_logs_dir_at\n        crate::cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // Logs dir should now exist\n        assert!(base_path.join(\"logs\").exists());\n        assert!(base_path.join(\"logs\").is_dir());\n    }\n\n    #[test]\n    fn test_ensure_logs_dir_updates_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create base dir without .gitignore\n        // (tempdir already exists, no need to create)\n\n        // Call ensure_logs_dir_at\n        crate::cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // .gitignore should now exist and contain \"logs/\"\n        let gitignore_path = base_path.join(\".gitignore\");\n        assert!(gitignore_path.exists());\n\n        let content = std::fs::read_to_string(\u0026gitignore_path).unwrap();\n        assert!(content.contains(\"logs/\"));\n    }\n\n    #[test]\n    fn test_verify_target_files_no_target_files() {\n        // Spec without target_files should return empty verification\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                target_files: None,\n                ..Default::default()\n            },\n            title: Some(\"Test spec\".to_string()),\n            body: \"# Test\\n\\nBody\".to_string(),\n        };\n\n        let verification = verify_target_files(\u0026spec).unwrap();\n        assert!(verification.files_with_changes.is_empty());\n        assert!(verification.files_without_changes.is_empty());\n        assert!(verification.commits.is_empty());\n        assert!(verification.actual_files_changed.is_empty());\n    }\n\n    #[test]\n    fn test_verify_target_files_empty_target_files() {\n        // Spec with empty target_files should return empty verification\n        let spec = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                target_files: Some(vec![]),\n                ..Default::default()\n            },\n            title: Some(\"Test spec\".to_string()),\n            body: \"# Test\\n\\nBody\".to_string(),\n        };\n\n        let verification = verify_target_files(\u0026spec).unwrap();\n        assert!(verification.files_with_changes.is_empty());\n        assert!(verification.files_without_changes.is_empty());\n        assert!(verification.commits.is_empty());\n        assert!(verification.actual_files_changed.is_empty());\n    }\n\n    #[test]\n    fn test_format_target_files_warning() {\n        let verification = TargetFilesVerification {\n            files_with_changes: vec![],\n            files_without_changes: vec![\"src/test.rs\".to_string(), \"src/main.rs\".to_string()],\n            commits: vec![],\n            actual_files_changed: vec![],\n        };\n\n        let warning = format_target_files_warning(\"2026-01-27-001-abc\", \u0026verification);\n\n        assert!(warning.contains(\"2026-01-27-001-abc\"));\n        assert!(warning.contains(\"predicted\"));\n        assert!(warning.contains(\"src/test.rs\"));\n        assert!(warning.contains(\"src/main.rs\"));\n        assert!(warning.contains(\"Prediction mismatch\"));\n    }\n\n    #[test]\n    fn test_target_files_verification_struct() {\n        let verification = TargetFilesVerification {\n            files_with_changes: vec![\"src/lib.rs\".to_string()],\n            files_without_changes: vec![\"src/test.rs\".to_string()],\n            commits: vec![\"abc1234\".to_string(), \"def5678\".to_string()],\n            actual_files_changed: vec![(\"src/lib.rs\".to_string(), 50)],\n        };\n\n        assert_eq!(verification.files_with_changes.len(), 1);\n        assert_eq!(verification.files_without_changes.len(), 1);\n        assert_eq!(verification.commits.len(), 2);\n        assert_eq!(verification.actual_files_changed.len(), 1);\n    }\n\n    #[test]\n    fn test_format_target_files_warning_with_mismatch() {\n        // Test case where target_files exist but changes were made to different files\n        let verification = TargetFilesVerification {\n            files_with_changes: vec![],\n            files_without_changes: vec![\"src/cmd/finalize.rs\".to_string()],\n            commits: vec![\"abc1234\".to_string()],\n            actual_files_changed: vec![\n                (\"src/commands/finalize.rs\".to_string(), 128),\n                (\"tests/finalize_test.rs\".to_string(), -10),\n            ],\n        };\n\n        let warning = format_target_files_warning(\"2026-01-29-00a-qza\", \u0026verification);\n\n        // Check spec ID is present\n        assert!(warning.contains(\"2026-01-29-00a-qza\"));\n\n        // Check predicted file is shown\n        assert!(warning.contains(\"src/cmd/finalize.rs\"));\n\n        // Check actual files changed are shown\n        assert!(warning.contains(\"src/commands/finalize.rs\"));\n        assert!(warning.contains(\"tests/finalize_test.rs\"));\n\n        // Check reassuring message\n        assert!(warning.contains(\"Prediction mismatch\"));\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":8}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":6}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":296},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","drift.rs"],"content":"//! Drift detection - checks if documented/researched inputs have changed\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\n\nuse chant::spec::{self, Spec, SpecStatus};\n\n#[derive(Debug)]\nstruct DriftReport {\n    spec_id: String,\n    spec_type: String,\n    completed_at: String,\n    drifted_files: Vec\u003cDriftedFile\u003e,\n}\n\n#[derive(Debug)]\nstruct DriftedFile {\n    path: String,\n    modified_at: String,\n}\n\n/// Check if any files matching a pattern have been modified after a certain time\nfn check_files_for_changes(\n    pattern: \u0026str,\n    completed_time: \u0026chrono::DateTime\u003cchrono::FixedOffset\u003e,\n    drift_report: \u0026mut DriftReport,\n) -\u003e Result\u003c()\u003e {\n    // Expand glob pattern to actual files\n    let mut expanded_files = Vec::new();\n\n    // Check if pattern is a glob\n    if pattern.contains('*') || pattern.contains('?') || pattern.contains('[') {\n        // Use glob to expand\n        use glob::glob as glob_fn;\n        for entry in glob_fn(pattern)\n            .context(format!(\"Invalid glob pattern: {}\", pattern))?\n            .flatten()\n        {\n            if entry.is_file() {\n                expanded_files.push(entry);\n            }\n        }\n    } else {\n        // Literal path\n        let path = std::path::PathBuf::from(pattern);\n        if path.exists() \u0026\u0026 path.is_file() {\n            expanded_files.push(path);\n        }\n    }\n\n    // For each file, check if it was modified after completed_at\n    for file_path in expanded_files {\n        if let Ok(metadata) = std::fs::metadata(\u0026file_path) {\n            if let Ok(modified) = metadata.modified() {\n                let file_modified_time = chrono::DateTime::\u003cchrono::Utc\u003e::from(modified);\n                let completed_utc = completed_time.with_timezone(\u0026chrono::Utc);\n\n                if file_modified_time \u003e completed_utc {\n                    let relative_path = file_path.to_string_lossy().to_string();\n                    drift_report.drifted_files.push(DriftedFile {\n                        path: relative_path,\n                        modified_at: file_modified_time.format(\"%Y-%m-%d\").to_string(),\n                    });\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if documentation and research specs have stale inputs\npub fn cmd_drift(id: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    let specs = spec::load_all_specs(\u0026specs_dir)?;\n\n    // If a specific ID is provided, filter to that spec\n    let specs_to_check: Vec\u003c\u0026Spec\u003e = if let Some(filter_id) = id {\n        specs.iter().filter(|s| s.id.contains(filter_id)).collect()\n    } else {\n        specs.iter().collect()\n    };\n\n    if specs_to_check.is_empty() {\n        if let Some(filter_id) = id {\n            anyhow::bail!(\"No specs found matching: {}\", filter_id);\n        } else {\n            println!(\"No specs to check for drift.\");\n            return Ok(());\n        }\n    }\n\n    let mut drifted_specs = Vec::new();\n    let mut up_to_date_specs = Vec::new();\n\n    for spec in specs_to_check {\n        // Only check completed specs\n        if spec.frontmatter.status != SpecStatus::Completed {\n            continue;\n        }\n\n        // Get completion time\n        let completed_at = match \u0026spec.frontmatter.completed_at {\n            Some(timestamp) =\u003e timestamp.clone(),\n            None =\u003e {\n                // If completed but no timestamp, skip\n                continue;\n            }\n        };\n\n        // Parse timestamp - format is ISO 8601 UTC (e.g., \"2026-01-24T15:30:00Z\")\n        let completed_time = match chrono::DateTime::parse_from_rfc3339(\u0026completed_at) {\n            Ok(dt) =\u003e dt,\n            Err(_) =\u003e {\n                // If timestamp format is invalid, skip\n                continue;\n            }\n        };\n\n        // Check for drifts\n        let mut drift_report = DriftReport {\n            spec_id: spec.id.clone(),\n            spec_type: spec.frontmatter.r#type.clone(),\n            completed_at: completed_at.clone(),\n            drifted_files: Vec::new(),\n        };\n\n        // Check tracked files (documentation specs)\n        if let Some(tracked) = \u0026spec.frontmatter.tracks {\n            for file_pattern in tracked {\n                check_files_for_changes(file_pattern, \u0026completed_time, \u0026mut drift_report)?;\n            }\n        }\n\n        // Check origin files (research specs)\n        if let Some(origin) = \u0026spec.frontmatter.origin {\n            for file_pattern in origin {\n                check_files_for_changes(file_pattern, \u0026completed_time, \u0026mut drift_report)?;\n            }\n        }\n\n        // Check informed_by files (research specs)\n        if let Some(informed_by) = \u0026spec.frontmatter.informed_by {\n            for file_pattern in informed_by {\n                check_files_for_changes(file_pattern, \u0026completed_time, \u0026mut drift_report)?;\n            }\n        }\n\n        if drift_report.drifted_files.is_empty() {\n            up_to_date_specs.push(drift_report);\n        } else {\n            drifted_specs.push(drift_report);\n        }\n    }\n\n    // Display results\n    if drifted_specs.is_empty() \u0026\u0026 up_to_date_specs.is_empty() {\n        println!(\"No completed specs with tracked/origin/informed_by fields to check.\");\n        return Ok(());\n    }\n\n    if !drifted_specs.is_empty() {\n        println!(\n            \"\\n{} Drifted Specs (inputs changed after completion)\",\n            \"â \".yellow()\n        );\n        println!(\"{}\", \"â\".repeat(70));\n\n        for report in \u0026drifted_specs {\n            println!(\n                \"\\n{} Spec: {} ({})\",\n                \"â\".red(),\n                report.spec_id,\n                report.spec_type\n            );\n            println!(\"  Completed: {}\", report.completed_at.bright_black());\n            for drifted_file in \u0026report.drifted_files {\n                println!(\n                    \"    {} {} (modified {})\",\n                    \"â\".bright_black(),\n                    drifted_file.path,\n                    drifted_file.modified_at.bright_black()\n                );\n            }\n            println!(\n                \"  {}\",\n                \"Recommendation: Re-run spec to update analysis/documentation\".yellow()\n            );\n        }\n    }\n\n    if !up_to_date_specs.is_empty() \u0026\u0026 !drifted_specs.is_empty() {\n        println!();\n    }\n\n    if !up_to_date_specs.is_empty() {\n        println!(\"\\n{} Up-to-date Specs (no input changes)\", \"â\".green());\n        println!(\"{}\", \"â\".repeat(70));\n\n        for report in \u0026up_to_date_specs {\n            println!(\"{} {} ({})\", \"â\".green(), report.spec_id, report.spec_type);\n        }\n    }\n\n    // Return success if checking specific spec even if it drifted\n    Ok(())\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","merge.rs"],"content":"//! Spec merging functionality - merges completed spec branches back to main\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::path::{Path, PathBuf};\n\nuse chant::config::Config;\nuse chant::git;\nuse chant::merge;\nuse chant::merge_errors;\nuse chant::paths::PROMPTS_DIR;\nuse chant::spec::{self, Spec, SpecFrontmatter, SpecStatus};\n\n/// Resolve merge conflicts using an agent\nfn resolve_conflicts_with_agent(\n    branch_name: \u0026str,\n    onto_branch: \u0026str,\n    conflicting_files: \u0026[String],\n    config: \u0026Config,\n) -\u003e Result\u003c()\u003e {\n    use crate::cmd::agent;\n\n    // Get the merge-conflict prompt if it exists, otherwise use a default message\n    let prompts_dir = PathBuf::from(PROMPTS_DIR);\n    let conflict_prompt_path = prompts_dir.join(\"merge-conflict.md\");\n\n    let message = if conflict_prompt_path.exists() {\n        // Load and assemble the conflict prompt\n        let prompt_content = std::fs::read_to_string(\u0026conflict_prompt_path)\n            .context(\"Failed to read merge-conflict prompt\")?;\n\n        // Get diff for conflicting files\n        let conflict_diff = get_conflict_diff(conflicting_files)?;\n\n        // Simple template substitution\n        prompt_content\n            .replace(\"{{branch_name}}\", branch_name)\n            .replace(\"{{target_branch}}\", onto_branch)\n            .replace(\"{{conflicting_files}}\", \u0026conflicting_files.join(\", \"))\n            .replace(\"{{conflict_diff}}\", \u0026conflict_diff)\n    } else {\n        // Default inline prompt\n        let conflict_diff = get_conflict_diff(conflicting_files)?;\n        format!(\n            r#\"# Resolve Merge Conflict\n\nYou are resolving a git conflict during rebase.\n\n## Context\n- Branch being rebased: {}\n- Rebasing onto: {}\n- Conflicting files: {}\n\n## Current Diff\n{}\n\n## Instructions\n1. Read each conflicting file to see the conflict markers (\u003c\u003c\u003c\u003c\u003c\u003c\u003c ======= \u003e\u003e\u003e\u003e\u003e\u003e\u003e)\n2. Edit the files to resolve the conflicts (usually include both changes for additive conflicts)\n3. After editing, stage each resolved file with a shell command: git add \u003cfile\u003e\n4. When all conflicts are resolved, run: git rebase --continue\n\nIMPORTANT: Do NOT use git commit. Just resolve conflicts, stage files, and run git rebase --continue.\n\"#,\n            branch_name,\n            onto_branch,\n            conflicting_files.join(\", \"),\n            conflict_diff\n        )\n    };\n\n    // Create a minimal spec for the agent invocation\n    let conflict_spec = Spec {\n        id: format!(\"conflict-{}\", branch_name.replace('/', \"-\")),\n        frontmatter: SpecFrontmatter::default(),\n        title: Some(format!(\n            \"Resolve conflict: {} â {}\",\n            branch_name, onto_branch\n        )),\n        body: message.clone(),\n    };\n\n    // Invoke agent to resolve conflicts\n    agent::invoke_agent(\u0026message, \u0026conflict_spec, \"merge-conflict\", config)?;\n\n    // Check if conflicts were resolved\n    let remaining_conflicts = git::get_conflicting_files()?;\n    if !remaining_conflicts.is_empty() {\n        anyhow::bail!(\n            \"Agent did not resolve all conflicts. Remaining: {}\",\n            remaining_conflicts.join(\", \")\n        );\n    }\n\n    Ok(())\n}\n\n/// Get diff output for conflicting files\nfn get_conflict_diff(files: \u0026[String]) -\u003e Result\u003cString\u003e {\n    use std::process::Command;\n\n    let mut diff_output = String::new();\n\n    for file in files {\n        let output = Command::new(\"git\")\n            .args([\"diff\", file])\n            .output()\n            .context(\"Failed to run git diff\")?;\n\n        if output.status.success() {\n            let diff = String::from_utf8_lossy(\u0026output.stdout);\n            diff_output.push_str(\u0026format!(\"### {}\\n```diff\\n{}\\n```\\n\\n\", file, diff));\n        }\n    }\n\n    Ok(diff_output)\n}\n\n// ============================================================================\n// MERGE WIZARD\n// ============================================================================\n\n/// Show branch status for all completed specs\nfn show_branch_status(all_specs: \u0026[Spec], branch_prefix: \u0026str, main_branch: \u0026str) -\u003e Result\u003c()\u003e {\n    use merge::{BranchInfo, BranchStatus};\n\n    let branch_infos = merge::get_branch_info_for_specs(all_specs, branch_prefix, main_branch)?;\n\n    if branch_infos.is_empty() {\n        println!(\"No completed specs with branches found.\");\n        return Ok(());\n    }\n\n    // Separate into ready and not ready\n    let ready: Vec\u003c\u0026BranchInfo\u003e = branch_infos\n        .iter()\n        .filter(|info| info.status == BranchStatus::Ready)\n        .collect();\n\n    let not_ready: Vec\u003c\u0026BranchInfo\u003e = branch_infos\n        .iter()\n        .filter(|info| info.status != BranchStatus::Ready)\n        .collect();\n\n    // Display ready branches\n    if !ready.is_empty() {\n        println!(\"{}\", \"Ready to merge:\".green().bold());\n        for info in ready {\n            let title = info.spec_title.as_deref().unwrap_or(\"(no title)\");\n            let commits_str = if info.commit_count == 1 {\n                \"1 commit\".to_string()\n            } else {\n                format!(\"{} commits\", info.commit_count)\n            };\n            println!(\n                \"  {} {}  ({}, all criteria met)\",\n                \"chant/\".dimmed(),\n                info.spec_id.cyan(),\n                commits_str.dimmed()\n            );\n            println!(\"    {}\", title.dimmed());\n        }\n        println!();\n    }\n\n    // Display not ready branches\n    if !not_ready.is_empty() {\n        println!(\"{}\", \"Not ready:\".yellow().bold());\n        for info in not_ready {\n            let title = info.spec_title.as_deref().unwrap_or(\"(no title)\");\n            let reason = match \u0026info.status {\n                BranchStatus::NeedsRebase =\u003e \"behind main, needs rebase\".to_string(),\n                BranchStatus::HasConflicts =\u003e \"has conflicts with main\".to_string(),\n                BranchStatus::Incomplete =\u003e format!(\n                    \"{}/{} criteria checked\",\n                    info.criteria_checked, info.criteria_total\n                ),\n                BranchStatus::NoCommits =\u003e \"no commits\".to_string(),\n                _ =\u003e \"unknown\".to_string(),\n            };\n            println!(\n                \"  {} {}  ({})\",\n                \"chant/\".dimmed(),\n                info.spec_id.yellow(),\n                reason.dimmed()\n            );\n            println!(\"    {}\", title.dimmed());\n        }\n    }\n\n    Ok(())\n}\n\n/// Merge all ready branches (can fast-forward, all criteria met)\n#[allow(clippy::too_many_arguments)]\nfn merge_ready_branches(\n    all_specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n    dry_run: bool,\n    delete_branch: bool,\n    continue_on_error: bool,\n    yes: bool,\n    auto_resolve: bool,\n    finalize: bool,\n    config: \u0026Config,\n    specs_dir: \u0026Path,\n) -\u003e Result\u003c()\u003e {\n    use merge::{BranchInfo, BranchStatus};\n\n    let branch_infos = merge::get_branch_info_for_specs(all_specs, branch_prefix, main_branch)?;\n\n    let ready: Vec\u003c\u0026BranchInfo\u003e = branch_infos\n        .iter()\n        .filter(|info| info.status == BranchStatus::Ready)\n        .collect();\n\n    if ready.is_empty() {\n        println!(\"No ready branches found.\");\n        return Ok(());\n    }\n\n    println!(\"{} Found {} ready branch(es):\", \"â\".cyan(), ready.len());\n    for info in \u0026ready {\n        let title = info.spec_title.as_deref().unwrap_or(\"(no title)\");\n        println!(\"  {} {} {}\", \"Â·\".cyan(), info.spec_id, title.dimmed());\n    }\n    println!();\n\n    let spec_ids: Vec\u003cString\u003e = ready.iter().map(|info| info.spec_id.clone()).collect();\n\n    execute_merge(\n        \u0026spec_ids,\n        false, // not --all mode\n        dry_run,\n        delete_branch,\n        continue_on_error,\n        yes,\n        false, // no rebase needed for ready branches\n        auto_resolve,\n        finalize,\n        all_specs,\n        config,\n        branch_prefix,\n        main_branch,\n        specs_dir,\n    )\n}\n\n/// Interactive mode to select which branches to merge\n#[allow(clippy::too_many_arguments)]\nfn merge_interactive(\n    all_specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n    dry_run: bool,\n    delete_branch: bool,\n    continue_on_error: bool,\n    yes: bool,\n    rebase: bool,\n    auto_resolve: bool,\n    finalize: bool,\n    config: \u0026Config,\n    specs_dir: \u0026Path,\n) -\u003e Result\u003c()\u003e {\n    use dialoguer::MultiSelect;\n    use merge::BranchStatus;\n\n    let branch_infos = merge::get_branch_info_for_specs(all_specs, branch_prefix, main_branch)?;\n\n    if branch_infos.is_empty() {\n        println!(\"No completed specs with branches found.\");\n        return Ok(());\n    }\n\n    // Build display items with status indicators\n    let display_items: Vec\u003cString\u003e = branch_infos\n        .iter()\n        .map(|info| {\n            let title = info.spec_title.as_deref().unwrap_or(\"(no title)\");\n            let status_str = match \u0026info.status {\n                BranchStatus::Ready =\u003e \"(ready)\".green().to_string(),\n                BranchStatus::NeedsRebase =\u003e \"(needs rebase)\".yellow().to_string(),\n                BranchStatus::HasConflicts =\u003e \"(has conflicts)\".red().to_string(),\n                BranchStatus::Incomplete =\u003e format!(\n                    \"(incomplete: {}/{})\",\n                    info.criteria_checked, info.criteria_total\n                )\n                .yellow()\n                .to_string(),\n                BranchStatus::NoCommits =\u003e \"(no commits)\".dimmed().to_string(),\n                _ =\u003e \"\".to_string(),\n            };\n            format!(\"{} - {} {}\", info.spec_id, title, status_str)\n        })\n        .collect();\n\n    // Pre-select ready branches\n    let defaults: Vec\u003cbool\u003e = branch_infos\n        .iter()\n        .map(|info| info.status == BranchStatus::Ready)\n        .collect();\n\n    // Show multi-select prompt\n    let selection = MultiSelect::new()\n        .with_prompt(\"Select branches to merge\")\n        .items(\u0026display_items)\n        .defaults(\u0026defaults)\n        .interact()?;\n\n    if selection.is_empty() {\n        println!(\"No branches selected\");\n        return Ok(());\n    }\n\n    let spec_ids: Vec\u003cString\u003e = selection\n        .iter()\n        .map(|\u0026idx| branch_infos[idx].spec_id.clone())\n        .collect();\n\n    println!(\n        \"\\n{} Merge {} selected branch(es)? (y/n)\",\n        \"?\".cyan(),\n        spec_ids.len()\n    );\n\n    if !yes {\n        use dialoguer::Confirm;\n        if !Confirm::new().interact()? {\n            println!(\"Cancelled\");\n            return Ok(());\n        }\n    }\n\n    execute_merge(\n        \u0026spec_ids,\n        false,\n        dry_run,\n        delete_branch,\n        continue_on_error,\n        yes,\n        rebase,\n        auto_resolve,\n        finalize,\n        all_specs,\n        config,\n        branch_prefix,\n        main_branch,\n        specs_dir,\n    )\n}\n\n/// Run the interactive wizard for selecting specs to merge\n/// Returns (selected_spec_ids, delete_branch, rebase)\nfn run_merge_wizard(\n    all_specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n    delete_branch: bool,\n    rebase: bool,\n) -\u003e Result\u003c(Vec\u003cString\u003e, bool, bool)\u003e {\n    use dialoguer::{Confirm, MultiSelect};\n\n    // Get completed specs that have branches and haven't been merged yet\n    let mergeable_specs: Vec\u003c(String, \u0026Spec)\u003e = all_specs\n        .iter()\n        .filter(|spec| spec.frontmatter.status == SpecStatus::Completed)\n        .filter_map(|spec| {\n            let branch_name = format!(\"{}{}\", branch_prefix, spec.id);\n            if git::branch_exists(\u0026branch_name).unwrap_or(false) {\n                // Check if branch has already been merged\n                if git::is_branch_merged(\u0026branch_name, main_branch).unwrap_or(false) {\n                    // Skip already-merged branches\n                    None\n                } else {\n                    Some((spec.id.clone(), spec))\n                }\n            } else {\n                None\n            }\n        })\n        .collect();\n\n    // If no mergeable specs, show message and return early\n    if mergeable_specs.is_empty() {\n        println!(\"No specs to merge\");\n        return Ok((Vec::new(), delete_branch, rebase));\n    }\n\n    // Build display items with ID, title, and branch name\n    let display_items: Vec\u003cString\u003e = mergeable_specs\n        .iter()\n        .map(|(spec_id, spec)| {\n            let title = spec.title.as_deref().unwrap_or(\"(no title)\");\n            let branch_name = format!(\"{}{}\", branch_prefix, spec_id);\n            format!(\"{}  {}  ({})\", spec_id, title, branch_name)\n        })\n        .collect();\n\n    // Add \"Select all\" option at the end\n    let mut all_items = display_items.clone();\n    all_items.push(\"[Select all]\".to_string());\n\n    // Show multi-select prompt\n    let selection = MultiSelect::new()\n        .with_prompt(\"Select specs to merge\")\n        .items(\u0026all_items)\n        .interact()?;\n\n    // Determine which specs were selected\n    let selected_spec_ids: Vec\u003cString\u003e =\n        if selection.len() == 1 \u0026\u0026 selection[0] == all_items.len() - 1 {\n            // \"Select all\" was the only selection\n            mergeable_specs.iter().map(|(id, _)| id.clone()).collect()\n        } else if selection.contains(\u0026(all_items.len() - 1)) {\n            // \"Select all\" was selected along with other specs - treat as select all\n            mergeable_specs.iter().map(|(id, _)| id.clone()).collect()\n        } else {\n            // Regular selections\n            selection\n                .iter()\n                .map(|\u0026idx| mergeable_specs[idx].0.clone())\n                .collect()\n        };\n\n    if selected_spec_ids.is_empty() {\n        println!(\"No specs selected\");\n        return Ok((Vec::new(), delete_branch, rebase));\n    }\n\n    // Ask about rebase strategy\n    let use_rebase = Confirm::new()\n        .with_prompt(\"Use rebase strategy\")\n        .default(false)\n        .interact()?;\n\n    // Ask about delete branches\n    let delete_after_merge = Confirm::new()\n        .with_prompt(\"Delete branches after merge\")\n        .default(true)\n        .interact()?;\n\n    Ok((selected_spec_ids, delete_after_merge, use_rebase))\n}\n\n/// Find all completed specs that have corresponding branches.\n/// Used by --all-completed to find specs to merge after parallel execution.\nfn find_completed_specs_with_branches(\n    all_specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut completed_with_branches = Vec::new();\n\n    for spec in all_specs {\n        // Only consider completed specs\n        if spec.frontmatter.status != SpecStatus::Completed {\n            continue;\n        }\n\n        // Check if the branch exists\n        let branch_name = format!(\"{}{}\", branch_prefix, spec.id);\n        if git::branch_exists(\u0026branch_name).unwrap_or(false) {\n            // Skip already-merged branches\n            if !git::is_branch_merged(\u0026branch_name, main_branch).unwrap_or(false) {\n                completed_with_branches.push(spec.id.clone());\n            }\n        }\n    }\n\n    Ok(completed_with_branches)\n}\n\n/// Execute the merge operation for a list of spec IDs.\n/// This is the core merge logic shared between different entry points.\n#[allow(clippy::too_many_arguments)]\nfn execute_merge(\n    final_ids: \u0026[String],\n    all: bool,\n    dry_run: bool,\n    final_delete_branch: bool,\n    continue_on_error: bool,\n    yes: bool,\n    final_rebase: bool,\n    auto_resolve: bool,\n    finalize: bool,\n    all_specs: \u0026[Spec],\n    config: \u0026Config,\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n    specs_dir: \u0026Path,\n) -\u003e Result\u003c()\u003e {\n    // Get specs to merge using the merge module function\n    let mut specs_to_merge = merge::get_specs_to_merge(final_ids, all, all_specs)?;\n\n    // Filter to only those with branches that exist (unless dry-run)\n    if !dry_run {\n        specs_to_merge.retain(|(spec_id, _spec)| {\n            git::branch_exists(\u0026format!(\"{}{}\", branch_prefix, spec_id)).unwrap_or_default()\n        });\n    }\n\n    if specs_to_merge.is_empty() {\n        println!(\"No completed specs with branches to merge.\");\n        return Ok(());\n    }\n\n    // Check for specs requiring approval before merge\n    let mut unapproved_specs: Vec\u003c(String, String)\u003e = Vec::new();\n    for (spec_id, spec) in \u0026specs_to_merge {\n        if spec.requires_approval() {\n            let title = spec.title.as_deref().unwrap_or(\"(no title)\").to_string();\n            unapproved_specs.push((spec_id.clone(), title));\n        }\n    }\n\n    if !unapproved_specs.is_empty() {\n        println!(\n            \"{} {} spec(s) require approval before merge:\",\n            \"â\".red(),\n            unapproved_specs.len()\n        );\n        for (spec_id, title) in \u0026unapproved_specs {\n            println!(\"  {} {} {}\", \"Â·\".red(), spec_id, title.dimmed());\n        }\n        println!();\n        println!(\n            \"Run {} to approve specs before merging.\",\n            \"chant approve \u003cspec-id\u003e --by \u003capprover\u003e\".cyan()\n        );\n        anyhow::bail!(\n            \"Cannot merge: {} spec(s) require approval\",\n            unapproved_specs.len()\n        );\n    }\n\n    // Display what would be merged\n    println!(\n        \"{} {} merge {} spec(s){}:\",\n        \"â\".cyan(),\n        if dry_run { \"Would\" } else { \"Will\" },\n        specs_to_merge.len(),\n        if all { \" (all completed)\" } else { \"\" }\n    );\n    for (spec_id, spec) in \u0026specs_to_merge {\n        let title = spec.title.as_deref().unwrap_or(\"(no title)\");\n        let branch_name = format!(\"{}{}\", branch_prefix, spec_id);\n        println!(\n            \"  {} {} â {} {}\",\n            \"Â·\".cyan(),\n            branch_name,\n            main_branch,\n            title.dimmed()\n        );\n    }\n    println!();\n\n    // If dry-run, show what would happen and exit\n    if dry_run {\n        println!(\"{} Dry-run mode: no changes made.\", \"â¹\".blue());\n        return Ok(());\n    }\n\n    // Show confirmation prompt unless --yes or --dry-run\n    if !yes {\n        let confirmed = chant::prompt::confirm(\u0026format!(\n            \"Proceed with merging {} spec(s)?\",\n            specs_to_merge.len()\n        ))?;\n        if !confirmed {\n            println!(\"{} Merge cancelled.\", \"â\".yellow());\n            return Ok(());\n        }\n    }\n\n    // Sort specs to merge members before drivers\n    // This ensures driver specs are merged after all their members\n    let mut sorted_specs: Vec\u003c(String, Spec)\u003e = specs_to_merge.clone();\n    sorted_specs.sort_by(|(id_a, _), (id_b, _)| {\n        // Count dots in IDs - members have more dots, sort them first\n        let dots_a = id_a.matches('.').count();\n        let dots_b = id_b.matches('.').count();\n        dots_b.cmp(\u0026dots_a) // Reverse order: members (more dots) before drivers (fewer dots)\n    });\n\n    // Execute merges\n    let mut merge_results: Vec\u003cgit::MergeResult\u003e = Vec::new();\n    let mut errors: Vec\u003c(String, String)\u003e = Vec::new();\n    let mut _skipped_conflicts: Vec\u003c(String, Vec\u003cString\u003e)\u003e = Vec::new();\n\n    println!(\n        \"{} Executing merges{}...\",\n        \"â\".cyan(),\n        if final_rebase { \" with rebase\" } else { \"\" }\n    );\n\n    for (spec_id, spec) in \u0026sorted_specs {\n        let branch_name = format!(\"{}{}\", branch_prefix, spec_id);\n\n        // If rebase mode, rebase branch onto main first\n        if final_rebase {\n            println!(\n                \"  {} Rebasing {} onto {}...\",\n                \"â\".cyan(),\n                branch_name,\n                main_branch\n            );\n\n            match git::rebase_branch(\u0026branch_name, main_branch) {\n                Ok(rebase_result) =\u003e {\n                    if !rebase_result.success {\n                        // Rebase had conflicts\n                        if auto_resolve {\n                            // Try to resolve conflicts with agent\n                            println!(\n                                \"    {} Conflict in: {}\",\n                                \"â \".yellow(),\n                                rebase_result.conflicting_files.join(\", \")\n                            );\n                            println!(\"    {} Invoking agent to resolve...\", \"â\".cyan());\n\n                            match resolve_conflicts_with_agent(\n                                \u0026branch_name,\n                                main_branch,\n                                \u0026rebase_result.conflicting_files,\n                                config,\n                            ) {\n                                Ok(()) =\u003e {\n                                    println!(\"    {} Conflicts resolved\", \"â\".green());\n                                }\n                                Err(e) =\u003e {\n                                    let error_msg = format!(\"Auto-resolve failed: {}\", e);\n                                    errors.push((spec_id.clone(), error_msg.clone()));\n                                    _skipped_conflicts\n                                        .push((spec_id.clone(), rebase_result.conflicting_files));\n                                    println!(\"    {} {}\", \"â\".red(), error_msg);\n                                    if !continue_on_error {\n                                        anyhow::bail!(\"Merge stopped at spec {}.\", spec_id);\n                                    }\n                                    continue;\n                                }\n                            }\n                        } else {\n                            // No auto-resolve, abort rebase and skip this branch\n                            git::rebase_abort()?;\n\n                            let error_msg = merge_errors::rebase_conflict(\n                                spec_id,\n                                \u0026branch_name,\n                                \u0026rebase_result.conflicting_files,\n                            );\n                            errors.push((spec_id.clone(), error_msg.clone()));\n                            _skipped_conflicts\n                                .push((spec_id.clone(), rebase_result.conflicting_files));\n                            println!(\"    {} {}\", \"â\".red(), error_msg);\n                            if !continue_on_error {\n                                anyhow::bail!(\"{}\", merge_errors::rebase_stopped(spec_id));\n                            }\n                            continue;\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    let error_msg = merge_errors::generic_merge_failed(\n                        spec_id,\n                        \u0026branch_name,\n                        main_branch,\n                        \u0026format!(\"Rebase failed: {}\", e),\n                    );\n                    errors.push((spec_id.clone(), error_msg.clone()));\n                    println!(\"    {} {}\", \"â\".red(), error_msg);\n                    if !continue_on_error {\n                        anyhow::bail!(\"{}\", merge_errors::merge_stopped(spec_id));\n                    }\n                    continue;\n                }\n            }\n        }\n\n        // Check if this is a driver spec\n        let is_driver = merge::is_driver_spec(spec, all_specs);\n\n        let merge_op_result = if is_driver {\n            // Merge driver and its members\n            merge::merge_driver_spec(\n                spec,\n                all_specs,\n                branch_prefix,\n                main_branch,\n                final_delete_branch,\n                false,\n            )\n        } else {\n            // Merge single spec\n            match git::merge_single_spec(\n                spec_id,\n                \u0026branch_name,\n                main_branch,\n                final_delete_branch,\n                false,\n            ) {\n                Ok(result) =\u003e Ok(vec![result]),\n                Err(e) =\u003e Err(e),\n            }\n        };\n\n        match merge_op_result {\n            Ok(results) =\u003e {\n                merge_results.extend(results);\n            }\n            Err(e) =\u003e {\n                let error_msg = e.to_string();\n                errors.push((spec_id.clone(), error_msg.clone()));\n                println!(\"  {} {} failed: {}\", \"â\".red(), spec_id, error_msg);\n\n                if !continue_on_error {\n                    anyhow::bail!(\"{}\", merge_errors::merge_stopped(spec_id));\n                }\n            }\n        }\n    }\n\n    // Display results\n    println!(\"\\n{} Merge Results\", \"â\".cyan());\n    println!(\"{}\", \"â\".repeat(60));\n\n    for result in \u0026merge_results {\n        println!(\"{}\", git::format_merge_summary(result));\n    }\n\n    // Finalize specs if --finalize flag is set\n    let mut finalized_count = 0;\n    let mut finalize_errors: Vec\u003c(String, String)\u003e = Vec::new();\n\n    if finalize \u0026\u0026 !dry_run {\n        println!(\"\\n{} Finalizing merged specs...\", \"â\".cyan());\n        for result in \u0026merge_results {\n            if result.success {\n                // Reload the spec from disk (it may have changed during merge)\n                match spec::resolve_spec(specs_dir, \u0026result.spec_id) {\n                    Ok(mut spec) =\u003e {\n                        // Update spec status to completed\n                        spec.frontmatter.status = SpecStatus::Completed;\n\n                        // Add completed_at if not present\n                        if spec.frontmatter.completed_at.is_none() {\n                            spec.frontmatter.completed_at =\n                                Some(chrono::Utc::now().format(\"%Y-%m-%dT%H:%M:%SZ\").to_string());\n                        }\n\n                        // Save the spec\n                        let spec_path = specs_dir.join(format!(\"{}.md\", result.spec_id));\n                        match spec.save(\u0026spec_path) {\n                            Ok(_) =\u003e {\n                                finalized_count += 1;\n                                println!(\"  {} {} finalized\", \"â\".green(), result.spec_id);\n                            }\n                            Err(e) =\u003e {\n                                finalize_errors.push((\n                                    result.spec_id.clone(),\n                                    format!(\"Failed to save: {}\", e),\n                                ));\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        finalize_errors.push((\n                            result.spec_id.clone(),\n                            format!(\"Failed to load spec: {}\", e),\n                        ));\n                    }\n                }\n            }\n        }\n    }\n\n    // Display summary\n    println!(\"\\n{} Summary\", \"â\".cyan());\n    println!(\"{}\", \"â\".repeat(60));\n    println!(\"  {} Specs merged: {}\", \"â\".green(), merge_results.len());\n    if finalize \u0026\u0026 finalized_count \u003e 0 {\n        println!(\"  {} Specs finalized: {}\", \"â\".green(), finalized_count);\n    }\n    if !errors.is_empty() {\n        println!(\"  {} Specs failed: {}\", \"â\".red(), errors.len());\n        for (spec_id, error_msg) in \u0026errors {\n            println!(\"    - {}: {}\", spec_id, error_msg);\n        }\n    }\n    if !finalize_errors.is_empty() {\n        println!(\n            \"  {} Specs failed to finalize: {}\",\n            \"â \".yellow(),\n            finalize_errors.len()\n        );\n        for (spec_id, error_msg) in \u0026finalize_errors {\n            println!(\"    - {}: {}\", spec_id, error_msg);\n        }\n    }\n    if final_delete_branch {\n        let deleted_count = merge_results.iter().filter(|r| r.branch_deleted).count();\n        println!(\"  {} Branches deleted: {}\", \"â\".green(), deleted_count);\n    }\n\n    if !errors.is_empty() {\n        println!(\"\\n{}\", \"Some merges failed.\".yellow());\n        println!(\"\\nNext steps:\");\n        println!(\"  1. Review failed specs with:  chant show \u003cspec-id\u003e\");\n        println!(\"  2. Retry with rebase:  chant merge --all --rebase\");\n        println!(\"  3. Auto-resolve conflicts:  chant merge --all --rebase --auto\");\n        println!(\"  4. Or merge individually:  chant merge \u003cspec-id\u003e\");\n        println!(\"\\nDocumentation: See 'chant merge --help' for more options\");\n        return Ok(());\n    }\n\n    if finalize {\n        if finalize_errors.is_empty() {\n            println!(\n                \"\\n{} All specs merged and finalized successfully.\",\n                \"â\".green()\n            );\n        } else {\n            println!(\"\\n{}\", \"Some specs failed to finalize.\".yellow());\n            println!(\n                \"Run {} for failed specs.\",\n                \"chant finalize \u003cspec-id\u003e\".bold()\n            );\n        }\n    } else {\n        println!(\"\\n{} All specs merged successfully.\", \"â\".green());\n    }\n    Ok(())\n}\n\n/// Merge completed spec branches back to main\n#[allow(clippy::too_many_arguments)]\npub fn cmd_merge(\n    ids: \u0026[String],\n    all: bool,\n    all_completed: bool,\n    list: bool,\n    ready: bool,\n    interactive: bool,\n    dry_run: bool,\n    delete_branch: bool,\n    continue_on_error: bool,\n    yes: bool,\n    rebase: bool,\n    auto_resolve: bool,\n    finalize: bool,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Load config\n    let config = Config::load()?;\n    let branch_prefix = \u0026config.defaults.branch_prefix;\n    let main_branch = merge::load_main_branch(\u0026config);\n\n    // Ensure main repo starts on main branch\n    let _ = chant::git::ensure_on_main_branch(\u0026config.defaults.main_branch);\n\n    // Load all specs first (needed for wizard and validation)\n    let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n\n    // Handle --list flag: show branch status\n    if list {\n        return show_branch_status(\u0026all_specs, branch_prefix, \u0026main_branch);\n    }\n\n    // Validate --all-completed is not used with explicit spec IDs\n    if all_completed \u0026\u0026 !ids.is_empty() {\n        anyhow::bail!(\n            \"Cannot use --all-completed with explicit spec IDs. Use either --all-completed or provide spec IDs.\"\n        );\n    }\n\n    // Handle --ready flag: merge all ready branches\n    if ready {\n        return merge_ready_branches(\n            \u0026all_specs,\n            branch_prefix,\n            \u0026main_branch,\n            dry_run,\n            delete_branch,\n            continue_on_error,\n            yes,\n            auto_resolve,\n            finalize,\n            \u0026config,\n            \u0026specs_dir,\n        );\n    }\n\n    // Handle -i/--interactive flag: interactive selection\n    if interactive {\n        return merge_interactive(\n            \u0026all_specs,\n            branch_prefix,\n            \u0026main_branch,\n            dry_run,\n            delete_branch,\n            continue_on_error,\n            yes,\n            rebase,\n            auto_resolve,\n            finalize,\n            \u0026config,\n            \u0026specs_dir,\n        );\n    }\n\n    // Handle --all-completed flag: find all completed specs with branches\n    if all_completed {\n        let completed_with_branches =\n            find_completed_specs_with_branches(\u0026all_specs, branch_prefix, \u0026main_branch)?;\n\n        if completed_with_branches.is_empty() {\n            println!(\"No completed specs with branches found.\");\n            return Ok(());\n        }\n\n        // Print which specs will be merged\n        println!(\n            \"{} Found {} completed spec(s) with branches:\",\n            \"â\".cyan(),\n            completed_with_branches.len()\n        );\n        for spec_id in \u0026completed_with_branches {\n            let spec = all_specs.iter().find(|s| \u0026s.id == spec_id);\n            let title = spec\n                .and_then(|s| s.title.as_deref())\n                .unwrap_or(\"(no title)\");\n            println!(\"  {} {} {}\", \"Â·\".cyan(), spec_id, title.dimmed());\n        }\n        println!();\n\n        // Proceed with merging using the found spec IDs\n        let final_ids = completed_with_branches;\n        let final_delete_branch = delete_branch;\n        let final_rebase = rebase;\n\n        let result = execute_merge(\n            \u0026final_ids,\n            false, // not --all mode\n            dry_run,\n            final_delete_branch,\n            continue_on_error,\n            yes,\n            final_rebase,\n            auto_resolve,\n            finalize,\n            \u0026all_specs,\n            \u0026config,\n            branch_prefix,\n            \u0026main_branch,\n            \u0026specs_dir,\n        );\n\n        // Ensure main repo ends on main branch\n        let _ = chant::git::ensure_on_main_branch(\u0026config.defaults.main_branch);\n\n        return result;\n    }\n\n    // Handle wizard mode when no arguments provided\n    let (final_ids, final_delete_branch, final_rebase) = if !all \u0026\u0026 ids.is_empty() {\n        run_merge_wizard(\n            \u0026all_specs,\n            branch_prefix,\n            \u0026main_branch,\n            delete_branch,\n            rebase,\n        )?\n    } else {\n        (ids.to_vec(), delete_branch, rebase)\n    };\n\n    // Validate arguments after wizard\n    if !all \u0026\u0026 final_ids.is_empty() {\n        anyhow::bail!(\n            \"Please specify one or more spec IDs, or use --all to merge all completed specs\"\n        );\n    }\n\n    // Execute merge using shared helper\n    let result = execute_merge(\n        \u0026final_ids,\n        all,\n        dry_run,\n        final_delete_branch,\n        continue_on_error,\n        yes,\n        final_rebase,\n        auto_resolve,\n        finalize,\n        \u0026all_specs,\n        \u0026config,\n        branch_prefix,\n        \u0026main_branch,\n        \u0026specs_dir,\n    );\n\n    // Ensure main repo ends on main branch\n    let _ = chant::git::ensure_on_main_branch(\u0026config.defaults.main_branch);\n\n    result\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":5}},{"line":494,"address":[],"length":0,"stats":{"Line":25}},{"line":497,"address":[],"length":0,"stats":{"Line":5}},{"line":498,"address":[],"length":0,"stats":{"Line":15}},{"line":499,"address":[],"length":0,"stats":{"Line":15}},{"line":503,"address":[],"length":0,"stats":{"Line":10}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":15}},{"line":510,"address":[],"length":0,"stats":{"Line":15}},{"line":511,"address":[],"length":0,"stats":{"Line":11}},{"line":512,"address":[],"length":0,"stats":{"Line":6}},{"line":513,"address":[],"length":0,"stats":{"Line":4}},{"line":517,"address":[],"length":0,"stats":{"Line":5}},{"line":518,"address":[],"length":0,"stats":{"Line":1}},{"line":520,"address":[],"length":0,"stats":{"Line":2}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":4}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":527,"address":[],"length":0,"stats":{"Line":1}},{"line":529,"address":[],"length":0,"stats":{"Line":2}},{"line":531,"address":[],"length":0,"stats":{"Line":1}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":538,"address":[],"length":0,"stats":{"Line":4}},{"line":540,"address":[],"length":0,"stats":{"Line":8}},{"line":541,"address":[],"length":0,"stats":{"Line":8}},{"line":542,"address":[],"length":0,"stats":{"Line":8}},{"line":543,"address":[],"length":0,"stats":{"Line":8}},{"line":545,"address":[],"length":0,"stats":{"Line":16}},{"line":546,"address":[],"length":0,"stats":{"Line":24}},{"line":547,"address":[],"length":0,"stats":{"Line":12}},{"line":548,"address":[],"length":0,"stats":{"Line":8}},{"line":549,"address":[],"length":0,"stats":{"Line":4}},{"line":550,"address":[],"length":0,"stats":{"Line":12}},{"line":551,"address":[],"length":0,"stats":{"Line":4}},{"line":552,"address":[],"length":0,"stats":{"Line":4}},{"line":553,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":4}},{"line":559,"address":[],"length":0,"stats":{"Line":4}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":566,"address":[],"length":0,"stats":{"Line":16}},{"line":567,"address":[],"length":0,"stats":{"Line":4}},{"line":568,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":4}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":16}},{"line":579,"address":[],"length":0,"stats":{"Line":8}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":12}},{"line":588,"address":[],"length":0,"stats":{"Line":12}},{"line":589,"address":[],"length":0,"stats":{"Line":12}},{"line":591,"address":[],"length":0,"stats":{"Line":4}},{"line":593,"address":[],"length":0,"stats":{"Line":8}},{"line":594,"address":[],"length":0,"stats":{"Line":8}},{"line":597,"address":[],"length":0,"stats":{"Line":12}},{"line":598,"address":[],"length":0,"stats":{"Line":8}},{"line":601,"address":[],"length":0,"stats":{"Line":4}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":16}},{"line":683,"address":[],"length":0,"stats":{"Line":8}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":8}},{"line":696,"address":[],"length":0,"stats":{"Line":8}},{"line":697,"address":[],"length":0,"stats":{"Line":8}},{"line":698,"address":[],"length":0,"stats":{"Line":4}},{"line":699,"address":[],"length":0,"stats":{"Line":4}},{"line":700,"address":[],"length":0,"stats":{"Line":4}},{"line":702,"address":[],"length":0,"stats":{"Line":8}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":4}},{"line":708,"address":[],"length":0,"stats":{"Line":8}},{"line":709,"address":[],"length":0,"stats":{"Line":8}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":12}},{"line":725,"address":[],"length":0,"stats":{"Line":12}},{"line":727,"address":[],"length":0,"stats":{"Line":12}},{"line":728,"address":[],"length":0,"stats":{"Line":8}},{"line":732,"address":[],"length":0,"stats":{"Line":8}},{"line":733,"address":[],"length":0,"stats":{"Line":12}},{"line":735,"address":[],"length":0,"stats":{"Line":5}},{"line":736,"address":[],"length":0,"stats":{"Line":3}},{"line":737,"address":[],"length":0,"stats":{"Line":2}},{"line":738,"address":[],"length":0,"stats":{"Line":1}},{"line":740,"address":[],"length":0,"stats":{"Line":2}},{"line":741,"address":[],"length":0,"stats":{"Line":1}},{"line":743,"address":[],"length":0,"stats":{"Line":1}},{"line":746,"address":[],"length":0,"stats":{"Line":3}},{"line":747,"address":[],"length":0,"stats":{"Line":2}},{"line":748,"address":[],"length":0,"stats":{"Line":2}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":2}},{"line":754,"address":[],"length":0,"stats":{"Line":1}},{"line":755,"address":[],"length":0,"stats":{"Line":2}},{"line":756,"address":[],"length":0,"stats":{"Line":2}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":12}},{"line":779,"address":[],"length":0,"stats":{"Line":12}},{"line":780,"address":[],"length":0,"stats":{"Line":20}},{"line":781,"address":[],"length":0,"stats":{"Line":6}},{"line":782,"address":[],"length":0,"stats":{"Line":2}},{"line":784,"address":[],"length":0,"stats":{"Line":4}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":4}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":4}},{"line":801,"address":[],"length":0,"stats":{"Line":16}},{"line":802,"address":[],"length":0,"stats":{"Line":12}},{"line":805,"address":[],"length":0,"stats":{"Line":4}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":4}},{"line":817,"address":[],"length":0,"stats":{"Line":3}},{"line":818,"address":[],"length":0,"stats":{"Line":2}},{"line":819,"address":[],"length":0,"stats":{"Line":1}},{"line":820,"address":[],"length":0,"stats":{"Line":1}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":6}},{"line":832,"address":[],"length":0,"stats":{"Line":4}},{"line":837,"address":[],"length":0,"stats":{"Line":5}},{"line":852,"address":[],"length":0,"stats":{"Line":10}},{"line":855,"address":[],"length":0,"stats":{"Line":10}},{"line":856,"address":[],"length":0,"stats":{"Line":10}},{"line":857,"address":[],"length":0,"stats":{"Line":15}},{"line":860,"address":[],"length":0,"stats":{"Line":5}},{"line":863,"address":[],"length":0,"stats":{"Line":15}},{"line":866,"address":[],"length":0,"stats":{"Line":5}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":5}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":5}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":5}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":5}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":30}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":15}},{"line":979,"address":[],"length":0,"stats":{"Line":15}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":5}},{"line":988,"address":[],"length":0,"stats":{"Line":5}},{"line":989,"address":[],"length":0,"stats":{"Line":5}},{"line":990,"address":[],"length":0,"stats":{"Line":5}},{"line":991,"address":[],"length":0,"stats":{"Line":5}},{"line":992,"address":[],"length":0,"stats":{"Line":5}},{"line":993,"address":[],"length":0,"stats":{"Line":5}},{"line":994,"address":[],"length":0,"stats":{"Line":5}},{"line":995,"address":[],"length":0,"stats":{"Line":5}},{"line":996,"address":[],"length":0,"stats":{"Line":5}},{"line":997,"address":[],"length":0,"stats":{"Line":5}},{"line":998,"address":[],"length":0,"stats":{"Line":5}},{"line":999,"address":[],"length":0,"stats":{"Line":5}},{"line":1000,"address":[],"length":0,"stats":{"Line":5}},{"line":1004,"address":[],"length":0,"stats":{"Line":5}},{"line":1006,"address":[],"length":0,"stats":{"Line":5}}],"covered":136,"coverable":488},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","mod.rs"],"content":"//! Lifecycle command handlers for chant CLI\n//!\n//! Handles lower-volume but logically related lifecycle operations:\n//! - Spec merging and archiving\n//! - Spec splitting into member specs\n//! - Diagnostic information for spec execution issues\n//! - Log file retrieval and display\n//! - Drift detection for documentation specs\n//! - Resume functionality for failed specs\n//!\n//! Note: Core spec operations (add, list, show) are in cmd::spec module\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse chant::config::Config;\nuse chant::diagnose;\nuse chant::git;\nuse chant::spec::{self, SpecStatus};\n\n// Submodules\npub mod archive;\npub mod drift;\npub mod merge;\npub mod resume;\npub mod split;\n\n// Re-export public command functions\npub use archive::cmd_archive;\npub use drift::cmd_drift;\npub use merge::cmd_merge;\npub use resume::cmd_resume;\npub use split::cmd_split;\n\n// ============================================================================\n// DIAGNOSTICS\n// ============================================================================\n\n/// Display detailed diagnostic information for a spec\npub fn cmd_diagnose(id: \u0026str) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve spec ID\n    let spec = spec::resolve_spec(\u0026specs_dir, id)?;\n\n    // Run diagnostics\n    let report = diagnose::diagnose_spec(\u0026spec.id)?;\n\n    // Display report\n    println!(\"\\n{}\", format!(\"Spec: {}\", report.spec_id).cyan().bold());\n    let status_str = match report.status {\n        SpecStatus::Pending =\u003e \"pending\".white(),\n        SpecStatus::InProgress =\u003e \"in_progress\".yellow(),\n        SpecStatus::Paused =\u003e \"paused\".cyan(),\n        SpecStatus::Completed =\u003e \"completed\".green(),\n        SpecStatus::Failed =\u003e \"failed\".red(),\n        SpecStatus::NeedsAttention =\u003e \"needs_attention\".yellow(),\n        SpecStatus::Ready =\u003e \"ready\".cyan(),\n        SpecStatus::Blocked =\u003e \"blocked\".red(),\n        SpecStatus::Cancelled =\u003e \"cancelled\".dimmed(),\n    };\n    println!(\"Status: {}\", status_str);\n    println!(\"Location: {}\", report.location.bright_black());\n\n    println!(\"\\n{}:\", \"Checks\".bold());\n    for check in \u0026report.checks {\n        let icon = if check.passed {\n            \"â\".green()\n        } else {\n            \"â\".red()\n        };\n        print!(\"  {} {}\", icon, check.name);\n        if let Some(details) = \u0026check.details {\n            println!(\" ({})\", details.bright_black());\n        } else {\n            println!();\n        }\n    }\n\n    println!(\"\\n{}:\", \"Diagnosis\".bold());\n    println!(\"  {}\", report.diagnosis);\n\n    if let Some(suggestion) = \u0026report.suggestion {\n        println!(\"\\n{}:\", \"Suggestion\".bold());\n        println!(\"  {}\", suggestion);\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// LOGGING\n// ============================================================================\n\n/// Show log for a spec (uses default .chant directory)\npub fn cmd_log(id: \u0026str, lines: usize, follow: bool) -\u003e Result\u003c()\u003e {\n    cmd_log_at(\u0026PathBuf::from(\".chant\"), id, lines, follow)\n}\n\n/// Show log for a spec with custom base path (useful for testing)\npub fn cmd_log_at(base_path: \u0026std::path::Path, id: \u0026str, lines: usize, follow: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = base_path.join(\"specs\");\n    let logs_dir = base_path.join(\"logs\");\n\n    // Note: For custom base paths, we check specs_dir directly instead of using ensure_initialized()\n    if !specs_dir.exists() {\n        anyhow::bail!(\"Chant not initialized. Run `chant init` first.\");\n    }\n\n    // Resolve spec ID to get the full ID\n    let spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let log_path = logs_dir.join(format!(\"{}.log\", spec.id));\n\n    if !log_path.exists() {\n        println!(\n            \"{} No log file found for spec '{}'.\",\n            \"â \".yellow(),\n            spec.id.cyan()\n        );\n        println!(\"\\nLogs are created when a spec is executed with `chant work`.\");\n        println!(\"Log path: {}\", log_path.display());\n        return Ok(());\n    }\n\n    // Use tail command to show/follow the log\n    let mut args = vec![\"-n\".to_string(), lines.to_string()];\n\n    if follow {\n        args.push(\"-f\".to_string());\n    }\n\n    args.push(log_path.to_string_lossy().to_string());\n\n    let status = std::process::Command::new(\"tail\")\n        .args(\u0026args)\n        .status()\n        .context(\"Failed to run tail command\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"tail command exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// LIFECYCLE OPERATIONS (for watch mode)\n// ============================================================================\n\n/// Handle a completed spec: finalize it, then merge if on a branch.\n///\n/// This orchestrates the completion workflow:\n/// 1. Run `chant finalize \u003cspec_id\u003e` to validate and mark complete\n/// 2. If spec is on a `chant/\u003cspec-id\u003e` branch, run `chant merge \u003cspec_id\u003e`\n/// 3. If spec is on main branch, skip merge step\n///\n/// # Arguments\n/// * `spec_id` - The spec ID to complete\n///\n/// # Returns\n/// * `Ok(())` on success\n/// * `Err(_)` if finalize or merge subprocess fails\n///\n/// # Edge Cases\n/// * Finalize fails: Return error, do not proceed to merge\n/// * Merge fails: Return error with conflict details\n/// * Spec on main branch: Skip merge step\npub fn handle_completed(spec_id: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    let _specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Step 1: Finalize the spec\n    println!(\"{} Finalizing spec {}\", \"â\".cyan(), spec_id.cyan());\n\n    let status = Command::new(std::env::current_exe()?)\n        .args([\"finalize\", spec_id])\n        .status()\n        .context(\"Failed to run chant finalize\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"Finalize failed for spec {}\", spec_id);\n    }\n\n    println!(\"{} Finalized spec {}\", \"â\".green(), spec_id);\n\n    // Step 2: Check if spec is on a branch\n    let branch_name = format!(\"chant/{}\", spec_id);\n    let on_branch = is_spec_on_branch(spec_id, \u0026branch_name)?;\n\n    if !on_branch {\n        println!(\n            \"{} Spec {} is on main branch, skipping merge\",\n            \"â\".cyan(),\n            spec_id\n        );\n        return Ok(());\n    }\n\n    // Step 3: Check if branch exists and hasn't been merged already\n    let config = Config::load()?;\n    let main_branch = chant::merge::load_main_branch(\u0026config);\n\n    if git::branch_exists(\u0026branch_name)? {\n        // Check if the branch has already been merged\n        if git::is_branch_merged(\u0026branch_name, \u0026main_branch)? {\n            println!(\n                \"{} Branch {} already merged to {}, auto-deleting\",\n                \"â\".cyan(),\n                branch_name.cyan(),\n                main_branch\n            );\n\n            // Auto-delete the merged branch\n            if let Err(e) = git::delete_branch(\u0026branch_name, false) {\n                println!(\n                    \"{} Warning: Could not delete branch {}: {}\",\n                    \"â \".yellow(),\n                    branch_name,\n                    e\n                );\n            } else {\n                println!(\"{} Deleted merged branch {}\", \"â\".green(), branch_name);\n            }\n\n            return Ok(());\n        }\n    } else {\n        println!(\n            \"{} Branch {} does not exist, skipping merge\",\n            \"â\".cyan(),\n            branch_name\n        );\n        return Ok(());\n    }\n\n    // Step 4: Merge the branch\n    println!(\"{} Merging branch {}\", \"â\".cyan(), branch_name.cyan());\n\n    let status = Command::new(std::env::current_exe()?)\n        .args([\"merge\", spec_id])\n        .status()\n        .context(\"Failed to run chant merge\")?;\n\n    if !status.success() {\n        anyhow::bail!(\n            \"Merge failed for spec {} (branch: {})\",\n            spec_id,\n            branch_name\n        );\n    }\n\n    println!(\"{} Merged spec {}\", \"â\".green(), spec_id);\n\n    Ok(())\n}\n\n/// Handle a failed spec: decide whether to retry or mark permanent failure.\n///\n/// This orchestrates the failure handling workflow:\n/// 1. Load spec and retry state\n/// 2. Read error log\n/// 3. Use retry logic to decide: retry or permanent failure\n/// 4. If retry: schedule resume with exponential backoff\n/// 5. If permanent: log and mark for manual intervention\n///\n/// # Arguments\n/// * `spec_id` - The spec ID that failed\n/// * `config` - Failure configuration with retry settings\n///\n/// # Returns\n/// * `Ok(())` on success (retry scheduled or marked failed)\n/// * `Err(_)` on subprocess failure or configuration error\n///\n/// # Edge Cases\n/// * Resume fails: Treat as permanent failure\n/// * Empty error log: Permanent failure\n/// * Max retries exceeded: Permanent failure\npub fn handle_failed(spec_id: \u0026str, config: \u0026chant::config::FailureConfig) -\u003e Result\u003c()\u003e {\n    use chant::retry::{decide_retry, RetryDecision};\n\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Load the spec\n    let mut spec = spec::resolve_spec(\u0026specs_dir, spec_id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n\n    // Get retry state (or create new one)\n    let mut retry_state = spec.frontmatter.retry_state.clone().unwrap_or_default();\n\n    // Read error log\n    let log_path = specs_dir\n        .parent()\n        .unwrap_or(\u0026specs_dir)\n        .join(\"logs\")\n        .join(format!(\"{}.log\", spec_id));\n\n    let error_log = if log_path.exists() {\n        std::fs::read_to_string(\u0026log_path).unwrap_or_default()\n    } else {\n        String::new()\n    };\n\n    // Decide whether to retry\n    let decision = decide_retry(\u0026retry_state, \u0026error_log, config);\n\n    match decision {\n        RetryDecision::Retry(delay) =\u003e {\n            // Schedule retry with exponential backoff\n            let delay_ms = delay.as_millis() as u64;\n            retry_state.record_attempt(delay_ms);\n\n            let next_retry_time = retry_state.next_retry_time;\n\n            println!(\n                \"{} Scheduling retry for spec {} (attempt {}/{}, delay: {}ms)\",\n                \"â\".cyan(),\n                spec_id,\n                retry_state.attempts,\n                config.max_retries,\n                delay_ms\n            );\n\n            // Update spec with new retry state\n            spec.frontmatter.retry_state = Some(retry_state);\n            spec.save(\u0026spec_path)?;\n\n            // Note: The watch loop will check next_retry_time and call resume when ready\n            println!(\n                \"{} Retry will be attempted at timestamp {}\",\n                \"â\".cyan(),\n                next_retry_time\n            );\n\n            Ok(())\n        }\n        RetryDecision::PermanentFailure(reason) =\u003e {\n            // Mark as permanent failure\n            println!(\n                \"{} Permanent failure for spec {}: {}\",\n                \"â\".red(),\n                spec_id,\n                reason\n            );\n\n            // Update spec status to failed (it should already be failed, but ensure it)\n            spec.frontmatter.status = chant::spec::SpecStatus::Failed;\n            spec.save(\u0026spec_path)?;\n\n            println!(\n                \"{} Spec {} marked for manual intervention\",\n                \"â\".cyan(),\n                spec_id\n            );\n\n            Ok(())\n        }\n    }\n}\n\n/// Check if a spec's worktree is on the specified branch.\n///\n/// # Arguments\n/// * `spec_id` - The spec ID\n/// * `branch_name` - The branch name to check (e.g., \"chant/spec-id\")\n///\n/// # Returns\n/// * `Ok(true)` if worktree exists and is on the specified branch\n/// * `Ok(false)` if worktree doesn't exist or is on a different branch\n/// * `Err(_)` if git operations fail\nfn is_spec_on_branch(spec_id: \u0026str, branch_name: \u0026str) -\u003e Result\u003cbool\u003e {\n    use std::process::Command;\n\n    // Get worktree path\n    let worktree_path = chant::worktree::worktree_path_for_spec(spec_id);\n\n    // Check if worktree exists\n    if !worktree_path.exists() {\n        return Ok(false);\n    }\n\n    // Get current branch in worktree\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", \"--abbrev-ref\", \"HEAD\"])\n        .current_dir(\u0026worktree_path)\n        .output()\n        .context(\"Failed to get current branch in worktree\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let current_branch = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    Ok(current_branch == branch_name)\n}\n\n/// Finalize a completed spec by verifying all criteria are checked\npub fn cmd_finalize(id: \u0026str, specs_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    use crate::cmd::finalize;\n    use chant::spec;\n    use chant::validation;\n    use chant::worktree;\n\n    // Resolve the spec\n    let spec = spec::resolve_spec(specs_dir, id)?;\n    let spec_id = spec.id.clone();\n\n    // Check if spec is in a valid state for finalization\n    // Allow failed too - agents often leave specs in failed state when they actually completed the work\n    match spec.frontmatter.status {\n        SpecStatus::Completed | SpecStatus::InProgress | SpecStatus::Failed =\u003e {\n            // These are valid for finalization\n        }\n        _ =\u003e {\n            anyhow::bail!(\n                \"Spec '{}' must be in_progress, completed, or failed to finalize. Current status: {:?}\",\n                spec_id,\n                spec.frontmatter.status\n            );\n        }\n    }\n\n    // Check for unchecked acceptance criteria\n    let unchecked = spec.count_unchecked_checkboxes();\n    if unchecked \u003e 0 {\n        anyhow::bail!(\n            \"Spec '{}' has {} unchecked acceptance criteria. All criteria must be checked before finalization.\",\n            spec_id,\n            unchecked\n        );\n    }\n\n    // Load the config for model information and validation settings\n    let config = Config::load()?;\n\n    // Validate output against schema if output_schema is defined\n    if let Some(ref schema_path_str) = spec.frontmatter.output_schema {\n        let schema_path = std::path::Path::new(schema_path_str);\n        if schema_path.exists() {\n            // Read agent output from log file\n            let log_path = specs_dir\n                .parent()\n                .unwrap_or(specs_dir)\n                .join(\"logs\")\n                .join(format!(\"{}.log\", spec_id));\n\n            if log_path.exists() {\n                let agent_output = std::fs::read_to_string(\u0026log_path)\n                    .with_context(|| format!(\"Failed to read agent log: {}\", log_path.display()))?;\n\n                match validation::validate_agent_output(\u0026spec_id, schema_path, \u0026agent_output) {\n                    Ok(result) =\u003e {\n                        if result.is_valid {\n                            println!(\n                                \"{} Output validation passed (schema: {})\",\n                                \"â\".green(),\n                                schema_path_str\n                            );\n                        } else {\n                            println!(\n                                \"{} Output validation failed (schema: {})\",\n                                \"â\".red(),\n                                schema_path_str\n                            );\n                            for error in \u0026result.errors {\n                                println!(\"  - {}\", error);\n                            }\n                            println!(\"  â Review .chant/logs/{}.log for details\", spec_id);\n\n                            // Check if strict validation is enabled\n                            if config.validation.strict_output_validation {\n                                anyhow::bail!(\n                                    \"Cannot finalize: output validation failed ({} error(s), strict mode enabled)\",\n                                    result.errors.len()\n                                );\n                            } else {\n                                println!(\n                                    \"  {} Proceeding with finalization (strict_output_validation=false)\",\n                                    \"â\".cyan()\n                                );\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"{} Failed to validate output: {}\", \"â \".yellow(), e);\n                        if config.validation.strict_output_validation {\n                            anyhow::bail!(\n                                \"Cannot finalize: output validation error (strict mode enabled)\"\n                            );\n                        } else {\n                            println!(\n                                \"  {} Proceeding with finalization (strict_output_validation=false)\",\n                                \"â\".cyan()\n                            );\n                        }\n                    }\n                }\n            } else {\n                println!(\n                    \"{} No log file found at {}, skipping output validation\",\n                    \"â \".yellow(),\n                    log_path.display()\n                );\n            }\n        } else {\n            println!(\n                \"{} Output schema file not found: {}, skipping validation\",\n                \"â \".yellow(),\n                schema_path.display()\n            );\n        }\n    }\n\n    // Check if this spec has an active worktree - if so, finalize there\n    if let Some(worktree_path) = worktree::get_active_worktree(\u0026spec_id) {\n        println!(\n            \"{} Finalizing spec {} in worktree\",\n            \"â\".cyan(),\n            spec_id.cyan()\n        );\n\n        // Get the spec path in the worktree\n        let worktree_spec_path = worktree_path\n            .join(\".chant/specs\")\n            .join(format!(\"{}.md\", spec_id));\n\n        // Load the spec from the worktree\n        let mut worktree_spec =\n            spec::Spec::load(\u0026worktree_spec_path).context(\"Failed to load spec from worktree\")?;\n\n        // Get all specs from worktree for validation\n        let worktree_specs_dir = worktree_path.join(\".chant/specs\");\n        let all_specs = spec::load_all_specs(\u0026worktree_specs_dir).unwrap_or_default();\n\n        // Finalize in worktree\n        finalize::finalize_spec(\n            \u0026mut worktree_spec,\n            \u0026worktree_spec_path,\n            \u0026config,\n            \u0026all_specs,\n            false,\n            None,\n        )?;\n\n        // Commit the finalization changes in the worktree\n        let commit_message = format!(\"chant({}): finalize spec\", spec_id);\n        worktree::commit_in_worktree(\u0026worktree_path, \u0026commit_message)?;\n\n        println!(\n            \"{} Spec {} finalized in worktree and committed\",\n            \"â\".green(),\n            spec_id.green()\n        );\n        if let Some(model) = \u0026worktree_spec.frontmatter.model {\n            println!(\"  {} Model: {}\", \"â¢\".cyan(), model);\n        }\n        if let Some(completed_at) = \u0026worktree_spec.frontmatter.completed_at {\n            println!(\"  {} Completed at: {}\", \"â¢\".cyan(), completed_at);\n        }\n        if let Some(commits) = \u0026worktree_spec.frontmatter.commits {\n            println!(\n                \"  {} {} commit{}\",\n                \"â¢\".cyan(),\n                commits.len(),\n                if commits.len() == 1 { \"\" } else { \"s\" }\n            );\n        }\n        println!(\"  {} Worktree: {}\", \"â¢\".cyan(), worktree_path.display());\n    } else {\n        // No active worktree - finalize on current branch (main)\n        let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n\n        // Perform finalization\n        let mut mut_spec = spec.clone();\n        finalize::re_finalize_spec(\u0026mut mut_spec, \u0026spec_path, \u0026config, false)?;\n\n        println!(\"{} Spec {} finalized\", \"â\".green(), spec_id.green());\n        if let Some(model) = \u0026mut_spec.frontmatter.model {\n            println!(\"  {} Model: {}\", \"â¢\".cyan(), model);\n        }\n        if let Some(completed_at) = \u0026mut_spec.frontmatter.completed_at {\n            println!(\"  {} Completed at: {}\", \"â¢\".cyan(), completed_at);\n        }\n        if let Some(commits) = \u0026mut_spec.frontmatter.commits {\n            println!(\n                \"  {} {} commit{}\",\n                \"â¢\".cyan(),\n                commits.len(),\n                if commits.len() == 1 { \"\" } else { \"s\" }\n            );\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":3}},{"line":406,"address":[],"length":0,"stats":{"Line":12}},{"line":407,"address":[],"length":0,"stats":{"Line":9}},{"line":411,"address":[],"length":0,"stats":{"Line":3}},{"line":412,"address":[],"length":0,"stats":{"Line":3}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":9}},{"line":426,"address":[],"length":0,"stats":{"Line":3}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":6}},{"line":438,"address":[],"length":0,"stats":{"Line":5}},{"line":439,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":4}},{"line":442,"address":[],"length":0,"stats":{"Line":8}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":448,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":6}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":452,"address":[],"length":0,"stats":{"Line":6}},{"line":453,"address":[],"length":0,"stats":{"Line":2}},{"line":454,"address":[],"length":0,"stats":{"Line":3}},{"line":455,"address":[],"length":0,"stats":{"Line":2}},{"line":456,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":458,"address":[],"length":0,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":1}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":466,"address":[],"length":0,"stats":{"Line":3}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":473,"address":[],"length":0,"stats":{"Line":1}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":8}},{"line":575,"address":[],"length":0,"stats":{"Line":6}},{"line":576,"address":[],"length":0,"stats":{"Line":8}},{"line":578,"address":[],"length":0,"stats":{"Line":8}},{"line":579,"address":[],"length":0,"stats":{"Line":2}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":6}},{"line":583,"address":[],"length":0,"stats":{"Line":4}},{"line":585,"address":[],"length":0,"stats":{"Line":4}},{"line":586,"address":[],"length":0,"stats":{"Line":2}},{"line":588,"address":[],"length":0,"stats":{"Line":4}},{"line":589,"address":[],"length":0,"stats":{"Line":4}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":595,"address":[],"length":0,"stats":{"Line":2}}],"covered":46,"coverable":235},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","resume.rs"],"content":"//! Resume functionality - resets failed specs to pending for retry\n\nuse anyhow::Result;\nuse colored::Colorize;\n\nuse chant::spec::{self, SpecStatus};\n\nuse crate::cmd;\n\n/// Resume a failed spec by resetting it to pending status\npub fn cmd_resume(\n    id: \u0026str,\n    work: bool,\n    prompt: Option\u003c\u0026str\u003e,\n    _branch: Option\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve the spec\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n    let spec_id = spec.id.clone();\n\n    // Check if spec is in failed or in_progress state\n    if spec.frontmatter.status != SpecStatus::Failed\n        \u0026\u0026 spec.frontmatter.status != SpecStatus::InProgress\n    {\n        anyhow::bail!(\n            \"Spec {} is not in failed or in_progress state (current status: {:?}). \\\n             Only failed or in_progress specs can be resumed.\",\n            spec_id,\n            spec.frontmatter.status\n        );\n    }\n\n    println!(\"{} Resuming spec {}\", \"â\".cyan(), spec_id.cyan());\n\n    // Reset to pending\n    spec.frontmatter.status = SpecStatus::Pending;\n    spec.save(\u0026spec_path)?;\n\n    println!(\"{} Spec {} reset to pending\", \"â\".green(), spec_id);\n\n    // If --work flag specified, execute the spec\n    if work {\n        println!(\"{} Re-executing spec...\", \"â\".cyan());\n\n        // Use cmd_work to execute the spec\n        cmd::work::cmd_work(\n            std::slice::from_ref(\u0026spec_id),\n            prompt,\n            false, // no_branch (use worktree by default)\n            false, // skip_deps\n            false, // skip_criteria\n            false, // parallel\n            \u0026[],   // label\n            false, // finalize\n            false, // allow_no_commits\n            None,  // max_parallel\n            false, // no_cleanup\n            false, // cleanup\n            false, // skip_approval\n            false, // chain\n            0,     // chain_max\n            false, // no_merge\n            false, // no_rebase\n        )?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","lifecycle","split.rs"],"content":"//! Spec splitting functionality - breaks large specs into smaller member specs\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse chant::config::Config;\nuse chant::paths::PROMPTS_DIR;\nuse chant::prompt;\nuse chant::score::isolation::calculate_isolation;\nuse chant::score::splittability::calculate_splittability;\nuse chant::score::traffic_light::{determine_status, generate_suggestions};\nuse chant::scoring::{SpecScore, SplittabilityGrade};\nuse chant::spec::{self, Spec, SpecFrontmatter, SpecStatus};\n\nuse crate::cmd;\n\n/// Show complexity analysis for a spec before splitting\nfn show_complexity_analysis(spec: \u0026Spec) {\n    // Thresholds for complexity\n    const CRITERIA_THRESHOLD: usize = 5;\n    const FILES_THRESHOLD: usize = 5;\n    const WORDS_THRESHOLD: usize = 500;\n\n    // Complexity thresholds for \"simple\" specs (haiku-friendly)\n    const HAIKU_CRITERIA_TARGET: usize = 5;\n    const HAIKU_FILES_TARGET: usize = 5;\n    const HAIKU_WORDS_TARGET: usize = 200;\n\n    let criteria_count = spec.count_total_checkboxes();\n    let files_count = spec\n        .frontmatter\n        .target_files\n        .as_ref()\n        .map(|f| f.len())\n        .unwrap_or(0);\n    let word_count = spec.body.split_whitespace().count();\n\n    // Check if complex (exceeds thresholds)\n    let is_too_complex = criteria_count \u003e CRITERIA_THRESHOLD\n        || files_count \u003e FILES_THRESHOLD\n        || word_count \u003e WORDS_THRESHOLD;\n\n    if is_too_complex {\n        println!(\"\\n{} Analyzing spec complexity...\", \"â\".cyan());\n        println!(\n            \"  Current: {} criteria, {} files, {} words (too complex for haiku)\\n\",\n            criteria_count, files_count, word_count\n        );\n        println!(\"{} Splitting into haiku-friendly specs...\", \"â\".cyan());\n        println!(\n            \"  Target per member: â¤{} criteria, â¤{} files, â¤{} words\\n\",\n            HAIKU_CRITERIA_TARGET, HAIKU_FILES_TARGET, HAIKU_WORDS_TARGET\n        );\n    }\n}\n\n/// Member spec extracted from split analysis\n#[derive(Debug, Clone)]\npub(crate) struct MemberSpec {\n    pub title: String,\n    pub description: String,\n    pub target_files: Option\u003cVec\u003cString\u003e\u003e,\n    pub dependencies: Vec\u003cusize\u003e, // Member numbers this depends on (1-indexed)\n}\n\n/// Result of dependency analysis from split prompt\n#[derive(Debug, Clone)]\npub(crate) struct DependencyAnalysis {\n    /// The dependency graph as text (for display)\n    pub graph_text: String,\n    /// Dependency edges: (from_member_num, to_member_num)\n    #[allow(dead_code)]\n    pub edges: Vec\u003c(usize, usize)\u003e,\n}\n\n/// Split a pending spec into member specs\npub fn cmd_split(\n    id: \u0026str,\n    override_model: Option\u003c\u0026str\u003e,\n    force: bool,\n    recursive: bool,\n    max_depth: usize,\n) -\u003e Result\u003c()\u003e {\n    cmd_split_impl(id, override_model, force, recursive, max_depth, 0)\n}\n\n/// Internal implementation of split with depth tracking\nfn cmd_split_impl(\n    id: \u0026str,\n    override_model: Option\u003c\u0026str\u003e,\n    force: bool,\n    recursive: bool,\n    max_depth: usize,\n    current_depth: usize,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let prompts_dir = PathBuf::from(PROMPTS_DIR);\n    let config = Config::load()?;\n\n    // Resolve the spec to split\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Check spec status before splitting\n    if !force {\n        match spec.frontmatter.status {\n            SpecStatus::InProgress =\u003e {\n                anyhow::bail!(\"Cannot split spec that is in progress\");\n            }\n            SpecStatus::Paused =\u003e {\n                anyhow::bail!(\"Cannot split paused spec\");\n            }\n            SpecStatus::Completed =\u003e {\n                anyhow::bail!(\"Cannot split completed spec\");\n            }\n            SpecStatus::Failed =\u003e {\n                anyhow::bail!(\"Cannot split failed spec\");\n            }\n            SpecStatus::NeedsAttention =\u003e {\n                anyhow::bail!(\"Cannot split spec that needs attention\");\n            }\n            SpecStatus::Blocked =\u003e {\n                anyhow::bail!(\"Cannot split blocked spec\");\n            }\n            SpecStatus::Cancelled =\u003e {\n                anyhow::bail!(\"Cannot split cancelled spec\");\n            }\n            SpecStatus::Pending | SpecStatus::Ready =\u003e {\n                // Allowed to split\n            }\n        }\n    }\n\n    // Check if already a group\n    if spec.frontmatter.r#type == \"group\" {\n        anyhow::bail!(\"Spec is already split\");\n    }\n\n    // Calculate splittability grade before splitting\n    let splittability_grade = calculate_splittability(\u0026spec);\n\n    // Warn if Grade C or D and allow user to proceed with confirmation\n    if matches!(\n        splittability_grade,\n        SplittabilityGrade::C | SplittabilityGrade::D\n    ) {\n        let warning_level = if matches!(splittability_grade, SplittabilityGrade::D) {\n            \"ð´ STRONG WARNING\"\n        } else {\n            \"ð¡ WARNING\"\n        };\n\n        eprintln!(\n            \"\\n{}: Splittability Grade {}\",\n            warning_level, splittability_grade\n        );\n\n        let suggestion = match splittability_grade {\n            SplittabilityGrade::D =\u003e \"This spec has tight coupling or circular dependencies. Splitting may not be effective.\",\n            SplittabilityGrade::C =\u003e \"This spec may not split well. Consider if splitting is appropriate.\",\n            _ =\u003e unreachable!(),\n        };\n\n        eprintln!(\"  {}\", suggestion);\n\n        // Prompt user to confirm they want to proceed\n        if atty::is(atty::Stream::Stdin) {\n            let should_proceed = dialoguer::Confirm::new()\n                .with_prompt(\"Do you want to proceed with splitting anyway?\")\n                .default(false)\n                .interact()?;\n\n            if !should_proceed {\n                println!(\"\\nSplit cancelled.\");\n                return Ok(());\n            }\n        } else {\n            // Non-interactive mode: bail on Grade D, proceed on Grade C\n            if matches!(splittability_grade, SplittabilityGrade::D) {\n                anyhow::bail!(\"Cannot split: Splittability Grade D (tightly coupled). Use --force to override.\");\n            }\n        }\n    }\n\n    // Show complexity analysis\n    show_complexity_analysis(\u0026spec);\n\n    println!(\"{} Analyzing spec {} for splitting...\", \"â\".cyan(), spec.id);\n\n    // Load prompt from file\n    let split_prompt_path = prompts_dir.join(\"split.md\");\n    if !split_prompt_path.exists() {\n        anyhow::bail!(\"Split prompt not found: split.md\");\n    }\n\n    // Assemble prompt for split analysis\n    let split_prompt = prompt::assemble(\u0026spec, \u0026split_prompt_path, \u0026config)?;\n\n    // Get the model to use for split\n    let model = get_model_for_split(\n        override_model,\n        config.defaults.model.as_deref(),\n        config.defaults.split_model.as_deref(),\n    );\n\n    // Invoke agent to propose split\n    let agent_output = cmd::agent::invoke_agent_with_model(\n        \u0026split_prompt,\n        \u0026spec,\n        \"split\",\n        \u0026config,\n        Some(\u0026model),\n        None,\n    )?;\n\n    // Parse member specs and dependency analysis from agent output\n    let (dep_analysis, members) = parse_split_output(\u0026agent_output)?;\n\n    if members.is_empty() {\n        anyhow::bail!(\"Agent did not propose any member specs. Check the agent output in the log.\");\n    }\n\n    // Display dependency analysis if present\n    if let Some(ref analysis) = dep_analysis {\n        println!(\"\\n{} Dependency Analysis:\", \"â\".cyan());\n        println!(\"{}\", analysis.graph_text);\n        println!();\n    }\n\n    println!(\n        \"{} Creating {} member specs for spec {}\",\n        \"â\".cyan(),\n        members.len(),\n        spec.id\n    );\n\n    // Validate members meet complexity thresholds and collect quality metrics\n    const HAIKU_CRITERIA_TARGET: usize = 5;\n    const HAIKU_FILES_TARGET: usize = 5;\n    const HAIKU_WORDS_TARGET: usize = 200;\n\n    let mut over_complex_count = 0;\n    let mut quality_issues = Vec::new();\n\n    for (index, member) in members.iter().enumerate() {\n        let member_number = index + 1;\n        let criteria_count = member.description.matches(\"- [ ]\").count()\n            + member.description.matches(\"- [x]\").count()\n            + member.description.matches(\"- [X]\").count();\n        let files_count = member.target_files.as_ref().map(|f| f.len()).unwrap_or(0);\n        let word_count = member.description.split_whitespace().count();\n\n        // Log warnings if member exceeds targets\n        let is_over_complex = criteria_count \u003e HAIKU_CRITERIA_TARGET\n            || files_count \u003e HAIKU_FILES_TARGET\n            || word_count \u003e HAIKU_WORDS_TARGET;\n\n        if is_over_complex {\n            over_complex_count += 1;\n            eprintln!(\n                \"  {} Member {}: {} criteria, {} files, {} words (exceeds targets)\",\n                \"â \".yellow(),\n                member_number,\n                criteria_count,\n                files_count,\n                word_count\n            );\n        }\n    }\n\n    // Warn if ALL members exceed complexity thresholds\n    if over_complex_count == members.len() \u0026\u0026 members.len() \u003e 1 {\n        eprintln!(\n            \"\\n  {} WARNING: All {} members exceed complexity thresholds!\",\n            \"â \".yellow(),\n            members.len()\n        );\n        eprintln!(\"  Consider re-splitting with --recursive flag (future feature)\");\n        quality_issues.push(\"All members over-complex\".to_string());\n    }\n\n    // Create member spec files with DAG-based dependencies\n    let driver_id = spec.id.clone();\n    for (index, member) in members.iter().enumerate() {\n        let member_number = index + 1;\n        let member_id = format!(\"{}.{}\", driver_id, member_number);\n        let member_filename = format!(\"{}.md\", member_id);\n        let member_path = specs_dir.join(\u0026member_filename);\n\n        // Use dependencies from member spec (from Dependencies: field or extracted from DAG)\n        // Always set depends_on (even if empty) to indicate explicit DAG ordering\n        // This prevents fallback to sequential member ordering in is_ready()\n        let depends_on = Some(\n            member\n                .dependencies\n                .iter()\n                .map(|dep_num| format!(\"{}.{}\", driver_id, dep_num))\n                .collect(),\n        );\n\n        let member_frontmatter = SpecFrontmatter {\n            r#type: \"code\".to_string(),\n            status: SpecStatus::Pending,\n            depends_on,\n            target_files: member.target_files.clone(),\n            ..Default::default()\n        };\n\n        // Build body with title and description\n        // If description already contains ### Acceptance Criteria, don't append generic ones\n        let body = if member.description.contains(\"### Acceptance Criteria\") {\n            format!(\"# {}\\n\\n{}\", member.title, member.description)\n        } else {\n            // No acceptance criteria found, append generic section\n            format!(\n                \"# {}\\n\\n{}\\n\\n## Acceptance Criteria\\n\\n- [ ] Implement as described\\n- [ ] All tests pass\",\n                member.title,\n                member.description\n            )\n        };\n\n        let member_spec = Spec {\n            id: member_id.clone(),\n            frontmatter: member_frontmatter,\n            title: Some(member.title.clone()),\n            body,\n        };\n\n        member_spec.save(\u0026member_path)?;\n        println!(\"  {} {}\", \"â\".green(), member_id);\n    }\n\n    // Update driver spec to type: group with depends_on all members\n    spec.frontmatter.r#type = \"group\".to_string();\n    let member_ids: Vec\u003cString\u003e = (1..=members.len())\n        .map(|i| format!(\"{}.{}\", driver_id, i))\n        .collect();\n    spec.frontmatter.depends_on = Some(member_ids.clone());\n    spec.save(\u0026spec_path)?;\n\n    println!(\n        \"\\n{} Split complete! Driver spec {} is now type: group\",\n        \"â\".green(),\n        spec.id\n    );\n    println!(\"Members:\");\n    for i in 1..=members.len() {\n        println!(\"  â¢ {}.{}\", spec.id, i);\n    }\n\n    // Detect infrastructure ordering issues\n    detect_infrastructure_issues(\u0026members, \u0026mut quality_issues);\n\n    // Auto-lint member specs to validate they pass complexity checks\n    println!(\"\\n{} Running lint on member specs...\", \"â\".cyan());\n\n    let member_ids: Vec\u003cString\u003e = (1..=members.len())\n        .map(|i| format!(\"{}.{}\", spec.id, i))\n        .collect();\n\n    let lint_result = cmd::spec::lint_specific_specs(\u0026specs_dir, \u0026member_ids)?;\n\n    let total_members = member_ids.len();\n    let summary = if lint_result.failed \u003e 0 {\n        format!(\n            \"All {} members checked. {} passed, {} warned, {} failed.\",\n            total_members, lint_result.passed, lint_result.warned, lint_result.failed\n        )\n    } else if lint_result.warned \u003e 0 {\n        format!(\n            \"All {} members checked. {} passed, {} warned.\",\n            total_members, lint_result.passed, lint_result.warned\n        )\n    } else {\n        format!(\"All {} members checked. All passed â\", total_members)\n    };\n\n    println!(\"{} {}\", \"â\".cyan(), summary);\n\n    // Calculate isolation score for the resulting group\n    // Reload all specs to include the newly created member specs\n    let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n    let driver_spec = all_specs\n        .iter()\n        .find(|s| s.id == spec.id)\n        .context(\"Driver spec not found after split\")?;\n\n    if let Some(isolation_grade) = calculate_isolation(driver_spec, \u0026all_specs) {\n        // Calculate isolation percentage for display\n        let member_specs: Vec\u003c\u0026Spec\u003e = all_specs\n            .iter()\n            .filter(|s| {\n                s.id.starts_with(\u0026format!(\"{}.\", spec.id)) \u0026\u0026 s.id.matches('.').count() == 1\n            })\n            .collect();\n\n        let isolation_percentage = calculate_isolation_percentage(\u0026member_specs);\n        let shared_file_count = count_shared_files(\u0026member_specs);\n        let total_files = count_total_unique_files(\u0026member_specs);\n\n        // Determine traffic light and suggestions\n        let mock_score = SpecScore {\n            isolation: Some(isolation_grade),\n            ..Default::default()\n        };\n        let traffic_light = determine_status(\u0026mock_score);\n        let suggestions = generate_suggestions(\u0026mock_score);\n\n        // Display isolation scoring\n        println!(\"\\n{} Split quality: {}\", \"â\".cyan(), traffic_light);\n\n        let isolation_detail = if shared_file_count \u003e 0 {\n            format!(\n                \"Member isolation: {:.0}% ({} of {} members share {} file{})\",\n                isolation_percentage,\n                member_specs.len()\n                    - (isolation_percentage / 100.0 * member_specs.len() as f64).round() as usize,\n                member_specs.len(),\n                shared_file_count,\n                if shared_file_count == 1 { \"\" } else { \"s\" }\n            )\n        } else if total_files \u003e 0 {\n            format!(\n                \"Member isolation: {:.0}% (No shared files)\",\n                isolation_percentage\n            )\n        } else {\n            format!(\n                \"Member isolation: {:.0}% (No files specified)\",\n                isolation_percentage\n            )\n        };\n\n        println!(\"  {}\", isolation_detail);\n\n        if !suggestions.is_empty() {\n            println!(\"\\nSuggestion: {}\", suggestions.join(\"; \"));\n        }\n    }\n\n    // Display split quality report\n    if dep_analysis.is_some() || !quality_issues.is_empty() {\n        display_split_quality_report(\u0026members, \u0026dep_analysis, \u0026quality_issues);\n    }\n\n    // Handle recursive split if requested and members are over-complex\n    if recursive \u0026\u0026 over_complex_count == members.len() \u0026\u0026 members.len() \u003e 1 {\n        if current_depth \u003e= max_depth {\n            eprintln!(\n                \"\\n{} Max recursion depth {} reached. Not splitting further.\",\n                \"â \".yellow(),\n                max_depth\n            );\n        } else {\n            println!(\n                \"\\n{} All members exceed complexity thresholds. Recursively splitting...\",\n                \"â\".cyan()\n            );\n\n            // Recursively split each over-complex member\n            for i in 1..=members.len() {\n                let member_id = format!(\"{}.{}\", spec.id, i);\n                println!(\"\\n{} Splitting member {}\", \"â\".cyan(), member_id);\n\n                // Recursively split this member\n                if let Err(e) = cmd_split_impl(\n                    \u0026member_id,\n                    override_model,\n                    true, // force split even if pending\n                    recursive,\n                    max_depth,\n                    current_depth + 1,\n                ) {\n                    eprintln!(\n                        \"  {} Failed to split member {}: {}\",\n                        \"â \".yellow(),\n                        member_id,\n                        e\n                    );\n                }\n            }\n\n            println!(\n                \"\\n{} Recursive split complete at depth {}\",\n                \"â\".green(),\n                current_depth + 1\n            );\n        }\n    }\n\n    Ok(())\n}\n\n/// Get the model to use for split operations.\n/// Resolution order:\n/// 1. --model flag (if provided)\n/// 2. CHANT_SPLIT_MODEL env var\n/// 3. defaults.split_model from config\n/// 4. CHANT_MODEL env var (fallback to general model)\n/// 5. defaults.model from config\n/// 6. Hardcoded default: \"sonnet\"\nfn get_model_for_split(\n    flag_model: Option\u003c\u0026str\u003e,\n    config_model: Option\u003c\u0026str\u003e,\n    config_split_model: Option\u003c\u0026str\u003e,\n) -\u003e String {\n    // 1. --model flag\n    if let Some(model) = flag_model {\n        if !model.is_empty() {\n            return model.to_string();\n        }\n    }\n\n    // 2. CHANT_SPLIT_MODEL env var\n    if let Ok(model) = std::env::var(\"CHANT_SPLIT_MODEL\") {\n        if !model.is_empty() {\n            return model;\n        }\n    }\n\n    // 3. defaults.split_model from config\n    if let Some(model) = config_split_model {\n        if !model.is_empty() {\n            return model.to_string();\n        }\n    }\n\n    // 4. CHANT_MODEL env var (fallback to general model)\n    if let Ok(model) = std::env::var(\"CHANT_MODEL\") {\n        if !model.is_empty() {\n            return model;\n        }\n    }\n\n    // 5. defaults.model from config\n    if let Some(model) = config_model {\n        if !model.is_empty() {\n            return model.to_string();\n        }\n    }\n\n    // 6. Hardcoded default\n    \"sonnet\".to_string()\n}\n\n/// Parse split analysis output (new format with dependency analysis)\nfn parse_split_output(output: \u0026str) -\u003e Result\u003c(Option\u003cDependencyAnalysis\u003e, Vec\u003cMemberSpec\u003e)\u003e {\n    // Try to extract dependency analysis section\n    let dep_analysis = extract_dependency_analysis(output);\n\n    // Parse member specs\n    let members = parse_member_specs_from_output(output)?;\n\n    Ok((dep_analysis, members))\n}\n\n/// Extract dependency analysis from output\nfn extract_dependency_analysis(output: \u0026str) -\u003e Option\u003cDependencyAnalysis\u003e {\n    // Look for \"# Dependency Analysis\" section\n    let mut in_dep_section = false;\n    let mut dep_text = String::new();\n    let mut in_graph = false;\n    let mut graph_text = String::new();\n\n    for line in output.lines() {\n        if line.starts_with(\"# Dependency Analysis\") {\n            in_dep_section = true;\n            continue;\n        }\n\n        if in_dep_section {\n            // Stop when we hit member specs\n            if line.starts_with(\"## Member \") {\n                break;\n            }\n\n            // Capture the dependency graph\n            if line.contains(\"## Dependency Graph\") {\n                in_graph = true;\n                continue;\n            }\n\n            if in_graph {\n                if line.starts_with(\"```\") {\n                    // Toggle code block\n                    if !graph_text.is_empty() {\n                        // End of graph\n                        break;\n                    }\n                    continue;\n                }\n                if line.starts_with(\"##\") \u0026\u0026 !line.contains(\"Dependency Graph\") {\n                    // New section, end of graph\n                    in_graph = false;\n                }\n                if in_graph \u0026\u0026 !line.trim().is_empty() \u0026\u0026 !line.starts_with(\"**\") {\n                    graph_text.push_str(line);\n                    graph_text.push('\\n');\n                }\n            }\n\n            dep_text.push_str(line);\n            dep_text.push('\\n');\n        }\n    }\n\n    if graph_text.is_empty() {\n        return None;\n    }\n\n    // Parse edges from dependency text (simple heuristic)\n    let edges = extract_dependency_edges(\u0026dep_text);\n\n    Some(DependencyAnalysis {\n        graph_text: graph_text.trim().to_string(),\n        edges,\n    })\n}\n\n/// Extract dependency edges from analysis text\n/// Looks for patterns like \"Task N depends on Task M\" or similar\nfn extract_dependency_edges(text: \u0026str) -\u003e Vec\u003c(usize, usize)\u003e {\n    let mut edges = Vec::new();\n\n    // Simple pattern matching for \"Member N depends on Member M\"\n    // or \"Task N depends on Task M\"\n    for line in text.lines() {\n        if line.contains(\"depends on\") {\n            // Try to extract numbers\n            let words: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n            let mut from_num = None;\n            let mut to_nums = Vec::new();\n\n            for (i, word) in words.iter().enumerate() {\n                if (word.starts_with(\"Member\") || word.starts_with(\"Task\")) \u0026\u0026 i + 1 \u003c words.len() {\n                    if let Ok(num) = words[i + 1].trim_end_matches([',', ':']).parse::\u003cusize\u003e() {\n                        if from_num.is_none() {\n                            from_num = Some(num);\n                        }\n                    }\n                }\n\n                if *word == \"on\" \u0026\u0026 i + 1 \u003c words.len() {\n                    // Look ahead for numbers\n                    for next_word in words.iter().skip(i + 1) {\n                        let next = next_word.trim_end_matches([',', '.', ':', ';', ')']);\n                        if let Ok(num) = next.parse::\u003cusize\u003e() {\n                            to_nums.push(num);\n                        }\n                        if next_word.contains(\"because\") || next_word.contains(\"and\") {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if let Some(from) = from_num {\n                for to in to_nums {\n                    edges.push((to, from)); // (dependency, dependent)\n                }\n            }\n        }\n    }\n\n    edges\n}\n\n/// Parse member specs from agent output (split analysis)\n/// Tuple representing a member being parsed: (title, description, files, dependencies, has_requires)\ntype MemberInProgress = (String, String, Vec\u003cString\u003e, Vec\u003cusize\u003e, bool);\n\nfn parse_member_specs_from_output(output: \u0026str) -\u003e Result\u003cVec\u003cMemberSpec\u003e\u003e {\n    let mut members = Vec::new();\n    let mut current_member: Option\u003cMemberInProgress\u003e = None;\n    let mut collecting_files = false;\n    let mut collecting_dependencies = false;\n    let mut collecting_requires = false;\n    let mut in_code_block = false;\n\n    for line in output.lines() {\n        // Check for member headers (## Member N: ...)\n        if line.starts_with(\"## Member \") \u0026\u0026 line.contains(':') {\n            // Save previous member if any\n            if let Some((title, desc, files, deps, _has_requires)) = current_member.take() {\n                members.push(MemberSpec {\n                    title,\n                    description: desc.trim().to_string(),\n                    target_files: if files.is_empty() { None } else { Some(files) },\n                    dependencies: deps,\n                });\n            }\n\n            // Extract title from \"## Member N: Title Here\"\n            if let Some(title_part) = line.split(':').nth(1) {\n                let title = title_part.trim().to_string();\n                current_member = Some((title, String::new(), Vec::new(), Vec::new(), false));\n                collecting_files = false;\n                collecting_dependencies = false;\n                collecting_requires = false;\n            }\n        } else if current_member.is_some() {\n            // Check for code block markers\n            if line.trim() == \"```\" {\n                in_code_block = !in_code_block;\n                if let Some((_, ref mut desc, _, _, _)) = \u0026mut current_member {\n                    desc.push_str(line);\n                    desc.push('\\n');\n                }\n                continue;\n            }\n\n            // Check for \"Affected Files:\" header\n            if line.contains(\"**Affected Files:**\") || line.contains(\"Affected Files:\") {\n                collecting_files = true;\n                collecting_dependencies = false;\n                collecting_requires = false;\n                continue;\n            }\n\n            // Check for \"Dependencies:\" header\n            if line.contains(\"**Dependencies:**\")\n                || (line.starts_with(\"Dependencies:\") \u0026\u0026 !line.contains(\"##\"))\n            {\n                collecting_dependencies = true;\n                collecting_files = false;\n                collecting_requires = false;\n                // Parse dependencies from same line if present, but ONLY if we haven't\n                // already collected dependencies from a Requires section\n                if let Some(deps_part) = line.split(':').nth(1) {\n                    if let Some((_, _, _, ref mut deps, has_requires)) = \u0026mut current_member {\n                        if !*has_requires {\n                            parse_dependencies_from_text(deps_part, deps);\n                        } else {\n                            eprintln!(\"Warning: Ignoring Dependencies line because Requires section was already parsed\");\n                        }\n                    }\n                }\n                continue;\n            }\n\n            // Check for \"### Requires\" header\n            if line.contains(\"### Requires\") {\n                collecting_requires = true;\n                collecting_files = false;\n                collecting_dependencies = false;\n                // Mark that we're using Requires section for dependencies\n                if let Some((_, _, _, _, ref mut has_requires)) = \u0026mut current_member {\n                    *has_requires = true;\n                }\n                continue;\n            }\n\n            // If collecting files, parse them (format: \"- filename\")\n            if collecting_files {\n                if let Some(stripped) = line.strip_prefix(\"- \") {\n                    let file = stripped.trim().to_string();\n                    if !file.is_empty() {\n                        // Strip annotations like \"(test module)\" from filename\n                        let cleaned_file = if let Some(paren_pos) = file.find('(') {\n                            file[..paren_pos].trim().to_string()\n                        } else {\n                            file\n                        };\n                        if let Some((_, _, ref mut files, _, _)) = current_member {\n                            files.push(cleaned_file);\n                        }\n                    }\n                } else if line.starts_with('-') \u0026\u0026 !line.starts_with(\"- \") {\n                    // Not a bullet list, stop collecting\n                    collecting_files = false;\n                } else if line.trim().is_empty() {\n                    // Empty line might end the files section, depending on context\n                } else if line.starts_with(\"##\") {\n                    // New section\n                    collecting_files = false;\n                }\n            } else if collecting_dependencies {\n                // Parse any additional dependency info\n                if line.starts_with(\"##\") || line.trim().is_empty() {\n                    collecting_dependencies = false;\n                }\n            } else if collecting_requires {\n                // Parse member references from Requires section\n                // Stop if we hit another section\n                if line.starts_with(\"###\") || line.starts_with(\"##\") {\n                    collecting_requires = false;\n                    // Don't continue - let the line be processed normally\n                } else if !line.trim().is_empty() {\n                    // Parse lines like \"- Uses X from Member N\" or \"- Requires Member N\"\n                    if let Some((_, _, _, ref mut deps, _)) = \u0026mut current_member {\n                        parse_dependencies_from_text(line, deps);\n                    }\n                    continue;\n                }\n            } else if !in_code_block {\n                // Skip \"Provides:\" section - don't include in description\n                if line.contains(\"### Provides\") {\n                    // Skip this section header\n                    continue;\n                }\n                // Preserve ### headers and all content except special sections\n                if let Some((_, ref mut desc, _, _, _)) = \u0026mut current_member {\n                    desc.push_str(line);\n                    desc.push('\\n');\n                }\n            }\n        }\n    }\n\n    // Save last member\n    if let Some((title, desc, files, deps, _has_requires)) = current_member {\n        members.push(MemberSpec {\n            title,\n            description: desc.trim().to_string(),\n            target_files: if files.is_empty() { None } else { Some(files) },\n            dependencies: deps,\n        });\n    }\n\n    if members.is_empty() {\n        anyhow::bail!(\"No member specs found in agent output\");\n    }\n\n    // Remove self-references and validate no cycles\n    validate_and_clean_dependencies(\u0026mut members)?;\n\n    Ok(members)\n}\n\n/// Validate dependencies and remove self-references and cycles\nfn validate_and_clean_dependencies(members: \u0026mut [MemberSpec]) -\u003e Result\u003c()\u003e {\n    // Remove self-references\n    for (index, member) in members.iter_mut().enumerate() {\n        let member_number = index + 1;\n        let original_len = member.dependencies.len();\n        member.dependencies.retain(|\u0026dep| dep != member_number);\n        if member.dependencies.len() \u003c original_len {\n            eprintln!(\n                \"Warning: Removed self-reference in Member {}: {}\",\n                member_number, member.title\n            );\n        }\n    }\n\n    // Detect cycles using depth-first search\n    fn has_cycle_from(\n        node: usize,\n        members: \u0026[MemberSpec],\n        visited: \u0026mut Vec\u003cbool\u003e,\n        rec_stack: \u0026mut Vec\u003cbool\u003e,\n    ) -\u003e Option\u003cVec\u003cusize\u003e\u003e {\n        if rec_stack[node] {\n            return Some(vec![node]);\n        }\n        if visited[node] {\n            return None;\n        }\n\n        visited[node] = true;\n        rec_stack[node] = true;\n\n        if let Some(member) = members.get(node) {\n            for \u0026dep in \u0026member.dependencies {\n                if dep \u003e 0 \u0026\u0026 dep \u003c= members.len() {\n                    let dep_idx = dep - 1;\n                    if let Some(mut cycle) = has_cycle_from(dep_idx, members, visited, rec_stack) {\n                        cycle.push(node);\n                        return Some(cycle);\n                    }\n                }\n            }\n        }\n\n        rec_stack[node] = false;\n        None\n    }\n\n    let n = members.len();\n    let mut visited = vec![false; n];\n    let mut rec_stack = vec![false; n];\n\n    for i in 0..n {\n        if !visited[i] {\n            if let Some(cycle) = has_cycle_from(i, members, \u0026mut visited, \u0026mut rec_stack) {\n                let cycle_members: Vec\u003cusize\u003e = cycle.iter().rev().map(|\u0026i| i + 1).collect();\n                eprintln!(\n                    \"Warning: Detected dependency cycle: {} -\u003e {}\",\n                    cycle_members\n                        .iter()\n                        .map(|n| n.to_string())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\" -\u003e \"),\n                    cycle_members[0]\n                );\n\n                // Remove the edge that creates the cycle (last dependency in cycle)\n                if cycle.len() \u003e= 2 {\n                    let from_idx = cycle[1];\n                    let to_member = cycle[0] + 1;\n                    if let Some(member) = members.get_mut(from_idx) {\n                        member.dependencies.retain(|\u0026dep| dep != to_member);\n                        eprintln!(\n                            \"  Removed dependency: Member {} -\u003e Member {}\",\n                            from_idx + 1,\n                            to_member\n                        );\n                    }\n                }\n\n                // Reset for next iteration\n                visited = vec![false; n];\n                rec_stack = vec![false; n];\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Parse dependencies from text like \"Member 2, Member 3\" or \"None\"\nfn parse_dependencies_from_text(text: \u0026str, deps: \u0026mut Vec\u003cusize\u003e) {\n    if text.trim().to_lowercase() == \"none\" {\n        return;\n    }\n\n    // Extract numbers from text\n    for word in text.split(\u0026[',', ' ', ';'][..]) {\n        let trimmed = word.trim();\n        if let Ok(num) = trimmed.parse::\u003cusize\u003e() {\n            if !deps.contains(\u0026num) {\n                deps.push(num);\n            }\n        } else if trimmed.starts_with(\"Member \") || trimmed.starts_with(\"Task \") {\n            // Try to extract number after \"Member \" or \"Task \"\n            let num_part = trimmed.split_whitespace().nth(1).unwrap_or(\"\");\n            if let Ok(num) = num_part.trim_end_matches([',', '.']).parse::\u003cusize\u003e() {\n                if !deps.contains(\u0026num) {\n                    deps.push(num);\n                }\n            }\n        }\n    }\n}\n\n/// Detect if a member is infrastructure based on title/description keywords\nfn is_infrastructure_member(member: \u0026MemberSpec) -\u003e bool {\n    let text = format!(\"{} {}\", member.title, member.description).to_lowercase();\n\n    // Infrastructure keywords\n    let infra_keywords = [\n        \"logging\",\n        \"logger\",\n        \"config\",\n        \"configuration\",\n        \"error handling\",\n        \"error type\",\n        \"utility\",\n        \"helper\",\n        \"common type\",\n        \"shared type\",\n        \"base type\",\n        \"interface\",\n        \"trait\",\n        \"constant\",\n    ];\n\n    infra_keywords.iter().any(|keyword| text.contains(keyword))\n}\n\n/// Calculate isolation percentage for a group of member specs.\n///\n/// Returns the percentage of members that are isolated (no cross-references to other members).\nfn calculate_isolation_percentage(members: \u0026[\u0026Spec]) -\u003e f64 {\n    if members.is_empty() {\n        return 100.0;\n    }\n\n    // Use regex to detect \"Member N\" patterns\n    let member_pattern = regex::Regex::new(r\"(?i)\\bmember\\s+\\d+\\b\").unwrap();\n\n    let isolated_count = members\n        .iter()\n        .filter(|member| !member_pattern.is_match(\u0026member.body))\n        .count();\n\n    (isolated_count as f64 / members.len() as f64) * 100.0\n}\n\n/// Count the number of files that appear in multiple members' target_files.\nfn count_shared_files(members: \u0026[\u0026Spec]) -\u003e usize {\n    use std::collections::HashMap;\n\n    let mut file_counts: HashMap\u003cString, usize\u003e = HashMap::new();\n\n    for member in members {\n        if let Some(target_files) = \u0026member.frontmatter.target_files {\n            let unique_files: std::collections::HashSet\u003c_\u003e = target_files.iter().collect();\n            for file in unique_files {\n                *file_counts.entry(file.clone()).or_insert(0) += 1;\n            }\n        }\n    }\n\n    file_counts.values().filter(|\u0026\u0026count| count \u003e 1).count()\n}\n\n/// Count total unique files across all members.\nfn count_total_unique_files(members: \u0026[\u0026Spec]) -\u003e usize {\n    use std::collections::HashSet;\n\n    let mut all_files = HashSet::new();\n\n    for member in members {\n        if let Some(target_files) = \u0026member.frontmatter.target_files {\n            for file in target_files {\n                all_files.insert(file.clone());\n            }\n        }\n    }\n\n    all_files.len()\n}\n\n/// Detect infrastructure ordering issues and add to quality issues\nfn detect_infrastructure_issues(members: \u0026[MemberSpec], quality_issues: \u0026mut Vec\u003cString\u003e) {\n    for (index, member) in members.iter().enumerate() {\n        let member_number = index + 1;\n\n        if is_infrastructure_member(member) {\n            // Check if infrastructure depends on non-infrastructure\n            for dep in \u0026member.dependencies {\n                let dep_index = dep - 1;\n                if dep_index \u003c members.len() {\n                    let dep_member = \u0026members[dep_index];\n                    if !is_infrastructure_member(dep_member) {\n                        eprintln!(\n                            \"  {} Member {} (infrastructure) depends on Member {} (feature) - may be incorrect\",\n                            \"â \".yellow(),\n                            member_number,\n                            dep\n                        );\n                        quality_issues.push(format!(\n                            \"Infrastructure Member {} depends on feature Member {}\",\n                            member_number, dep\n                        ));\n                    }\n                }\n            }\n\n            // Warn if infrastructure appears late in sequence\n            if member_number \u003e members.len() / 2 {\n                eprintln!(\n                    \"  {} Member {} (infrastructure) appears late in sequence - consider reordering\",\n                    \"â \".yellow(),\n                    member_number\n                );\n            }\n        }\n    }\n}\n\n/// Display split quality report\nfn display_split_quality_report(\n    members: \u0026[MemberSpec],\n    dep_analysis: \u0026Option\u003cDependencyAnalysis\u003e,\n    quality_issues: \u0026[String],\n) {\n    println!(\"\\n{} Split Quality Report\", \"â\".cyan());\n    println!(\"ââââââââââââââââââââââââââââââââââââââââ\");\n\n    // Show dependency structure\n    if let Some(analysis) = dep_analysis {\n        println!(\"\\n{} Dependency Graph:\", \"ð\".cyan());\n        println!(\"{}\", analysis.graph_text);\n\n        // Analyze parallelism\n        let mut parallel_groups: std::collections::HashMap\u003cString, Vec\u003cusize\u003e\u003e =\n            std::collections::HashMap::new();\n        for (i, member) in members.iter().enumerate() {\n            let deps_key = if member.dependencies.is_empty() {\n                \"none\".to_string()\n            } else {\n                let mut deps = member.dependencies.clone();\n                deps.sort();\n                format!(\"{:?}\", deps)\n            };\n            parallel_groups.entry(deps_key).or_default().push(i + 1);\n        }\n\n        let parallel_count = parallel_groups.values().filter(|v| v.len() \u003e 1).count();\n        if parallel_count \u003e 0 {\n            println!(\"\\n{} Parallelism Detected:\", \"â\".green());\n            for (deps, group) in parallel_groups.iter() {\n                if group.len() \u003e 1 {\n                    println!(\n                        \"  Members {:?} can run in parallel (depend on: {})\",\n                        group,\n                        if deps == \"none\" {\n                            \"nothing\".to_string()\n                        } else {\n                            deps.clone()\n                        }\n                    );\n                }\n            }\n        }\n    }\n\n    // Show complexity metrics\n    println!(\"\\n{} Complexity Metrics:\", \"ð\".cyan());\n    for (index, member) in members.iter().enumerate() {\n        let member_number = index + 1;\n        let criteria_count = member.description.matches(\"- [ ]\").count()\n            + member.description.matches(\"- [x]\").count()\n            + member.description.matches(\"- [X]\").count();\n        let files_count = member.target_files.as_ref().map(|f| f.len()).unwrap_or(0);\n        let word_count = member.description.split_whitespace().count();\n\n        println!(\n            \"  Member {}: {} criteria, {} files, {} words\",\n            member_number, criteria_count, files_count, word_count\n        );\n    }\n\n    // Show quality issues\n    if !quality_issues.is_empty() {\n        println!(\"\\n{} Quality Issues:\", \"â \".yellow());\n        for issue in quality_issues {\n            println!(\"  â¢ {}\", issue);\n        }\n    } else {\n        println!(\"\\n{} No quality issues detected\", \"â\".green());\n    }\n\n    println!(\"ââââââââââââââââââââââââââââââââââââââââ\\n\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_parse_member_specs_requires_section() {\n        let output = r#\"\n## Member 1: Base Configuration\n\nThis member implements the base configuration system.\n\n### Provides\n- Config type\n- Default settings\n\n**Affected Files:**\n- src/config.rs\n\n## Member 2: Feature A\n\nThis member implements feature A.\n\n### Requires\n- Uses `Config` from Member 1\n\n**Affected Files:**\n- src/feature_a.rs\n\n## Member 3: Feature B\n\nThis member implements feature B.\n\n### Requires\n- Requires Member 1 for configuration\n- Uses types from Member 2\n\n**Affected Files:**\n- src/feature_b.rs\n\n## Member 4: Integration\n\nThis member integrates all features.\n\n### Requires\n- Uses Member 2 and Member 3\n\n**Affected Files:**\n- src/integration.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 4);\n\n        // Member 1 should have no dependencies\n        assert_eq!(members[0].dependencies.len(), 0);\n\n        // Member 2 should depend on Member 1\n        assert_eq!(members[1].dependencies, vec![1]);\n\n        // Member 3 should depend on Members 1 and 2\n        let mut deps = members[2].dependencies.clone();\n        deps.sort();\n        assert_eq!(deps, vec![1, 2]);\n\n        // Member 4 should depend on Members 2 and 3\n        let mut deps = members[3].dependencies.clone();\n        deps.sort();\n        assert_eq!(deps, vec![2, 3]);\n    }\n\n    #[test]\n    fn test_parse_member_specs_preserves_dependencies_fallback() {\n        let output = r#\"\n## Member 1: Base\n\nBase implementation.\n\n**Dependencies:** None\n\n**Affected Files:**\n- src/base.rs\n\n## Member 2: Feature\n\nFeature implementation.\n\n**Dependencies:** Member 1\n\n**Affected Files:**\n- src/feature.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 2);\n\n        // Member 1 should have no dependencies\n        assert_eq!(members[0].dependencies.len(), 0);\n\n        // Member 2 should depend on Member 1 (from **Dependencies:** section)\n        assert_eq!(members[1].dependencies, vec![1]);\n    }\n\n    #[test]\n    fn test_requires_preferred_over_dependencies() {\n        // Test that Requires section takes precedence over Dependencies line\n        let output = r#\"\n## Member 1: Base\n\nBase implementation.\n\n**Affected Files:**\n- src/base.rs\n\n## Member 2: Feature\n\nFeature implementation.\n\n### Requires\n- Uses `WatchConfig` from Member 1\n\n**Dependencies:** Member 5\n\n**Affected Files:**\n- src/feature.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 2);\n\n        // Member 2 should depend ONLY on Member 1 (from Requires), not Member 5 (from Dependencies)\n        assert_eq!(members[1].dependencies, vec![1]);\n    }\n\n    #[test]\n    fn test_cycle_detection_and_removal() {\n        // Test that cycles are detected and broken\n        let output = r#\"\n## Member 1: Base\n\nBase implementation.\n\n**Affected Files:**\n- src/base.rs\n\n## Member 2: Feature A\n\nFeature A.\n\n### Requires\n- Uses Member 3\n\n**Affected Files:**\n- src/feature_a.rs\n\n## Member 3: Feature B\n\nFeature B.\n\n### Requires\n- Uses Member 2\n\n**Affected Files:**\n- src/feature_b.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 3);\n\n        // After cycle removal, at least one of the circular edges should be removed\n        // Member 2 depends on Member 3, Member 3 depends on Member 2 (cycle)\n        let member2_deps = \u0026members[1].dependencies;\n        let member3_deps = \u0026members[2].dependencies;\n\n        // At least one of these should be empty to break the cycle\n        assert!(\n            member2_deps.is_empty()\n                || member3_deps.is_empty()\n                || !member2_deps.contains(\u00263)\n                || !member3_deps.contains(\u00262),\n            \"Cycle should be broken\"\n        );\n    }\n\n    #[test]\n    fn test_self_reference_removal() {\n        // Test that self-references are removed\n        let output = r#\"\n## Member 1: Feature\n\nFeature implementation.\n\n### Requires\n- Uses Member 1\n\n**Affected Files:**\n- src/feature.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 1);\n\n        // Self-reference should be removed\n        assert_eq!(members[0].dependencies.len(), 0);\n    }\n\n    #[test]\n    fn test_both_requires_and_dependencies_prefer_requires() {\n        // Test with both sections present - should use only Requires\n        let output = r#\"\n## Member 1: Base\n\nBase config.\n\n**Affected Files:**\n- src/config.rs\n\n## Member 2: Logger\n\nLogger module.\n\n**Affected Files:**\n- src/logger.rs\n\n## Member 3: Feature\n\nFeature implementation.\n\n### Requires\n- Uses `Config` from Member 1\n- Uses `Logger` from Member 2\n\n**Dependencies:** None\n\n**Affected Files:**\n- src/feature.rs\n\"#;\n\n        let result = parse_member_specs_from_output(output);\n        assert!(result.is_ok());\n\n        let members = result.unwrap();\n        assert_eq!(members.len(), 3);\n\n        // Member 3 should depend on Members 1 and 2 (from Requires), not \"None\" (from Dependencies)\n        let mut deps = members[2].dependencies.clone();\n        deps.sort();\n        assert_eq!(deps, vec![1, 2]);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":6}},{"line":674,"address":[],"length":0,"stats":{"Line":12}},{"line":675,"address":[],"length":0,"stats":{"Line":18}},{"line":676,"address":[],"length":0,"stats":{"Line":12}},{"line":677,"address":[],"length":0,"stats":{"Line":12}},{"line":678,"address":[],"length":0,"stats":{"Line":12}},{"line":679,"address":[],"length":0,"stats":{"Line":12}},{"line":681,"address":[],"length":0,"stats":{"Line":155}},{"line":683,"address":[],"length":0,"stats":{"Line":316}},{"line":685,"address":[],"length":0,"stats":{"Line":60}},{"line":686,"address":[],"length":0,"stats":{"Line":18}},{"line":687,"address":[],"length":0,"stats":{"Line":9}},{"line":688,"address":[],"length":0,"stats":{"Line":18}},{"line":689,"address":[],"length":0,"stats":{"Line":27}},{"line":690,"address":[],"length":0,"stats":{"Line":9}},{"line":695,"address":[],"length":0,"stats":{"Line":45}},{"line":696,"address":[],"length":0,"stats":{"Line":60}},{"line":697,"address":[],"length":0,"stats":{"Line":75}},{"line":698,"address":[],"length":0,"stats":{"Line":30}},{"line":699,"address":[],"length":0,"stats":{"Line":15}},{"line":700,"address":[],"length":0,"stats":{"Line":15}},{"line":702,"address":[],"length":0,"stats":{"Line":256}},{"line":704,"address":[],"length":0,"stats":{"Line":122}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":458}},{"line":715,"address":[],"length":0,"stats":{"Line":15}},{"line":716,"address":[],"length":0,"stats":{"Line":15}},{"line":717,"address":[],"length":0,"stats":{"Line":15}},{"line":718,"address":[],"length":0,"stats":{"Line":15}},{"line":722,"address":[],"length":0,"stats":{"Line":214}},{"line":723,"address":[],"length":0,"stats":{"Line":206}},{"line":725,"address":[],"length":0,"stats":{"Line":4}},{"line":726,"address":[],"length":0,"stats":{"Line":4}},{"line":727,"address":[],"length":0,"stats":{"Line":4}},{"line":730,"address":[],"length":0,"stats":{"Line":8}},{"line":731,"address":[],"length":0,"stats":{"Line":12}},{"line":732,"address":[],"length":0,"stats":{"Line":6}},{"line":733,"address":[],"length":0,"stats":{"Line":4}},{"line":735,"address":[],"length":0,"stats":{"Line":2}},{"line":739,"address":[],"length":0,"stats":{"Line":4}},{"line":743,"address":[],"length":0,"stats":{"Line":206}},{"line":744,"address":[],"length":0,"stats":{"Line":8}},{"line":745,"address":[],"length":0,"stats":{"Line":8}},{"line":746,"address":[],"length":0,"stats":{"Line":8}},{"line":748,"address":[],"length":0,"stats":{"Line":24}},{"line":749,"address":[],"length":0,"stats":{"Line":8}},{"line":751,"address":[],"length":0,"stats":{"Line":8}},{"line":755,"address":[],"length":0,"stats":{"Line":95}},{"line":756,"address":[],"length":0,"stats":{"Line":39}},{"line":757,"address":[],"length":0,"stats":{"Line":45}},{"line":758,"address":[],"length":0,"stats":{"Line":15}},{"line":760,"address":[],"length":0,"stats":{"Line":30}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":15}},{"line":765,"address":[],"length":0,"stats":{"Line":45}},{"line":766,"address":[],"length":0,"stats":{"Line":30}},{"line":769,"address":[],"length":0,"stats":{"Line":18}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":27}},{"line":774,"address":[],"length":0,"stats":{"Line":9}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":71}},{"line":780,"address":[],"length":0,"stats":{"Line":20}},{"line":781,"address":[],"length":0,"stats":{"Line":4}},{"line":783,"address":[],"length":0,"stats":{"Line":67}},{"line":786,"address":[],"length":0,"stats":{"Line":72}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":18}},{"line":791,"address":[],"length":0,"stats":{"Line":30}},{"line":792,"address":[],"length":0,"stats":{"Line":20}},{"line":794,"address":[],"length":0,"stats":{"Line":10}},{"line":796,"address":[],"length":0,"stats":{"Line":49}},{"line":798,"address":[],"length":0,"stats":{"Line":98}},{"line":800,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":144}},{"line":804,"address":[],"length":0,"stats":{"Line":192}},{"line":805,"address":[],"length":0,"stats":{"Line":48}},{"line":812,"address":[],"length":0,"stats":{"Line":36}},{"line":813,"address":[],"length":0,"stats":{"Line":12}},{"line":814,"address":[],"length":0,"stats":{"Line":6}},{"line":815,"address":[],"length":0,"stats":{"Line":12}},{"line":816,"address":[],"length":0,"stats":{"Line":18}},{"line":817,"address":[],"length":0,"stats":{"Line":6}},{"line":821,"address":[],"length":0,"stats":{"Line":12}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":12}},{"line":828,"address":[],"length":0,"stats":{"Line":6}},{"line":832,"address":[],"length":0,"stats":{"Line":6}},{"line":834,"address":[],"length":0,"stats":{"Line":48}},{"line":835,"address":[],"length":0,"stats":{"Line":30}},{"line":836,"address":[],"length":0,"stats":{"Line":45}},{"line":837,"address":[],"length":0,"stats":{"Line":54}},{"line":838,"address":[],"length":0,"stats":{"Line":31}},{"line":839,"address":[],"length":0,"stats":{"Line":1}},{"line":840,"address":[],"length":0,"stats":{"Line":1}},{"line":841,"address":[],"length":0,"stats":{"Line":1}},{"line":847,"address":[],"length":0,"stats":{"Line":26}},{"line":853,"address":[],"length":0,"stats":{"Line":26}},{"line":854,"address":[],"length":0,"stats":{"Line":1}},{"line":856,"address":[],"length":0,"stats":{"Line":25}},{"line":857,"address":[],"length":0,"stats":{"Line":9}},{"line":860,"address":[],"length":0,"stats":{"Line":16}},{"line":861,"address":[],"length":0,"stats":{"Line":16}},{"line":863,"address":[],"length":0,"stats":{"Line":48}},{"line":864,"address":[],"length":0,"stats":{"Line":27}},{"line":865,"address":[],"length":0,"stats":{"Line":33}},{"line":866,"address":[],"length":0,"stats":{"Line":22}},{"line":867,"address":[],"length":0,"stats":{"Line":46}},{"line":868,"address":[],"length":0,"stats":{"Line":6}},{"line":869,"address":[],"length":0,"stats":{"Line":2}},{"line":875,"address":[],"length":0,"stats":{"Line":14}},{"line":876,"address":[],"length":0,"stats":{"Line":14}},{"line":879,"address":[],"length":0,"stats":{"Line":18}},{"line":880,"address":[],"length":0,"stats":{"Line":18}},{"line":881,"address":[],"length":0,"stats":{"Line":18}},{"line":883,"address":[],"length":0,"stats":{"Line":21}},{"line":884,"address":[],"length":0,"stats":{"Line":15}},{"line":885,"address":[],"length":0,"stats":{"Line":61}},{"line":886,"address":[],"length":0,"stats":{"Line":9}},{"line":887,"address":[],"length":0,"stats":{"Line":1}},{"line":889,"address":[],"length":0,"stats":{"Line":1}},{"line":890,"address":[],"length":0,"stats":{"Line":1}},{"line":891,"address":[],"length":0,"stats":{"Line":7}},{"line":892,"address":[],"length":0,"stats":{"Line":1}},{"line":893,"address":[],"length":0,"stats":{"Line":2}},{"line":894,"address":[],"length":0,"stats":{"Line":1}},{"line":898,"address":[],"length":0,"stats":{"Line":1}},{"line":899,"address":[],"length":0,"stats":{"Line":2}},{"line":900,"address":[],"length":0,"stats":{"Line":2}},{"line":901,"address":[],"length":0,"stats":{"Line":3}},{"line":902,"address":[],"length":0,"stats":{"Line":4}},{"line":903,"address":[],"length":0,"stats":{"Line":1}},{"line":905,"address":[],"length":0,"stats":{"Line":1}},{"line":912,"address":[],"length":0,"stats":{"Line":3}},{"line":913,"address":[],"length":0,"stats":{"Line":3}},{"line":918,"address":[],"length":0,"stats":{"Line":6}},{"line":922,"address":[],"length":0,"stats":{"Line":12}},{"line":923,"address":[],"length":0,"stats":{"Line":12}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":96}},{"line":929,"address":[],"length":0,"stats":{"Line":180}},{"line":930,"address":[],"length":0,"stats":{"Line":72}},{"line":931,"address":[],"length":0,"stats":{"Line":36}},{"line":932,"address":[],"length":0,"stats":{"Line":24}},{"line":934,"address":[],"length":0,"stats":{"Line":192}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}}],"covered":138,"coverable":535},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","mod.rs"],"content":"//! Command module structure for chant CLI\n\nuse anyhow::Result;\nuse std::path::PathBuf;\n\nuse chant::paths::SPECS_DIR;\n\npub mod activity;\npub mod agent;\npub mod agent_rotation;\npub mod cleanup;\npub mod commits;\npub mod config;\npub mod derive;\npub mod disk;\npub mod dispatch;\npub mod export;\npub mod finalize;\npub mod git_ops;\npub mod lifecycle;\npub mod model;\npub mod pause;\npub mod prep;\npub mod refresh;\npub mod search;\npub mod silent;\npub mod site;\npub mod spec;\npub mod takeover;\npub mod template;\npub mod validate;\npub mod verify;\npub mod watch;\npub mod work;\npub mod worktree;\n\n/// Ensure chant is initialized and return the specs directory path.\n///\n/// This checks for the existence of `.chant/specs` and returns an error\n/// if chant has not been initialized.\npub fn ensure_initialized() -\u003e Result\u003cPathBuf\u003e {\n    let specs_dir = PathBuf::from(SPECS_DIR);\n    if !specs_dir.exists() {\n        anyhow::bail!(\n            \"Not a chant project (no .chant/ directory found)\\n\\n\\\n             To initialize chant, run:\\n    \\\n             chant init\\n\\n\\\n             This starts an interactive wizard to configure your project.\"\n        );\n    }\n    Ok(specs_dir)\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":54}},{"line":42,"address":[],"length":0,"stats":{"Line":108}},{"line":43,"address":[],"length":0,"stats":{"Line":54}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":54}}],"covered":4,"coverable":5},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","model.rs"],"content":"//! Model selection and detection logic.\n//!\n//! Handles model name resolution with the following priority:\n//! 1. CHANT_MODEL env var (explicit override)\n//! 2. ANTHROPIC_MODEL env var (Claude CLI default)\n//! 3. defaults.model in config\n//! 4. Parse from `claude --version` output (last resort)\n\nuse chant::config::Config;\n\n/// Get the model name using the following priority:\n/// 1. CHANT_MODEL env var (explicit override)\n/// 2. ANTHROPIC_MODEL env var (Claude CLI default)\n/// 3. defaults.model in config\n/// 4. Parse from `claude --version` output (last resort)\npub fn get_model_name(config: Option\u003c\u0026Config\u003e) -\u003e Option\u003cString\u003e {\n    get_model_name_with_default(config.and_then(|c| c.defaults.model.as_deref()))\n}\n\n/// Get the model name with an optional default from config.\n/// Used by parallel execution where full Config isn't available.\npub fn get_model_name_with_default(config_model: Option\u003c\u0026str\u003e) -\u003e Option\u003cString\u003e {\n    // 1. CHANT_MODEL env var\n    if let Ok(model) = std::env::var(\"CHANT_MODEL\") {\n        if !model.is_empty() {\n            return Some(model);\n        }\n    }\n\n    // 2. ANTHROPIC_MODEL env var\n    if let Ok(model) = std::env::var(\"ANTHROPIC_MODEL\") {\n        if !model.is_empty() {\n            return Some(model);\n        }\n    }\n\n    // 3. defaults.model from config\n    if let Some(model) = config_model {\n        if !model.is_empty() {\n            return Some(model.to_string());\n        }\n    }\n\n    // 4. Parse from claude --version output\n    parse_model_from_claude_version()\n}\n\n/// Parse model name from `claude --version` output.\n/// Expected format: \"X.Y.Z (model-name)\" or similar patterns.\nfn parse_model_from_claude_version() -\u003e Option\u003cString\u003e {\n    use std::process::Command;\n\n    let output = Command::new(\"claude\").arg(\"--version\").output().ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let version_str = String::from_utf8_lossy(\u0026output.stdout);\n\n    // Try to extract model from parentheses, e.g., \"1.0.0 (claude-sonnet-4)\"\n    if let Some(start) = version_str.find('(') {\n        if let Some(end) = version_str.find(')') {\n            if start \u003c end {\n                let model = version_str[start + 1..end].trim();\n                // Check if it looks like a model name (contains \"claude\" or common model patterns)\n                if model.contains(\"claude\")\n                    || model.contains(\"sonnet\")\n                    || model.contains(\"opus\")\n                    || model.contains(\"haiku\")\n                {\n                    return Some(model.to_string());\n                }\n            }\n        }\n    }\n\n    None\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":7}},{"line":17,"address":[],"length":0,"stats":{"Line":29}},{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":15}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":7}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":28}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":21}},{"line":62,"address":[],"length":0,"stats":{"Line":14}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":64,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":28}},{"line":67,"address":[],"length":0,"stats":{"Line":14}},{"line":68,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":14}},{"line":70,"address":[],"length":0,"stats":{"Line":14}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":7}}],"covered":26,"coverable":28},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","pause.rs"],"content":"//! Pause command for pausing running work processes\n\nuse anyhow::Result;\nuse colored::Colorize;\n\nuse chant::pid;\nuse chant::spec::{self, SpecStatus};\n\n/// Pause a running work process for a spec\npub fn cmd_pause(id: \u0026str, force: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve the spec ID\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_id = spec.id.clone();\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n\n    println!(\"{} Pausing work for spec {}\", \"â\".cyan(), spec_id.cyan());\n\n    // Check if there's a PID file\n    let pid = pid::read_pid_file(\u0026spec_id)?;\n\n    let mut process_stopped = false;\n    if let Some(pid) = pid {\n        if pid::is_process_running(pid) {\n            // Process is running, stop it\n            println!(\"  {} Process {} is running\", \"â¢\".cyan(), pid);\n\n            if force {\n                println!(\"  {} Sending SIGTERM to process {}\", \"â¢\".cyan(), pid);\n                pid::stop_process(pid)?;\n                pid::remove_pid_file(\u0026spec_id)?;\n                process_stopped = true;\n                println!(\"  {} Process stopped\", \"â\".green());\n            } else {\n                println!(\"{} Use --force to stop the process\", \"â \".yellow());\n                anyhow::bail!(\n                    \"Spec {} has a running process (PID: {}). Use --force to stop it.\",\n                    spec_id,\n                    pid\n                );\n            }\n        } else {\n            // Process not running, clean up PID file\n            println!(\n                \"  {} Process {} is not running (cleaning up PID file)\",\n                \"â¢\".cyan(),\n                pid\n            );\n            pid::remove_pid_file(\u0026spec_id)?;\n        }\n    } else {\n        println!(\n            \"{} No work process found for spec {}\",\n            \"â \".yellow(),\n            spec_id\n        );\n    }\n\n    // Update spec status to paused if it was in_progress\n    if spec.frontmatter.status == SpecStatus::InProgress {\n        spec.frontmatter.status = SpecStatus::Paused;\n        spec.save(\u0026spec_path)?;\n        println!(\"  {} Status set to: paused\", \"â¢\".cyan());\n    }\n\n    if process_stopped {\n        println!(\"{} Paused work for spec {}\", \"â\".green(), spec_id);\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","prep.rs"],"content":"//! Prep command for retrieving and cleaning spec content for agents.\n//!\n//! This module implements the `chant prep` subcommand, which loads a specification\n//! and outputs its content in a clean format suitable for agents to read. It handles\n//! preprocessing of spec content to remove artifacts from previous executions.\n//!\n//! Key responsibilities:\n//! - Loads spec files from the specs directory\n//! - Strips agent conversation sections that may have been added during previous runs\n//! - Outputs the cleaned spec content to stdout\n//! - Preserves section hierarchy while removing level 2 headers tagged as agent output\n\nuse anyhow::{Context, Result};\nuse std::path::Path;\n\nuse chant::spec;\n\n/// Strip agent conversation sections from spec body.\n/// Removes markdown sections like \"## Agent Conversation\" or similar that may have been added during previous runs.\n/// Only removes level 2 headers (##) and their direct content, preserving level 3+ headers as regular content.\npub fn strip_agent_conversation(body: \u0026str) -\u003e String {\n    let lines: Vec\u003c\u0026str\u003e = body.lines().collect();\n    let mut result = Vec::new();\n    let mut skip_section = false;\n\n    for line in lines {\n        // Check if this is a level 2 header (## but not ###)\n        if line.starts_with(\"##\") \u0026\u0026 !line.starts_with(\"###\") {\n            let header_lower = line.to_lowercase();\n            if header_lower.contains(\"agent conversation\")\n                || header_lower.contains(\"agent output\")\n                || header_lower.contains(\"execution result\")\n            {\n                skip_section = true;\n                continue; // Skip this header line\n            } else {\n                skip_section = false;\n            }\n        }\n\n        // Include line if we're not in a skipped section\n        if !skip_section {\n            result.push(line);\n        }\n    }\n\n    result.join(\"\\n\").trim_end().to_string()\n}\n\n/// Output cleaned spec content for the agent to read.\npub fn cmd_prep(spec_id: \u0026str, clean: bool, specs_dir: \u0026Path) -\u003e Result\u003c()\u003e {\n    // Load the spec\n    let all_specs = spec::load_all_specs(specs_dir)?;\n    let spec = all_specs\n        .iter()\n        .find(|s| s.id == spec_id || s.id.ends_with(spec_id))\n        .cloned()\n        .with_context(|| format!(\"Spec not found: {}\", spec_id))?;\n\n    // Get the body content\n    let body = if clean {\n        strip_agent_conversation(\u0026spec.body)\n    } else {\n        spec.body.clone()\n    };\n\n    // Output the spec content\n    println!(\"{}\", body);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_strip_agent_conversation() {\n        let body = r#\"# My Spec\n\nSome content here.\n\n## Agent Conversation\n\nThis should be removed.\nMore agent output.\n\n## Other Section\n\nThis should stay.\"#;\n\n        let result = strip_agent_conversation(body);\n        assert!(!result.contains(\"Agent Conversation\"));\n        assert!(!result.contains(\"This should be removed\"));\n        assert!(result.contains(\"My Spec\"));\n        assert!(result.contains(\"Some content here\"));\n        assert!(result.contains(\"Other Section\"));\n    }\n\n    #[test]\n    fn test_strip_execution_result() {\n        let body = r#\"# Spec Title\n\nContent.\n\n## Execution Result\n\nAgent output here.\n\n## Acceptance Criteria\n\n- [ ] Item\"#;\n\n        let result = strip_agent_conversation(body);\n        assert!(!result.contains(\"Execution Result\"));\n        assert!(!result.contains(\"Agent output\"));\n        assert!(result.contains(\"Spec Title\"));\n        assert!(result.contains(\"Acceptance Criteria\"));\n    }\n\n    #[test]\n    fn test_preserve_level_3_headers() {\n        let body = r#\"# Spec\n\n## Instructions\n\n### Subsection\n\nThis is level 3, not a section header.\n\n## Agent Conversation\n\nShould remove.\"#;\n\n        let result = strip_agent_conversation(body);\n        assert!(!result.contains(\"Agent Conversation\"));\n        // Level 3 headers should be preserved as they're part of content\n        assert!(result.contains(\"### Subsection\"));\n        assert!(result.contains(\"This is level 3\"));\n    }\n\n    #[test]\n    fn test_no_agent_sections() {\n        let body = r#\"# Spec\n\n## Instructions\n\nDo this work.\n\n## Acceptance Criteria\n\n- [ ] Item\"#;\n\n        let result = strip_agent_conversation(body);\n        assert_eq!(result, body);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":20}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":26,"address":[],"length":0,"stats":{"Line":47}},{"line":28,"address":[],"length":0,"stats":{"Line":95}},{"line":29,"address":[],"length":0,"stats":{"Line":24}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":71}},{"line":43,"address":[],"length":0,"stats":{"Line":62}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":26},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","refresh.rs"],"content":"//! Refresh command to update dependency status for all specs.\n//!\n//! This command reloads all specs from disk and recalculates their dependency\n//! status, showing what changed (newly ready vs blocked).\n\nuse anyhow::Result;\nuse colored::Colorize;\n\nuse chant::spec::{load_all_specs, Spec, SpecStatus};\n\n/// Get blocking dependencies for a spec.\nfn get_blocking_dependencies(spec: \u0026Spec, all_specs: \u0026[Spec]) -\u003e Vec\u003cString\u003e {\n    let mut blockers = Vec::new();\n\n    if let Some(deps) = \u0026spec.frontmatter.depends_on {\n        for dep_id in deps {\n            let dep = all_specs.iter().find(|s| s.id == *dep_id);\n            match dep {\n                Some(d) if d.frontmatter.status == SpecStatus::Completed =\u003e continue,\n                Some(d) =\u003e blockers.push(format!(\n                    \"{} ({})\",\n                    dep_id,\n                    status_label(\u0026d.frontmatter.status)\n                )),\n                None =\u003e blockers.push(format!(\"{} (not found)\", dep_id)),\n            }\n        }\n    }\n\n    blockers\n}\n\n/// Get a short label for a status.\nfn status_label(status: \u0026SpecStatus) -\u003e \u0026'static str {\n    match status {\n        SpecStatus::Pending =\u003e \"pending\",\n        SpecStatus::InProgress =\u003e \"in_progress\",\n        SpecStatus::Paused =\u003e \"paused\",\n        SpecStatus::Completed =\u003e \"completed\",\n        SpecStatus::Failed =\u003e \"failed\",\n        SpecStatus::NeedsAttention =\u003e \"needs_attention\",\n        SpecStatus::Ready =\u003e \"ready\",\n        SpecStatus::Blocked =\u003e \"blocked\",\n        SpecStatus::Cancelled =\u003e \"cancelled\",\n    }\n}\n\n/// Execute the refresh command.\n///\n/// Reloads all specs from disk, recalculates dependency status, and reports\n/// what changed.\npub fn cmd_refresh(verbose: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    println!(\"Checking dependency status...\");\n\n    // Load all specs fresh from disk (this applies blocked status automatically)\n    let specs = load_all_specs(\u0026specs_dir)?;\n\n    let total = specs.len();\n    let completed = specs\n        .iter()\n        .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n        .count();\n    let ready: Vec\u003c_\u003e = specs.iter().filter(|s| s.is_ready(\u0026specs)).collect();\n    let blocked: Vec\u003c_\u003e = specs\n        .iter()\n        .filter(|s| {\n            s.frontmatter.status == SpecStatus::Blocked\n                || (s.frontmatter.status == SpecStatus::Pending \u0026\u0026 s.is_blocked(\u0026specs))\n        })\n        .collect();\n    let in_progress = specs\n        .iter()\n        .filter(|s| s.frontmatter.status == SpecStatus::InProgress)\n        .count();\n    let pending_not_blocked = specs\n        .iter()\n        .filter(|s| s.frontmatter.status == SpecStatus::Pending \u0026\u0026 !s.is_blocked(\u0026specs))\n        .count();\n\n    println!(\"{} Refreshed {} specs\", \"â\".green(), total);\n    println!(\"  {}: {}\", \"Completed\".green(), completed);\n    println!(\"  {}: {}\", \"Ready\".cyan(), ready.len());\n    println!(\"  {}: {}\", \"In Progress\".yellow(), in_progress);\n    println!(\"  {}: {}\", \"Pending\".white(), pending_not_blocked);\n    println!(\"  {}: {}\", \"Blocked\".red(), blocked.len());\n\n    if verbose {\n        if !ready.is_empty() {\n            println!(\"\\n{}\", \"Ready specs:\".bold());\n            for spec in \u0026ready {\n                if let Some(title) = \u0026spec.title {\n                    println!(\"  {} {} {}\", \"â\".green(), spec.id, title.dimmed());\n                } else {\n                    println!(\"  {} {}\", \"â\".green(), spec.id);\n                }\n            }\n        }\n\n        if !blocked.is_empty() {\n            println!(\"\\n{}\", \"Blocked specs:\".bold());\n            for spec in \u0026blocked {\n                let blockers = get_blocking_dependencies(spec, \u0026specs);\n                let title = spec.title.as_deref().unwrap_or(\"\");\n                if blockers.is_empty() {\n                    // Blocked by prior sibling or other reason\n                    println!(\"  {} {} {}\", \"â\".red(), spec.id, title.dimmed());\n                } else {\n                    println!(\n                        \"  {} {} {} (blocked by: {})\",\n                        \"â\".red(),\n                        spec.id,\n                        title.dimmed(),\n                        blockers.join(\", \")\n                    );\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::spec::SpecFrontmatter;\n\n    #[test]\n    fn test_get_blocking_dependencies_none() {\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let blockers = get_blocking_dependencies(\u0026spec, \u0026[]);\n        assert!(blockers.is_empty());\n    }\n\n    #[test]\n    fn test_get_blocking_dependencies_unmet() {\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let dependency = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Dependency\".to_string()),\n            body: \"# Dependency\\n\\nBody.\".to_string(),\n        };\n\n        let blockers = get_blocking_dependencies(\u0026spec, \u0026[dependency]);\n        assert_eq!(blockers.len(), 1);\n        assert!(blockers[0].contains(\"2026-01-27-002-def\"));\n        assert!(blockers[0].contains(\"pending\"));\n    }\n\n    #[test]\n    fn test_get_blocking_dependencies_met() {\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let dependency = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Dependency\".to_string()),\n            body: \"# Dependency\\n\\nBody.\".to_string(),\n        };\n\n        let blockers = get_blocking_dependencies(\u0026spec, \u0026[dependency]);\n        assert!(blockers.is_empty());\n    }\n\n    #[test]\n    fn test_get_blocking_dependencies_not_found() {\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: Some(vec![\"nonexistent-spec\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let blockers = get_blocking_dependencies(\u0026spec, \u0026[]);\n        assert_eq!(blockers.len(), 1);\n        assert!(blockers[0].contains(\"nonexistent-spec\"));\n        assert!(blockers[0].contains(\"not found\"));\n    }\n\n    #[test]\n    fn test_status_label() {\n        assert_eq!(status_label(\u0026SpecStatus::Pending), \"pending\");\n        assert_eq!(status_label(\u0026SpecStatus::Completed), \"completed\");\n        assert_eq!(status_label(\u0026SpecStatus::Blocked), \"blocked\");\n        assert_eq!(status_label(\u0026SpecStatus::InProgress), \"in_progress\");\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":15,"address":[],"length":0,"stats":{"Line":7}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":13}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":5}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":5}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":17,"coverable":65},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","search.rs"],"content":"//! Search command handler for searching specs by title and body content\n//!\n//! Supports case-insensitive and case-sensitive search, filtering by date,\n//! status, type, labels, and archive scope. Includes interactive wizard mode\n//! when no query is provided.\n\nuse anyhow::Result;\nuse atty;\nuse chrono::{Duration, Local, NaiveDate};\nuse colored::Colorize;\n\nuse chant::paths::ARCHIVE_DIR;\nuse chant::spec::{self, Spec};\n\nuse crate::render;\n\n/// Print usage hint for search command in non-TTY contexts\nfn print_search_usage_hint() {\n    println!(\"Usage: chant search \u003cQUERY\u003e\\n\");\n    println!(\"Examples:\");\n    println!(\"  chant search \\\"authentication\\\"\");\n    println!(\"  chant search --status pending \\\"api\\\"\");\n    println!(\"  chant search --label bugfix\\n\");\n    println!(\"Run 'chant search --help' for all options.\");\n}\n\n/// Search options for filtering and display\n#[derive(Debug, Clone)]\npub struct SearchOptions {\n    pub query: String,\n    pub title_only: bool,\n    pub body_only: bool,\n    pub case_sensitive: bool,\n    pub status_filter: Option\u003cString\u003e,\n    pub type_filter: Option\u003cString\u003e,\n    pub label_filters: Vec\u003cString\u003e,\n    pub since: Option\u003cNaiveDate\u003e,\n    pub until: Option\u003cNaiveDate\u003e,\n    pub active_only: bool,\n    pub archived_only: bool,\n    pub global: bool,\n    pub repo: Option\u003cString\u003e,\n}\n\n/// Parse a date specification string\nfn parse_date_spec(spec: \u0026str) -\u003e Result\u003cNaiveDate\u003e {\n    let today = Local::now().naive_local().date();\n\n    // Check if it's a relative spec like \"7d\", \"2w\", \"1m\"\n    if let Some(days_str) = spec.strip_suffix('d') {\n        if let Ok(days) = days_str.parse::\u003ci64\u003e() {\n            return Ok(today - Duration::days(days));\n        }\n    }\n\n    if let Some(weeks_str) = spec.strip_suffix('w') {\n        if let Ok(weeks) = weeks_str.parse::\u003ci64\u003e() {\n            return Ok(today - Duration::weeks(weeks));\n        }\n    }\n\n    if let Some(months_str) = spec.strip_suffix('m') {\n        if let Ok(months) = months_str.parse::\u003ci64\u003e() {\n            return Ok(today - Duration::days(months * 30));\n        }\n    }\n\n    // Try parsing as YYYY-MM-DD\n    if let Ok(date) = NaiveDate::parse_from_str(spec, \"%Y-%m-%d\") {\n        return Ok(date);\n    }\n\n    anyhow::bail!(\n        \"Invalid date format: {}. Use Nd, Nw, Nm, or YYYY-MM-DD\",\n        spec\n    )\n}\n\n/// Extract date from spec ID (YYYY-MM-DD prefix)\nfn spec_date_from_id(spec_id: \u0026str) -\u003e Option\u003cNaiveDate\u003e {\n    // Spec ID format: YYYY-MM-DD-XXX-abc\n    let parts: Vec\u003c\u0026str\u003e = spec_id.split('-').collect();\n    if parts.len() \u003e= 3 {\n        let date_str = format!(\"{}-{}-{}\", parts[0], parts[1], parts[2]);\n        return NaiveDate::parse_from_str(\u0026date_str, \"%Y-%m-%d\").ok();\n    }\n    None\n}\n\n/// Check if a spec matches the search criteria\nfn matches_search(spec: \u0026Spec, opts: \u0026SearchOptions) -\u003e bool {\n    // Text search\n    let (search_title, search_body) = match (opts.title_only, opts.body_only) {\n        (true, _) =\u003e (true, false),\n        (false, true) =\u003e (false, true),\n        _ =\u003e (true, true),\n    };\n\n    let mut text_match = false;\n\n    if search_title {\n        let title = spec.title.as_deref().unwrap_or(\"\");\n        if opts.case_sensitive {\n            text_match = title.contains(\u0026opts.query);\n        } else {\n            text_match = title.to_lowercase().contains(\u0026opts.query.to_lowercase());\n        }\n    }\n\n    if !text_match \u0026\u0026 search_body {\n        if opts.case_sensitive {\n            text_match = spec.body.contains(\u0026opts.query);\n        } else {\n            text_match = spec\n                .body\n                .to_lowercase()\n                .contains(\u0026opts.query.to_lowercase());\n        }\n    }\n\n    if !text_match {\n        return false;\n    }\n\n    // Status filter\n    if let Some(status) = \u0026opts.status_filter {\n        let status_match = match status.as_str() {\n            \"pending\" =\u003e spec.frontmatter.status == chant::spec::SpecStatus::Pending,\n            \"ready\" =\u003e spec.frontmatter.status == chant::spec::SpecStatus::Ready,\n            \"in_progress\" =\u003e spec.frontmatter.status == chant::spec::SpecStatus::InProgress,\n            \"completed\" =\u003e spec.frontmatter.status == chant::spec::SpecStatus::Completed,\n            \"failed\" =\u003e spec.frontmatter.status == chant::spec::SpecStatus::Failed,\n            _ =\u003e false,\n        };\n        if !status_match {\n            return false;\n        }\n    }\n\n    // Type filter\n    if let Some(type_filter) = \u0026opts.type_filter {\n        if spec.frontmatter.r#type != *type_filter {\n            return false;\n        }\n    }\n\n    // Label filters (OR logic - any matching label)\n    if !opts.label_filters.is_empty() {\n        let has_label = if let Some(spec_labels) = \u0026spec.frontmatter.labels {\n            opts.label_filters.iter().any(|l| spec_labels.contains(l))\n        } else {\n            false\n        };\n        if !has_label {\n            return false;\n        }\n    }\n\n    // Date range filter\n    if let Some(since) = opts.since {\n        if let Some(spec_date) = spec_date_from_id(\u0026spec.id) {\n            if spec_date \u003c since {\n                return false;\n            }\n        }\n    }\n\n    if let Some(until) = opts.until {\n        if let Some(spec_date) = spec_date_from_id(\u0026spec.id) {\n            if spec_date \u003e until {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n\n/// Run the interactive search wizard\nfn run_wizard() -\u003e Result\u003c()\u003e {\n    use dialoguer::theme::ColorfulTheme;\n    use dialoguer::{Confirm, Input, Select};\n\n    let theme = ColorfulTheme::default();\n\n    // Get search query\n    let query: String = Input::with_theme(\u0026theme)\n        .with_prompt(\"Search query\")\n        .interact()?;\n\n    if query.is_empty() {\n        println!(\"Search query cannot be empty.\");\n        return Ok(());\n    }\n\n    // Select search scope\n    let scope_idx = Select::with_theme(\u0026theme)\n        .with_prompt(\"Search in\")\n        .default(0)\n        .items(\u0026[\"Title + Body\", \"Title only\", \"Body only\"])\n        .interact()?;\n\n    let (title_only, body_only) = match scope_idx {\n        0 =\u003e (false, false),\n        1 =\u003e (true, false),\n        2 =\u003e (false, true),\n        _ =\u003e (false, false),\n    };\n\n    // Select date range\n    let date_options = vec![\n        \"Any time\",\n        \"Last 7 days (--since 7d)\",\n        \"Last 2 weeks (--since 2w)\",\n        \"Last month (--since 1m)\",\n        \"Custom...\",\n    ];\n    let date_idx = Select::with_theme(\u0026theme)\n        .with_prompt(\"Date range\")\n        .default(0)\n        .items(\u0026date_options)\n        .interact()?;\n\n    let (since_opt, until_opt): (Option\u003cString\u003e, Option\u003cString\u003e) = match date_idx {\n        0 =\u003e (None, None),\n        1 =\u003e (Some(\"7d\".to_string()), None),\n        2 =\u003e (Some(\"2w\".to_string()), None),\n        3 =\u003e (Some(\"1m\".to_string()), None),\n        4 =\u003e {\n            let custom: String = Input::with_theme(\u0026theme)\n                .with_prompt(\"Date spec (e.g., 7d, 2w, 1m, or YYYY-MM-DD)\")\n                .interact()?;\n            (Some(custom), None)\n        }\n        _ =\u003e (None, None),\n    };\n\n    // Include archived?\n    let include_archived = Confirm::with_theme(\u0026theme)\n        .with_prompt(\"Include archived specs?\")\n        .default(true)\n        .interact()?;\n\n    // Status filter\n    let status_options = vec![\n        \"Any\",\n        \"pending\",\n        \"ready\",\n        \"in_progress\",\n        \"completed\",\n        \"failed\",\n    ];\n    let status_idx = Select::with_theme(\u0026theme)\n        .with_prompt(\"Filter by status\")\n        .default(0)\n        .items(\u0026status_options)\n        .interact()?;\n\n    let status_filter = match status_idx {\n        0 =\u003e None,\n        _ =\u003e Some(status_options[status_idx].to_string()),\n    };\n\n    // Type filter\n    let type_options = vec![\"Any\", \"code\", \"task\", \"documentation\", \"research\"];\n    let type_idx = Select::with_theme(\u0026theme)\n        .with_prompt(\"Filter by type\")\n        .default(0)\n        .items(\u0026type_options)\n        .interact()?;\n\n    let type_filter = match type_idx {\n        0 =\u003e None,\n        _ =\u003e Some(type_options[type_idx].to_string()),\n    };\n\n    let opts = SearchOptions {\n        query,\n        title_only,\n        body_only,\n        case_sensitive: false,\n        status_filter,\n        type_filter,\n        label_filters: vec![],\n        since: since_opt.as_deref().and_then(|s| parse_date_spec(s).ok()),\n        until: until_opt.as_deref().and_then(|s| parse_date_spec(s).ok()),\n        // include_archived=true means search both (neither flag set)\n        // include_archived=false means active only\n        active_only: !include_archived,\n        archived_only: false,\n        global: false,\n        repo: None,\n    };\n\n    perform_search(\u0026opts)\n}\n\n/// Perform the actual search and display results\nfn perform_search(opts: \u0026SearchOptions) -\u003e Result\u003c()\u003e {\n    let mut all_specs = Vec::new();\n    let specs_dir = std::path::PathBuf::from(\".\");\n\n    if opts.global || opts.repo.is_some() {\n        // Load specs from multiple repos\n        use chant::config::Config;\n        use std::path::PathBuf;\n\n        let config = Config::load_merged()?;\n\n        if config.repos.is_empty() {\n            anyhow::bail!(\n                \"No repos configured in global config. \\\n                 Please add repos to ~/.config/chant/config.md or use local mode without --global/--repo\"\n            );\n        }\n\n        // If repo filter is specified, validate it exists\n        if let Some(repo_name) = \u0026opts.repo {\n            if !config.repos.iter().any(|r| \u0026r.name == repo_name) {\n                anyhow::bail!(\n                    \"Repository '{}' not found in global config. Available repos: {}\",\n                    repo_name,\n                    config\n                        .repos\n                        .iter()\n                        .map(|r| r.name.as_str())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\", \")\n                );\n            }\n        }\n\n        for repo_config in \u0026config.repos {\n            // Skip if filtering by repo and this isn't it\n            if let Some(filter) = \u0026opts.repo {\n                if \u0026repo_config.name != filter {\n                    continue;\n                }\n            }\n\n            // Expand path\n            let repo_path = shellexpand::tilde(\u0026repo_config.path).to_string();\n            let repo_path = PathBuf::from(repo_path);\n\n            let active_specs_dir = repo_path.join(\".chant/specs\");\n            let archive_specs_dir = repo_path.join(\".chant/archive\");\n\n            // Load active specs\n            if !opts.archived_only \u0026\u0026 active_specs_dir.exists() {\n                match spec::load_all_specs(\u0026active_specs_dir) {\n                    Ok(mut repo_specs) =\u003e {\n                        for spec in \u0026mut repo_specs {\n                            spec.id = format!(\"{}:{}\", repo_config.name, spec.id);\n                        }\n                        all_specs.extend(repo_specs);\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\n                            \"{} Failed to load specs from repo '{}': {}\",\n                            \"â \".yellow(),\n                            repo_config.name,\n                            e\n                        );\n                    }\n                }\n            }\n\n            // Load archived specs\n            if !opts.active_only \u0026\u0026 archive_specs_dir.exists() {\n                match spec::load_all_specs(\u0026archive_specs_dir) {\n                    Ok(mut repo_specs) =\u003e {\n                        for spec in \u0026mut repo_specs {\n                            spec.id = format!(\"{}:{}\", repo_config.name, spec.id);\n                        }\n                        all_specs.extend(repo_specs);\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\n                            \"{} Failed to load archived specs from repo '{}': {}\",\n                            \"â \".yellow(),\n                            repo_config.name,\n                            e\n                        );\n                    }\n                }\n            }\n        }\n    } else {\n        // Load local specs\n        let specs_dir = crate::cmd::ensure_initialized()?;\n\n        // Load active specs\n        if !opts.archived_only {\n            all_specs.extend(spec::load_all_specs(\u0026specs_dir)?);\n        }\n\n        // Load archived specs\n        if !opts.active_only {\n            let archive_path = std::path::PathBuf::from(ARCHIVE_DIR);\n            if archive_path.exists() {\n                let mut archived = spec::load_all_specs(\u0026archive_path)?;\n                all_specs.append(\u0026mut archived);\n            }\n        }\n    }\n\n    // Filter specs\n    let mut results: Vec\u003c(bool, \u0026Spec)\u003e = all_specs\n        .iter()\n        .filter(|s| matches_search(s, opts))\n        .map(|s| {\n            // For global search, always treat as potentially archived\n            // (we can't easily check if a cross-repo spec is archived without more context)\n            let is_archived = if opts.global || opts.repo.is_some() {\n                s.id.contains(\"archive\")\n            } else {\n                !specs_dir.join(format!(\"{}.md\", s.id)).exists()\n            };\n            (is_archived, s)\n        })\n        .collect();\n\n    // Sort by ID\n    results.sort_by(|a, b| a.1.id.cmp(\u0026b.1.id));\n\n    if results.is_empty() {\n        println!(\"No specs found matching \\\"{}\\\"\", opts.query);\n        return Ok(());\n    }\n\n    // Display results\n    for (is_archived, spec) in \u0026results {\n        let icon = if spec.frontmatter.r#type == \"conflict\" {\n            \"â¡\".yellow()\n        } else {\n            render::status_icon(\u0026spec.frontmatter.status)\n        };\n\n        let title = spec.title.as_deref().unwrap_or(\"(no title)\");\n        let archive_label = if *is_archived { \" [archived]\" } else { \"\" };\n\n        println!(\n            \"{} {} {}{}\",\n            icon,\n            spec.id.cyan(),\n            title,\n            archive_label.dimmed()\n        );\n    }\n\n    let count = results.len();\n    let matches_text = if count == 1 { \"spec\" } else { \"specs\" };\n    println!(\n        \"\\nFound {} {} matching \\\"{}\\\"\",\n        count, matches_text, opts.query\n    );\n\n    Ok(())\n}\n\n/// Execute the search command with the given options\npub fn cmd_search(opts: Option\u003cSearchOptions\u003e) -\u003e Result\u003c()\u003e {\n    // If no options provided, check for TTY\n    if opts.is_none() {\n        // If not a TTY, print usage hint instead of launching wizard\n        if !atty::is(atty::Stream::Stdin) {\n            print_search_usage_hint();\n            return Ok(());\n        }\n        return run_wizard();\n    }\n\n    perform_search(\u0026opts.unwrap())\n}\n\n/// Build search options from command-line arguments\n#[allow(clippy::too_many_arguments)]\npub fn build_search_options(\n    query: Option\u003cString\u003e,\n    title_only: bool,\n    body_only: bool,\n    case_sensitive: bool,\n    status: Option\u003cString\u003e,\n    type_: Option\u003cString\u003e,\n    label: Vec\u003cString\u003e,\n    since: Option\u003cString\u003e,\n    until: Option\u003cString\u003e,\n    active_only: bool,\n    archived_only: bool,\n    global: bool,\n    repo: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cOption\u003cSearchOptions\u003e\u003e {\n    if query.is_none() {\n        return Ok(None);\n    }\n\n    let query = query.unwrap();\n    Ok(Some(SearchOptions {\n        query,\n        title_only,\n        body_only,\n        case_sensitive,\n        status_filter: status,\n        type_filter: type_,\n        label_filters: label,\n        since: since.as_deref().and_then(|s| parse_date_spec(s).ok()),\n        until: until.as_deref().and_then(|s| parse_date_spec(s).ok()),\n        active_only,\n        archived_only,\n        global,\n        repo: repo.map(|s| s.to_string()),\n    }))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_date_spec_days() {\n        let date = parse_date_spec(\"7d\").unwrap();\n        let today = Local::now().naive_local().date();\n        assert_eq!(date, today - Duration::days(7));\n    }\n\n    #[test]\n    fn test_parse_date_spec_weeks() {\n        let date = parse_date_spec(\"2w\").unwrap();\n        let today = Local::now().naive_local().date();\n        assert_eq!(date, today - Duration::weeks(2));\n    }\n\n    #[test]\n    fn test_parse_date_spec_months() {\n        let date = parse_date_spec(\"1m\").unwrap();\n        let today = Local::now().naive_local().date();\n        assert_eq!(date, today - Duration::days(30));\n    }\n\n    #[test]\n    fn test_parse_date_spec_absolute() {\n        let date = parse_date_spec(\"2026-01-20\").unwrap();\n        assert_eq!(date, NaiveDate::from_ymd_opt(2026, 1, 20).unwrap());\n    }\n\n    #[test]\n    fn test_spec_date_from_id() {\n        let date = spec_date_from_id(\"2026-01-24-001-abc\");\n        assert_eq!(date, NaiveDate::from_ymd_opt(2026, 1, 24));\n    }\n\n    #[test]\n    fn test_spec_date_from_id_with_suffix() {\n        let date = spec_date_from_id(\"2026-01-24-001-abc.1\");\n        assert_eq!(date, NaiveDate::from_ymd_opt(2026, 1, 24));\n    }\n\n    #[test]\n    fn test_text_match_case_insensitive() {\n        // Create a minimal spec for testing\n        let spec = Spec {\n            id: \"2026-01-24-001-abc\".to_string(),\n            frontmatter: chant::spec::SpecFrontmatter::default(),\n            title: Some(\"Add user Authentication\".to_string()),\n            body: \"This spec adds user auth support.\".to_string(),\n        };\n\n        let opts = SearchOptions {\n            query: \"auth\".to_string(),\n            title_only: false,\n            body_only: false,\n            case_sensitive: false,\n            status_filter: None,\n            type_filter: None,\n            label_filters: vec![],\n            since: None,\n            until: None,\n            active_only: false,\n            archived_only: false,\n            global: false,\n            repo: None,\n        };\n\n        assert!(matches_search(\u0026spec, \u0026opts));\n\n        let opts2 = SearchOptions {\n            query: \"AUTH\".to_string(),\n            ..opts.clone()\n        };\n\n        assert!(matches_search(\u0026spec, \u0026opts2));\n    }\n\n    #[test]\n    fn test_text_match_case_sensitive() {\n        let spec = Spec {\n            id: \"2026-01-24-001-abc\".to_string(),\n            frontmatter: chant::spec::SpecFrontmatter::default(),\n            title: Some(\"Add user Authentication\".to_string()),\n            body: \"This spec adds user auth support.\".to_string(),\n        };\n\n        let opts = SearchOptions {\n            query: \"Authentication\".to_string(),\n            title_only: false,\n            body_only: false,\n            case_sensitive: true,\n            status_filter: None,\n            type_filter: None,\n            label_filters: vec![],\n            since: None,\n            until: None,\n            active_only: false,\n            archived_only: false,\n            global: false,\n            repo: None,\n        };\n\n        assert!(matches_search(\u0026spec, \u0026opts));\n\n        let opts2 = SearchOptions {\n            query: \"authentication\".to_string(),\n            ..opts.clone()\n        };\n\n        assert!(!matches_search(\u0026spec, \u0026opts2));\n    }\n\n    #[test]\n    fn test_title_only_filter() {\n        let spec = Spec {\n            id: \"2026-01-24-001-abc\".to_string(),\n            frontmatter: chant::spec::SpecFrontmatter::default(),\n            title: Some(\"Add user\".to_string()),\n            body: \"This is about authentication.\".to_string(),\n        };\n\n        // Should match in title\n        let opts = SearchOptions {\n            query: \"user\".to_string(),\n            title_only: true,\n            body_only: false,\n            case_sensitive: false,\n            status_filter: None,\n            type_filter: None,\n            label_filters: vec![],\n            since: None,\n            until: None,\n            active_only: false,\n            archived_only: false,\n            global: false,\n            repo: None,\n        };\n\n        assert!(matches_search(\u0026spec, \u0026opts));\n\n        // Should not match in body only\n        let opts2 = SearchOptions {\n            query: \"authentication\".to_string(),\n            title_only: true,\n            ..opts.clone()\n        };\n\n        assert!(!matches_search(\u0026spec, \u0026opts2));\n    }\n\n    #[test]\n    fn test_body_only_filter() {\n        let spec = Spec {\n            id: \"2026-01-24-001-abc\".to_string(),\n            frontmatter: chant::spec::SpecFrontmatter::default(),\n            title: Some(\"Add user\".to_string()),\n            body: \"This is about authentication.\".to_string(),\n        };\n\n        // Should match in body\n        let opts = SearchOptions {\n            query: \"authentication\".to_string(),\n            title_only: false,\n            body_only: true,\n            case_sensitive: false,\n            status_filter: None,\n            type_filter: None,\n            label_filters: vec![],\n            since: None,\n            until: None,\n            active_only: false,\n            archived_only: false,\n            global: false,\n            repo: None,\n        };\n\n        assert!(matches_search(\u0026spec, \u0026opts));\n\n        // Should not match in title only\n        let opts2 = SearchOptions {\n            query: \"user\".to_string(),\n            ..opts.clone()\n        };\n\n        assert!(!matches_search(\u0026spec, \u0026opts2));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":24}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":30}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":12}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":5}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}}],"covered":44,"coverable":221},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","silent.rs"],"content":"//! Silent mode management command\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Enable or disable silent mode for project or globally\npub fn cmd_silent(global: bool, off: bool, status: bool) -\u003e Result\u003c()\u003e {\n    if status {\n        return show_status(global);\n    }\n\n    if off {\n        disable_silent_mode(global)\n    } else {\n        enable_silent_mode(global)\n    }\n}\n\nfn show_status(global: bool) -\u003e Result\u003c()\u003e {\n    if global {\n        // Check global config\n        if let Some(config_path) = chant::config::global_config_path() {\n            if config_path.exists() {\n                let silent = check_silent_in_config(\u0026config_path)?;\n                if silent {\n                    println!(\"{} Globally enabled\", \"â\".green());\n                } else {\n                    println!(\"{} Globally disabled\", \"â\".dimmed());\n                }\n            } else {\n                println!(\"{} Globally disabled (no global config)\", \"â\".dimmed());\n            }\n        } else {\n            println!(\"{} Cannot determine global config path\", \"â\".red());\n        }\n    } else {\n        // Check project config\n        let project_config_path = Path::new(\".chant/config.md\");\n        if !project_config_path.exists() {\n            anyhow::bail!(\"Not in a chant project (no .chant/config.md found)\");\n        }\n\n        let silent = check_silent_in_config(project_config_path)?;\n\n        // Also check if .chant/ is in git/info/exclude\n        let in_git_exclude = is_in_git_exclude()?;\n\n        if silent {\n            println!(\"{} Enabled for this project\", \"â\".green());\n            if in_git_exclude {\n                println!(\"  {} .chant/ is excluded from git\", \"â\".dimmed());\n            } else {\n                println!(\n                    \"  {} .chant/ is NOT excluded from git (inconsistent)\",\n                    \"â \".yellow()\n                );\n            }\n        } else {\n            println!(\"{} Disabled for this project\", \"â\".dimmed());\n            if in_git_exclude {\n                println!(\n                    \"  {} .chant/ is excluded from git (inconsistent)\",\n                    \"â \".yellow()\n                );\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn enable_silent_mode(global: bool) -\u003e Result\u003c()\u003e {\n    if global {\n        enable_global_silent()?;\n        println!(\"{} Silent mode enabled globally\", \"â\".green());\n        println!(\"  All new and existing projects will default to silent mode\");\n    } else {\n        enable_project_silent()?;\n        println!(\"{} Silent mode enabled for this project\", \"â\".green());\n        println!(\"  {} .chant/ added to .git/info/exclude\", \"â\".dimmed());\n        println!(\"  {} Specs will not be committed\", \"â¹\".blue());\n    }\n\n    Ok(())\n}\n\nfn disable_silent_mode(global: bool) -\u003e Result\u003c()\u003e {\n    if global {\n        disable_global_silent()?;\n        println!(\"{} Silent mode disabled globally\", \"â\".green());\n    } else {\n        disable_project_silent()?;\n        println!(\"{} Silent mode disabled for this project\", \"â\".green());\n        println!(\"  {} .chant/ removed from .git/info/exclude\", \"â\".dimmed());\n        println!(\"  {} Specs can now be committed\", \"â¹\".blue());\n    }\n\n    Ok(())\n}\n\nfn enable_global_silent() -\u003e Result\u003c()\u003e {\n    let config_path =\n        chant::config::global_config_path().context(\"Cannot determine global config path\")?;\n\n    // Create config directory if it doesn't exist\n    if let Some(parent) = config_path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    update_config_silent(\u0026config_path, true)?;\n\n    Ok(())\n}\n\nfn disable_global_silent() -\u003e Result\u003c()\u003e {\n    let config_path =\n        chant::config::global_config_path().context(\"Cannot determine global config path\")?;\n\n    if !config_path.exists() {\n        anyhow::bail!(\"No global config found\");\n    }\n\n    update_config_silent(\u0026config_path, false)?;\n\n    Ok(())\n}\n\nfn enable_project_silent() -\u003e Result\u003c()\u003e {\n    let config_path = Path::new(\".chant/config.md\");\n    if !config_path.exists() {\n        anyhow::bail!(\"Not in a chant project (no .chant/config.md found)\");\n    }\n\n    // Update config\n    update_config_silent(config_path, true)?;\n\n    // Add to .git/info/exclude\n    add_to_git_exclude()?;\n\n    // Remove from .gitignore if present\n    remove_from_gitignore()?;\n\n    Ok(())\n}\n\nfn disable_project_silent() -\u003e Result\u003c()\u003e {\n    let config_path = Path::new(\".chant/config.md\");\n    if !config_path.exists() {\n        anyhow::bail!(\"Not in a chant project (no .chant/config.md found)\");\n    }\n\n    // Update config\n    update_config_silent(config_path, false)?;\n\n    // Remove from .git/info/exclude\n    remove_from_git_exclude()?;\n\n    Ok(())\n}\n\nfn update_config_silent(config_path: \u0026Path, enable: bool) -\u003e Result\u003c()\u003e {\n    let content = fs::read_to_string(config_path)\n        .with_context(|| format!(\"Failed to read config from {}\", config_path.display()))?;\n\n    let (frontmatter, body) = chant::spec::split_frontmatter(\u0026content);\n    let frontmatter = frontmatter.context(\"Failed to extract frontmatter from config\")?;\n\n    // Parse as YAML value to manipulate\n    let mut yaml: serde_yaml::Value =\n        serde_yaml::from_str(\u0026frontmatter).context(\"Failed to parse config frontmatter\")?;\n\n    // Update silent field\n    if let Some(mapping) = yaml.as_mapping_mut() {\n        let silent_key = serde_yaml::Value::String(\"silent\".to_string());\n        mapping.insert(silent_key, serde_yaml::Value::Bool(enable));\n    }\n\n    // Serialize back to YAML\n    let updated_frontmatter =\n        serde_yaml::to_string(\u0026yaml).context(\"Failed to serialize updated config\")?;\n\n    // Reconstruct the file\n    let updated_content = format!(\"---\\n{}---\\n{}\", updated_frontmatter, body);\n\n    fs::write(config_path, updated_content)\n        .with_context(|| format!(\"Failed to write config to {}\", config_path.display()))?;\n\n    Ok(())\n}\n\nfn check_silent_in_config(config_path: \u0026Path) -\u003e Result\u003cbool\u003e {\n    let content = fs::read_to_string(config_path)\n        .with_context(|| format!(\"Failed to read config from {}\", config_path.display()))?;\n\n    let (frontmatter, _body) = chant::spec::split_frontmatter(\u0026content);\n    let frontmatter = frontmatter.context(\"Failed to extract frontmatter from config\")?;\n\n    let yaml: serde_yaml::Value =\n        serde_yaml::from_str(\u0026frontmatter).context(\"Failed to parse config frontmatter\")?;\n\n    Ok(yaml\n        .as_mapping()\n        .and_then(|m| m.get(serde_yaml::Value::String(\"silent\".to_string())))\n        .and_then(|v| v.as_bool())\n        .unwrap_or(false))\n}\n\nfn add_to_git_exclude() -\u003e Result\u003c()\u003e {\n    let exclude_path = get_git_exclude_path()?;\n\n    // Create info directory if it doesn't exist\n    if let Some(parent) = exclude_path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    // Read existing exclude file\n    let mut exclude_content = fs::read_to_string(\u0026exclude_path).unwrap_or_default();\n\n    // Add .chant/ if not already present\n    if !exclude_content.contains(\".chant/\") \u0026\u0026 !exclude_content.contains(\".chant\") {\n        if !exclude_content.ends_with('\\n') \u0026\u0026 !exclude_content.is_empty() {\n            exclude_content.push('\\n');\n        }\n        exclude_content.push_str(\".chant/\\n\");\n        fs::write(\u0026exclude_path, exclude_content)?;\n    }\n\n    Ok(())\n}\n\nfn remove_from_git_exclude() -\u003e Result\u003c()\u003e {\n    let exclude_path = get_git_exclude_path()?;\n\n    if !exclude_path.exists() {\n        return Ok(());\n    }\n\n    let exclude_content = fs::read_to_string(\u0026exclude_path)?;\n    let updated_content: String = exclude_content\n        .lines()\n        .filter(|line| {\n            let trimmed = line.trim();\n            trimmed != \".chant/\" \u0026\u0026 trimmed != \".chant\"\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\");\n\n    // Add trailing newline if content is not empty\n    let final_content = if updated_content.is_empty() {\n        updated_content\n    } else {\n        format!(\"{}\\n\", updated_content)\n    };\n\n    fs::write(\u0026exclude_path, final_content)?;\n\n    Ok(())\n}\n\nfn remove_from_gitignore() -\u003e Result\u003c()\u003e {\n    let gitignore_path = Path::new(\".gitignore\");\n\n    if !gitignore_path.exists() {\n        return Ok(());\n    }\n\n    let gitignore_content = fs::read_to_string(gitignore_path)?;\n    let updated_content: String = gitignore_content\n        .lines()\n        .filter(|line| {\n            let trimmed = line.trim();\n            trimmed != \".chant/\" \u0026\u0026 trimmed != \".chant\"\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\");\n\n    // Add trailing newline if content is not empty\n    let final_content = if updated_content.is_empty() {\n        updated_content\n    } else {\n        format!(\"{}\\n\", updated_content)\n    };\n\n    fs::write(gitignore_path, final_content)?;\n\n    Ok(())\n}\n\nfn get_git_exclude_path() -\u003e Result\u003cPathBuf\u003e {\n    let output = std::process::Command::new(\"git\")\n        .args([\"rev-parse\", \"--git-common-dir\"])\n        .output()\n        .context(\"Failed to run git rev-parse\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Not in a git repository\");\n    }\n\n    let git_dir = String::from_utf8(output.stdout)?.trim().to_string();\n    Ok(PathBuf::from(\u0026git_dir).join(\"info/exclude\"))\n}\n\nfn is_in_git_exclude() -\u003e Result\u003cbool\u003e {\n    let exclude_path = get_git_exclude_path()?;\n\n    if !exclude_path.exists() {\n        return Ok(false);\n    }\n\n    let exclude_content = fs::read_to_string(\u0026exclude_path)?;\n    Ok(exclude_content.contains(\".chant/\") || exclude_content.contains(\".chant\"))\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":162},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","site.rs"],"content":"//! Site generation commands\n//!\n//! Commands for generating static documentation sites from specs.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::fs;\nuse std::io::{Read, Write};\nuse std::net::TcpListener;\nuse std::path::{Path, PathBuf};\n\nuse chant::config::Config;\nuse chant::site::{theme, SiteGenerator};\nuse chant::spec::Spec;\n\n/// Path to the theme directory\nconst THEME_DIR: \u0026str = \".chant/site/theme\";\n\n/// Initialize the theme directory with default templates\npub fn cmd_site_init(force: bool) -\u003e Result\u003c()\u003e {\n    let _specs_dir = crate::cmd::ensure_initialized()?;\n\n    let theme_dir = PathBuf::from(THEME_DIR);\n\n    if theme_dir.exists() \u0026\u0026 !force {\n        println!(\n            \"{} Theme directory already exists at {}\",\n            \"Note:\".cyan(),\n            theme_dir.display()\n        );\n        println!(\"Use {} to overwrite existing files\", \"--force\".cyan());\n\n        // List existing files\n        let files = theme::list_theme_files(\u0026theme_dir)?;\n        if !files.is_empty() {\n            println!(\"\\n{}\", \"Existing theme files:\".bold());\n            for file in files {\n                println!(\"  {}\", file);\n            }\n        }\n        return Ok(());\n    }\n\n    // Create parent directory\n    if let Some(parent) = theme_dir.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    let result = theme::init_theme(\u0026theme_dir, force)?;\n\n    if result.has_changes() {\n        println!(\n            \"{} Theme initialized at {}\",\n            \"â\".green(),\n            theme_dir.display()\n        );\n        println!(\"\\n{}\", \"Created files:\".bold());\n        for file in \u0026result.created {\n            let info = theme::get_theme_files()\n                .iter()\n                .find(|f| f.name == file)\n                .map(|f| f.description)\n                .unwrap_or(\"\");\n            println!(\"  {} - {}\", file.cyan(), info.dimmed());\n        }\n\n        if !result.skipped.is_empty() {\n            println!(\"\\n{}\", \"Skipped (already exist):\".yellow());\n            for file in \u0026result.skipped {\n                println!(\"  {}\", file);\n            }\n        }\n\n        println!(\"\\n{}\", \"Next steps:\".bold());\n        println!(\"  1. Edit templates in {}\", theme_dir.display());\n        println!(\n            \"  2. Run {} to generate the site\",\n            \"chant site build\".cyan()\n        );\n        println!(\"  3. Run {} to preview locally\", \"chant site serve\".cyan());\n\n        // Add template variables documentation hint\n        println!(\n            \"\\n{} See {} for template variable documentation\",\n            \"Tip:\".cyan(),\n            \"chant site init --help\".dimmed()\n        );\n    } else {\n        println!(\n            \"{} No files created (all exist). Use {} to overwrite.\",\n            \"Note:\".yellow(),\n            \"--force\".cyan()\n        );\n    }\n\n    Ok(())\n}\n\n/// Build the static site\npub fn cmd_site_build(output: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Load configuration\n    let config = Config::load()?;\n\n    // Determine output directory\n    let output_dir = output\n        .map(PathBuf::from)\n        .unwrap_or_else(|| PathBuf::from(\u0026config.site.output_dir));\n\n    println!(\"{} Building site to {}\", \"â\".cyan(), output_dir.display());\n\n    // Load all specs\n    let specs = load_specs(\u0026specs_dir)?;\n    println!(\"  Found {} specs\", specs.len());\n\n    // Check for custom theme\n    let theme_dir = PathBuf::from(THEME_DIR);\n    let theme_path = if theme_dir.exists() {\n        println!(\"  Using custom theme from {}\", theme_dir.display());\n        Some(theme_dir.as_path())\n    } else {\n        println!(\"  Using embedded default theme\");\n        None\n    };\n\n    // Build the site\n    let generator = SiteGenerator::new(config.site.clone(), specs, theme_path)?;\n    let result = generator.build(\u0026output_dir)?;\n\n    println!(\"\\n{} Site built successfully\", \"â\".green());\n    println!(\"  {} specs included\", result.specs_included);\n    println!(\"  {} files written\", result.files_written);\n    println!(\"  Output: {}\", output_dir.display());\n\n    println!(\"\\n{}\", \"Next steps:\".bold());\n    println!(\n        \"  Preview locally: {}\",\n        \"chant site serve --port 3000\".cyan()\n    );\n    println!(\"  Deploy: Copy {} to your web server\", output_dir.display());\n\n    Ok(())\n}\n\n/// Start a local HTTP server to preview the site\npub fn cmd_site_serve(port: u16, output: Option\u003c\u0026str\u003e) -\u003e Result\u003c()\u003e {\n    let _specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Load configuration for default output dir\n    let config = Config::load()?;\n\n    let output_dir = output\n        .map(PathBuf::from)\n        .unwrap_or_else(|| PathBuf::from(\u0026config.site.output_dir));\n\n    if !output_dir.exists() {\n        anyhow::bail!(\n            \"Site not built yet. Run {} first.\",\n            \"chant site build\".cyan()\n        );\n    }\n\n    // Check if index.html exists\n    if !output_dir.join(\"index.html\").exists() {\n        anyhow::bail!(\n            \"No index.html found in {}. Run {} first.\",\n            output_dir.display(),\n            \"chant site build\".cyan()\n        );\n    }\n\n    // Start simple HTTP server\n    let addr = format!(\"127.0.0.1:{}\", port);\n    let listener =\n        TcpListener::bind(\u0026addr).with_context(|| format!(\"Failed to bind to {}\", addr))?;\n\n    println!(\n        \"{} Serving {} at {}\",\n        \"â\".cyan(),\n        output_dir.display(),\n        format!(\"http://{}\", addr).green()\n    );\n    println!(\"Press {} to stop\", \"Ctrl+C\".yellow());\n\n    for stream in listener.incoming() {\n        match stream {\n            Ok(mut stream) =\u003e {\n                // Read request\n                let mut buffer = [0; 4096];\n                if stream.read(\u0026mut buffer).is_err() {\n                    continue;\n                }\n\n                let request = String::from_utf8_lossy(\u0026buffer);\n                let path = parse_request_path(\u0026request);\n\n                // Serve file\n                let file_path = resolve_file_path(\u0026output_dir, \u0026path);\n                let (status, content_type, body) = read_file(\u0026file_path);\n\n                let response = format!(\n                    \"HTTP/1.1 {}\\r\\nContent-Type: {}\\r\\nContent-Length: {}\\r\\n\\r\\n\",\n                    status,\n                    content_type,\n                    body.len()\n                );\n\n                let _ = stream.write_all(response.as_bytes());\n                let _ = stream.write_all(\u0026body);\n\n                // Log request\n                let status_code = status.split(' ').next().unwrap_or(\"???\");\n                let status_color = if status_code == \"200\" {\n                    status_code.green()\n                } else {\n                    status_code.yellow()\n                };\n                println!(\n                    \"  {} {} {}\",\n                    status_color,\n                    path,\n                    file_path.display().to_string().dimmed()\n                );\n            }\n            Err(e) =\u003e {\n                eprintln!(\"{} Connection error: {}\", \"Error:\".red(), e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Load all specs from the specs directory\nfn load_specs(specs_dir: \u0026Path) -\u003e Result\u003cVec\u003cSpec\u003e\u003e {\n    let mut specs = Vec::new();\n\n    for entry in fs::read_dir(specs_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n            match Spec::load(\u0026path) {\n                Ok(spec) =\u003e specs.push(spec),\n                Err(e) =\u003e {\n                    eprintln!(\n                        \"{} Failed to load {}: {}\",\n                        \"Warning:\".yellow(),\n                        path.display(),\n                        e\n                    );\n                }\n            }\n        }\n    }\n\n    // Sort by ID (most recent first)\n    specs.sort_by(|a, b| b.id.cmp(\u0026a.id));\n\n    Ok(specs)\n}\n\n/// Parse the request path from an HTTP request\nfn parse_request_path(request: \u0026str) -\u003e String {\n    let first_line = request.lines().next().unwrap_or(\"\");\n    let parts: Vec\u003c\u0026str\u003e = first_line.split_whitespace().collect();\n\n    if parts.len() \u003e= 2 {\n        let path = parts[1];\n        // Remove query string\n        let path = path.split('?').next().unwrap_or(path);\n        // URL decode\n        urlencoding_decode(path)\n    } else {\n        \"/\".to_string()\n    }\n}\n\n/// Simple URL decoding\nfn urlencoding_decode(s: \u0026str) -\u003e String {\n    let mut result = String::new();\n    let mut chars = s.chars().peekable();\n\n    while let Some(c) = chars.next() {\n        if c == '%' {\n            let hex: String = chars.by_ref().take(2).collect();\n            if let Ok(byte) = u8::from_str_radix(\u0026hex, 16) {\n                result.push(byte as char);\n            }\n        } else if c == '+' {\n            result.push(' ');\n        } else {\n            result.push(c);\n        }\n    }\n\n    result\n}\n\n/// Resolve the file path for a request\nfn resolve_file_path(root: \u0026Path, request_path: \u0026str) -\u003e PathBuf {\n    let path = request_path.trim_start_matches('/');\n\n    let file_path = if path.is_empty() || path.ends_with('/') {\n        root.join(path).join(\"index.html\")\n    } else {\n        let full_path = root.join(path);\n        if full_path.is_dir() {\n            full_path.join(\"index.html\")\n        } else {\n            full_path\n        }\n    };\n\n    // Security: ensure path is within root\n    if let Ok(canonical) = file_path.canonicalize() {\n        if let Ok(root_canonical) = root.canonicalize() {\n            if canonical.starts_with(\u0026root_canonical) {\n                return canonical;\n            }\n        }\n    }\n\n    file_path\n}\n\n/// Read a file and return status, content type, and body\nfn read_file(path: \u0026Path) -\u003e (\u0026'static str, \u0026'static str, Vec\u003cu8\u003e) {\n    let content_type = match path.extension().and_then(|e| e.to_str()) {\n        Some(\"html\") | Some(\"htm\") =\u003e \"text/html; charset=utf-8\",\n        Some(\"css\") =\u003e \"text/css; charset=utf-8\",\n        Some(\"js\") =\u003e \"application/javascript; charset=utf-8\",\n        Some(\"json\") =\u003e \"application/json; charset=utf-8\",\n        Some(\"png\") =\u003e \"image/png\",\n        Some(\"jpg\") | Some(\"jpeg\") =\u003e \"image/jpeg\",\n        Some(\"gif\") =\u003e \"image/gif\",\n        Some(\"svg\") =\u003e \"image/svg+xml\",\n        Some(\"ico\") =\u003e \"image/x-icon\",\n        _ =\u003e \"application/octet-stream\",\n    };\n\n    match fs::read(path) {\n        Ok(body) =\u003e (\"200 OK\", content_type, body),\n        Err(_) =\u003e (\n            \"404 Not Found\",\n            \"text/html; charset=utf-8\",\n            b\"\u003ch1\u003e404 Not Found\u003c/h1\u003e\".to_vec(),\n        ),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_request_path() {\n        assert_eq!(parse_request_path(\"GET / HTTP/1.1\"), \"/\");\n        assert_eq!(\n            parse_request_path(\"GET /index.html HTTP/1.1\"),\n            \"/index.html\"\n        );\n        assert_eq!(\n            parse_request_path(\"GET /specs/test.html?v=1 HTTP/1.1\"),\n            \"/specs/test.html\"\n        );\n    }\n\n    #[test]\n    fn test_urlencoding_decode() {\n        assert_eq!(urlencoding_decode(\"hello%20world\"), \"hello world\");\n        assert_eq!(urlencoding_decode(\"test+value\"), \"test value\");\n        assert_eq!(urlencoding_decode(\"normal\"), \"normal\");\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":3}},{"line":266,"address":[],"length":0,"stats":{"Line":15}},{"line":267,"address":[],"length":0,"stats":{"Line":15}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":15}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":12}},{"line":283,"address":[],"length":0,"stats":{"Line":24}},{"line":285,"address":[],"length":0,"stats":{"Line":116}},{"line":286,"address":[],"length":0,"stats":{"Line":55}},{"line":287,"address":[],"length":0,"stats":{"Line":5}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":55}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":294,"address":[],"length":0,"stats":{"Line":106}},{"line":298,"address":[],"length":0,"stats":{"Line":6}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":181},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","add.rs"],"content":"//! Spec creation functionality\n//!\n//! Provides the `cmd_add` command function for creating new specs.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::process::Command;\n\nuse chant::config::Config;\nuse chant::derivation::{self, DerivationEngine};\nuse chant::id;\nuse chant::score::ac_quality::calculate_ac_quality;\nuse chant::score::confidence::calculate_confidence;\nuse chant::score::splittability::calculate_splittability;\nuse chant::score::traffic_light::{determine_status, generate_suggestions};\nuse chant::scoring::{calculate_complexity, SpecScore, TrafficLight};\nuse chant::spec;\n\npub fn cmd_add(description: \u0026str, prompt: Option\u003c\u0026str\u003e, needs_approval: bool) -\u003e Result\u003c()\u003e {\n    let config = Config::load()?;\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Generate ID\n    let id = id::generate_id(\u0026specs_dir)?;\n    let filename = format!(\"{}.md\", id);\n    let filepath = specs_dir.join(\u0026filename);\n\n    // Create spec content\n    let prompt_line = match prompt {\n        Some(p) =\u003e format!(\"prompt: {}\\n\", p),\n        None =\u003e String::new(),\n    };\n\n    let approval_line = if needs_approval {\n        \"approval:\\n  required: true\\n  status: pending\\n\"\n    } else {\n        \"\"\n    };\n\n    let content = format!(\n        r#\"---\ntype: code\nstatus: pending\n{}{}---\n\n# {}\n\"#,\n        prompt_line, approval_line, description\n    );\n\n    std::fs::write(\u0026filepath, content)?;\n\n    // Parse the spec to add derived fields if enterprise config is present\n    if !config.enterprise.derived.is_empty() {\n        // Load the spec we just created\n        let mut spec = spec::Spec::load(\u0026filepath)?;\n\n        // Build derivation context\n        let context = derivation::build_context(\u0026id, \u0026specs_dir);\n\n        // Derive fields using the engine\n        let engine = DerivationEngine::new(config.enterprise.clone());\n        let derived_fields = engine.derive_fields(\u0026context);\n\n        // Add derived fields to spec frontmatter\n        spec.add_derived_fields(derived_fields);\n\n        // Write the spec with derived fields\n        spec.save(\u0026filepath)?;\n    }\n\n    // Auto-commit the spec file to git (skip if .chant/ is gitignored, e.g. silent mode)\n    let output = Command::new(\"git\")\n        .args([\"add\", \u0026filepath.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git add for spec file\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        // If the path is ignored (silent mode), skip git commit silently\n        if stderr.contains(\"ignored\") {\n            // .chant/ is gitignored (silent mode) - skip git commit\n        } else {\n            anyhow::bail!(\"Failed to stage spec file {}: {}\", id, stderr);\n        }\n    } else {\n        let commit_message = format!(\"chant: Add spec {}\", id);\n        let output = Command::new(\"git\")\n            .args([\"commit\", \"-m\", \u0026commit_message])\n            .output()\n            .context(\"Failed to run git commit for spec file\")?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            // It's ok if there's nothing to commit (shouldn't happen but be safe)\n            if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n                anyhow::bail!(\"Failed to commit spec file {}: {}\", id, stderr);\n            }\n        }\n    }\n\n    if !chant::ui::is_quiet() {\n        println!(\"{} {}\", \"Created\".green(), id.cyan());\n        if needs_approval {\n            println!(\"{} Requires approval before work can begin\", \"â¹\".cyan());\n        }\n        println!(\"Edit: {}\", filepath.display());\n\n        // Calculate and display quality score\n        let spec = spec::Spec::load(\u0026filepath)?;\n        let score = calculate_spec_score(\u0026spec, \u0026config);\n        display_quality_feedback(\u0026score, \u0026spec);\n    }\n\n    Ok(())\n}\n\n/// Extract acceptance criteria text from spec body\nfn extract_acceptance_criteria(spec: \u0026spec::Spec) -\u003e Vec\u003cString\u003e {\n    let acceptance_criteria_marker = \"## Acceptance Criteria\";\n    let mut criteria = Vec::new();\n    let mut in_code_fence = false;\n    let mut in_ac_section = false;\n\n    for line in spec.body.lines() {\n        let trimmed = line.trim_start();\n\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n            in_ac_section = true;\n            continue;\n        }\n\n        // Stop if we hit another ## heading\n        if in_ac_section \u0026\u0026 !in_code_fence \u0026\u0026 trimmed.starts_with(\"## \") {\n            break;\n        }\n\n        // Extract checkbox items\n        if in_ac_section\n            \u0026\u0026 !in_code_fence\n            \u0026\u0026 (trimmed.starts_with(\"- [ ]\") || trimmed.starts_with(\"- [x]\"))\n        {\n            // Extract text after checkbox\n            let text = trimmed\n                .trim_start_matches(\"- [ ]\")\n                .trim_start_matches(\"- [x]\")\n                .trim()\n                .to_string();\n            if !text.is_empty() {\n                criteria.push(text);\n            }\n        }\n    }\n\n    criteria\n}\n\n/// Calculate complete quality score for a spec\nfn calculate_spec_score(spec: \u0026spec::Spec, config: \u0026Config) -\u003e SpecScore {\n    let complexity = calculate_complexity(spec);\n    let confidence = calculate_confidence(spec, config);\n    let splittability = calculate_splittability(spec);\n\n    // No isolation for newly created specs (not part of a group yet)\n    let isolation = None;\n\n    // Extract acceptance criteria for AC quality scoring\n    let criteria = extract_acceptance_criteria(spec);\n    let ac_quality = calculate_ac_quality(\u0026criteria);\n\n    let mut score = SpecScore {\n        complexity,\n        confidence,\n        splittability,\n        isolation,\n        ac_quality,\n        traffic_light: TrafficLight::Ready, // temporary, will be overwritten\n    };\n\n    // Determine final traffic light status\n    score.traffic_light = determine_status(\u0026score);\n\n    score\n}\n\n/// Display quality feedback with traffic light, grades, and suggestions\nfn display_quality_feedback(score: \u0026SpecScore, spec: \u0026spec::Spec) {\n    // Calculate metrics for display\n    let criteria_count = spec.count_total_checkboxes();\n    let file_count = spec\n        .frontmatter\n        .target_files\n        .as_ref()\n        .map(|files| files.len())\n        .unwrap_or(0);\n    let word_count = spec.body.split_whitespace().count();\n\n    println!();\n    println!(\"Quality: {}\", score.traffic_light);\n    println!(\n        \"  Complexity: {} ({} criteria, {} files, {} words)\",\n        score.complexity, criteria_count, file_count, word_count\n    );\n    println!(\"  Confidence: {}\", score.confidence);\n    println!(\"  AC Quality: {}\", score.ac_quality);\n\n    // Only show suggestions if status is Review or Refine\n    if matches!(\n        score.traffic_light,\n        TrafficLight::Review | TrafficLight::Refine\n    ) {\n        let suggestions = generate_suggestions(score);\n        if !suggestions.is_empty() {\n            println!();\n            println!(\"{}\", \"Suggestions:\".bold());\n            for suggestion in suggestions {\n                println!(\"  â¢ {}\", suggestion);\n            }\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":14}},{"line":24,"address":[],"length":0,"stats":{"Line":21}},{"line":25,"address":[],"length":0,"stats":{"Line":14}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":7}},{"line":34,"address":[],"length":0,"stats":{"Line":14}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":14}},{"line":51,"address":[],"length":0,"stats":{"Line":21}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":16}},{"line":62,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":21}},{"line":74,"address":[],"length":0,"stats":{"Line":14}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":18}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":93,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":28}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":14}},{"line":110,"address":[],"length":0,"stats":{"Line":21}},{"line":111,"address":[],"length":0,"stats":{"Line":28}},{"line":112,"address":[],"length":0,"stats":{"Line":21}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":119,"address":[],"length":0,"stats":{"Line":7}},{"line":120,"address":[],"length":0,"stats":{"Line":14}},{"line":121,"address":[],"length":0,"stats":{"Line":14}},{"line":122,"address":[],"length":0,"stats":{"Line":14}},{"line":123,"address":[],"length":0,"stats":{"Line":14}},{"line":125,"address":[],"length":0,"stats":{"Line":14}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":128,"address":[],"length":0,"stats":{"Line":14}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":28}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":7}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":7}},{"line":164,"address":[],"length":0,"stats":{"Line":7}},{"line":165,"address":[],"length":0,"stats":{"Line":21}},{"line":166,"address":[],"length":0,"stats":{"Line":28}},{"line":167,"address":[],"length":0,"stats":{"Line":21}},{"line":170,"address":[],"length":0,"stats":{"Line":14}},{"line":173,"address":[],"length":0,"stats":{"Line":21}},{"line":174,"address":[],"length":0,"stats":{"Line":21}},{"line":186,"address":[],"length":0,"stats":{"Line":7}},{"line":188,"address":[],"length":0,"stats":{"Line":7}},{"line":192,"address":[],"length":0,"stats":{"Line":7}},{"line":194,"address":[],"length":0,"stats":{"Line":21}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":7}},{"line":197,"address":[],"length":0,"stats":{"Line":7}},{"line":199,"address":[],"length":0,"stats":{"Line":7}},{"line":201,"address":[],"length":0,"stats":{"Line":21}},{"line":203,"address":[],"length":0,"stats":{"Line":7}},{"line":204,"address":[],"length":0,"stats":{"Line":7}},{"line":205,"address":[],"length":0,"stats":{"Line":7}},{"line":209,"address":[],"length":0,"stats":{"Line":7}},{"line":210,"address":[],"length":0,"stats":{"Line":7}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":7}},{"line":217,"address":[],"length":0,"stats":{"Line":21}},{"line":218,"address":[],"length":0,"stats":{"Line":7}},{"line":219,"address":[],"length":0,"stats":{"Line":7}},{"line":220,"address":[],"length":0,"stats":{"Line":21}},{"line":221,"address":[],"length":0,"stats":{"Line":49}},{"line":222,"address":[],"length":0,"stats":{"Line":21}}],"covered":76,"coverable":94},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","approve.rs"],"content":"//! Approval workflow functionality\n//!\n//! Provides the `cmd_approve` and `cmd_reject` command functions\n//! along with helper functions for the approval workflow.\n\nuse anyhow::{Context, Result};\nuse atty;\nuse colored::Colorize;\nuse std::path::Path;\nuse std::process::Command;\n\nuse chant::config::{Config, RejectionAction};\nuse chant::id;\nuse chant::spec::{self, ApprovalStatus, Spec, SpecStatus};\n\n// ============================================================================\n// VALIDATION HELPERS\n// ============================================================================\n\n/// Get list of git committers from the repository history\nfn get_git_committers() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"shortlog\", \"-sn\", \"--all\"])\n        .output()\n        .context(\"Failed to run git shortlog\")?;\n\n    if !output.status.success() {\n        return Ok(Vec::new());\n    }\n\n    let output_str = String::from_utf8_lossy(\u0026output.stdout);\n    let committers: Vec\u003cString\u003e = output_str\n        .lines()\n        .filter_map(|line| {\n            // Format is \"   123\\tName\" - extract the name part\n            let parts: Vec\u003c\u0026str\u003e = line.trim().splitn(2, '\\t').collect();\n            parts.get(1).map(|s| s.to_string())\n        })\n        .collect();\n\n    Ok(committers)\n}\n\n/// Validate that a name exists in the git committers list\nfn validate_committer(name: \u0026str) -\u003e Result\u003cbool\u003e {\n    let committers = get_git_committers()?;\n\n    // Check for exact match or partial match (case-insensitive)\n    let name_lower = name.to_lowercase();\n    let is_valid = committers\n        .iter()\n        .any(|c| c.to_lowercase() == name_lower || c.to_lowercase().contains(\u0026name_lower));\n\n    Ok(is_valid)\n}\n\n// ============================================================================\n// DISCUSSION HELPERS\n// ============================================================================\n\n/// Append a message to the Approval Discussion section in the spec body.\n/// Creates the section if it doesn't exist.\nfn append_to_approval_discussion(spec: \u0026mut Spec, message: \u0026str) {\n    let discussion_header = \"## Approval Discussion\";\n\n    if spec.body.contains(discussion_header) {\n        // Find the section and append to it\n        if let Some(pos) = spec.body.find(discussion_header) {\n            let insert_pos = pos + discussion_header.len();\n            // Find the next section heading or end of body\n            let rest = \u0026spec.body[insert_pos..];\n            let next_section = rest.find(\"\\n## \").unwrap_or(rest.len());\n            let insert_at = insert_pos + next_section;\n\n            // Insert the message before the next section (or at end)\n            let new_body = format!(\n                \"{}\\n\\n{}{}\",\n                \u0026spec.body[..insert_at].trim_end(),\n                message,\n                \u0026spec.body[insert_at..]\n            );\n            spec.body = new_body;\n        }\n    } else {\n        // Add the section at the end of the body\n        spec.body = format!(\n            \"{}\\n\\n{}\\n\\n{}\",\n            spec.body.trim_end(),\n            discussion_header,\n            message\n        );\n    }\n}\n\n// ============================================================================\n// REJECTION HANDLERS\n// ============================================================================\n\n/// Handle rejection in dependency mode: create a fix spec and link it as a dependency.\nfn handle_rejection_dependency(\n    specs_dir: \u0026Path,\n    spec: \u0026mut Spec,\n    spec_path: \u0026Path,\n    reason: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    // Check if stdin is a TTY for interactive prompt\n    let should_create = if atty::is(atty::Stream::Stdin) {\n        // Interactive: prompt user\n        eprint!(\"{} Create fix spec? (Y/n): \", \"?\".cyan());\n        let mut input = String::new();\n        std::io::stdin().read_line(\u0026mut input)?;\n        let trimmed = input.trim().to_lowercase();\n        trimmed.is_empty() || trimmed == \"y\" || trimmed == \"yes\"\n    } else {\n        // Non-interactive: automatically create fix spec\n        true\n    };\n\n    if !should_create {\n        println!(\n            \"{} Skipping fix spec creation. Spec remains rejected.\",\n            \"â¹\".cyan()\n        );\n        return Ok(());\n    }\n\n    // Generate a new spec ID for the fix spec\n    let fix_id = id::generate_id(specs_dir)?;\n    let fix_filename = format!(\"{}.md\", fix_id);\n    let fix_path = specs_dir.join(\u0026fix_filename);\n\n    // Create the fix spec content\n    let fix_description = format!(\"Fix rejection issues for {}\", spec.id);\n    let fix_content = format!(\n        r#\"---\ntype: code\nstatus: pending\n---\n\n# {}\n\n## Context\n\nOriginal spec {} was rejected with reason:\n\u003e {}\n\n## Acceptance Criteria\n\n- [ ] Address rejection feedback\n- [ ] Changes ready for re-review\n\"#,\n        fix_description, spec.id, reason\n    );\n\n    std::fs::write(\u0026fix_path, fix_content)?;\n\n    // Update original spec: add depends_on and set status to blocked\n    let depends_on = spec.frontmatter.depends_on.get_or_insert_with(Vec::new);\n    depends_on.push(fix_id.clone());\n    spec.frontmatter.status = SpecStatus::Blocked;\n    spec.save(spec_path)?;\n\n    // Git add and commit both files\n    let output = Command::new(\"git\")\n        .args([\n            \"add\",\n            \u0026fix_path.to_string_lossy(),\n            \u0026spec_path.to_string_lossy(),\n        ])\n        .output()\n        .context(\"Failed to run git add for fix spec\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage fix spec files: {}\", stderr);\n    }\n\n    let commit_message = format!(\n        \"chant({}): create fix spec {} (dependency mode)\",\n        spec.id, fix_id\n    );\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026commit_message])\n        .output()\n        .context(\"Failed to run git commit for fix spec\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n            anyhow::bail!(\"Failed to commit fix spec: {}\", stderr);\n        }\n    }\n\n    println!(\"{} Created fix spec {}\", \"â\".green(), fix_id.cyan());\n    println!(\n        \"{} Spec {} is now blocked, waiting for fix spec {}\",\n        \"â¹\".cyan(),\n        spec.id.cyan(),\n        fix_id.cyan()\n    );\n\n    Ok(())\n}\n\n/// Handle rejection in group mode: convert spec to driver with numbered member specs.\nfn handle_rejection_group(\n    specs_dir: \u0026Path,\n    spec: \u0026mut Spec,\n    spec_path: \u0026Path,\n    reason: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\n        \"{} Converting rejected spec to driver with member specs...\",\n        \"â\".cyan()\n    );\n\n    // Extract acceptance criteria from the spec body to distribute across members\n    let criteria = extract_acceptance_criteria(\u0026spec.body);\n\n    let driver_id = spec.id.clone();\n    let mut member_ids = Vec::new();\n\n    if criteria.is_empty() {\n        // No acceptance criteria to distribute - create a single fix member\n        let member_id = format!(\"{}.1\", driver_id);\n        let member_path = specs_dir.join(format!(\"{}.md\", member_id));\n\n        let member_content = format!(\n            r#\"---\ntype: code\nstatus: pending\n---\n\n# Fix rejection issues for {}\n\n## Context\n\nOriginal spec was rejected with reason:\n\u003e {}\n\n## Acceptance Criteria\n\n- [ ] Address rejection feedback\n- [ ] Changes ready for re-review\n\"#,\n            driver_id, reason\n        );\n\n        std::fs::write(\u0026member_path, member_content)?;\n        member_ids.push(member_id);\n    } else {\n        // Distribute criteria across member specs\n        for (index, criterion) in criteria.iter().enumerate() {\n            let member_number = index + 1;\n            let member_id = format!(\"{}.{}\", driver_id, member_number);\n            let member_path = specs_dir.join(format!(\"{}.md\", member_id));\n\n            // Build depends_on for sequential ordering (each depends on previous)\n            let depends_on_line = if index \u003e 0 {\n                format!(\n                    \"depends_on:\\n  - {}.{}\\n\",\n                    driver_id,\n                    index // previous member number\n                )\n            } else {\n                String::new()\n            };\n\n            let member_content = format!(\n                r#\"---\ntype: code\nstatus: pending\n{}---\n\n# {}\n\n## Acceptance Criteria\n\n- [ ] {}\n\"#,\n                depends_on_line,\n                criterion\n                    .trim_start_matches(\"- [ ] \")\n                    .trim_start_matches(\"- [x] \")\n                    .trim_start_matches(\"- [X] \"),\n                criterion\n                    .trim_start_matches(\"- [ ] \")\n                    .trim_start_matches(\"- [x] \")\n                    .trim_start_matches(\"- [X] \")\n            );\n\n            std::fs::write(\u0026member_path, member_content)?;\n            member_ids.push(member_id);\n        }\n    }\n\n    // Update driver spec: change type to driver, add members list\n    spec.frontmatter.r#type = \"driver\".to_string();\n    spec.frontmatter.members = Some(member_ids.clone());\n    spec.save(spec_path)?;\n\n    // Git add all files\n    let mut git_args: Vec\u003cString\u003e = vec![\"add\".to_string()];\n    git_args.push(spec_path.to_string_lossy().to_string());\n    for member_id in \u0026member_ids {\n        git_args.push(\n            specs_dir\n                .join(format!(\"{}.md\", member_id))\n                .to_string_lossy()\n                .to_string(),\n        );\n    }\n\n    let output = Command::new(\"git\")\n        .args(\u0026git_args)\n        .output()\n        .context(\"Failed to run git add for group mode files\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage group mode files: {}\", stderr);\n    }\n\n    let commit_message = format!(\n        \"chant({}): convert to driver with {} member specs (group mode)\",\n        spec.id,\n        member_ids.len()\n    );\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026commit_message])\n        .output()\n        .context(\"Failed to run git commit for group mode\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n            anyhow::bail!(\"Failed to commit group mode changes: {}\", stderr);\n        }\n    }\n\n    println!(\n        \"{} Spec {} converted to driver\",\n        \"â\".green(),\n        spec.id.cyan()\n    );\n    println!(\"Created members:\");\n    for member_id in \u0026member_ids {\n        println!(\"  {} {}\", \"â¢\".cyan(), member_id);\n    }\n\n    Ok(())\n}\n\n/// Extract acceptance criteria items from a spec body.\n/// Returns a list of criterion text strings (including the checkbox prefix).\nfn extract_acceptance_criteria(body: \u0026str) -\u003e Vec\u003cString\u003e {\n    let acceptance_criteria_marker = \"## Acceptance Criteria\";\n    let mut criteria = Vec::new();\n    let mut in_ac_section = false;\n    let mut in_code_fence = false;\n\n    for line in body.lines() {\n        let trimmed = line.trim_start();\n\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        if in_code_fence {\n            continue;\n        }\n\n        if trimmed.starts_with(acceptance_criteria_marker) {\n            in_ac_section = true;\n            continue;\n        }\n\n        if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") {\n            break;\n        }\n\n        if in_ac_section {\n            let checkbox_line = trimmed;\n            if checkbox_line.starts_with(\"- [ ] \")\n                || checkbox_line.starts_with(\"- [x] \")\n                || checkbox_line.starts_with(\"- [X] \")\n            {\n                // Only include top-level criteria (not indented sub-items)\n                if line.starts_with(\"- \") || line.starts_with(\"  - \") {\n                    // Skip deeply nested items (more than one level of indentation)\n                    let indent = line.len() - line.trim_start().len();\n                    if indent \u003c= 2 {\n                        criteria.push(trimmed.to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    criteria\n}\n\n// ============================================================================\n// APPROVE COMMAND\n// ============================================================================\n\npub fn cmd_approve(id: \u0026str, by: \u0026str) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve spec\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Validate the approver name against git committers\n    match validate_committer(by) {\n        Ok(true) =\u003e {}\n        Ok(false) =\u003e {\n            eprintln!(\n                \"{} Warning: '{}' is not a known git committer in this repository\",\n                \"â \".yellow(),\n                by\n            );\n        }\n        Err(e) =\u003e {\n            eprintln!(\n                \"{} Warning: Could not validate committer name: {}\",\n                \"â \".yellow(),\n                e\n            );\n        }\n    }\n\n    // Check if spec has approval section\n    let approval = spec\n        .frontmatter\n        .approval\n        .get_or_insert_with(Default::default);\n\n    // Check if already approved\n    if approval.status == ApprovalStatus::Approved {\n        println!(\n            \"{} Spec {} is already approved{}\",\n            \"â¹\".cyan(),\n            spec.id,\n            approval\n                .by\n                .as_ref()\n                .map(|b| format!(\" by {}\", b))\n                .unwrap_or_default()\n        );\n        return Ok(());\n    }\n\n    // Update approval status\n    let timestamp = chrono::Utc::now().format(\"%Y-%m-%dT%H:%M:%SZ\").to_string();\n    approval.status = ApprovalStatus::Approved;\n    approval.by = Some(by.to_string());\n    approval.at = Some(timestamp.clone());\n\n    // Add discussion entry\n    let discussion_entry = format!(\n        \"**{}** - {} - APPROVED\",\n        by,\n        chrono::Local::now().format(\"%Y-%m-%d %H:%M\")\n    );\n    append_to_approval_discussion(\u0026mut spec, \u0026discussion_entry);\n\n    // Save the spec\n    spec.save(\u0026spec_path)?;\n\n    // Commit the change\n    let output = Command::new(\"git\")\n        .args([\"add\", \u0026spec_path.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git add for spec file\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage spec file: {}\", stderr);\n    }\n\n    let commit_message = format!(\"chant({}): approve spec\", spec.id);\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026commit_message])\n        .output()\n        .context(\"Failed to run git commit\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n            anyhow::bail!(\"Failed to commit spec file: {}\", stderr);\n        }\n    }\n\n    println!(\"{} Spec {} approved by {}\", \"â\".green(), spec.id.cyan(), by);\n\n    Ok(())\n}\n\n// ============================================================================\n// REJECT COMMAND\n// ============================================================================\n\npub fn cmd_reject(id: \u0026str, by: \u0026str, reason: \u0026str) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let config = Config::load()?;\n\n    // Resolve spec\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Validate the rejector name against git committers\n    match validate_committer(by) {\n        Ok(true) =\u003e {}\n        Ok(false) =\u003e {\n            eprintln!(\n                \"{} Warning: '{}' is not a known git committer in this repository\",\n                \"â \".yellow(),\n                by\n            );\n        }\n        Err(e) =\u003e {\n            eprintln!(\n                \"{} Warning: Could not validate committer name: {}\",\n                \"â \".yellow(),\n                e\n            );\n        }\n    }\n\n    // Check if spec has approval section\n    let approval = spec\n        .frontmatter\n        .approval\n        .get_or_insert_with(Default::default);\n\n    // Update approval status\n    let timestamp = chrono::Utc::now().format(\"%Y-%m-%dT%H:%M:%SZ\").to_string();\n    approval.status = ApprovalStatus::Rejected;\n    approval.by = Some(by.to_string());\n    approval.at = Some(timestamp.clone());\n\n    // Add discussion entry with reason\n    let discussion_entry = format!(\n        \"**{}** - {} - REJECTED\\n{}\",\n        by,\n        chrono::Local::now().format(\"%Y-%m-%d %H:%M\"),\n        reason\n    );\n    append_to_approval_discussion(\u0026mut spec, \u0026discussion_entry);\n\n    // Save the spec\n    spec.save(\u0026spec_path)?;\n\n    // Commit the change\n    let output = Command::new(\"git\")\n        .args([\"add\", \u0026spec_path.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git add for spec file\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage spec file: {}\", stderr);\n    }\n\n    let commit_message = format!(\"chant({}): reject spec\", spec.id);\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026commit_message])\n        .output()\n        .context(\"Failed to run git commit\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n            anyhow::bail!(\"Failed to commit spec file: {}\", stderr);\n        }\n    }\n\n    println!(\n        \"{} Spec {} rejected by {}: {}\",\n        \"â\".red(),\n        spec.id.cyan(),\n        by,\n        reason\n    );\n\n    // Apply rejection action based on config\n    let rejection_action = config.approval.rejection_action;\n    match rejection_action {\n        RejectionAction::Manual =\u003e {\n            // No automatic action - user handles it manually\n        }\n        RejectionAction::Dependency =\u003e {\n            handle_rejection_dependency(\u0026specs_dir, \u0026mut spec, \u0026spec_path, reason)?;\n        }\n        RejectionAction::Group =\u003e {\n            handle_rejection_group(\u0026specs_dir, \u0026mut spec, \u0026spec_path, reason)?;\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":267},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","dag.rs"],"content":"//! DAG (dependency graph) visualization command\n\nuse anyhow::Result;\nuse colored::Colorize;\n\nuse chant::config::GraphDetailLevel;\nuse chant::site::graph::build_dependency_graph;\nuse chant::spec::{self, SpecStatus};\n\npub fn cmd_dag(\n    detail: \u0026str,\n    status_filter: Option\u003c\u0026str\u003e,\n    labels: \u0026[String],\n    type_filter: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Parse detail level\n    let detail_level = match detail.to_lowercase().as_str() {\n        \"minimal\" =\u003e GraphDetailLevel::Minimal,\n        \"titles\" =\u003e GraphDetailLevel::Titles,\n        \"full\" =\u003e GraphDetailLevel::Full,\n        _ =\u003e {\n            anyhow::bail!(\n                \"Invalid detail level '{}'. Valid options: minimal, titles, full\",\n                detail\n            );\n        }\n    };\n\n    // Load all specs\n    let mut specs = spec::load_all_specs(\u0026specs_dir)?;\n\n    // Apply filters\n\n    // Exclude cancelled specs\n    specs.retain(|s| s.frontmatter.status != SpecStatus::Cancelled);\n\n    // Filter by status if specified\n    if let Some(status_val) = status_filter {\n        let status_lower = status_val.to_lowercase();\n        match status_lower.as_str() {\n            \"blocked\" =\u003e {\n                let all_specs_clone = specs.clone();\n                specs.retain(|s| {\n                    s.frontmatter.status == SpecStatus::Blocked\n                        || (s.frontmatter.status == SpecStatus::Pending\n                            \u0026\u0026 s.is_blocked(\u0026all_specs_clone))\n                });\n            }\n            \"ready\" =\u003e {\n                let all_specs_clone = specs.clone();\n                specs.retain(|s| s.is_ready(\u0026all_specs_clone));\n            }\n            _ =\u003e {\n                let target_status = match status_lower.as_str() {\n                    \"pending\" =\u003e SpecStatus::Pending,\n                    \"in_progress\" | \"inprogress\" =\u003e SpecStatus::InProgress,\n                    \"completed\" =\u003e SpecStatus::Completed,\n                    \"failed\" =\u003e SpecStatus::Failed,\n                    \"needs_attention\" | \"needsattention\" =\u003e SpecStatus::NeedsAttention,\n                    _ =\u003e {\n                        anyhow::bail!(\"Invalid status filter: {}. Valid options: pending, in_progress, completed, failed, blocked, ready, needs_attention\", status_val);\n                    }\n                };\n                specs.retain(|s| s.frontmatter.status == target_status);\n            }\n        }\n    }\n\n    // Filter by type if specified\n    if let Some(type_val) = type_filter {\n        specs.retain(|s| s.frontmatter.r#type == type_val);\n    }\n\n    // Filter by labels if specified (OR logic)\n    if !labels.is_empty() {\n        specs.retain(|s| {\n            if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                spec_labels.iter().any(|l| labels.contains(l))\n            } else {\n                false\n            }\n        });\n    }\n\n    if specs.is_empty() {\n        println!(\"{}\", \"(No specs to display)\".dimmed());\n        return Ok(());\n    }\n\n    // Build and display the graph\n    let spec_refs: Vec\u003c\u0026_\u003e = specs.iter().collect();\n    let (graph, roots, leaves) = build_dependency_graph(\u0026spec_refs, detail_level);\n\n    println!(\"{}\", graph);\n\n    // Show summary\n    println!();\n    println!(\"{}\", \"Summary:\".bold());\n    println!(\"  Total specs: {}\", specs.len());\n    println!(\"  Root specs (no dependencies): {}\", roots.len());\n    println!(\"  Leaf specs (nothing depends on): {}\", leaves.len());\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":48},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","delete.rs"],"content":"//! Spec deletion and cancellation functionality\n//!\n//! Provides the `cmd_delete`, `cmd_cancel`, and `cmd_export` command functions.\n\nuse anyhow::{Context, Result};\nuse atty;\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse chant::config::Config;\nuse chant::git;\nuse chant::paths::{ARCHIVE_DIR, LOGS_DIR};\nuse chant::pid;\nuse chant::spec::{self, SpecStatus};\nuse chant::worktree;\n\n// ============================================================================\n// EXPORT COMMAND (wrapper)\n// ============================================================================\n\n#[allow(clippy::too_many_arguments)]\npub fn cmd_export(\n    format: Option\u003c\u0026str\u003e,\n    statuses: \u0026[String],\n    type_: Option\u003c\u0026str\u003e,\n    labels: \u0026[String],\n    ready: bool,\n    from: Option\u003c\u0026str\u003e,\n    to: Option\u003c\u0026str\u003e,\n    fields: Option\u003c\u0026str\u003e,\n    output: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    crate::cmd::export::cmd_export(\n        format, statuses, type_, labels, ready, from, to, fields, output,\n    )\n}\n\n// ============================================================================\n// DELETE COMMAND\n// ============================================================================\n\n/// Delete a spec permanently, removing the spec file and optionally related artifacts.\n///\n/// Note: Deletion is allowed regardless of approval status. A spec that requires\n/// approval but hasn't been approved can still be deleted - this is intentional\n/// since deletion is a cleanup operation that doesn't need approval.\npub fn cmd_delete(\n    id: \u0026str,\n    force: bool,\n    cascade: bool,\n    delete_branch: bool,\n    dry_run: bool,\n    yes: bool,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let logs_dir = PathBuf::from(LOGS_DIR);\n\n    // Load config for branch prefix\n    let config = Config::load()?;\n    let branch_prefix = \u0026config.defaults.branch_prefix;\n\n    // Load all specs (both active and archived)\n    let mut all_specs = spec::load_all_specs(\u0026specs_dir)?;\n    let archive_dir = PathBuf::from(ARCHIVE_DIR);\n    if archive_dir.exists() {\n        let archived_specs = spec::load_all_specs(\u0026archive_dir)?;\n        all_specs.extend(archived_specs);\n    }\n\n    // Resolve the spec ID\n    let spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_id = \u0026spec.id;\n\n    // Check if this is a member spec\n    if let Some(driver_id) = spec::extract_driver_id(spec_id) {\n        if !cascade {\n            anyhow::bail!(\n                \"Cannot delete member spec '{}' directly. Delete the driver spec '{}' instead, or use --cascade.\",\n                spec_id,\n                driver_id\n            );\n        }\n    }\n\n    // Check if we should collect members for cascade delete\n    let members = spec::get_members(spec_id, \u0026all_specs);\n    let specs_to_delete: Vec\u003cspec::Spec\u003e = if cascade \u0026\u0026 !members.is_empty() {\n        // Include all members plus the driver\n        let mut to_delete: Vec\u003cspec::Spec\u003e = members.iter().map(|s| (*s).clone()).collect();\n        to_delete.push(spec.clone());\n        to_delete\n    } else {\n        // Just delete the single spec\n        vec![spec.clone()]\n    };\n\n    // Check safety constraints\n    if !force {\n        for spec_to_delete in \u0026specs_to_delete {\n            match spec_to_delete.frontmatter.status {\n                SpecStatus::InProgress | SpecStatus::Failed | SpecStatus::NeedsAttention =\u003e {\n                    anyhow::bail!(\n                        \"Spec '{}' is {}. Use --force to delete anyway.\",\n                        spec_to_delete.id,\n                        match spec_to_delete.frontmatter.status {\n                            SpecStatus::InProgress =\u003e \"in progress\",\n                            SpecStatus::Failed =\u003e \"failed\",\n                            SpecStatus::NeedsAttention =\u003e \"needs attention\",\n                            _ =\u003e unreachable!(),\n                        }\n                    );\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    // Check if this spec is a dependency for others\n    let mut dependents = Vec::new();\n    for other_spec in \u0026all_specs {\n        if let Some(deps) = \u0026other_spec.frontmatter.depends_on {\n            for dep_id in deps {\n                if dep_id == spec_id {\n                    dependents.push(other_spec.id.clone());\n                }\n            }\n        }\n    }\n\n    if !dependents.is_empty() \u0026\u0026 !force {\n        eprintln!(\n            \"{} Spec '{}' is a dependency for: {}\",\n            \"â \".yellow(),\n            spec_id,\n            dependents.join(\", \")\n        );\n        anyhow::bail!(\"Use --force to delete this spec and its dependents.\");\n    }\n\n    // Display what will be deleted\n    println!(\"{} Deleting spec:\", \"â\".cyan());\n    for spec_to_delete in \u0026specs_to_delete {\n        if spec::extract_driver_id(\u0026spec_to_delete.id).is_some() {\n            println!(\"  {} {} (member)\", \"â\".cyan(), spec_to_delete.id);\n        } else if cascade \u0026\u0026 !members.is_empty() {\n            println!(\n                \"  {} {} (driver with {} member{})\",\n                \"â\".cyan(),\n                spec_to_delete.id,\n                members.len(),\n                if members.len() == 1 { \"\" } else { \"s\" }\n            );\n        } else {\n            println!(\"  {} {}\", \"â\".cyan(), spec_to_delete.id);\n        }\n    }\n\n    // Check for associated artifacts\n    let mut artifacts = Vec::new();\n    for spec_to_delete in \u0026specs_to_delete {\n        let log_path = logs_dir.join(format!(\"{}.log\", spec_to_delete.id));\n        if log_path.exists() {\n            artifacts.push(format!(\"log file ({})\", log_path.display()));\n        }\n\n        let full_spec_path_active = specs_dir.join(format!(\"{}.md\", spec_to_delete.id));\n        if full_spec_path_active.exists() {\n            artifacts.push(format!(\"spec file ({})\", full_spec_path_active.display()));\n        }\n\n        let branch_name = format!(\"{}{}\", branch_prefix, spec_to_delete.id);\n        if git::branch_exists(\u0026branch_name).unwrap_or_default() {\n            artifacts.push(format!(\"git branch ({})\", branch_name));\n        }\n\n        let worktree_path = PathBuf::from(format!(\"/tmp/chant-{}\", spec_to_delete.id));\n        if worktree_path.exists() {\n            artifacts.push(format!(\"worktree ({})\", worktree_path.display()));\n        }\n    }\n\n    if !artifacts.is_empty() {\n        println!(\"{} Artifacts to be removed:\", \"â\".cyan());\n        for artifact in \u0026artifacts {\n            println!(\"  {} {}\", \"â\".cyan(), artifact);\n        }\n    }\n\n    if delete_branch \u0026\u0026 !members.is_empty() {\n        println!(\"{} (will also delete associated branch)\", \"â\".cyan());\n    }\n\n    if dry_run {\n        println!(\"{} {}\", \"â\".cyan(), \"(dry run, no changes made)\".dimmed());\n        return Ok(());\n    }\n\n    // Ask for confirmation unless --yes\n    if !yes {\n        // Detect non-TTY contexts (e.g., when running in worktrees or piped input)\n        if !atty::is(atty::Stream::Stdin) {\n            eprintln!(\"â¹ Non-interactive mode detected, proceeding without confirmation\");\n        } else {\n            eprint!(\n                \"{} Are you sure you want to delete {}? [y/N] \",\n                \"â\".cyan(),\n                spec_id\n            );\n            std::io::Write::flush(\u0026mut std::io::stderr())?;\n\n            let mut response = String::new();\n            std::io::stdin().read_line(\u0026mut response)?;\n            if !response.trim().eq_ignore_ascii_case(\"y\") {\n                println!(\"{} Delete cancelled.\", \"â\".red());\n                return Ok(());\n            }\n        }\n    }\n\n    // Perform deletions\n    for spec_to_delete in \u0026specs_to_delete {\n        // Delete spec file (could be in active or archived)\n        let full_spec_path_active = specs_dir.join(format!(\"{}.md\", spec_to_delete.id));\n        if full_spec_path_active.exists() {\n            std::fs::remove_file(\u0026full_spec_path_active).context(\"Failed to delete spec file\")?;\n            println!(\"  {} {} (deleted)\", \"â\".green(), spec_to_delete.id);\n        }\n\n        // Delete log file if it exists\n        let log_path = logs_dir.join(format!(\"{}.log\", spec_to_delete.id));\n        if log_path.exists() {\n            std::fs::remove_file(\u0026log_path).context(\"Failed to delete log file\")?;\n        }\n\n        // Delete worktree if it exists\n        let worktree_path = PathBuf::from(format!(\"/tmp/chant-{}\", spec_to_delete.id));\n        if worktree_path.exists() {\n            worktree::remove_worktree(\u0026worktree_path).context(\"Failed to clean up worktree\")?;\n        }\n    }\n\n    // Delete branch if requested\n    if delete_branch {\n        for spec_to_delete in \u0026specs_to_delete {\n            let branch_name = format!(\"{}{}\", branch_prefix, spec_to_delete.id);\n            if git::branch_exists(\u0026branch_name).unwrap_or_default() {\n                git::delete_branch(\u0026branch_name, false).context(\"Failed to delete branch\")?;\n            }\n        }\n    }\n\n    if specs_to_delete.len() == 1 {\n        println!(\"{} Deleted spec: {}\", \"â\".green(), specs_to_delete[0].id);\n    } else {\n        println!(\"{} Deleted {} spec(s)\", \"â\".green(), specs_to_delete.len());\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// CANCEL COMMAND\n// ============================================================================\n\n/// Cancel a spec (soft-delete) by setting its status to cancelled.\n/// Preserves the spec file and git history.\n///\n/// Note: Cancellation is allowed regardless of approval status. A spec that requires\n/// approval but hasn't been approved can still be cancelled - this is intentional\n/// since cancelling doesn't need approval (it's just removing the spec from active work).\npub fn cmd_cancel(id: \u0026str, force: bool, dry_run: bool, yes: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve the spec ID\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_id = \u0026spec.id.clone();\n\n    // Check if this is a member spec - cancel is not allowed for members\n    if let Some(driver_id) = spec::extract_driver_id(spec_id) {\n        anyhow::bail!(\n            \"Cannot cancel member spec '{}'. Cancel the driver spec '{}' instead.\",\n            spec_id,\n            driver_id\n        );\n    }\n\n    // Stop any running process\n    let pid = pid::read_pid_file(spec_id)?;\n    if let Some(pid) = pid {\n        if pid::is_process_running(pid) {\n            println!(\"  {} Stopping running process (PID: {})\", \"â¢\".cyan(), pid);\n            pid::stop_process(pid)?;\n            pid::remove_pid_file(spec_id)?;\n            println!(\"  {} Process stopped\", \"â\".green());\n        } else {\n            pid::remove_pid_file(spec_id)?;\n        }\n    }\n\n    // Check safety constraints\n    if !force {\n        match spec.frontmatter.status {\n            SpecStatus::Cancelled =\u003e {\n                anyhow::bail!(\"Spec '{}' is already cancelled.\", spec_id);\n            }\n            SpecStatus::InProgress | SpecStatus::Failed | SpecStatus::NeedsAttention =\u003e {\n                anyhow::bail!(\n                    \"Spec '{}' is {}. Use --force to cancel anyway.\",\n                    spec_id,\n                    match spec.frontmatter.status {\n                        SpecStatus::InProgress =\u003e \"in progress\",\n                        SpecStatus::Failed =\u003e \"failed\",\n                        SpecStatus::NeedsAttention =\u003e \"needs attention\",\n                        _ =\u003e unreachable!(),\n                    }\n                );\n            }\n            _ =\u003e {}\n        }\n    }\n\n    // Check if this spec is a dependency for others\n    let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n    let mut dependents = Vec::new();\n    for other_spec in \u0026all_specs {\n        if let Some(deps) = \u0026other_spec.frontmatter.depends_on {\n            for dep_id in deps {\n                if dep_id == spec_id {\n                    dependents.push(other_spec.id.clone());\n                }\n            }\n        }\n    }\n\n    if !dependents.is_empty() \u0026\u0026 !force {\n        eprintln!(\n            \"{} Spec '{}' is a dependency for: {}\",\n            \"â \".yellow(),\n            spec_id,\n            dependents.join(\", \")\n        );\n        anyhow::bail!(\"Use --force to cancel this spec and its dependents.\");\n    }\n\n    // Display what will be cancelled\n    println!(\"{} Cancelling spec:\", \"â\".cyan());\n    println!(\"  {} {}\", \"â\".cyan(), spec_id);\n\n    if !dependents.is_empty() {\n        println!(\"{} Dependents will be blocked:\", \"â \".yellow());\n        for dep in \u0026dependents {\n            println!(\"  {} {}\", \"â \".yellow(), dep);\n        }\n    }\n\n    if dry_run {\n        println!(\"{} {}\", \"â\".cyan(), \"(dry run, no changes made)\".dimmed());\n        return Ok(());\n    }\n\n    // Ask for confirmation unless --yes\n    if !yes {\n        // Detect non-TTY contexts (e.g., when running in worktrees or piped input)\n        if !atty::is(atty::Stream::Stdin) {\n            eprintln!(\"â¹ Non-interactive mode detected, proceeding without confirmation\");\n        } else {\n            eprint!(\n                \"{} Are you sure you want to cancel {}? [y/N] \",\n                \"â\".cyan(),\n                spec_id\n            );\n            std::io::Write::flush(\u0026mut std::io::stderr())?;\n\n            let mut response = String::new();\n            std::io::stdin().read_line(\u0026mut response)?;\n            if !response.trim().eq_ignore_ascii_case(\"y\") {\n                println!(\"{} Cancel cancelled.\", \"â\".red());\n                return Ok(());\n            }\n        }\n    }\n\n    // Update the spec status to Cancelled\n    spec.frontmatter.status = SpecStatus::Cancelled;\n\n    // Save the spec file with the new status\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    spec.save(\u0026spec_path)?;\n\n    println!(\"{} Cancelled spec: {}\", \"â\".green(), spec_id);\n\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":169},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","edit.rs"],"content":"//! Spec editing functionality\n//!\n//! Provides the `cmd_edit` command function for opening specs in $EDITOR.\n\nuse anyhow::{Context, Result};\nuse std::process::Command;\n\nuse chant::spec;\n\n/// Opens a spec file in $EDITOR for editing.\n///\n/// Resolves the spec ID to its file path and launches the editor specified\n/// in the EDITOR environment variable.\npub fn cmd_edit(id: \u0026str) -\u003e Result\u003c()\u003e {\n    // Resolve spec ID to file path\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Get editor from environment\n    let editor = std::env::var(\"EDITOR\").unwrap_or_else(|_| {\n        // Fall back to common editors\n        if cfg!(target_os = \"windows\") {\n            \"notepad\".to_string()\n        } else {\n            \"vi\".to_string()\n        }\n    });\n\n    // Launch editor\n    let status = Command::new(\u0026editor)\n        .arg(\u0026spec_path)\n        .status()\n        .context(format!(\"Failed to launch editor: {}\", editor))?;\n\n    if !status.success() {\n        anyhow::bail!(\"Editor exited with non-zero status\");\n    }\n\n    Ok(())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","lint.rs"],"content":"//! Validation and linting functionality for specs\n//!\n//! Provides validation helpers for spec complexity, coupling, approval,\n//! output schema, model usage, and type-specific validation. Also provides\n//! the `cmd_lint` command function.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse serde::Serialize;\nuse serde_json;\nuse std::path::Path;\n\nuse chant::config::Config;\nuse chant::paths::LOGS_DIR;\nuse chant::score::ac_quality::calculate_ac_quality;\nuse chant::score::confidence::calculate_confidence;\nuse chant::score::isolation::calculate_isolation;\nuse chant::score::splittability::calculate_splittability;\nuse chant::score::traffic_light::{determine_status, generate_suggestions};\nuse chant::scoring::{calculate_complexity, SpecScore};\nuse chant::spec::{self, ApprovalStatus, Spec, SpecStatus};\nuse chant::validation;\n\nuse std::path::PathBuf;\n\n// ============================================================================\n// LINT TYPES\n// ============================================================================\n\n/// Output format for lint results\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum LintFormat {\n    /// Human-readable text output with colors\n    Text,\n    /// Machine-readable JSON output\n    Json,\n}\n\n/// Categories of lint rules for spec validation\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum LintRule {\n    /// Spec is too complex (too many criteria, files, or words)\n    Complexity,\n    /// Spec references other spec IDs in body text (coupling)\n    Coupling,\n    /// Type-specific validation issues\n    Type,\n    /// Using expensive model on simple spec\n    ModelWaste,\n    /// Approval schema inconsistencies\n    Approval,\n    /// Output schema validation issues\n    Output,\n    /// Missing or invalid dependency references\n    Dependency,\n    /// Missing required enterprise fields\n    Required,\n    /// Missing spec title\n    Title,\n    /// YAML frontmatter parse errors\n    Parse,\n}\n\nimpl LintRule {\n    /// Returns the string representation of the lint rule\n    #[allow(dead_code)]\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            LintRule::Complexity =\u003e \"complexity\",\n            LintRule::Coupling =\u003e \"coupling\",\n            LintRule::Type =\u003e \"type\",\n            LintRule::ModelWaste =\u003e \"model_waste\",\n            LintRule::Approval =\u003e \"approval\",\n            LintRule::Output =\u003e \"output\",\n            LintRule::Dependency =\u003e \"dependency\",\n            LintRule::Required =\u003e \"required\",\n            LintRule::Title =\u003e \"title\",\n            LintRule::Parse =\u003e \"parse\",\n        }\n    }\n}\n\n/// Severity level for lint diagnostics\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Severity {\n    /// Error - spec is invalid and must be fixed\n    Error,\n    /// Warning - spec is valid but could be improved\n    Warning,\n}\n\n/// A single diagnostic message from linting\n#[derive(Debug, Clone, Serialize)]\npub struct LintDiagnostic {\n    /// The spec ID this diagnostic applies to\n    pub spec_id: String,\n    /// The lint rule that triggered this diagnostic\n    pub rule: LintRule,\n    /// The severity level\n    pub severity: Severity,\n    /// The diagnostic message\n    pub message: String,\n    /// Optional suggestion for fixing the issue\n    pub suggestion: Option\u003cString\u003e,\n}\n\nimpl LintDiagnostic {\n    /// Create a new error diagnostic\n    pub fn error(spec_id: \u0026str, rule: LintRule, message: String) -\u003e Self {\n        Self {\n            spec_id: spec_id.to_string(),\n            rule,\n            severity: Severity::Error,\n            message,\n            suggestion: None,\n        }\n    }\n\n    /// Create a new warning diagnostic\n    pub fn warning(spec_id: \u0026str, rule: LintRule, message: String) -\u003e Self {\n        Self {\n            spec_id: spec_id.to_string(),\n            rule,\n            severity: Severity::Warning,\n            message,\n            suggestion: None,\n        }\n    }\n\n    /// Add a suggestion to this diagnostic\n    pub fn with_suggestion(mut self, suggestion: String) -\u003e Self {\n        self.suggestion = Some(suggestion);\n        self\n    }\n}\n\n/// Complete report from linting operation\n#[derive(Debug, Serialize)]\npub struct LintReport {\n    /// All diagnostics found during linting\n    pub diagnostics: Vec\u003cLintDiagnostic\u003e,\n    /// Number of specs that passed all checks\n    pub passed: usize,\n    /// Number of specs with warnings only\n    pub warned: usize,\n    /// Number of specs with errors\n    pub failed: usize,\n    /// Total number of specs checked\n    pub total: usize,\n}\n\nimpl LintReport {\n    /// Check if the report has any errors\n    #[allow(dead_code)]\n    pub fn has_errors(\u0026self) -\u003e bool {\n        self.diagnostics\n            .iter()\n            .any(|d| d.severity == Severity::Error)\n    }\n\n    /// Check if the report has any warnings\n    #[allow(dead_code)]\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.diagnostics\n            .iter()\n            .any(|d| d.severity == Severity::Warning)\n    }\n}\n\n// ============================================================================\n// VALIDATION THRESHOLDS\n// ============================================================================\n\n/// Regex pattern for spec IDs: YYYY-MM-DD-XXX-abc with optional .N suffix\nconst SPEC_ID_PATTERN: \u0026str = r\"\\b\\d{4}-\\d{2}-\\d{2}-[0-9a-z]{3}-[0-9a-z]{3}(?:\\.\\d+)?\\b\";\n\n// ============================================================================\n// SCORING HELPERS\n// ============================================================================\n\n/// Extract acceptance criteria text from spec body\nfn extract_acceptance_criteria(spec: \u0026Spec) -\u003e Vec\u003cString\u003e {\n    let acceptance_criteria_marker = \"## Acceptance Criteria\";\n    let mut criteria = Vec::new();\n    let mut in_code_fence = false;\n    let mut in_ac_section = false;\n\n    for line in spec.body.lines() {\n        let trimmed = line.trim_start();\n\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n            in_ac_section = true;\n            continue;\n        }\n\n        // Stop if we hit another ## heading\n        if in_ac_section \u0026\u0026 !in_code_fence \u0026\u0026 trimmed.starts_with(\"## \") {\n            break;\n        }\n\n        // Extract checkbox items\n        if in_ac_section\n            \u0026\u0026 !in_code_fence\n            \u0026\u0026 (trimmed.starts_with(\"- [ ]\") || trimmed.starts_with(\"- [x]\"))\n        {\n            // Extract text after checkbox\n            let text = trimmed\n                .trim_start_matches(\"- [ ]\")\n                .trim_start_matches(\"- [x]\")\n                .trim()\n                .to_string();\n            if !text.is_empty() {\n                criteria.push(text);\n            }\n        }\n    }\n\n    criteria\n}\n\n/// Calculate complete quality score for a spec\nfn calculate_spec_score(spec: \u0026Spec, all_specs: \u0026[Spec]) -\u003e SpecScore {\n    let complexity = calculate_complexity(spec);\n\n    // Load config for confidence calculation (creates minimal default if load fails)\n    let loaded_config = Config::load().ok();\n    let minimal_config = if loaded_config.is_none() {\n        // Create a minimal config on the fly if load fails\n        let toml_str = r#\"\n[project]\nname = \"default\"\nprefix = \"\"\n\"#;\n        Config::parse(toml_str).ok()\n    } else {\n        None\n    };\n    let conf = loaded_config.as_ref().or(minimal_config.as_ref());\n\n    let confidence = if let Some(c) = conf {\n        calculate_confidence(spec, c)\n    } else {\n        // Fallback if config creation fails - use basic confidence calculation\n        chant::scoring::ConfidenceGrade::B\n    };\n    let splittability = calculate_splittability(spec);\n    let isolation = calculate_isolation(spec, all_specs);\n\n    // Extract acceptance criteria for AC quality scoring\n    let criteria = extract_acceptance_criteria(spec);\n    let ac_quality = calculate_ac_quality(\u0026criteria);\n\n    let mut score = SpecScore {\n        complexity,\n        confidence,\n        splittability,\n        isolation,\n        ac_quality,\n        traffic_light: chant::scoring::TrafficLight::Ready, // temporary, will be overwritten\n    };\n\n    // Determine final traffic light status\n    score.traffic_light = determine_status(\u0026score);\n\n    score\n}\n\n// ============================================================================\n// VALIDATION HELPERS\n// ============================================================================\n\n/// Validate spec complexity and return diagnostics.\n/// Detects specs that may be too complex for haiku execution.\npub fn validate_spec_complexity(\n    spec: \u0026Spec,\n    thresholds: \u0026chant::config::LintThresholds,\n) -\u003e Vec\u003cLintDiagnostic\u003e {\n    let mut diagnostics = Vec::new();\n\n    // Count total acceptance criteria\n    let criteria_count = spec.count_total_checkboxes();\n    if criteria_count \u003e thresholds.complexity_criteria {\n        diagnostics.push(\n            LintDiagnostic::warning(\n                \u0026spec.id,\n                LintRule::Complexity,\n                format!(\n                    \"Spec has {} acceptance criteria (\u003e{}) - consider splitting for haiku\",\n                    criteria_count, thresholds.complexity_criteria\n                ),\n            )\n            .with_suggestion(format!(\"Consider using 'chant split {}'\", spec.id)),\n        );\n    }\n\n    // Count target files\n    if let Some(files) = \u0026spec.frontmatter.target_files {\n        if files.len() \u003e thresholds.complexity_files {\n            diagnostics.push(\n                LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Complexity,\n                    format!(\n                        \"Spec touches {} files (\u003e{}) - consider splitting\",\n                        files.len(),\n                        thresholds.complexity_files\n                    ),\n                )\n                .with_suggestion(format!(\"Consider using 'chant split {}'\", spec.id)),\n            );\n        }\n    }\n\n    // Count words in body\n    let word_count = spec.body.split_whitespace().count();\n    if word_count \u003e thresholds.complexity_words {\n        diagnostics.push(\n            LintDiagnostic::warning(\n                \u0026spec.id,\n                LintRule::Complexity,\n                format!(\n                    \"Spec description is {} words (\u003e{}) - may be too complex for haiku\",\n                    word_count, thresholds.complexity_words\n                ),\n            )\n            .with_suggestion(format!(\"Consider using 'chant split {}'\", spec.id)),\n        );\n    }\n\n    diagnostics\n}\n\n/// Validate spec for coupling - detect references to other spec IDs in body text.\n/// Specs should be self-contained; use depends_on for explicit dependencies.\n///\n/// Rules:\n/// - Drivers (type: driver/group): excluded from coupling check entirely\n/// - Member specs (.1, .2, etc): warned only for sibling references (same driver, different member)\n/// - Regular specs: warned for any spec ID reference\npub fn validate_spec_coupling(spec: \u0026Spec) -\u003e Vec\u003cLintDiagnostic\u003e {\n    use regex::Regex;\n\n    let mut diagnostics = Vec::new();\n\n    // Drivers are allowed to reference their members - skip check entirely\n    if spec.frontmatter.r#type == \"driver\" || spec.frontmatter.r#type == \"group\" {\n        return diagnostics;\n    }\n\n    // Build regex for spec ID pattern\n    let re = match Regex::new(SPEC_ID_PATTERN) {\n        Ok(r) =\u003e r,\n        Err(_) =\u003e return diagnostics,\n    };\n\n    // Remove code blocks from body before searching\n    let body_without_code = remove_code_blocks(\u0026spec.body);\n\n    // Find all spec IDs in the body (excluding code blocks)\n    let mut referenced_ids: Vec\u003cString\u003e = re\n        .find_iter(\u0026body_without_code)\n        .map(|m| m.as_str().to_string())\n        .filter(|id| {\n            // Exclude the spec's own ID\n            !id.starts_with(\u0026spec.id) \u0026\u0026 !spec.id.starts_with(id)\n        })\n        .collect();\n\n    // Deduplicate\n    referenced_ids.sort();\n    referenced_ids.dedup();\n\n    // Check if this is a member spec\n    if let Some(driver_id) = spec::extract_driver_id(\u0026spec.id) {\n        // This is a member spec - only warn for sibling references\n        let sibling_refs: Vec\u003cString\u003e = referenced_ids\n            .into_iter()\n            .filter(|ref_id| {\n                // Check if referenced spec is a sibling (same driver, different member)\n                if let Some(ref_driver_id) = spec::extract_driver_id(ref_id) {\n                    if ref_driver_id == driver_id {\n                        // Same driver, so it's a sibling\n                        return true;\n                    }\n                }\n                false\n            })\n            .collect();\n\n        if !sibling_refs.is_empty() {\n            let ids_str = sibling_refs.join(\", \");\n            diagnostics.push(\n                LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Coupling,\n                    format!(\n                        \"Spec references sibling spec(s): {} - member specs should be independent\",\n                        ids_str\n                    ),\n                )\n                .with_suggestion(\n                    \"Use depends_on for dependencies instead of referencing spec IDs in the body\"\n                        .to_string(),\n                ),\n            );\n        }\n    } else {\n        // Regular spec - warn on any spec ID reference\n        if !referenced_ids.is_empty() {\n            let ids_str = referenced_ids.join(\", \");\n            diagnostics.push(\n                LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Coupling,\n                    format!(\n                        \"Spec references other spec ID(s) in body: {} - use depends_on for dependencies\",\n                        ids_str\n                    ),\n                )\n                .with_suggestion(\"Use depends_on for dependencies instead of referencing spec IDs in the body\".to_string()),\n            );\n        }\n    }\n\n    diagnostics\n}\n\n/// Remove code blocks from text (content between ``` markers)\nfn remove_code_blocks(text: \u0026str) -\u003e String {\n    let mut result = String::new();\n    let mut in_code_block = false;\n\n    for line in text.lines() {\n        let trimmed = line.trim_start();\n        if trimmed.starts_with(\"```\") {\n            in_code_block = !in_code_block;\n            continue;\n        }\n        if !in_code_block {\n            result.push_str(line);\n            result.push('\\n');\n        }\n    }\n\n    result\n}\n\n/// Validate approval schema - check for consistency in approval fields.\npub fn validate_approval_schema(spec: \u0026Spec) -\u003e Vec\u003cLintDiagnostic\u003e {\n    let mut diagnostics = Vec::new();\n\n    if let Some(ref approval) = spec.frontmatter.approval {\n        // If approved or rejected, should have 'by' and 'at' fields\n        if approval.status == ApprovalStatus::Approved\n            || approval.status == ApprovalStatus::Rejected\n        {\n            if approval.by.is_none() {\n                diagnostics.push(LintDiagnostic::error(\n                    \u0026spec.id,\n                    LintRule::Approval,\n                    format!(\n                        \"Approval status is {:?} but 'by' field is missing\",\n                        approval.status\n                    ),\n                ));\n            }\n            if approval.at.is_none() {\n                diagnostics.push(LintDiagnostic::error(\n                    \u0026spec.id,\n                    LintRule::Approval,\n                    format!(\n                        \"Approval status is {:?} but 'at' timestamp is missing\",\n                        approval.status\n                    ),\n                ));\n            }\n        }\n\n        // If 'by' is set but status is still pending, that's inconsistent\n        if approval.status == ApprovalStatus::Pending \u0026\u0026 approval.by.is_some() {\n            diagnostics.push(LintDiagnostic::error(\n                \u0026spec.id,\n                LintRule::Approval,\n                \"Approval has 'by' field set but status is still 'pending'\".to_string(),\n            ));\n        }\n    }\n\n    diagnostics\n}\n\n/// Validate output schema for completed specs.\n/// If a spec has output_schema defined and is completed, check that the agent log\n/// contains valid JSON matching the schema.\npub fn validate_output_schema(spec: \u0026Spec) -\u003e Vec\u003cLintDiagnostic\u003e {\n    let mut diagnostics = Vec::new();\n\n    // Only validate completed specs with output_schema defined\n    if spec.frontmatter.status != SpecStatus::Completed {\n        return diagnostics;\n    }\n\n    let schema_path_str = match \u0026spec.frontmatter.output_schema {\n        Some(path) =\u003e path,\n        None =\u003e return diagnostics,\n    };\n\n    let schema_path = Path::new(schema_path_str);\n\n    // Check if schema file exists\n    if !schema_path.exists() {\n        diagnostics.push(LintDiagnostic::error(\n            \u0026spec.id,\n            LintRule::Output,\n            format!(\"Output schema file not found: {}\", schema_path_str),\n        ));\n        return diagnostics;\n    }\n\n    // Check if log file exists\n    let logs_dir = PathBuf::from(LOGS_DIR);\n    match validation::validate_spec_output_from_log(\u0026spec.id, schema_path, \u0026logs_dir) {\n        Ok(Some(result)) =\u003e {\n            if !result.is_valid {\n                diagnostics.push(LintDiagnostic::error(\n                    \u0026spec.id,\n                    LintRule::Output,\n                    format!(\"Output validation failed: {}\", result.errors.join(\"; \")),\n                ));\n            }\n        }\n        Ok(None) =\u003e {\n            // No log file - this is expected for specs not yet executed\n            // Don't warn since completion may have been set manually or from archive\n        }\n        Err(e) =\u003e {\n            diagnostics.push(LintDiagnostic::error(\n                \u0026spec.id,\n                LintRule::Output,\n                format!(\"Failed to validate output: {}\", e),\n            ));\n        }\n    }\n\n    diagnostics\n}\n\n/// Validate model usage - warn when expensive models are used on simple specs.\n/// Haiku should be used for straightforward specs; opus/sonnet for complex work.\npub fn validate_model_waste(\n    spec: \u0026Spec,\n    thresholds: \u0026chant::config::LintThresholds,\n) -\u003e Vec\u003cLintDiagnostic\u003e {\n    let mut diagnostics = Vec::new();\n\n    // Only check if model is explicitly set to opus or sonnet\n    let model = match \u0026spec.frontmatter.model {\n        Some(m) =\u003e m.to_lowercase(),\n        None =\u003e return diagnostics,\n    };\n\n    let is_expensive = model.contains(\"opus\") || model.contains(\"sonnet\");\n    if !is_expensive {\n        return diagnostics;\n    }\n\n    // Don't warn on driver/research specs - they benefit from smarter models\n    let spec_type = spec.frontmatter.r#type.as_str();\n    if spec_type == \"driver\" || spec_type == \"group\" || spec_type == \"research\" {\n        return diagnostics;\n    }\n\n    // Check if spec looks simple\n    let criteria_count = spec.count_total_checkboxes();\n    let file_count = spec\n        .frontmatter\n        .target_files\n        .as_ref()\n        .map(|f| f.len())\n        .unwrap_or(0);\n    let word_count = spec.body.split_whitespace().count();\n\n    let is_simple = criteria_count \u003c= thresholds.simple_criteria\n        \u0026\u0026 file_count \u003c= thresholds.simple_files\n        \u0026\u0026 word_count \u003c= thresholds.simple_words;\n\n    if is_simple {\n        diagnostics.push(\n            LintDiagnostic::warning(\n                \u0026spec.id,\n                LintRule::ModelWaste,\n                format!(\n                    \"Spec uses '{}' but appears simple ({} criteria, {} files, {} words) - consider haiku\",\n                    spec.frontmatter.model.as_ref().unwrap(),\n                    criteria_count,\n                    file_count,\n                    word_count\n                ),\n            )\n            .with_suggestion(\"Consider using haiku model for simple specs to reduce cost\".to_string()),\n        );\n    }\n\n    diagnostics\n}\n\n/// Validate a spec based on its type and return diagnostics.\n/// Returns a vector of diagnostics for type-specific validation issues.\npub fn validate_spec_type(spec: \u0026Spec) -\u003e Vec\u003cLintDiagnostic\u003e {\n    let mut diagnostics = Vec::new();\n\n    match spec.frontmatter.r#type.as_str() {\n        \"documentation\" =\u003e {\n            if spec.frontmatter.tracks.is_none() {\n                diagnostics.push(LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Type,\n                    \"Documentation spec missing 'tracks' field\".to_string(),\n                ));\n            }\n            if spec.frontmatter.target_files.is_none() {\n                diagnostics.push(LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Type,\n                    \"Documentation spec missing 'target_files' field\".to_string(),\n                ));\n            }\n        }\n        \"research\" =\u003e {\n            if spec.frontmatter.informed_by.is_none() \u0026\u0026 spec.frontmatter.origin.is_none() {\n                diagnostics.push(LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Type,\n                    \"Research spec missing both 'informed_by' and 'origin' fields\".to_string(),\n                ));\n            }\n            if spec.frontmatter.target_files.is_none() {\n                diagnostics.push(LintDiagnostic::warning(\n                    \u0026spec.id,\n                    LintRule::Type,\n                    \"Research spec missing 'target_files' field\".to_string(),\n                ));\n            }\n        }\n        \"driver\" | \"group\" =\u003e {\n            // Validate members field if present\n            if let Some(ref members) = spec.frontmatter.members {\n                if members.is_empty() {\n                    diagnostics.push(LintDiagnostic::warning(\n                        \u0026spec.id,\n                        LintRule::Type,\n                        \"Driver/group spec has empty 'members' array\".to_string(),\n                    ));\n                }\n            }\n        }\n        _ =\u003e {}\n    }\n\n    diagnostics\n}\n\n// ============================================================================\n// LINT COMMAND FUNCTIONS\n// ============================================================================\n\n/// Internal result type for linting operations\npub struct LintResult {\n    pub passed: usize,\n    pub warned: usize,\n    pub failed: usize,\n}\n\n/// Lint specific specs (by ID) and return a summary.\n/// Useful for linting a subset of specs, like member specs after split.\npub fn lint_specific_specs(specs_dir: \u0026std::path::Path, spec_ids: \u0026[String]) -\u003e Result\u003cLintResult\u003e {\n    let mut all_specs: Vec\u003cSpec\u003e = Vec::new();\n    let mut specs_to_check: Vec\u003cSpec\u003e = Vec::new();\n\n    // Load config to get lint thresholds\n    let config = Config::load().ok();\n    let default_thresholds = chant::config::LintThresholds::default();\n    let thresholds = config\n        .as_ref()\n        .map(|c| \u0026c.lint.thresholds)\n        .unwrap_or(\u0026default_thresholds);\n\n    // Load all specs to validate dependencies\n    for entry in std::fs::read_dir(specs_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n            if let Ok(spec) = Spec::load(\u0026path) {\n                all_specs.push(spec);\n            }\n        }\n    }\n\n    // Build set of all spec IDs for dependency validation\n    let all_spec_ids: std::collections::HashSet\u003c\u0026str\u003e =\n        all_specs.iter().map(|s| s.id.as_str()).collect();\n\n    // Load only the specs we want to check\n    for spec_id in spec_ids {\n        let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n        if spec_path.exists() {\n            match Spec::load(\u0026spec_path) {\n                Ok(spec) =\u003e {\n                    specs_to_check.push(spec);\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"{} {}: Invalid YAML frontmatter: {}\", \"â\".red(), spec_id, e);\n                    return Ok(LintResult {\n                        passed: 0,\n                        warned: 0,\n                        failed: 1,\n                    });\n                }\n            }\n        }\n    }\n\n    let mut passed = 0;\n    let mut warned = 0;\n    let mut failed = 0;\n\n    // Validate each spec\n    for spec in \u0026specs_to_check {\n        let mut spec_diagnostics: Vec\u003cLintDiagnostic\u003e = Vec::new();\n\n        // Check for title\n        if spec.title.is_none() {\n            spec_diagnostics.push(LintDiagnostic::error(\n                \u0026spec.id,\n                LintRule::Title,\n                \"Missing title\".to_string(),\n            ));\n        }\n\n        // Check depends_on references\n        if let Some(deps) = \u0026spec.frontmatter.depends_on {\n            for dep_id in deps {\n                if !all_spec_ids.contains(dep_id.as_str()) {\n                    spec_diagnostics.push(LintDiagnostic::error(\n                        \u0026spec.id,\n                        LintRule::Dependency,\n                        format!(\"Unknown dependency '{}'\", dep_id),\n                    ));\n                }\n            }\n        }\n\n        // Type-specific validation\n        spec_diagnostics.extend(validate_spec_type(spec));\n\n        // Complexity validation\n        spec_diagnostics.extend(validate_spec_complexity(spec, thresholds));\n\n        // Coupling validation (spec references other spec IDs)\n        spec_diagnostics.extend(validate_spec_coupling(spec));\n\n        // Model waste validation (expensive model on simple spec)\n        spec_diagnostics.extend(validate_model_waste(spec, thresholds));\n\n        // Separate errors and warnings\n        let errors: Vec\u003c_\u003e = spec_diagnostics\n            .iter()\n            .filter(|d| d.severity == Severity::Error)\n            .collect();\n        let warnings: Vec\u003c_\u003e = spec_diagnostics\n            .iter()\n            .filter(|d| d.severity == Severity::Warning)\n            .collect();\n\n        if spec_diagnostics.is_empty() {\n            println!(\"  {} {}\", \"â\".green(), spec.id);\n            passed += 1;\n        } else {\n            let has_errors = !errors.is_empty();\n            let has_warnings = !warnings.is_empty();\n\n            if has_errors {\n                for diagnostic in \u0026errors {\n                    println!(\"  {} {}: {}\", \"â\".red(), spec.id, diagnostic.message);\n                }\n                failed += 1;\n            }\n\n            if has_warnings {\n                let has_complexity_warning =\n                    warnings.iter().any(|d| d.rule == LintRule::Complexity);\n                for diagnostic in \u0026warnings {\n                    println!(\"  {} {}: {}\", \"â \".yellow(), spec.id, diagnostic.message);\n                    if let Some(ref suggestion) = diagnostic.suggestion {\n                        println!(\"      {} {}\", \"â\".cyan(), suggestion);\n                    }\n                }\n                // Suggest split if there are complexity warnings\n                if has_complexity_warning {\n                    println!(\"      {} Consider: chant split {}\", \"â\".cyan(), spec.id);\n                }\n                if !has_errors {\n                    warned += 1;\n                }\n            }\n        }\n    }\n\n    Ok(LintResult {\n        passed,\n        warned,\n        failed,\n    })\n}\n\npub fn cmd_lint(format: LintFormat, verbose: bool) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    if format == LintFormat::Text {\n        println!(\"Linting specs...\");\n    }\n\n    let mut all_diagnostics: Vec\u003cLintDiagnostic\u003e = Vec::new();\n    let mut total_specs = 0;\n\n    // Load config to get enterprise required fields and lint thresholds\n    let config = Config::load().ok();\n    let default_thresholds = chant::config::LintThresholds::default();\n    let thresholds = config\n        .as_ref()\n        .map(|c| \u0026c.lint.thresholds)\n        .unwrap_or(\u0026default_thresholds);\n\n    // First pass: collect all specs and check for parse errors\n    let mut specs_to_check: Vec\u003cSpec\u003e = Vec::new();\n\n    for entry in std::fs::read_dir(\u0026specs_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n            total_specs += 1;\n            let id = path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"unknown\")\n                .to_string();\n\n            match Spec::load(\u0026path) {\n                Ok(spec) =\u003e {\n                    specs_to_check.push(spec);\n                }\n                Err(e) =\u003e {\n                    let diagnostic = LintDiagnostic::error(\n                        \u0026id,\n                        LintRule::Parse,\n                        format!(\"Invalid YAML frontmatter: {}\", e),\n                    );\n                    if format == LintFormat::Text {\n                        println!(\"{} {}: {}\", \"â\".red(), id, diagnostic.message);\n                    }\n                    all_diagnostics.push(diagnostic);\n                }\n            }\n        }\n    }\n\n    // Build set of all spec IDs for dependency validation\n    let all_spec_ids: std::collections::HashSet\u003c\u0026str\u003e =\n        specs_to_check.iter().map(|s| s.id.as_str()).collect();\n\n    // Second pass: validate each spec\n    for spec in \u0026specs_to_check {\n        let mut spec_diagnostics: Vec\u003cLintDiagnostic\u003e = Vec::new();\n\n        // Check for title\n        if spec.title.is_none() {\n            spec_diagnostics.push(LintDiagnostic::error(\n                \u0026spec.id,\n                LintRule::Title,\n                \"Missing title\".to_string(),\n            ));\n        }\n\n        // Check depends_on references\n        if let Some(deps) = \u0026spec.frontmatter.depends_on {\n            for dep_id in deps {\n                if !all_spec_ids.contains(dep_id.as_str()) {\n                    spec_diagnostics.push(LintDiagnostic::error(\n                        \u0026spec.id,\n                        LintRule::Dependency,\n                        format!(\"Unknown dependency '{}'\", dep_id),\n                    ));\n                }\n            }\n        }\n\n        // Check members references\n        if let Some(members) = \u0026spec.frontmatter.members {\n            for member_id in members {\n                if !all_spec_ids.contains(member_id.as_str()) {\n                    spec_diagnostics.push(LintDiagnostic::error(\n                        \u0026spec.id,\n                        LintRule::Dependency,\n                        format!(\"Unknown member spec '{}'\", member_id),\n                    ));\n                }\n            }\n        }\n\n        // Check required fields from enterprise config\n        if let Some(ref cfg) = config {\n            if !cfg.enterprise.required.is_empty() {\n                for required_field in \u0026cfg.enterprise.required {\n                    if !spec.has_frontmatter_field(required_field) {\n                        spec_diagnostics.push(LintDiagnostic::error(\n                            \u0026spec.id,\n                            LintRule::Required,\n                            format!(\"Missing required field '{}'\", required_field),\n                        ));\n                    }\n                }\n            }\n        }\n\n        // Type-specific validation\n        spec_diagnostics.extend(validate_spec_type(spec));\n\n        // Complexity validation\n        spec_diagnostics.extend(validate_spec_complexity(spec, thresholds));\n\n        // Coupling validation (spec references other spec IDs)\n        spec_diagnostics.extend(validate_spec_coupling(spec));\n\n        // Model waste validation (expensive model on simple spec)\n        spec_diagnostics.extend(validate_model_waste(spec, thresholds));\n\n        // Approval schema validation\n        spec_diagnostics.extend(validate_approval_schema(spec));\n\n        // Output schema validation for completed specs\n        spec_diagnostics.extend(validate_output_schema(spec));\n\n        // Separate errors and warnings\n        let errors: Vec\u003c_\u003e = spec_diagnostics\n            .iter()\n            .filter(|d| d.severity == Severity::Error)\n            .collect();\n        let warnings: Vec\u003c_\u003e = spec_diagnostics\n            .iter()\n            .filter(|d| d.severity == Severity::Warning)\n            .collect();\n\n        if format == LintFormat::Text {\n            // Calculate quality score for this spec\n            let score = calculate_spec_score(spec, \u0026specs_to_check);\n\n            // Build score display string\n            let mut score_display = format!(\n                \"{} | Complexity: {} | Confidence: {} | Splittable: {}\",\n                score.traffic_light, score.complexity, score.confidence, score.splittability\n            );\n\n            // Add isolation grade if present (specs with members)\n            if verbose {\n                if let Some(isolation) = score.isolation {\n                    score_display.push_str(\u0026format!(\" | Isolation: {}\", isolation));\n                }\n                score_display.push_str(\u0026format!(\" | AC Quality: {}\", score.ac_quality));\n            }\n\n            if spec_diagnostics.is_empty() {\n                println!(\"{} {}: {}\", \"â\".green(), spec.id, score_display);\n            } else {\n                for diagnostic in \u0026errors {\n                    println!(\n                        \"{} {}: {} | {}\",\n                        \"â\".red(),\n                        spec.id,\n                        score_display,\n                        diagnostic.message\n                    );\n                }\n                // Check if there are complexity warnings\n                let has_complexity_warning =\n                    warnings.iter().any(|d| d.rule == LintRule::Complexity);\n                for diagnostic in \u0026warnings {\n                    println!(\n                        \"{} {}: {} | {}\",\n                        \"â \".yellow(),\n                        spec.id,\n                        score_display,\n                        diagnostic.message\n                    );\n                    if let Some(ref suggestion) = diagnostic.suggestion {\n                        println!(\"    {} {}\", \"â\".cyan(), suggestion);\n                    }\n                }\n                // Suggest split if there are complexity warnings\n                if has_complexity_warning {\n                    println!(\"    {} Consider: chant split {}\", \"â\".cyan(), spec.id);\n                }\n            }\n\n            // Show quality suggestions for Review/Refine status\n            use chant::scoring::TrafficLight;\n            if matches!(\n                score.traffic_light,\n                TrafficLight::Review | TrafficLight::Refine\n            ) {\n                // Show basic suggestions\n                let suggestions = generate_suggestions(\u0026score);\n                const MAX_SUGGESTIONS: usize = 3;\n                for (i, suggestion) in suggestions.iter().take(MAX_SUGGESTIONS).enumerate() {\n                    println!(\"    {} {}\", \"â\".cyan(), suggestion);\n                    if i == MAX_SUGGESTIONS - 1 \u0026\u0026 suggestions.len() \u003e MAX_SUGGESTIONS {\n                        let remaining = suggestions.len() - MAX_SUGGESTIONS;\n                        println!(\"    {} ... and {} more\", \"â\".cyan(), remaining);\n                        break;\n                    }\n                }\n\n                // Show detailed guidance in verbose mode\n                if verbose {\n                    use chant::score::traffic_light::generate_detailed_guidance;\n                    let guidance = generate_detailed_guidance(\u0026score);\n                    if !guidance.is_empty() {\n                        print!(\"{}\", guidance);\n                    }\n                }\n            }\n        }\n\n        all_diagnostics.extend(spec_diagnostics);\n    }\n\n    // Count errors\n    let error_count = all_diagnostics\n        .iter()\n        .filter(|d| d.severity == Severity::Error)\n        .count();\n\n    // Output results based on format\n    match format {\n        LintFormat::Text =\u003e {\n            // Print summary with enterprise policy if configured\n            if error_count \u003e 0 {\n                println!(\n                    \"\\nFound {} {} in {} specs.\",\n                    error_count,\n                    if error_count == 1 { \"error\" } else { \"errors\" },\n                    total_specs\n                );\n\n                // Show enterprise policy if required fields are configured\n                if let Some(cfg) = \u0026config {\n                    if !cfg.enterprise.required.is_empty() {\n                        println!(\n                            \"\\n{} Enterprise policy requires: {}\",\n                            \"â¹\".cyan(),\n                            cfg.enterprise.required.join(\", \")\n                        );\n                    }\n                }\n\n                std::process::exit(1);\n            } else {\n                println!(\"\\nAll {} specs valid.\", total_specs);\n                Ok(())\n            }\n        }\n        LintFormat::Json =\u003e {\n            // Count specs by diagnostic status\n            let mut spec_errors = std::collections::HashSet::new();\n            let mut spec_warnings = std::collections::HashSet::new();\n\n            for diag in \u0026all_diagnostics {\n                if diag.severity == Severity::Error {\n                    spec_errors.insert(\u0026diag.spec_id);\n                } else {\n                    spec_warnings.insert(\u0026diag.spec_id);\n                }\n            }\n\n            let failed = spec_errors.len();\n            let warned = spec_warnings.difference(\u0026spec_errors).count();\n            let passed = total_specs - failed - warned;\n\n            let report = LintReport {\n                diagnostics: all_diagnostics,\n                passed,\n                warned,\n                failed,\n                total: total_specs,\n            };\n\n            let json = serde_json::to_string_pretty(\u0026report)?;\n            println!(\"{}\", json);\n\n            if error_count \u003e 0 {\n                std::process::exit(1);\n            } else {\n                Ok(())\n            }\n        }\n    }\n}\n\n// ============================================================================\n// TESTS\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::config::LintThresholds;\n    use chant::spec::{Spec, SpecFrontmatter};\n\n    /// Create a test spec with the specified number of criteria, files, and approximate body words.\n    /// Note: The body will contain slightly more words than `body_words` due to the Acceptance Criteria\n    /// section, but this helper ensures consistent test data.\n    fn create_test_spec(\n        id: \u0026str,\n        criteria_count: usize,\n        file_count: usize,\n        body_words: usize,\n    ) -\u003e Spec {\n        let mut body = String::new();\n\n        // Add body content with approximately the specified word count\n        // We add simple filler text to control the word count\n        if body_words \u003e 0 {\n            for _ in 0..body_words {\n                body.push_str(\"word \");\n            }\n            body.push('\\n');\n        }\n\n        // Add Acceptance Criteria section with specified number of checkboxes\n        if criteria_count \u003e 0 {\n            body.push_str(\"\\n## Acceptance Criteria\\n\\n\");\n            for i in 0..criteria_count {\n                body.push_str(\u0026format!(\"- [ ] Criterion {}\\n\", i + 1));\n            }\n        }\n\n        let mut frontmatter = SpecFrontmatter::default();\n        if file_count \u003e 0 {\n            frontmatter.target_files =\n                Some((0..file_count).map(|i| format!(\"file{}.rs\", i)).collect());\n        }\n\n        Spec {\n            id: id.to_string(),\n            frontmatter,\n            title: Some(\"Test Spec\".to_string()),\n            body,\n        }\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_below_thresholds() {\n        // Default thresholds: criteria=10, files=5, words=50\n        // Create spec well below all thresholds\n        let spec = create_test_spec(\"2026-01-30-001-abc\", 5, 3, 20);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Should have no diagnostics when below all thresholds\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_exceeds_criteria() {\n        // Default threshold: 10 criteria, 50 words\n        // Create spec with 11 criteria (just above threshold), but within files limit\n        // Note: Each criterion adds ~5 words, so 11 criteria â 58 words total\n        // This will trigger both criteria and words warnings, which is expected\n        let spec = create_test_spec(\"2026-01-30-002-def\", 11, 3, 0);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026thresholds);\n\n        // Find the criteria diagnostic\n        let criteria_diag = diagnostics\n            .iter()\n            .find(|d| d.message.contains(\"acceptance criteria\"))\n            .expect(\"Should have criteria diagnostic\");\n\n        assert_eq!(criteria_diag.rule, LintRule::Complexity);\n        assert_eq!(criteria_diag.severity, Severity::Warning);\n        assert!(\n            criteria_diag.message.contains(\"11 acceptance criteria\"),\n            \"Message should mention the criteria count\"\n        );\n        assert!(\n            criteria_diag.message.contains(\"\u003e10\"),\n            \"Message should mention the threshold\"\n        );\n        assert!(\n            criteria_diag.suggestion.is_some(),\n            \"Should have a suggestion\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_exceeds_files() {\n        // Default threshold: 5 files\n        // Create spec with 8 files, but within criteria and words limits\n        let spec = create_test_spec(\"2026-01-30-003-ghi\", 5, 8, 20);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026thresholds);\n\n        assert_eq!(diagnostics.len(), 1, \"Should have exactly one diagnostic\");\n        assert_eq!(diagnostics[0].rule, LintRule::Complexity);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"8 files\"),\n            \"Message should mention the file count\"\n        );\n        assert!(\n            diagnostics[0].message.contains(\"\u003e5\"),\n            \"Message should mention the threshold\"\n        );\n        assert!(\n            diagnostics[0].suggestion.is_some(),\n            \"Should have a suggestion\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_exceeds_words() {\n        // Default threshold: 50 words\n        // Create spec with 100 words, but within criteria and files limits\n        let spec = create_test_spec(\"2026-01-30-004-jkl\", 5, 3, 100);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026thresholds);\n\n        assert_eq!(diagnostics.len(), 1, \"Should have exactly one diagnostic\");\n        assert_eq!(diagnostics[0].rule, LintRule::Complexity);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\" words\"),\n            \"Message should mention words\"\n        );\n        assert!(\n            diagnostics[0].message.contains(\"\u003e50\"),\n            \"Message should mention the threshold\"\n        );\n        assert!(\n            diagnostics[0].suggestion.is_some(),\n            \"Should have a suggestion\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_custom_thresholds() {\n        // Custom thresholds: criteria=7, files=3, words=35\n        // Create spec with: criteria=8, files=4, words=40\n        let spec = create_test_spec(\"2026-01-30-005-mno\", 8, 4, 40);\n        let custom_thresholds = LintThresholds {\n            complexity_criteria: 7,\n            complexity_files: 3,\n            complexity_words: 35,\n            simple_criteria: 1,\n            simple_files: 1,\n            simple_words: 3,\n        };\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026custom_thresholds);\n\n        // Should trigger all three warnings with custom thresholds\n        assert_eq!(\n            diagnostics.len(),\n            3,\n            \"Should have three diagnostics with custom thresholds\"\n        );\n\n        // Check that we have warnings for criteria, files, and words\n        let has_criteria_warning = diagnostics\n            .iter()\n            .any(|d| d.message.contains(\"8 acceptance criteria\"));\n        let has_files_warning = diagnostics.iter().any(|d| d.message.contains(\"4 files\"));\n        let has_words_warning = diagnostics.iter().any(|d| d.message.contains(\" words\"));\n\n        assert!(has_criteria_warning, \"Should have criteria warning\");\n        assert!(has_files_warning, \"Should have files warning\");\n        assert!(has_words_warning, \"Should have words warning\");\n    }\n\n    #[test]\n    fn test_validate_spec_complexity_multiple_thresholds_exceeded() {\n        // Default thresholds: criteria=10, files=5, words=50\n        // Create spec that exceeds all: criteria=15, files=8, words=100\n        let spec = create_test_spec(\"2026-01-30-006-pqr\", 15, 8, 100);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_spec_complexity(\u0026spec, \u0026thresholds);\n\n        // Should trigger all three warnings\n        assert_eq!(\n            diagnostics.len(),\n            3,\n            \"Should have three diagnostics when all thresholds exceeded\"\n        );\n        assert!(diagnostics.iter().all(|d| d.rule == LintRule::Complexity));\n        assert!(diagnostics.iter().all(|d| d.severity == Severity::Warning));\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_no_references() {\n        // Create a regular spec with no spec ID references\n        let spec = Spec {\n            id: \"2026-01-30-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"This is a spec without any spec ID references.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Should have no diagnostics when there are no spec references\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_driver_excluded() {\n        // Create a driver spec that references member specs\n        let spec = Spec {\n            id: \"2026-01-30-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"driver\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Driver\".to_string()),\n            body: \"This driver references 2026-01-30-002-def.1 and 2026-01-30-002-def.2.\"\n                .to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Driver specs should be excluded from coupling check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_group_excluded() {\n        // Create a group spec that references other specs\n        let spec = Spec {\n            id: \"2026-01-30-003-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"group\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Group\".to_string()),\n            body: \"This group references 2026-01-30-003-ghi.1 and 2026-01-30-004-jkl.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Group specs should be excluded from coupling check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_regular_spec_with_reference() {\n        // Create a regular spec that references another spec ID\n        let spec = Spec {\n            id: \"2026-01-30-004-jkl\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"This spec depends on 2026-01-30-003-ghi for completion.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for spec ID reference\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Coupling);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"2026-01-30-003-ghi\"),\n            \"Message should mention the referenced spec ID\"\n        );\n        assert!(\n            diagnostics[0].message.contains(\"use depends_on\"),\n            \"Message should suggest using depends_on\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_self_reference_excluded() {\n        // Create a spec that references its own ID\n        let spec = Spec {\n            id: \"2026-01-30-005-mno\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"This spec is 2026-01-30-005-mno and references itself.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Self-references should be excluded from coupling check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_code_block_excluded() {\n        // Create a spec with spec IDs in code blocks\n        let spec = Spec {\n            id: \"2026-01-30-006-pqr\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: r#\"\nThis spec shows code examples:\n\n```bash\nchant work 2026-01-30-003-ghi\n```\n\nAnd another example:\n```\n2026-01-30-004-jkl\n```\n\nNo coupling issues here.\n\"#\n            .to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Spec IDs in code blocks should be excluded from coupling check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_member_spec_sibling_warning() {\n        // Create a member spec that references a sibling member\n        let spec = Spec {\n            id: \"2026-01-30-007-stu.1\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Member\".to_string()),\n            body: \"This member depends on 2026-01-30-007-stu.2 being completed.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for sibling reference\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Coupling);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"2026-01-30-007-stu.2\"),\n            \"Message should mention the sibling spec ID\"\n        );\n        assert!(\n            diagnostics[0]\n                .message\n                .contains(\"member specs should be independent\"),\n            \"Message should mention member independence\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_coupling_member_spec_non_sibling_ok() {\n        // Create a member spec that references a non-sibling spec (different driver)\n        let spec = Spec {\n            id: \"2026-01-30-008-vwx.1\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"code\".to_string(),\n                ..Default::default()\n            },\n            title: Some(\"Test Member\".to_string()),\n            body: \"This member references 2026-01-30-009-yza which is not a sibling.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_coupling(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Member specs should be allowed to reference non-sibling specs\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_type_documentation_missing_tracks() {\n        // Create a documentation spec without tracks field\n        let spec = Spec {\n            id: \"2026-01-30-010-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"documentation\".to_string(),\n                target_files: Some(vec![\"README.md\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Documentation Spec\".to_string()),\n            body: \"Document the API.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_type(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for missing tracks\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Type);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"missing 'tracks'\"),\n            \"Message should mention missing tracks field\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_type_documentation_missing_target_files() {\n        // Create a documentation spec without target_files field\n        let spec = Spec {\n            id: \"2026-01-30-011-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"documentation\".to_string(),\n                tracks: Some(vec![\"2026-01-30-001-abc\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Documentation Spec\".to_string()),\n            body: \"Document the API.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_type(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for missing target_files\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Type);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"missing 'target_files'\"),\n            \"Message should mention missing target_files field\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_type_research_missing_fields() {\n        // Create a research spec without informed_by or origin\n        let spec = Spec {\n            id: \"2026-01-30-012-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"research\".to_string(),\n                target_files: Some(vec![\"analysis.md\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Research Spec\".to_string()),\n            body: \"Research the topic.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_type(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for missing informed_by and origin\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Type);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0]\n                .message\n                .contains(\"missing both 'informed_by' and 'origin'\"),\n            \"Message should mention missing informed_by and origin fields\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_type_driver_empty_members() {\n        // Create a driver spec with empty members array\n        let spec = Spec {\n            id: \"2026-01-30-013-jkl\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"driver\".to_string(),\n                members: Some(vec![]),\n                ..Default::default()\n            },\n            title: Some(\"Driver Spec\".to_string()),\n            body: \"Driver with no members.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_type(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for empty members\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Type);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"empty 'members' array\"),\n            \"Message should mention empty members array\"\n        );\n    }\n\n    #[test]\n    fn test_validate_spec_type_driver_with_members_ok() {\n        // Create a driver spec with non-empty members array\n        let spec = Spec {\n            id: \"2026-01-30-014-mno\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"driver\".to_string(),\n                members: Some(vec![\n                    \"2026-01-30-014-mno.1\".to_string(),\n                    \"2026-01-30-014-mno.2\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Driver Spec\".to_string()),\n            body: \"Driver with members.\".to_string(),\n        };\n\n        let diagnostics = validate_spec_type(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Should have no diagnostics when driver has members\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_no_model_set() {\n        // Create a simple spec without model field\n        let spec = create_test_spec(\"2026-01-30-020-abc\", 1, 1, 5);\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Should have no diagnostics when model is not set\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_haiku_ok() {\n        // Create a simple spec with haiku model - should not trigger warning\n        let mut spec = create_test_spec(\"2026-01-30-021-def\", 1, 1, 5);\n        spec.frontmatter.model = Some(\"haiku\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Haiku model should never trigger model waste warning\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_opus_on_simple_spec() {\n        // Create a simple spec with opus model - should trigger warning\n        // Default simple thresholds: criteria\u003c=1, files\u003c=1, words\u003c=3\n        // Create spec with 0 criteria, 0 files, 0 words to ensure it's simple\n        let mut spec = create_test_spec(\"2026-01-30-022-ghi\", 0, 0, 0);\n        spec.frontmatter.model = Some(\"opus\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for opus on simple spec\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::ModelWaste);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"opus\"),\n            \"Message should mention opus model\"\n        );\n        assert!(\n            diagnostics[0].message.contains(\"simple\"),\n            \"Message should mention spec is simple\"\n        );\n        assert!(\n            diagnostics[0].suggestion.is_some(),\n            \"Should have a suggestion\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_sonnet_on_simple_spec() {\n        // Create a simple spec with sonnet model - should trigger warning\n        let mut spec = create_test_spec(\"2026-01-30-023-jkl\", 0, 0, 0);\n        spec.frontmatter.model = Some(\"sonnet\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Should have one diagnostic for sonnet on simple spec\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::ModelWaste);\n        assert_eq!(diagnostics[0].severity, Severity::Warning);\n        assert!(\n            diagnostics[0].message.contains(\"sonnet\"),\n            \"Message should mention sonnet model\"\n        );\n        assert!(\n            diagnostics[0].message.contains(\"simple\"),\n            \"Message should mention spec is simple\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_research_excluded() {\n        // Create a simple research spec with opus - should not trigger warning\n        let mut spec = create_test_spec(\"2026-01-30-024-mno\", 0, 0, 0);\n        spec.frontmatter.r#type = \"research\".to_string();\n        spec.frontmatter.model = Some(\"opus\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Research specs should be excluded from model waste check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_driver_excluded() {\n        // Create a simple driver spec with sonnet - should not trigger warning\n        let mut spec = create_test_spec(\"2026-01-30-025-pqr\", 0, 0, 0);\n        spec.frontmatter.r#type = \"driver\".to_string();\n        spec.frontmatter.model = Some(\"sonnet\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Driver specs should be excluded from model waste check\"\n        );\n    }\n\n    #[test]\n    fn test_validate_model_waste_complex_spec_ok() {\n        // Create a complex spec with opus - should not trigger warning\n        // Default simple thresholds: criteria\u003c=1, files\u003c=1, words\u003c=3\n        // This spec exceeds all simple thresholds so it's considered complex\n        let mut spec = create_test_spec(\"2026-01-30-026-stu\", 5, 3, 20);\n        spec.frontmatter.model = Some(\"opus\".to_string());\n        let thresholds = LintThresholds::default();\n\n        let diagnostics = validate_model_waste(\u0026spec, \u0026thresholds);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Complex specs should be allowed to use expensive models\"\n        );\n    }\n\n    #[test]\n    fn test_validate_approval_schema_no_approval_field() {\n        // Create a spec without approval field - should be OK\n        let spec = Spec {\n            id: \"2026-01-30-030-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                approval: None,\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"No approval needed.\".to_string(),\n        };\n\n        let diagnostics = validate_approval_schema(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Spec without approval field should have no diagnostics\"\n        );\n    }\n\n    #[test]\n    fn test_validate_approval_schema_pending_ok() {\n        // Create a spec with pending approval - should be OK\n        let spec = Spec {\n            id: \"2026-01-30-031-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                approval: Some(chant::spec::Approval {\n                    required: false,\n                    status: ApprovalStatus::Pending,\n                    by: None,\n                    at: None,\n                }),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"Pending approval.\".to_string(),\n        };\n\n        let diagnostics = validate_approval_schema(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            0,\n            \"Pending approval without 'by' or 'at' should have no diagnostics\"\n        );\n    }\n\n    #[test]\n    fn test_validate_approval_schema_approved_missing_by() {\n        // Create a spec with approved status but missing 'by' field\n        let spec = Spec {\n            id: \"2026-01-30-032-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                approval: Some(chant::spec::Approval {\n                    required: false,\n                    status: ApprovalStatus::Approved,\n                    by: None,\n                    at: Some(\"2026-01-30T12:00:00Z\".to_string()),\n                }),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"Approved but missing by.\".to_string(),\n        };\n\n        let diagnostics = validate_approval_schema(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Approved status without 'by' should have one diagnostic\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Approval);\n        assert_eq!(diagnostics[0].severity, Severity::Error);\n        assert!(\n            diagnostics[0].message.contains(\"'by' field is missing\"),\n            \"Message should mention missing 'by' field\"\n        );\n    }\n\n    #[test]\n    fn test_validate_approval_schema_approved_missing_at() {\n        // Create a spec with approved status but missing 'at' field\n        let spec = Spec {\n            id: \"2026-01-30-033-jkl\".to_string(),\n            frontmatter: SpecFrontmatter {\n                approval: Some(chant::spec::Approval {\n                    required: false,\n                    status: ApprovalStatus::Approved,\n                    by: Some(\"alice\".to_string()),\n                    at: None,\n                }),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"Approved but missing at.\".to_string(),\n        };\n\n        let diagnostics = validate_approval_schema(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Approved status without 'at' should have one diagnostic\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Approval);\n        assert_eq!(diagnostics[0].severity, Severity::Error);\n        assert!(\n            diagnostics[0].message.contains(\"'at' timestamp is missing\"),\n            \"Message should mention missing 'at' timestamp\"\n        );\n    }\n\n    #[test]\n    fn test_validate_approval_schema_pending_with_by_inconsistent() {\n        // Create a spec with pending status but 'by' field set - inconsistent\n        let spec = Spec {\n            id: \"2026-01-30-034-mno\".to_string(),\n            frontmatter: SpecFrontmatter {\n                approval: Some(chant::spec::Approval {\n                    required: false,\n                    status: ApprovalStatus::Pending,\n                    by: Some(\"alice\".to_string()),\n                    at: None,\n                }),\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"Pending with by field.\".to_string(),\n        };\n\n        let diagnostics = validate_approval_schema(\u0026spec);\n\n        assert_eq!(\n            diagnostics.len(),\n            1,\n            \"Pending status with 'by' field should have one diagnostic\"\n        );\n        assert_eq!(diagnostics[0].rule, LintRule::Approval);\n        assert_eq!(diagnostics[0].severity, Severity::Error);\n        assert!(\n            diagnostics[0]\n                .message\n                .contains(\"has 'by' field set but status is still 'pending'\"),\n            \"Message should mention inconsistency\"\n        );\n    }\n}\n","traces":[{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":18}},{"line":122,"address":[],"length":0,"stats":{"Line":19}},{"line":124,"address":[],"length":0,"stats":{"Line":57}},{"line":133,"address":[],"length":0,"stats":{"Line":14}},{"line":134,"address":[],"length":0,"stats":{"Line":28}},{"line":135,"address":[],"length":0,"stats":{"Line":14}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":12}},{"line":191,"address":[],"length":0,"stats":{"Line":27}},{"line":193,"address":[],"length":0,"stats":{"Line":18}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":36}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":9}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":9}},{"line":233,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":18}},{"line":247,"address":[],"length":0,"stats":{"Line":9}},{"line":248,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":9}},{"line":254,"address":[],"length":0,"stats":{"Line":12}},{"line":257,"address":[],"length":0,"stats":{"Line":9}},{"line":258,"address":[],"length":0,"stats":{"Line":9}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":9}},{"line":285,"address":[],"length":0,"stats":{"Line":18}},{"line":288,"address":[],"length":0,"stats":{"Line":27}},{"line":289,"address":[],"length":0,"stats":{"Line":12}},{"line":290,"address":[],"length":0,"stats":{"Line":9}},{"line":291,"address":[],"length":0,"stats":{"Line":6}},{"line":292,"address":[],"length":0,"stats":{"Line":6}},{"line":293,"address":[],"length":0,"stats":{"Line":6}},{"line":294,"address":[],"length":0,"stats":{"Line":6}},{"line":295,"address":[],"length":0,"stats":{"Line":3}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":304,"address":[],"length":0,"stats":{"Line":15}},{"line":305,"address":[],"length":0,"stats":{"Line":15}},{"line":306,"address":[],"length":0,"stats":{"Line":9}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":308,"address":[],"length":0,"stats":{"Line":6}},{"line":309,"address":[],"length":0,"stats":{"Line":6}},{"line":310,"address":[],"length":0,"stats":{"Line":6}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":9}},{"line":313,"address":[],"length":0,"stats":{"Line":3}},{"line":316,"address":[],"length":0,"stats":{"Line":3}},{"line":322,"address":[],"length":0,"stats":{"Line":27}},{"line":323,"address":[],"length":0,"stats":{"Line":13}},{"line":324,"address":[],"length":0,"stats":{"Line":12}},{"line":325,"address":[],"length":0,"stats":{"Line":8}},{"line":326,"address":[],"length":0,"stats":{"Line":8}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":8}},{"line":329,"address":[],"length":0,"stats":{"Line":4}},{"line":330,"address":[],"length":0,"stats":{"Line":4}},{"line":333,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":9}},{"line":347,"address":[],"length":0,"stats":{"Line":11}},{"line":350,"address":[],"length":0,"stats":{"Line":22}},{"line":353,"address":[],"length":0,"stats":{"Line":21}},{"line":354,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":18}},{"line":359,"address":[],"length":0,"stats":{"Line":18}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":27}},{"line":367,"address":[],"length":0,"stats":{"Line":27}},{"line":368,"address":[],"length":0,"stats":{"Line":18}},{"line":369,"address":[],"length":0,"stats":{"Line":17}},{"line":370,"address":[],"length":0,"stats":{"Line":13}},{"line":372,"address":[],"length":0,"stats":{"Line":14}},{"line":377,"address":[],"length":0,"stats":{"Line":9}},{"line":378,"address":[],"length":0,"stats":{"Line":18}},{"line":381,"address":[],"length":0,"stats":{"Line":11}},{"line":383,"address":[],"length":0,"stats":{"Line":6}},{"line":385,"address":[],"length":0,"stats":{"Line":4}},{"line":387,"address":[],"length":0,"stats":{"Line":3}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[],"length":0,"stats":{"Line":3}},{"line":398,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":8}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[],"length":0,"stats":{"Line":3}},{"line":419,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":9}},{"line":436,"address":[],"length":0,"stats":{"Line":9}},{"line":437,"address":[],"length":0,"stats":{"Line":18}},{"line":438,"address":[],"length":0,"stats":{"Line":18}},{"line":440,"address":[],"length":0,"stats":{"Line":45}},{"line":441,"address":[],"length":0,"stats":{"Line":81}},{"line":442,"address":[],"length":0,"stats":{"Line":54}},{"line":443,"address":[],"length":0,"stats":{"Line":4}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":446,"address":[],"length":0,"stats":{"Line":44}},{"line":447,"address":[],"length":0,"stats":{"Line":84}},{"line":448,"address":[],"length":0,"stats":{"Line":21}},{"line":452,"address":[],"length":0,"stats":{"Line":9}},{"line":456,"address":[],"length":0,"stats":{"Line":8}},{"line":457,"address":[],"length":0,"stats":{"Line":16}},{"line":459,"address":[],"length":0,"stats":{"Line":12}},{"line":461,"address":[],"length":0,"stats":{"Line":4}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":464,"address":[],"length":0,"stats":{"Line":5}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":468,"address":[],"length":0,"stats":{"Line":1}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":470,"address":[],"length":0,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":5}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":1}},{"line":478,"address":[],"length":0,"stats":{"Line":1}},{"line":479,"address":[],"length":0,"stats":{"Line":1}},{"line":480,"address":[],"length":0,"stats":{"Line":1}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":488,"address":[],"length":0,"stats":{"Line":4}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":496,"address":[],"length":0,"stats":{"Line":8}},{"line":502,"address":[],"length":0,"stats":{"Line":3}},{"line":503,"address":[],"length":0,"stats":{"Line":6}},{"line":506,"address":[],"length":0,"stats":{"Line":3}},{"line":507,"address":[],"length":0,"stats":{"Line":3}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":10}},{"line":561,"address":[],"length":0,"stats":{"Line":20}},{"line":564,"address":[],"length":0,"stats":{"Line":16}},{"line":565,"address":[],"length":0,"stats":{"Line":12}},{"line":566,"address":[],"length":0,"stats":{"Line":4}},{"line":569,"address":[],"length":0,"stats":{"Line":15}},{"line":570,"address":[],"length":0,"stats":{"Line":6}},{"line":571,"address":[],"length":0,"stats":{"Line":1}},{"line":575,"address":[],"length":0,"stats":{"Line":15}},{"line":576,"address":[],"length":0,"stats":{"Line":13}},{"line":577,"address":[],"length":0,"stats":{"Line":2}},{"line":581,"address":[],"length":0,"stats":{"Line":9}},{"line":582,"address":[],"length":0,"stats":{"Line":6}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":584,"address":[],"length":0,"stats":{"Line":3}},{"line":586,"address":[],"length":0,"stats":{"Line":5}},{"line":588,"address":[],"length":0,"stats":{"Line":9}},{"line":590,"address":[],"length":0,"stats":{"Line":6}},{"line":591,"address":[],"length":0,"stats":{"Line":2}},{"line":592,"address":[],"length":0,"stats":{"Line":2}},{"line":594,"address":[],"length":0,"stats":{"Line":5}},{"line":595,"address":[],"length":0,"stats":{"Line":6}},{"line":596,"address":[],"length":0,"stats":{"Line":4}},{"line":597,"address":[],"length":0,"stats":{"Line":4}},{"line":598,"address":[],"length":0,"stats":{"Line":4}},{"line":599,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":2}},{"line":601,"address":[],"length":0,"stats":{"Line":8}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":4}},{"line":611,"address":[],"length":0,"stats":{"Line":3}},{"line":616,"address":[],"length":0,"stats":{"Line":10}},{"line":617,"address":[],"length":0,"stats":{"Line":20}},{"line":619,"address":[],"length":0,"stats":{"Line":10}},{"line":620,"address":[],"length":0,"stats":{"Line":10}},{"line":621,"address":[],"length":0,"stats":{"Line":5}},{"line":622,"address":[],"length":0,"stats":{"Line":4}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[],"length":0,"stats":{"Line":1}},{"line":628,"address":[],"length":0,"stats":{"Line":5}},{"line":629,"address":[],"length":0,"stats":{"Line":4}},{"line":630,"address":[],"length":0,"stats":{"Line":2}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":632,"address":[],"length":0,"stats":{"Line":1}},{"line":636,"address":[],"length":0,"stats":{"Line":8}},{"line":637,"address":[],"length":0,"stats":{"Line":5}},{"line":638,"address":[],"length":0,"stats":{"Line":4}},{"line":639,"address":[],"length":0,"stats":{"Line":2}},{"line":640,"address":[],"length":0,"stats":{"Line":2}},{"line":641,"address":[],"length":0,"stats":{"Line":1}},{"line":644,"address":[],"length":0,"stats":{"Line":2}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":10}},{"line":654,"address":[],"length":0,"stats":{"Line":8}},{"line":655,"address":[],"length":0,"stats":{"Line":10}},{"line":656,"address":[],"length":0,"stats":{"Line":8}},{"line":657,"address":[],"length":0,"stats":{"Line":4}},{"line":658,"address":[],"length":0,"stats":{"Line":4}},{"line":659,"address":[],"length":0,"stats":{"Line":2}},{"line":664,"address":[],"length":0,"stats":{"Line":3}},{"line":667,"address":[],"length":0,"stats":{"Line":10}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":3}},{"line":825,"address":[],"length":0,"stats":{"Line":6}},{"line":827,"address":[],"length":0,"stats":{"Line":6}},{"line":828,"address":[],"length":0,"stats":{"Line":3}},{"line":831,"address":[],"length":0,"stats":{"Line":9}},{"line":832,"address":[],"length":0,"stats":{"Line":6}},{"line":835,"address":[],"length":0,"stats":{"Line":9}},{"line":836,"address":[],"length":0,"stats":{"Line":6}},{"line":837,"address":[],"length":0,"stats":{"Line":6}},{"line":839,"address":[],"length":0,"stats":{"Line":3}},{"line":840,"address":[],"length":0,"stats":{"Line":6}},{"line":843,"address":[],"length":0,"stats":{"Line":9}},{"line":845,"address":[],"length":0,"stats":{"Line":9}},{"line":846,"address":[],"length":0,"stats":{"Line":6}},{"line":847,"address":[],"length":0,"stats":{"Line":9}},{"line":849,"address":[],"length":0,"stats":{"Line":15}},{"line":850,"address":[],"length":0,"stats":{"Line":3}},{"line":851,"address":[],"length":0,"stats":{"Line":6}},{"line":853,"address":[],"length":0,"stats":{"Line":9}},{"line":857,"address":[],"length":0,"stats":{"Line":3}},{"line":858,"address":[],"length":0,"stats":{"Line":6}},{"line":859,"address":[],"length":0,"stats":{"Line":6}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":6}},{"line":878,"address":[],"length":0,"stats":{"Line":15}},{"line":881,"address":[],"length":0,"stats":{"Line":6}},{"line":882,"address":[],"length":0,"stats":{"Line":9}},{"line":885,"address":[],"length":0,"stats":{"Line":6}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":3}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":3}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":6}},{"line":921,"address":[],"length":0,"stats":{"Line":3}},{"line":922,"address":[],"length":0,"stats":{"Line":7}},{"line":923,"address":[],"length":0,"stats":{"Line":13}},{"line":924,"address":[],"length":0,"stats":{"Line":12}},{"line":925,"address":[],"length":0,"stats":{"Line":6}},{"line":926,"address":[],"length":0,"stats":{"Line":3}},{"line":927,"address":[],"length":0,"stats":{"Line":3}},{"line":935,"address":[],"length":0,"stats":{"Line":12}},{"line":938,"address":[],"length":0,"stats":{"Line":15}},{"line":941,"address":[],"length":0,"stats":{"Line":12}},{"line":944,"address":[],"length":0,"stats":{"Line":15}},{"line":947,"address":[],"length":0,"stats":{"Line":12}},{"line":950,"address":[],"length":0,"stats":{"Line":12}},{"line":953,"address":[],"length":0,"stats":{"Line":9}},{"line":955,"address":[],"length":0,"stats":{"Line":9}},{"line":957,"address":[],"length":0,"stats":{"Line":9}},{"line":959,"address":[],"length":0,"stats":{"Line":9}},{"line":962,"address":[],"length":0,"stats":{"Line":3}},{"line":964,"address":[],"length":0,"stats":{"Line":12}},{"line":967,"address":[],"length":0,"stats":{"Line":6}},{"line":973,"address":[],"length":0,"stats":{"Line":3}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":8}},{"line":981,"address":[],"length":0,"stats":{"Line":4}},{"line":983,"address":[],"length":0,"stats":{"Line":7}},{"line":984,"address":[],"length":0,"stats":{"Line":6}},{"line":985,"address":[],"length":0,"stats":{"Line":3}},{"line":986,"address":[],"length":0,"stats":{"Line":3}},{"line":987,"address":[],"length":0,"stats":{"Line":3}},{"line":988,"address":[],"length":0,"stats":{"Line":3}},{"line":989,"address":[],"length":0,"stats":{"Line":3}},{"line":993,"address":[],"length":0,"stats":{"Line":1}},{"line":994,"address":[],"length":0,"stats":{"Line":2}},{"line":995,"address":[],"length":0,"stats":{"Line":1}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":1}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":3}},{"line":1020,"address":[],"length":0,"stats":{"Line":9}},{"line":1022,"address":[],"length":0,"stats":{"Line":27}},{"line":1023,"address":[],"length":0,"stats":{"Line":27}},{"line":1024,"address":[],"length":0,"stats":{"Line":12}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":3}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":9}},{"line":1046,"address":[],"length":0,"stats":{"Line":6}},{"line":1048,"address":[],"length":0,"stats":{"Line":9}},{"line":1052,"address":[],"length":0,"stats":{"Line":3}},{"line":1055,"address":[],"length":0,"stats":{"Line":3}},{"line":1056,"address":[],"length":0,"stats":{"Line":1}},{"line":1059,"address":[],"length":0,"stats":{"Line":2}},{"line":1064,"address":[],"length":0,"stats":{"Line":2}},{"line":1065,"address":[],"length":0,"stats":{"Line":2}},{"line":1066,"address":[],"length":0,"stats":{"Line":2}},{"line":1067,"address":[],"length":0,"stats":{"Line":1}},{"line":1068,"address":[],"length":0,"stats":{"Line":3}},{"line":1069,"address":[],"length":0,"stats":{"Line":2}},{"line":1074,"address":[],"length":0,"stats":{"Line":1}},{"line":1076,"address":[],"length":0,"stats":{"Line":2}},{"line":1077,"address":[],"length":0,"stats":{"Line":2}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}}],"covered":301,"coverable":495},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","list.rs"],"content":"//! Spec listing and filtering functionality\n//!\n//! Provides the `cmd_list` and `cmd_status` command functions\n//! along with helper functions for filtering, sorting, and displaying specs.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\nuse chant::config::Config;\nuse chant::id;\nuse chant::spec::{self, ApprovalStatus, Spec, SpecStatus};\nuse chant::spec_group;\n\nuse crate::render;\n\n// ============================================================================\n// MULTI-REPO HELPERS\n// ============================================================================\n\n/// Load specs from all configured repos (or a specific repo if specified)\npub(crate) fn load_specs_from_repos(repo_filter: Option\u003c\u0026str\u003e) -\u003e Result\u003cVec\u003cSpec\u003e\u003e {\n    // Load global config\n    let config = Config::load_merged()?;\n\n    if config.repos.is_empty() {\n        anyhow::bail!(\n            \"No repos configured in global config. \\\n             Please add repos to ~/.config/chant/config.md or use local mode without --global/--repo\"\n        );\n    }\n\n    // If repo_filter is specified, validate it exists\n    if let Some(repo_name) = repo_filter {\n        if !config.repos.iter().any(|r| r.name == repo_name) {\n            anyhow::bail!(\n                \"Repository '{}' not found in global config. Available repos: {}\",\n                repo_name,\n                config\n                    .repos\n                    .iter()\n                    .map(|r| r.name.as_str())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \")\n            );\n        }\n    }\n\n    let mut all_specs = Vec::new();\n\n    for repo_config in \u0026config.repos {\n        // Skip if filtering by repo and this isn't it\n        if let Some(filter) = repo_filter {\n            if repo_config.name != filter {\n                continue;\n            }\n        }\n\n        // Expand path (handle ~ and environment variables)\n        let repo_path = shellexpand::tilde(\u0026repo_config.path).to_string();\n        let repo_path = PathBuf::from(repo_path);\n\n        let specs_dir = repo_path.join(\".chant/specs\");\n\n        // Gracefully skip if repo doesn't exist or has no specs dir\n        if !specs_dir.exists() {\n            eprintln!(\n                \"{} Warning: Specs directory not found for repo '{}' at {}\",\n                \"â \".yellow(),\n                repo_config.name,\n                specs_dir.display()\n            );\n            continue;\n        }\n\n        // Load specs from this repo\n        match spec::load_all_specs(\u0026specs_dir) {\n            Ok(mut repo_specs) =\u003e {\n                // Add repo prefix to each spec ID\n                for spec in \u0026mut repo_specs {\n                    spec.id = format!(\"{}:{}\", repo_config.name, spec.id);\n                }\n                all_specs.extend(repo_specs);\n            }\n            Err(e) =\u003e {\n                eprintln!(\n                    \"{} Failed to load specs from repo '{}': {}\",\n                    \"â \".yellow(),\n                    repo_config.name,\n                    e\n                );\n            }\n        }\n    }\n\n    if all_specs.is_empty() \u0026\u0026 repo_filter.is_none() {\n        eprintln!(\n            \"{} No specs found in any configured repositories\",\n            \"â \".yellow()\n        );\n    }\n\n    Ok(all_specs)\n}\n\n// ============================================================================\n// GIT METADATA HELPERS\n// ============================================================================\n\n/// Git metadata for a spec file, loaded in batch for performance\n#[derive(Debug, Clone)]\nstruct SpecGitMetadata {\n    /// Author who first created the spec file\n    creator: Option\u003cString\u003e,\n    /// Last modification time from git log\n    last_modified: Option\u003cchrono::DateTime\u003cchrono::Local\u003e\u003e,\n}\n\n/// Batch load git metadata (creator and last_modified) for all spec files.\n/// This uses targeted git commands to minimize history traversal.\n///\n/// Performance optimization:\n/// - last_modified: Uses limited history (recent 200 commits) for fast lookup\n/// - creator: Only loaded when `include_creator` is true, as it requires full history scan\nfn batch_load_spec_git_metadata(\n    specs_dir: \u0026Path,\n    include_creator: bool,\n) -\u003e HashMap\u003cString, SpecGitMetadata\u003e {\n    let mut metadata: HashMap\u003cString, SpecGitMetadata\u003e = HashMap::new();\n\n    // Get last_modified: Use limited history for fast lookup\n    // We check the last 200 commits which should cover all active specs\n    let output = Command::new(\"git\")\n        .args([\n            \"log\",\n            \"-200\", // Limit to recent commits for speed\n            \"--name-only\",\n            \"--format=COMMIT|%an|%aI\",\n            \"--\",\n        ])\n        .arg(specs_dir)\n        .output();\n\n    if let Ok(ref output) = output {\n        if output.status.success() {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let mut current_author: Option\u003cString\u003e = None;\n            let mut current_timestamp: Option\u003cchrono::DateTime\u003cchrono::Local\u003e\u003e = None;\n\n            for line in stdout.lines() {\n                let line = line.trim();\n                if line.is_empty() {\n                    continue;\n                }\n\n                if let Some(commit_data) = line.strip_prefix(\"COMMIT|\") {\n                    let parts: Vec\u003c\u0026str\u003e = commit_data.splitn(2, '|').collect();\n                    if parts.len() == 2 {\n                        current_author = Some(parts[0].to_string());\n                        current_timestamp = chrono::DateTime::parse_from_rfc3339(parts[1])\n                            .ok()\n                            .map(|dt| dt.with_timezone(\u0026chrono::Local));\n                    }\n                } else if line.starts_with(\".chant/specs/\") \u0026\u0026 line.ends_with(\".md\") {\n                    let spec_id = Path::new(line)\n                        .file_stem()\n                        .and_then(|s| s.to_str())\n                        .map(|s| s.to_string());\n\n                    if let Some(spec_id) = spec_id {\n                        let entry = metadata.entry(spec_id).or_insert(SpecGitMetadata {\n                            creator: None,\n                            last_modified: None,\n                        });\n\n                        // First occurrence = most recent commit = last_modified\n                        if entry.last_modified.is_none() {\n                            entry.last_modified = current_timestamp;\n                            // Also use this as tentative creator (will be overwritten if include_creator)\n                            if !include_creator {\n                                entry.creator = current_author.clone();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Get creator: Only when needed (requires scanning full history for file additions)\n    if include_creator {\n        let output = Command::new(\"git\")\n            .args([\n                \"log\",\n                \"--name-only\",\n                \"--format=COMMIT|%an|%aI\",\n                \"--diff-filter=A\", // Only file additions\n                \"--\",\n            ])\n            .arg(specs_dir)\n            .output();\n\n        if let Ok(ref output) = output {\n            if output.status.success() {\n                let stdout = String::from_utf8_lossy(\u0026output.stdout);\n                let mut current_author: Option\u003cString\u003e = None;\n\n                for line in stdout.lines() {\n                    let line = line.trim();\n                    if line.is_empty() {\n                        continue;\n                    }\n\n                    if let Some(commit_data) = line.strip_prefix(\"COMMIT|\") {\n                        let parts: Vec\u003c\u0026str\u003e = commit_data.splitn(2, '|').collect();\n                        if !parts.is_empty() {\n                            current_author = Some(parts[0].to_string());\n                        }\n                    } else if line.starts_with(\".chant/specs/\") \u0026\u0026 line.ends_with(\".md\") {\n                        let spec_id = Path::new(line)\n                            .file_stem()\n                            .and_then(|s| s.to_str())\n                            .map(|s| s.to_string());\n\n                        if let Some(spec_id) = spec_id {\n                            if let Some(entry) = metadata.get_mut(\u0026spec_id) {\n                                // This is the commit that added the file = creator\n                                if let Some(ref author) = current_author {\n                                    entry.creator = Some(author.clone());\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    metadata\n}\n\n/// Format a duration as a relative time string (e.g., \"2h\", \"3d\", \"1w\")\nfn format_relative_time(datetime: chrono::DateTime\u003cchrono::Local\u003e) -\u003e String {\n    let now = chrono::Local::now();\n    let duration = now.signed_duration_since(datetime);\n\n    if duration.num_minutes() \u003c 1 {\n        \"now\".to_string()\n    } else if duration.num_minutes() \u003c 60 {\n        format!(\"{}m\", duration.num_minutes())\n    } else if duration.num_hours() \u003c 24 {\n        format!(\"{}h\", duration.num_hours())\n    } else if duration.num_days() \u003c 7 {\n        format!(\"{}d\", duration.num_days())\n    } else if duration.num_weeks() \u003c 4 {\n        format!(\"{}w\", duration.num_weeks())\n    } else {\n        format!(\"{}mo\", duration.num_days() / 30)\n    }\n}\n\n/// Parse a duration string like \"2h\", \"1d\", \"1w\" into a chrono::Duration\nfn parse_duration(s: \u0026str) -\u003e Option\u003cchrono::Duration\u003e {\n    let s = s.trim().to_lowercase();\n    if s.is_empty() {\n        return None;\n    }\n\n    let (num_str, unit) = if s.ends_with(\"mo\") {\n        (\u0026s[..s.len() - 2], \"mo\")\n    } else {\n        let unit_char = s.chars().last()?;\n        (\n            \u0026s[..s.len() - 1],\n            match unit_char {\n                'm' =\u003e \"m\",\n                'h' =\u003e \"h\",\n                'd' =\u003e \"d\",\n                'w' =\u003e \"w\",\n                _ =\u003e return None,\n            },\n        )\n    };\n\n    let num: i64 = num_str.parse().ok()?;\n    match unit {\n        \"m\" =\u003e Some(chrono::Duration::minutes(num)),\n        \"h\" =\u003e Some(chrono::Duration::hours(num)),\n        \"d\" =\u003e Some(chrono::Duration::days(num)),\n        \"w\" =\u003e Some(chrono::Duration::weeks(num)),\n        \"mo\" =\u003e Some(chrono::Duration::days(num * 30)),\n        _ =\u003e None,\n    }\n}\n\n/// Count comments in the approval discussion section\nfn count_approval_comments(body: \u0026str) -\u003e usize {\n    let discussion_header = \"## Approval Discussion\";\n\n    if let Some(pos) = body.find(discussion_header) {\n        let section_start = pos + discussion_header.len();\n        let rest = \u0026body[section_start..];\n        // Find the next section heading or end of body\n        let section_end = rest.find(\"\\n## \").unwrap_or(rest.len());\n        let section = \u0026rest[..section_end];\n\n        // Count entries that start with **name** pattern (bold names indicate comments)\n        section\n            .lines()\n            .filter(|line| {\n                let trimmed = line.trim();\n                trimmed.starts_with(\"**\") \u0026\u0026 trimmed.contains(\"** -\")\n            })\n            .count()\n    } else {\n        0\n    }\n}\n\n/// Check if a name is mentioned in the approval discussion section\nfn mentions_person(body: \u0026str, name: \u0026str) -\u003e bool {\n    let discussion_header = \"## Approval Discussion\";\n    let name_lower = name.to_lowercase();\n\n    if let Some(pos) = body.find(discussion_header) {\n        let section_start = pos + discussion_header.len();\n        let rest = \u0026body[section_start..];\n        // Find the next section heading or end of body\n        let section_end = rest.find(\"\\n## \").unwrap_or(rest.len());\n        let section = \u0026rest[..section_end].to_lowercase();\n\n        section.contains(\u0026name_lower)\n    } else {\n        false\n    }\n}\n\n/// Check if silent mode is enabled via environment variable.\nfn is_silent_mode() -\u003e bool {\n    std::env::var(\"CHANT_SILENT_MODE\")\n        .map(|v| v.eq_ignore_ascii_case(\"true\") || v == \"1\")\n        .unwrap_or_default()\n}\n\n// ============================================================================\n// LIST COMMAND\n// ============================================================================\n\n#[allow(clippy::too_many_arguments)]\npub fn cmd_list(\n    ready_only: bool,\n    labels: \u0026[String],\n    type_filter: Option\u003c\u0026str\u003e,\n    status_filter: Option\u003c\u0026str\u003e,\n    global: bool,\n    repo: Option\u003c\u0026str\u003e,\n    project: Option\u003c\u0026str\u003e,\n    approval_filter: Option\u003c\u0026str\u003e,\n    created_by_filter: Option\u003c\u0026str\u003e,\n    activity_since_filter: Option\u003c\u0026str\u003e,\n    mentions_filter: Option\u003c\u0026str\u003e,\n    count_only: bool,\n    main_only: bool,\n) -\u003e Result\u003c()\u003e {\n    let is_multi_repo = global || repo.is_some();\n\n    // Get specs_dir for file path resolution\n    let specs_dir = if is_multi_repo {\n        None\n    } else {\n        Some(crate::cmd::ensure_initialized()?)\n    };\n\n    let mut specs = if is_multi_repo {\n        // Load specs from multiple repos\n        load_specs_from_repos(repo)?\n    } else {\n        // Load specs from current repo only (existing behavior)\n        let use_branch_resolution = !main_only;\n        spec::load_all_specs_with_options(specs_dir.as_ref().unwrap(), use_branch_resolution)?\n    };\n\n    specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    // Batch load git metadata for all specs (single git call instead of 2 per spec)\n    // Only load creator info when filtering by creator (requires full history scan)\n    let need_creator = created_by_filter.is_some();\n    let git_metadata = if let Some(ref dir) = specs_dir {\n        batch_load_spec_git_metadata(dir, need_creator)\n    } else {\n        HashMap::new()\n    };\n\n    // Exclude cancelled specs\n    specs.retain(|s| s.frontmatter.status != SpecStatus::Cancelled);\n\n    if ready_only {\n        let all_specs = specs.clone();\n        specs.retain(|s| s.is_ready(\u0026all_specs));\n        // Filter out group specs - they are containers, not actionable work\n        specs.retain(|s| s.frontmatter.r#type != \"group\");\n    }\n\n    // Filter by type if specified\n    if let Some(type_val) = type_filter {\n        specs.retain(|s| s.frontmatter.r#type == type_val);\n    }\n\n    // Filter by status if specified\n    if let Some(status_val) = status_filter {\n        let status_lower = status_val.to_lowercase();\n        match status_lower.as_str() {\n            \"blocked\" =\u003e {\n                // \"blocked\" is a computed state: pending specs with incomplete dependencies\n                // or specs explicitly marked with status: blocked\n                let all_specs_clone = specs.clone();\n                specs.retain(|s| {\n                    s.frontmatter.status == SpecStatus::Blocked\n                        || (s.frontmatter.status == SpecStatus::Pending\n                            \u0026\u0026 s.is_blocked(\u0026all_specs_clone))\n                });\n            }\n            \"ready\" =\u003e {\n                // \"ready\" is a computed state: pending with all dependencies met\n                let all_specs_clone = specs.clone();\n                specs.retain(|s| s.is_ready(\u0026all_specs_clone));\n            }\n            _ =\u003e {\n                let target_status = match status_lower.as_str() {\n                    \"pending\" =\u003e SpecStatus::Pending,\n                    \"in_progress\" | \"inprogress\" =\u003e SpecStatus::InProgress,\n                    \"completed\" =\u003e SpecStatus::Completed,\n                    \"failed\" =\u003e SpecStatus::Failed,\n                    \"needs_attention\" | \"needsattention\" =\u003e SpecStatus::NeedsAttention,\n                    \"cancelled\" =\u003e SpecStatus::Cancelled,\n                    _ =\u003e {\n                        anyhow::bail!(\"Invalid status filter: {}. Valid options: pending, in_progress, completed, failed, blocked, cancelled, ready, needs_attention\", status_val);\n                    }\n                };\n                specs.retain(|s| s.frontmatter.status == target_status);\n            }\n        }\n    }\n\n    // Filter by labels if specified (OR logic - show specs with any matching label)\n    if !labels.is_empty() {\n        specs.retain(|s| {\n            if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                labels.iter().any(|l| spec_labels.contains(l))\n            } else {\n                false\n            }\n        });\n    }\n\n    // Filter by project if specified\n    if let Some(proj_val) = project {\n        specs.retain(|s| {\n            // Parse the spec ID to check if it matches the project\n            if let Ok(parsed_id) = id::SpecId::parse(\u0026s.id) {\n                parsed_id.project.as_deref() == Some(proj_val)\n            } else {\n                false\n            }\n        });\n    }\n\n    // Filter by approval status if specified\n    if let Some(approval_val) = approval_filter {\n        let approval_lower = approval_val.to_lowercase();\n        specs.retain(|s| {\n            if let Some(ref approval) = s.frontmatter.approval {\n                match approval_lower.as_str() {\n                    \"pending\" =\u003e approval.status == ApprovalStatus::Pending,\n                    \"approved\" =\u003e approval.status == ApprovalStatus::Approved,\n                    \"rejected\" =\u003e approval.status == ApprovalStatus::Rejected,\n                    _ =\u003e false,\n                }\n            } else {\n                // Specs without approval section are not in the approval workflow\n                false\n            }\n        });\n    }\n\n    // Filter by creator if specified (uses batch-loaded metadata)\n    if let Some(creator) = created_by_filter {\n        let creator_lower = creator.to_lowercase();\n        specs.retain(|s| {\n            if let Some(meta) = git_metadata.get(\u0026s.id) {\n                if let Some(ref file_creator) = meta.creator {\n                    file_creator.to_lowercase().contains(\u0026creator_lower)\n                } else {\n                    false\n                }\n            } else {\n                false // No metadata available\n            }\n        });\n    }\n\n    // Filter by activity since if specified (uses batch-loaded metadata)\n    if let Some(duration_str) = activity_since_filter {\n        if let Some(duration) = parse_duration(duration_str) {\n            let cutoff = chrono::Local::now() - duration;\n            specs.retain(|s| {\n                if let Some(meta) = git_metadata.get(\u0026s.id) {\n                    if let Some(last_modified) = meta.last_modified {\n                        last_modified \u003e= cutoff\n                    } else {\n                        false\n                    }\n                } else {\n                    false // No metadata available\n                }\n            });\n        } else {\n            anyhow::bail!(\n                \"Invalid duration format: '{}'. Valid formats: 2h, 1d, 1w, 2mo\",\n                duration_str\n            );\n        }\n    }\n\n    // Filter by mentions in approval discussion if specified\n    if let Some(name) = mentions_filter {\n        specs.retain(|s| mentions_person(\u0026s.body, name));\n    }\n\n    // Handle count-only mode\n    if count_only {\n        println!(\"{}\", specs.len());\n        return Ok(());\n    }\n\n    if specs.is_empty() {\n        if !chant::ui::is_quiet() {\n            if ready_only \u0026\u0026 !labels.is_empty() {\n                println!(\"No ready specs with specified labels.\");\n            } else if ready_only {\n                println!(\"No ready specs.\");\n            } else if !labels.is_empty() {\n                println!(\"No specs with specified labels.\");\n            } else {\n                println!(\"No specs. Create one with `chant add \\\"description\\\"`\");\n            }\n        }\n        return Ok(());\n    }\n\n    for spec in \u0026specs {\n        let icon = if spec.frontmatter.r#type == \"conflict\" {\n            \"â¡\".yellow()\n        } else {\n            render::status_icon(\u0026spec.frontmatter.status)\n        };\n\n        // Build approval status marker\n        let approval_marker = if let Some(ref approval) = spec.frontmatter.approval {\n            match approval.status {\n                ApprovalStatus::Pending if approval.required =\u003e {\n                    format!(\" {}\", \"[needs approval]\".yellow())\n                }\n                ApprovalStatus::Rejected =\u003e {\n                    format!(\" {}\", \"[rejected]\".red())\n                }\n                ApprovalStatus::Approved =\u003e {\n                    format!(\" {}\", \"[approved]\".green())\n                }\n                _ =\u003e String::new(),\n            }\n        } else {\n            String::new()\n        };\n\n        // Build visual indicators (using batch-loaded metadata for performance)\n        let mut indicators: Vec\u003cString\u003e = Vec::new();\n\n        // Created by and last activity indicators (from batch-loaded git metadata)\n        if let Some(meta) = git_metadata.get(\u0026spec.id) {\n            if let Some(ref creator) = meta.creator {\n                indicators.push(format!(\"ð¤ {}\", creator.dimmed()));\n            }\n\n            if let Some(last_modified) = meta.last_modified {\n                let relative = format_relative_time(last_modified);\n                indicators.push(format!(\"â© {}\", relative.dimmed()));\n            }\n        }\n\n        // Comment count in approval discussion\n        let comment_count = count_approval_comments(\u0026spec.body);\n        if comment_count \u003e 0 {\n            indicators.push(format!(\"ð¬ {}\", comment_count.to_string().dimmed()));\n        }\n\n        // Approved by indicator (from frontmatter)\n        if let Some(ref approval) = spec.frontmatter.approval {\n            if approval.status == ApprovalStatus::Approved {\n                if let Some(ref by) = approval.by {\n                    indicators.push(format!(\"â {}\", by.green()));\n                }\n            }\n        }\n\n        // Branch indicator for in_progress specs\n        if spec.frontmatter.status == spec::SpecStatus::InProgress {\n            indicators.push(\"[branch]\".dimmed().to_string());\n        }\n\n        let indicators_str = if indicators.is_empty() {\n            String::new()\n        } else {\n            format!(\" {}\", indicators.join(\" \"))\n        };\n\n        if !chant::ui::is_quiet() {\n            println!(\n                \"{} {}{} {}{}\",\n                icon,\n                spec.id.cyan(),\n                approval_marker,\n                spec.title.as_deref().unwrap_or(\"(no title)\"),\n                indicators_str\n            );\n        }\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// STATUS COMMAND\n// ============================================================================\n\npub fn cmd_status(\n    global: bool,\n    repo_filter: Option\u003c\u0026str\u003e,\n    watch: bool,\n    brief: bool,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    // Validate mutually exclusive flags\n    if brief \u0026\u0026 json {\n        anyhow::bail!(\"Error: --brief and --json are mutually exclusive. Use one or the other.\\n\\nUsage: chant status [--brief | --json] [--watch]\");\n    }\n\n    if watch {\n        cmd_status_watch(global, repo_filter, brief, json)\n    } else {\n        cmd_status_once(global, repo_filter, brief, json)\n    }\n}\n\nfn cmd_status_once(global: bool, repo_filter: Option\u003c\u0026str\u003e, brief: bool, json: bool) -\u003e Result\u003c()\u003e {\n    if global || repo_filter.is_some() {\n        // Multi-repo status output\n        let specs = load_specs_from_repos(repo_filter)?;\n        let mut per_repo_stats: HashMap\u003cString, (usize, usize, usize, usize)\u003e = HashMap::new();\n\n        for spec in \u0026specs {\n            // Extract repo prefix from spec ID (format: \"repo:spec-id\")\n            let repo_name = if let Some(idx) = spec.id.find(':') {\n                spec.id[..idx].to_string()\n            } else {\n                \"local\".to_string()\n            };\n\n            let entry = per_repo_stats.entry(repo_name).or_insert((0, 0, 0, 0));\n            match spec.frontmatter.status {\n                SpecStatus::Pending | SpecStatus::Ready | SpecStatus::Blocked =\u003e entry.0 += 1,\n                SpecStatus::InProgress | SpecStatus::Paused =\u003e entry.1 += 1,\n                SpecStatus::Completed =\u003e entry.2 += 1,\n                SpecStatus::Failed | SpecStatus::NeedsAttention =\u003e entry.3 += 1,\n                SpecStatus::Cancelled =\u003e {\n                    // Cancelled specs are not counted in the summary\n                }\n            }\n        }\n\n        if !chant::ui::is_quiet() {\n            println!(\"{}\", \"Chant Status (Global)\".bold());\n            println!(\"====================\");\n        }\n\n        // Sort repos by name for consistent output\n        let mut repos: Vec\u003c_\u003e = per_repo_stats.into_iter().collect();\n        repos.sort_by(|a, b| a.0.cmp(\u0026b.0));\n\n        let mut total_pending = 0;\n        let mut total_in_progress = 0;\n        let mut total_completed = 0;\n        let mut total_failed = 0;\n\n        for (repo_name, (pending, in_progress, completed, failed)) in repos {\n            if !chant::ui::is_quiet() {\n                println!(\"\\n{}: {}\", \"Repository\".bold(), repo_name.cyan());\n                println!(\n                    \"  {:\u003c18} {} | {:\u003c18} {} | {:\u003c18} {} | {:\u003c18} {}\",\n                    \"Pending\",\n                    pending,\n                    \"In Progress\",\n                    in_progress,\n                    \"Completed\",\n                    completed,\n                    \"Failed\",\n                    failed\n                );\n            }\n\n            total_pending += pending;\n            total_in_progress += in_progress;\n            total_completed += completed;\n            total_failed += failed;\n        }\n\n        let total = total_pending + total_in_progress + total_completed + total_failed;\n        if !chant::ui::is_quiet() {\n            println!(\"\\n{}\", \"Total\".bold());\n            println!(\"âââââ\");\n            println!(\n                \"  {:\u003c18} {} | {:\u003c18} {} | {:\u003c18} {} | {:\u003c18} {}\",\n                \"Pending\",\n                total_pending,\n                \"In Progress\",\n                total_in_progress,\n                \"Completed\",\n                total_completed,\n                \"Failed\",\n                total_failed\n            );\n            println!(\"  {:\u003c18} {}\", \"Overall Total:\", total);\n        }\n    } else {\n        // Single repo status output - use formatter based on flags\n        let specs_dir = crate::cmd::ensure_initialized()?;\n        let status_data = chant::status::aggregate_status(\u0026specs_dir)?;\n\n        if !chant::ui::is_quiet() {\n            if json {\n                let output = chant::status::format_status_as_json(\u0026status_data)?;\n                println!(\"{}\", output);\n            } else if brief {\n                let output = status_data.format_brief();\n                println!(\"{}\", output);\n            } else {\n                let output = chant::formatters::format_regular_status(\u0026status_data);\n                println!(\"{}\", output);\n\n                // Show silent mode indicator if enabled\n                if is_silent_mode() {\n                    println!(\n                        \"\\n{} Silent mode enabled - specs are local-only\",\n                        \"â¹\".cyan()\n                    );\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn cmd_status_watch(\n    global: bool,\n    repo_filter: Option\u003c\u0026str\u003e,\n    brief: bool,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    use std::time::Duration;\n\n    loop {\n        // Clear the screen using ANSI escape codes\n        // Try ANSI codes first, fall back to separator line if that fails\n        if clear_screen().is_err() {\n            // Fallback: print separator line\n            println!(\"\\n{}\\n\", \"=\".repeat(80));\n        }\n\n        // Display status once\n        if let Err(e) = cmd_status_once(global, repo_filter, brief, json) {\n            eprintln!(\"Error refreshing status: {}\", e);\n            // Continue watching even if there's an error\n        }\n\n        // Flush stdout to ensure output is visible immediately\n        io::stdout().flush()?;\n\n        // Sleep for 5 seconds\n        std::thread::sleep(Duration::from_secs(5));\n    }\n}\n\n/// Clear the screen using ANSI escape codes\nfn clear_screen() -\u003e io::Result\u003c()\u003e {\n    // ANSI escape code to clear screen and move cursor to top-left\n    print!(\"\\x1B[2J\\x1B[1;1H\");\n    io::stdout().flush()\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":20}},{"line":132,"address":[],"length":0,"stats":{"Line":60}},{"line":136,"address":[],"length":0,"stats":{"Line":80}},{"line":137,"address":[],"length":0,"stats":{"Line":60}},{"line":138,"address":[],"length":0,"stats":{"Line":40}},{"line":139,"address":[],"length":0,"stats":{"Line":60}},{"line":140,"address":[],"length":0,"stats":{"Line":60}},{"line":141,"address":[],"length":0,"stats":{"Line":40}},{"line":142,"address":[],"length":0,"stats":{"Line":40}},{"line":144,"address":[],"length":0,"stats":{"Line":20}},{"line":147,"address":[],"length":0,"stats":{"Line":40}},{"line":148,"address":[],"length":0,"stats":{"Line":40}},{"line":149,"address":[],"length":0,"stats":{"Line":60}},{"line":150,"address":[],"length":0,"stats":{"Line":60}},{"line":151,"address":[],"length":0,"stats":{"Line":60}},{"line":153,"address":[],"length":0,"stats":{"Line":24}},{"line":154,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":6}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":12}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":20}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":20}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":8}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":40}},{"line":301,"address":[],"length":0,"stats":{"Line":80}},{"line":303,"address":[],"length":0,"stats":{"Line":80}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":40}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":20}},{"line":368,"address":[],"length":0,"stats":{"Line":80}},{"line":371,"address":[],"length":0,"stats":{"Line":40}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":20}},{"line":377,"address":[],"length":0,"stats":{"Line":40}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":40}},{"line":383,"address":[],"length":0,"stats":{"Line":80}},{"line":386,"address":[],"length":0,"stats":{"Line":187}},{"line":390,"address":[],"length":0,"stats":{"Line":60}},{"line":391,"address":[],"length":0,"stats":{"Line":60}},{"line":392,"address":[],"length":0,"stats":{"Line":60}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":148}},{"line":400,"address":[],"length":0,"stats":{"Line":20}},{"line":401,"address":[],"length":0,"stats":{"Line":6}},{"line":402,"address":[],"length":0,"stats":{"Line":19}},{"line":404,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":20}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":27}},{"line":414,"address":[],"length":0,"stats":{"Line":21}},{"line":415,"address":[],"length":0,"stats":{"Line":7}},{"line":416,"address":[],"length":0,"stats":{"Line":7}},{"line":419,"address":[],"length":0,"stats":{"Line":21}},{"line":420,"address":[],"length":0,"stats":{"Line":33}},{"line":421,"address":[],"length":0,"stats":{"Line":19}},{"line":422,"address":[],"length":0,"stats":{"Line":11}},{"line":423,"address":[],"length":0,"stats":{"Line":21}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":20}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":20}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":20}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":20}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":20}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":20}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":20}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":40}},{"line":540,"address":[],"length":0,"stats":{"Line":2}},{"line":541,"address":[],"length":0,"stats":{"Line":2}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":2}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":2}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":2}},{"line":554,"address":[],"length":0,"stats":{"Line":58}},{"line":555,"address":[],"length":0,"stats":{"Line":80}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":80}},{"line":562,"address":[],"length":0,"stats":{"Line":81}},{"line":563,"address":[],"length":0,"stats":{"Line":1}},{"line":564,"address":[],"length":0,"stats":{"Line":1}},{"line":565,"address":[],"length":0,"stats":{"Line":3}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":39}},{"line":580,"address":[],"length":0,"stats":{"Line":120}},{"line":583,"address":[],"length":0,"stats":{"Line":82}},{"line":584,"address":[],"length":0,"stats":{"Line":6}},{"line":585,"address":[],"length":0,"stats":{"Line":8}},{"line":588,"address":[],"length":0,"stats":{"Line":6}},{"line":589,"address":[],"length":0,"stats":{"Line":8}},{"line":590,"address":[],"length":0,"stats":{"Line":8}},{"line":595,"address":[],"length":0,"stats":{"Line":120}},{"line":596,"address":[],"length":0,"stats":{"Line":40}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":41}},{"line":602,"address":[],"length":0,"stats":{"Line":1}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":40}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":120}},{"line":615,"address":[],"length":0,"stats":{"Line":38}},{"line":617,"address":[],"length":0,"stats":{"Line":6}},{"line":620,"address":[],"length":0,"stats":{"Line":80}},{"line":621,"address":[],"length":0,"stats":{"Line":80}},{"line":622,"address":[],"length":0,"stats":{"Line":40}},{"line":623,"address":[],"length":0,"stats":{"Line":40}},{"line":624,"address":[],"length":0,"stats":{"Line":80}},{"line":625,"address":[],"length":0,"stats":{"Line":40}},{"line":626,"address":[],"length":0,"stats":{"Line":120}},{"line":627,"address":[],"length":0,"stats":{"Line":40}},{"line":632,"address":[],"length":0,"stats":{"Line":18}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}}],"covered":121,"coverable":394},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","mod.rs"],"content":"//! Spec command handlers for chant CLI\n//!\n//! Handles core spec operations including:\n//! - Creating, listing, showing, and deleting specs\n//! - Status checking and linting\n//!\n//! Note: Spec execution is handled by cmd::work module\n//! Note: Lifecycle operations (merge, archive, split, diagnostics, logging) are in cmd::lifecycle module\n\nmod add;\nmod approve;\nmod dag;\nmod delete;\nmod edit;\npub mod lint;\nmod list;\nmod show;\n\n// Re-export public command functions\npub use add::cmd_add;\npub use approve::{cmd_approve, cmd_reject};\npub use dag::cmd_dag;\npub use delete::{cmd_cancel, cmd_delete, cmd_export};\npub use edit::cmd_edit;\npub use lint::{cmd_lint, lint_specific_specs, LintFormat};\npub use list::{cmd_list, cmd_status};\npub use show::cmd_show;\n\n// ============================================================================\n// TESTS\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cmd;\n    use crate::cmd::commits::CommitError;\n    use crate::cmd::finalize::finalize_spec;\n    use crate::cmd::model::{get_model_name, get_model_name_with_default};\n    use crate::{lookup_log_file, LogLookupResult};\n    use chant::config::Config;\n    use chant::spec::{self, Spec, SpecFrontmatter, SpecStatus};\n    use lint::validate_spec_type;\n    use serial_test::serial;\n    use show::{format_yaml_value, key_to_title_case};\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_ensure_logs_dir_creates_directory() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Logs dir shouldn't exist yet\n        assert!(!base_path.join(\"logs\").exists());\n\n        // Call ensure_logs_dir_at\n        cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // Logs dir should now exist\n        assert!(base_path.join(\"logs\").exists());\n        assert!(base_path.join(\"logs\").is_dir());\n    }\n\n    #[test]\n    fn test_ensure_logs_dir_updates_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create base dir without .gitignore\n        // (tempdir already exists, no need to create)\n\n        // Call ensure_logs_dir_at\n        cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // .gitignore should now exist and contain \"logs/\"\n        let gitignore_path = base_path.join(\".gitignore\");\n        assert!(gitignore_path.exists());\n\n        let content = std::fs::read_to_string(\u0026gitignore_path).unwrap();\n        assert!(content.contains(\"logs/\"));\n    }\n\n    #[test]\n    fn test_ensure_logs_dir_appends_to_existing_gitignore() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create existing .gitignore with other content\n        let gitignore_path = base_path.join(\".gitignore\");\n        std::fs::write(\u0026gitignore_path, \"*.tmp\\n\").unwrap();\n\n        // Call ensure_logs_dir_at\n        cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // .gitignore should contain both original and new content\n        let content = std::fs::read_to_string(\u0026gitignore_path).unwrap();\n        assert!(content.contains(\"*.tmp\"));\n        assert!(content.contains(\"logs/\"));\n    }\n\n    #[test]\n    fn test_ensure_logs_dir_no_duplicate_gitignore_entry() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create existing .gitignore that already has logs/\n        let gitignore_path = base_path.join(\".gitignore\");\n        std::fs::write(\u0026gitignore_path, \"logs/\\n\").unwrap();\n\n        // Create logs dir (since ensure_logs_dir only updates gitignore when creating dir)\n        std::fs::create_dir_all(base_path.join(\"logs\")).unwrap();\n\n        // Call ensure_logs_dir_at\n        cmd::agent::ensure_logs_dir_at(\u0026base_path).unwrap();\n\n        // .gitignore should still have only one \"logs/\" entry\n        let content = std::fs::read_to_string(\u0026gitignore_path).unwrap();\n        let count = content\n            .lines()\n            .filter(|line| line.trim() == \"logs/\")\n            .count();\n        assert_eq!(count, 1);\n    }\n\n    #[test]\n    fn test_streaming_log_writer_creates_header() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        let spec_id = \"2026-01-24-00a-xyz\";\n        let prompt_name = \"standard\";\n\n        // Create log writer (this writes the header)\n        let _writer =\n            cmd::agent::StreamingLogWriter::new_at(\u0026base_path, spec_id, prompt_name).unwrap();\n\n        // Check that log file exists with header BEFORE any lines are written\n        let log_path = base_path.join(\"logs\").join(format!(\"{}.log\", spec_id));\n        assert!(log_path.exists());\n\n        let content = std::fs::read_to_string(\u0026log_path).unwrap();\n\n        // Check header format\n        assert!(content.starts_with(\"# Agent Log: 2026-01-24-00a-xyz\\n\"));\n        assert!(content.contains(\"# Started: \"));\n        assert!(content.contains(\"# Prompt: standard\\n\"));\n    }\n\n    #[test]\n    fn test_streaming_log_writer_writes_lines() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        let spec_id = \"2026-01-24-00a-xyz\";\n        let prompt_name = \"standard\";\n\n        // Create log writer and write lines\n        let mut writer =\n            cmd::agent::StreamingLogWriter::new_at(\u0026base_path, spec_id, prompt_name).unwrap();\n        writer.write_line(\"Test agent output\").unwrap();\n        writer.write_line(\"With multiple lines\").unwrap();\n\n        // Read it back\n        let log_path = base_path.join(\"logs\").join(format!(\"{}.log\", spec_id));\n        let content = std::fs::read_to_string(\u0026log_path).unwrap();\n\n        // Check header format\n        assert!(content.starts_with(\"# Agent Log: 2026-01-24-00a-xyz\\n\"));\n        assert!(content.contains(\"# Started: \"));\n        assert!(content.contains(\"# Prompt: standard\\n\"));\n\n        // Check output is preserved\n        assert!(content.contains(\"Test agent output\\n\"));\n        assert!(content.contains(\"With multiple lines\\n\"));\n    }\n\n    #[test]\n    fn test_streaming_log_writer_flushes_each_line() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        let spec_id = \"2026-01-24-00a-xyz\";\n        let prompt_name = \"standard\";\n\n        // Create log writer\n        let mut writer =\n            cmd::agent::StreamingLogWriter::new_at(\u0026base_path, spec_id, prompt_name).unwrap();\n        let log_path = base_path.join(\"logs\").join(format!(\"{}.log\", spec_id));\n\n        // Write first line\n        writer.write_line(\"Line 1\").unwrap();\n\n        // Verify it's visible immediately (flushed) by reading the file\n        let content = std::fs::read_to_string(\u0026log_path).unwrap();\n        assert!(content.contains(\"Line 1\"));\n\n        // Write second line\n        writer.write_line(\"Line 2\").unwrap();\n\n        // Verify both lines are visible\n        let content = std::fs::read_to_string(\u0026log_path).unwrap();\n        assert!(content.contains(\"Line 1\"));\n        assert!(content.contains(\"Line 2\"));\n    }\n\n    #[test]\n    fn test_streaming_log_writer_overwrites_on_new_run() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        let spec_id = \"2026-01-24-00b-abc\";\n        let prompt_name = \"standard\";\n\n        // First run\n        {\n            let mut writer =\n                cmd::agent::StreamingLogWriter::new_at(\u0026base_path, spec_id, prompt_name).unwrap();\n            writer.write_line(\"Content A\").unwrap();\n        }\n\n        // Second run (simulating replay)\n        {\n            let mut writer =\n                cmd::agent::StreamingLogWriter::new_at(\u0026base_path, spec_id, prompt_name).unwrap();\n            writer.write_line(\"Content B\").unwrap();\n        }\n\n        // Read it back\n        let log_path = base_path.join(\"logs\").join(format!(\"{}.log\", spec_id));\n        let content = std::fs::read_to_string(\u0026log_path).unwrap();\n\n        // Should contain only Content B\n        assert!(content.contains(\"Content B\"));\n        assert!(!content.contains(\"Content A\"));\n    }\n\n    #[test]\n    fn test_lookup_log_file_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create specs directory and a spec file\n        let specs_dir = base_path.join(\"specs\");\n        std::fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let spec_content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Test spec\n\"#;\n        std::fs::write(specs_dir.join(\"2026-01-24-00a-xyz.md\"), spec_content).unwrap();\n\n        // Lookup log without creating logs directory\n        let result = lookup_log_file(\u0026base_path, \"xyz\").unwrap();\n\n        match result {\n            LogLookupResult::NotFound { spec_id, log_path } =\u003e {\n                assert_eq!(spec_id, \"2026-01-24-00a-xyz\");\n                assert!(log_path\n                    .to_string_lossy()\n                    .contains(\"2026-01-24-00a-xyz.log\"));\n            }\n            LogLookupResult::Found(_) =\u003e panic!(\"Expected NotFound, got Found\"),\n        }\n    }\n\n    #[test]\n    fn test_lookup_log_file_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create specs directory and a spec file\n        let specs_dir = base_path.join(\"specs\");\n        let logs_dir = base_path.join(\"logs\");\n        std::fs::create_dir_all(\u0026specs_dir).unwrap();\n        std::fs::create_dir_all(\u0026logs_dir).unwrap();\n\n        let spec_content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Test spec\n\"#;\n        std::fs::write(specs_dir.join(\"2026-01-24-00b-abc.md\"), spec_content).unwrap();\n\n        // Create a log file\n        std::fs::write(\n            logs_dir.join(\"2026-01-24-00b-abc.log\"),\n            \"# Agent Log\\nTest output\",\n        )\n        .unwrap();\n\n        // Lookup log\n        let result = lookup_log_file(\u0026base_path, \"abc\").unwrap();\n\n        match result {\n            LogLookupResult::Found(path) =\u003e {\n                assert!(path.to_string_lossy().contains(\"2026-01-24-00b-abc.log\"));\n            }\n            LogLookupResult::NotFound { .. } =\u003e panic!(\"Expected Found, got NotFound\"),\n        }\n    }\n\n    #[test]\n    fn test_lookup_log_file_spec_resolution() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Create specs directory and multiple spec files\n        let specs_dir = base_path.join(\"specs\");\n        let logs_dir = base_path.join(\"logs\");\n        std::fs::create_dir_all(\u0026specs_dir).unwrap();\n        std::fs::create_dir_all(\u0026logs_dir).unwrap();\n\n        let spec_content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Test spec\n\"#;\n        std::fs::write(specs_dir.join(\"2026-01-24-00c-def.md\"), spec_content).unwrap();\n        std::fs::write(specs_dir.join(\"2026-01-24-00d-ghi.md\"), spec_content).unwrap();\n\n        // Create log file for one spec\n        std::fs::write(\n            logs_dir.join(\"2026-01-24-00c-def.log\"),\n            \"# Agent Log\\nOutput for def\",\n        )\n        .unwrap();\n\n        // Lookup using partial ID should resolve correctly\n        let result = lookup_log_file(\u0026base_path, \"def\").unwrap();\n        match result {\n            LogLookupResult::Found(path) =\u003e {\n                assert!(path.to_string_lossy().contains(\"2026-01-24-00c-def.log\"));\n            }\n            LogLookupResult::NotFound { .. } =\u003e panic!(\"Expected Found for 'def'\"),\n        }\n\n        // Lookup for spec without log\n        let result = lookup_log_file(\u0026base_path, \"ghi\").unwrap();\n        match result {\n            LogLookupResult::NotFound { spec_id, .. } =\u003e {\n                assert_eq!(spec_id, \"2026-01-24-00d-ghi\");\n            }\n            LogLookupResult::Found(_) =\u003e panic!(\"Expected NotFound for 'ghi'\"),\n        }\n    }\n\n    #[test]\n    fn test_lookup_log_file_not_initialized() {\n        let temp_dir = TempDir::new().unwrap();\n        let base_path = temp_dir.path().to_path_buf();\n\n        // Don't create specs directory\n        let result = lookup_log_file(\u0026base_path, \"abc\");\n\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Chant not initialized\"));\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_from_chant_model() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set CHANT_MODEL\n        std::env::set_var(\"CHANT_MODEL\", \"claude-opus-4-5\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let result = get_model_name(None);\n        assert_eq!(result, Some(\"claude-opus-4-5\".to_string()));\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_from_anthropic_model() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set only ANTHROPIC_MODEL\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"claude-sonnet-4\");\n\n        let result = get_model_name(None);\n        assert_eq!(result, Some(\"claude-sonnet-4\".to_string()));\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_chant_takes_precedence() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set both env vars\n        std::env::set_var(\"CHANT_MODEL\", \"claude-opus-4-5\");\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"claude-sonnet-4\");\n\n        let result = get_model_name(None);\n        // CHANT_MODEL takes precedence\n        assert_eq!(result, Some(\"claude-opus-4-5\".to_string()));\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_from_config_default() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset env vars so config default is used\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let result = get_model_name_with_default(Some(\"claude-sonnet-4\"));\n        assert_eq!(result, Some(\"claude-sonnet-4\".to_string()));\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_env_takes_precedence_over_config() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set env var\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"claude-opus-4-5\");\n        std::env::remove_var(\"CHANT_MODEL\");\n\n        // Env var should take precedence over config\n        let result = get_model_name_with_default(Some(\"claude-sonnet-4\"));\n        assert_eq!(result, Some(\"claude-opus-4-5\".to_string()));\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_none_when_unset() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset both env vars\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        // With no config and no env vars, falls back to claude version parsing\n        // which may or may not return a value depending on system\n        let result = get_model_name_with_default(None);\n        // We can't assert the exact value since it depends on whether claude is installed\n        // and what version it is, so we just verify it doesn't panic\n        let _ = result;\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_empty_string_returns_none() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set empty string\n        std::env::set_var(\"CHANT_MODEL\", \"\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        // Empty env var should fall through to config default or claude version\n        let result = get_model_name_with_default(None);\n        // Can't assert exact value since it depends on whether claude is installed\n        let _ = result;\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_name_empty_config_model_skipped() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset env vars\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        // Empty config model should be skipped\n        let result = get_model_name_with_default(Some(\"\"));\n        // Falls through to claude version parsing\n        let _ = result;\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    fn test_key_to_title_case_single_word() {\n        assert_eq!(key_to_title_case(\"status\"), \"Status\");\n        assert_eq!(key_to_title_case(\"type\"), \"Type\");\n        assert_eq!(key_to_title_case(\"commit\"), \"Commit\");\n    }\n\n    #[test]\n    fn test_key_to_title_case_snake_case() {\n        assert_eq!(key_to_title_case(\"depends_on\"), \"Depends On\");\n        assert_eq!(key_to_title_case(\"completed_at\"), \"Completed At\");\n        assert_eq!(key_to_title_case(\"target_files\"), \"Target Files\");\n    }\n\n    #[test]\n    fn test_key_to_title_case_empty_string() {\n        assert_eq!(key_to_title_case(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_format_yaml_value_null() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"test\", \u0026Value::Null);\n        // Result contains ANSI codes, but should represent \"~\"\n        assert!(result.contains(\"~\") || result.contains('\\x1b'));\n    }\n\n    #[test]\n    fn test_format_yaml_value_bool_true() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"test\", \u0026Value::Bool(true));\n        // Result contains ANSI codes for green, but should represent \"true\"\n        assert!(result.contains(\"true\") || result.contains('\\x1b'));\n    }\n\n    #[test]\n    fn test_format_yaml_value_bool_false() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"test\", \u0026Value::Bool(false));\n        // Result contains ANSI codes for red, but should represent \"false\"\n        assert!(result.contains(\"false\") || result.contains('\\x1b'));\n    }\n\n    #[test]\n    fn test_format_yaml_value_number() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"test\", \u0026Value::Number(42.into()));\n        assert_eq!(result, \"42\");\n    }\n\n    #[test]\n    fn test_format_yaml_value_string_status_completed() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"status\", \u0026Value::String(\"completed\".to_string()));\n        // Should contain green ANSI codes\n        assert!(result.contains(\"completed\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_string_status_failed() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"status\", \u0026Value::String(\"failed\".to_string()));\n        // Should contain red ANSI codes\n        assert!(result.contains(\"failed\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_string_status_pending() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"status\", \u0026Value::String(\"pending\".to_string()));\n        // Should contain yellow ANSI codes\n        assert!(result.contains(\"pending\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_string_commit() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"commit\", \u0026Value::String(\"abc1234\".to_string()));\n        // Should contain cyan ANSI codes\n        assert!(result.contains(\"abc1234\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_string_type() {\n        use serde_yaml::Value;\n        let result = format_yaml_value(\"type\", \u0026Value::String(\"code\".to_string()));\n        // Should contain blue ANSI codes\n        assert!(result.contains(\"code\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_sequence() {\n        use serde_yaml::Value;\n        let seq = Value::Sequence(vec![\n            Value::String(\"item1\".to_string()),\n            Value::String(\"item2\".to_string()),\n        ]);\n        let result = format_yaml_value(\"labels\", \u0026seq);\n        // Should be formatted as [item1, item2] with magenta colors\n        assert!(result.starts_with('['));\n        assert!(result.ends_with(']'));\n        assert!(result.contains(\"item1\"));\n        assert!(result.contains(\"item2\"));\n    }\n\n    #[test]\n    fn test_format_yaml_value_plain_string() {\n        use serde_yaml::Value;\n        // For keys not in the special list, string should be plain\n        let result = format_yaml_value(\"prompt\", \u0026Value::String(\"standard\".to_string()));\n        assert_eq!(result, \"standard\");\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_assistant_message() {\n        let json_line = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"Hello, world!\"}]}}\"#;\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert_eq!(texts, vec![\"Hello, world!\"]);\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_multiple_content_blocks() {\n        let json_line = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"First\"},{\"type\":\"text\",\"text\":\"Second\"}]}}\"#;\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert_eq!(texts, vec![\"First\", \"Second\"]);\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_system_message() {\n        let json_line = r#\"{\"type\":\"system\",\"subtype\":\"init\"}\"#;\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert!(texts.is_empty());\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_result_message() {\n        let json_line = r#\"{\"type\":\"result\",\"subtype\":\"success\",\"result\":\"Done\"}\"#;\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert!(texts.is_empty());\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_invalid_json() {\n        let json_line = \"not valid json\";\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert!(texts.is_empty());\n    }\n\n    #[test]\n    fn test_extract_text_from_stream_json_mixed_content_types() {\n        // Content can include tool_use blocks which we should skip\n        let json_line = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"Analyzing...\"},{\"type\":\"tool_use\",\"name\":\"read_file\"}]}}\"#;\n        let texts = cmd::agent::extract_text_from_stream_json(json_line);\n        assert_eq!(texts, vec![\"Analyzing...\"]);\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_from_chant_model() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set CHANT_MODEL\n        std::env::set_var(\"CHANT_MODEL\", \"claude-opus-4-5\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let result = cmd::agent::get_model_for_invocation(None);\n        assert_eq!(result, \"claude-opus-4-5\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_from_anthropic_model() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set only ANTHROPIC_MODEL\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"claude-sonnet-4\");\n\n        let result = cmd::agent::get_model_for_invocation(None);\n        assert_eq!(result, \"claude-sonnet-4\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_chant_takes_precedence() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set both env vars\n        std::env::set_var(\"CHANT_MODEL\", \"claude-opus-4-5\");\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"claude-sonnet-4\");\n\n        let result = cmd::agent::get_model_for_invocation(Some(\"config-model\"));\n        // CHANT_MODEL takes precedence\n        assert_eq!(result, \"claude-opus-4-5\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_from_config() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset env vars so config default is used\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let result = cmd::agent::get_model_for_invocation(Some(\"claude-sonnet-4\"));\n        assert_eq!(result, \"claude-sonnet-4\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_defaults_to_haiku() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset both env vars and no config\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        let result = cmd::agent::get_model_for_invocation(None);\n        assert_eq!(result, \"haiku\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_empty_env_falls_through() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Set empty env vars\n        std::env::set_var(\"CHANT_MODEL\", \"\");\n        std::env::set_var(\"ANTHROPIC_MODEL\", \"\");\n\n        let result = cmd::agent::get_model_for_invocation(Some(\"config-model\"));\n        // Empty env vars should fall through to config\n        assert_eq!(result, \"config-model\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        } else {\n            std::env::remove_var(\"CHANT_MODEL\");\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        } else {\n            std::env::remove_var(\"ANTHROPIC_MODEL\");\n        }\n    }\n\n    #[test]\n    #[serial]\n    fn test_get_model_for_invocation_empty_config_falls_to_haiku() {\n        // Save original env vars\n        let orig_chant = std::env::var(\"CHANT_MODEL\").ok();\n        let orig_anthropic = std::env::var(\"ANTHROPIC_MODEL\").ok();\n\n        // Unset env vars\n        std::env::remove_var(\"CHANT_MODEL\");\n        std::env::remove_var(\"ANTHROPIC_MODEL\");\n\n        // Empty config model should fall through to haiku\n        let result = cmd::agent::get_model_for_invocation(Some(\"\"));\n        assert_eq!(result, \"haiku\");\n\n        // Restore original env vars\n        if let Some(val) = orig_chant {\n            std::env::set_var(\"CHANT_MODEL\", val);\n        }\n        if let Some(val) = orig_anthropic {\n            std::env::set_var(\"ANTHROPIC_MODEL\", val);\n        }\n    }\n\n    #[test]\n    fn test_finalize_spec_sets_status_and_timestamps() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().to_path_buf();\n\n        // Create a spec with pending status\n        let spec_content = r#\"---\ntype: task\nid: 2026-01-24-test-xyz\nstatus: in_progress\n---\n\n# Test spec\n\n## Acceptance Criteria\n\n- [x] Item 1\n- [x] Item 2\n\"#;\n        specs_dir\n            .join(\"2026-01-24-test-xyz.md\")\n            .parent()\n            .map(|p| std::fs::create_dir_all(p).ok());\n        std::fs::write(specs_dir.join(\"2026-01-24-test-xyz.md\"), spec_content).unwrap();\n\n        // Create a minimal config from string\n        let config_str = r#\"---\nproject:\n  name: test-project\ndefaults:\n  prompt: standard\n  branch: true\n  branch_prefix: \"chant/\"\ngit:\n  provider: github\n---\n\"#;\n        let config = Config::parse(config_str).unwrap();\n\n        // Load and finalize the spec\n        let mut spec = spec::resolve_spec(\u0026specs_dir, \"2026-01-24-test-xyz\").unwrap();\n        let spec_path = specs_dir.join(\"2026-01-24-test-xyz.md\");\n\n        // Before finalization, status should be in_progress\n        assert_eq!(spec.frontmatter.status, SpecStatus::InProgress);\n        assert!(spec.frontmatter.completed_at.is_none());\n\n        // Finalize the spec (pass empty commits to avoid git dependency in tests)\n        finalize_spec(\u0026mut spec, \u0026spec_path, \u0026config, \u0026[], true, Some(vec![])).unwrap();\n\n        // After finalization, status should be completed\n        assert_eq!(spec.frontmatter.status, SpecStatus::Completed);\n        assert!(spec.frontmatter.completed_at.is_some());\n\n        // Read back the spec from file to verify it was saved\n        let saved_spec = spec::resolve_spec(\u0026specs_dir, \"2026-01-24-test-xyz\").unwrap();\n        assert_eq!(saved_spec.frontmatter.status, SpecStatus::Completed);\n        assert!(saved_spec.frontmatter.completed_at.is_some());\n    }\n\n    #[test]\n    fn test_commit_error_display() {\n        let err1 = CommitError::GitCommandFailed(\"test error\".to_string());\n        assert_eq!(err1.to_string(), \"Git command failed: test error\");\n\n        let err2 = CommitError::NoMatchingCommits;\n        assert_eq!(err2.to_string(), \"No matching commits found\");\n    }\n\n    #[test]\n    fn test_validate_spec_type_driver_empty_members() {\n        let spec = Spec {\n            id: \"test-driver\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"driver\".to_string(),\n                members: Some(vec![]),\n                ..Default::default()\n            },\n            title: Some(\"Driver spec\".to_string()),\n            body: \"# Driver\\n\".to_string(),\n        };\n\n        let warnings = validate_spec_type(\u0026spec);\n        assert!(warnings\n            .iter()\n            .any(|w| w.message.contains(\"empty 'members' array\")));\n    }\n\n    #[test]\n    fn test_validate_spec_type_driver_with_members() {\n        let spec = Spec {\n            id: \"test-driver\".to_string(),\n            frontmatter: SpecFrontmatter {\n                r#type: \"driver\".to_string(),\n                members: Some(vec![\"test-driver.1\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Driver spec\".to_string()),\n            body: \"# Driver\\n\".to_string(),\n        };\n\n        let warnings = validate_spec_type(\u0026spec);\n        assert!(warnings.is_empty());\n    }\n\n    #[test]\n    fn test_spec_status_needs_attention_added() {\n        // This test verifies that SpecStatus enum includes NeedsAttention variant\n        let status = SpecStatus::NeedsAttention;\n        assert_eq!(status, SpecStatus::NeedsAttention);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","spec","show.rs"],"content":"//! Spec display functionality\n//!\n//! Provides the `cmd_show` command function for displaying spec details.\n\nuse anyhow::Result;\nuse atty;\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse chant::config::Config;\nuse chant::spec;\n\nuse crate::cmd::prep::strip_agent_conversation;\nuse crate::render;\n\n// ============================================================================\n// DISPLAY HELPERS\n// ============================================================================\n\n/// Format a YAML value with semantic colors based on key and value type.\n/// - status: green (completed), yellow (in_progress/pending), red (failed)\n/// - commit: cyan\n/// - type: blue\n/// - lists: magenta\n/// - bools: green (true), red (false)\npub(crate) fn format_yaml_value(key: \u0026str, value: \u0026serde_yaml::Value) -\u003e String {\n    use serde_yaml::Value;\n\n    match value {\n        Value::Null =\u003e \"~\".dimmed().to_string(),\n        Value::Bool(b) =\u003e {\n            if *b {\n                \"true\".green().to_string()\n            } else {\n                \"false\".red().to_string()\n            }\n        }\n        Value::Number(n) =\u003e n.to_string(),\n        Value::String(s) =\u003e {\n            // Apply semantic coloring based on key\n            match key {\n                \"status\" =\u003e match s.as_str() {\n                    \"completed\" =\u003e s.green().to_string(),\n                    \"failed\" =\u003e s.red().to_string(),\n                    _ =\u003e s.yellow().to_string(), // pending, in_progress\n                },\n                \"commit\" =\u003e s.cyan().to_string(),\n                \"type\" =\u003e s.blue().to_string(),\n                _ =\u003e s.to_string(),\n            }\n        }\n        Value::Sequence(seq) =\u003e {\n            let items: Vec\u003cString\u003e = seq\n                .iter()\n                .map(|v| match v {\n                    Value::String(s) =\u003e {\n                        // Color commits like commit hashes\n                        if key == \"commits\" {\n                            s.cyan().to_string()\n                        } else {\n                            s.magenta().to_string()\n                        }\n                    }\n                    _ =\u003e format_yaml_value(\"\", v),\n                })\n                .collect();\n            format!(\"[{}]\", items.join(\", \"))\n        }\n        Value::Mapping(map) =\u003e {\n            let items: Vec\u003cString\u003e = map\n                .iter()\n                .map(|(k, v)| {\n                    let key_str = match k {\n                        Value::String(s) =\u003e s.clone(),\n                        _ =\u003e format!(\"{:?}\", k),\n                    };\n                    format!(\"{}: {}\", key_str, format_yaml_value(\u0026key_str, v))\n                })\n                .collect();\n            format!(\"{{{}}}\", items.join(\", \"))\n        }\n        Value::Tagged(tagged) =\u003e format_yaml_value(key, \u0026tagged.value),\n    }\n}\n\n/// Convert a snake_case key to Title Case for display.\npub(crate) fn key_to_title_case(key: \u0026str) -\u003e String {\n    key.split('_')\n        .map(|word| {\n            let mut chars = word.chars();\n            match chars.next() {\n                Some(first) =\u003e first.to_uppercase().chain(chars).collect(),\n                None =\u003e String::new(),\n            }\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\" \")\n}\n\n// ============================================================================\n// SHOW COMMAND\n// ============================================================================\n\npub fn cmd_show(id: \u0026str, show_body: bool, no_render: bool, raw: bool, clean: bool) -\u003e Result\u003c()\u003e {\n    // Handle --raw mode: output just the body\n    if raw {\n        let spec = if id.contains(':') {\n            // Cross-repo spec ID format: \"repo:spec-id\"\n            let parts: Vec\u003c\u0026str\u003e = id.splitn(2, ':').collect();\n            if parts.len() != 2 {\n                anyhow::bail!(\"Invalid spec ID format. Use 'repo:spec-id' for cross-repo specs\");\n            }\n\n            let repo_name = parts[0];\n            let spec_id = parts[1];\n\n            // Load from global config repos\n            let config = Config::load_merged()?;\n            if !config.repos.iter().any(|r| r.name == repo_name) {\n                anyhow::bail!(\n                    \"Repository '{}' not found in global config. Available repos: {}\",\n                    repo_name,\n                    config\n                        .repos\n                        .iter()\n                        .map(|r| r.name.as_str())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\", \")\n                );\n            }\n\n            let repo_config = config.repos.iter().find(|r| r.name == repo_name).unwrap();\n            let repo_path = shellexpand::tilde(\u0026repo_config.path).to_string();\n            let repo_path = PathBuf::from(repo_path);\n            let specs_dir = repo_path.join(\".chant/specs\");\n\n            spec::resolve_spec(\u0026specs_dir, spec_id)?\n        } else {\n            // Local spec ID\n            let specs_dir = crate::cmd::ensure_initialized()?;\n            spec::resolve_spec(\u0026specs_dir, id)?\n        };\n\n        // Get the body content\n        let body = if clean {\n            strip_agent_conversation(\u0026spec.body)\n        } else {\n            spec.body.clone()\n        };\n\n        // Output the spec content\n        println!(\"{}\", body);\n\n        return Ok(());\n    }\n\n    let spec = if id.contains(':') {\n        // Cross-repo spec ID format: \"repo:spec-id\"\n        let parts: Vec\u003c\u0026str\u003e = id.splitn(2, ':').collect();\n        if parts.len() != 2 {\n            anyhow::bail!(\"Invalid spec ID format. Use 'repo:spec-id' for cross-repo specs\");\n        }\n\n        let repo_name = parts[0];\n        let spec_id = parts[1];\n\n        // Load from global config repos\n        let config = Config::load_merged()?;\n        if !config.repos.iter().any(|r| r.name == repo_name) {\n            anyhow::bail!(\n                \"Repository '{}' not found in global config. Available repos: {}\",\n                repo_name,\n                config\n                    .repos\n                    .iter()\n                    .map(|r| r.name.as_str())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \")\n            );\n        }\n\n        let repo_config = config.repos.iter().find(|r| r.name == repo_name).unwrap();\n        let repo_path = shellexpand::tilde(\u0026repo_config.path).to_string();\n        let repo_path = PathBuf::from(repo_path);\n        let specs_dir = repo_path.join(\".chant/specs\");\n\n        let mut resolved = spec::resolve_spec(\u0026specs_dir, spec_id)?;\n        // Keep the full cross-repo ID format\n        resolved.id = format!(\"{}:{}\", repo_name, resolved.id);\n        resolved\n    } else {\n        // Local spec ID\n        let specs_dir = crate::cmd::ensure_initialized()?;\n        spec::resolve_spec(\u0026specs_dir, id)?\n    };\n\n    // Print branch resolution header for in_progress specs\n    if spec.frontmatter.status == spec::SpecStatus::InProgress {\n        let default_branch = format!(\"chant/{}\", spec.id);\n        let display_branch = spec.frontmatter.branch.as_ref().unwrap_or(\u0026default_branch);\n        println!(\n            \"Spec: {} (showing state from branch {})\",\n            spec.id.cyan(),\n            display_branch.dimmed()\n        );\n        println!();\n    }\n\n    // Print ID (not from frontmatter)\n    println!(\"{}: {}\", \"ID\".bold(), spec.id.cyan());\n\n    // Print title if available (extracted from body, not frontmatter)\n    if let Some(title) = \u0026spec.title {\n        println!(\"{}: {}\", \"Title\".bold(), title);\n    }\n\n    // Get list of derived fields for marking\n    let derived_fields = spec\n        .frontmatter\n        .derived_fields\n        .as_deref()\n        .unwrap_or_default();\n\n    // Convert frontmatter to YAML value and iterate over fields\n    let frontmatter_value = serde_yaml::to_value(\u0026spec.frontmatter)?;\n    if let serde_yaml::Value::Mapping(map) = frontmatter_value {\n        for (key, value) in map {\n            // Skip null values and the derived_fields field itself\n            if value.is_null() {\n                continue;\n            }\n\n            let key_str = match \u0026key {\n                serde_yaml::Value::String(s) =\u003e s.clone(),\n                _ =\u003e continue,\n            };\n\n            // Skip displaying the derived_fields field itself (internal tracking)\n            if key_str == \"derived_fields\" {\n                continue;\n            }\n\n            let display_key = key_to_title_case(\u0026key_str);\n            let formatted_value = format_yaml_value(\u0026key_str, \u0026value);\n\n            // Add [derived] indicator if this field was auto-derived\n            let indicator = if derived_fields.contains(\u0026key_str) {\n                \" [derived]\".dimmed()\n            } else {\n                \"\".normal()\n            };\n\n            println!(\"{}{}: {}\", display_key.bold(), indicator, formatted_value);\n        }\n    }\n\n    // Only show body if --body flag is passed\n    if show_body {\n        println!(\"\\n{}\", \"--- Body ---\".dimmed());\n\n        // Check if we should render markdown\n        let should_render =\n            !no_render \u0026\u0026 atty::is(atty::Stream::Stdout) \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n\n        if should_render {\n            render::render_markdown(\u0026spec.body);\n        } else {\n            println!(\"{}\", spec.body);\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":14}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":20}},{"line":89,"address":[],"length":0,"stats":{"Line":23}},{"line":90,"address":[],"length":0,"stats":{"Line":39}},{"line":91,"address":[],"length":0,"stats":{"Line":13}},{"line":92,"address":[],"length":0,"stats":{"Line":72}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":4}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":9}},{"line":244,"address":[],"length":0,"stats":{"Line":12}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}}],"covered":59,"coverable":133},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","takeover.rs"],"content":"//! Takeover command for intervening in running work processes\n//!\n//! Allows users to stop an autonomous agent and continue with manual guidance.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::fs;\nuse std::path::PathBuf;\n\nuse chant::paths::LOGS_DIR;\nuse chant::pid;\nuse chant::spec::{self, SpecStatus};\n\n/// Result of a takeover operation\npub struct TakeoverResult {\n    pub spec_id: String,\n    pub analysis: String,\n    pub log_tail: String,\n    pub suggestion: String,\n}\n\n/// Takeover a spec that is currently being worked on\npub fn cmd_takeover(id: \u0026str, force: bool) -\u003e Result\u003cTakeoverResult\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n\n    // Resolve the spec ID\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_id = spec.id.clone();\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n\n    println!(\"{} Taking over spec {}\", \"â\".cyan(), spec_id.cyan());\n\n    // Pause the work (stops process and sets status to paused)\n    let pid = pid::read_pid_file(\u0026spec_id)?;\n    let was_running = if let Some(pid) = pid {\n        if pid::is_process_running(pid) {\n            println!(\"  {} Stopping running process (PID: {})\", \"â¢\".cyan(), pid);\n            pid::stop_process(pid)?;\n            pid::remove_pid_file(\u0026spec_id)?;\n            println!(\"  {} Process stopped\", \"â\".green());\n            true\n        } else {\n            println!(\"  {} Cleaning up stale PID file\", \"â¢\".cyan());\n            pid::remove_pid_file(\u0026spec_id)?;\n            false\n        }\n    } else {\n        if !force {\n            anyhow::bail!(\n                \"Spec {} is not currently running. Use --force to analyze anyway.\",\n                spec_id\n            );\n        }\n        false\n    };\n\n    // Read and analyze the log\n    let log_path = PathBuf::from(LOGS_DIR).join(format!(\"{}.log\", spec_id));\n    let (log_tail, analysis) = if log_path.exists() {\n        let log_content = fs::read_to_string(\u0026log_path)\n            .with_context(|| format!(\"Failed to read log file: {}\", log_path.display()))?;\n\n        let tail = get_log_tail(\u0026log_content, 50);\n        let analysis = analyze_log(\u0026log_content);\n\n        (tail, analysis)\n    } else {\n        (\n            \"No log file found\".to_string(),\n            \"No execution log available for analysis\".to_string(),\n        )\n    };\n\n    // Generate suggestion based on spec status and analysis\n    let suggestion = generate_suggestion(\u0026spec, \u0026analysis);\n\n    // Update spec status to paused if it was in_progress\n    if spec.frontmatter.status == SpecStatus::InProgress {\n        spec.frontmatter.status = SpecStatus::Paused;\n    }\n\n    // Append takeover analysis to spec body\n    let takeover_section = format!(\n        \"\\n\\n## Takeover Analysis\\n\\n{}\\n\\n### Recent Log Activity\\n\\n```\\n{}\\n```\\n\\n### Recommendation\\n\\n{}\\n\",\n        analysis,\n        log_tail,\n        suggestion\n    );\n\n    spec.body.push_str(\u0026takeover_section);\n    spec.save(\u0026spec_path)?;\n\n    println!(\"{} Updated spec with takeover analysis\", \"â\".green());\n    if was_running {\n        println!(\"  {} Status set to: paused\", \"â¢\".cyan());\n    }\n    println!(\"  {} Analysis appended to spec body\", \"â¢\".cyan());\n\n    Ok(TakeoverResult {\n        spec_id,\n        analysis,\n        log_tail,\n        suggestion,\n    })\n}\n\n/// Get the last N lines from a log\nfn get_log_tail(log_content: \u0026str, lines: usize) -\u003e String {\n    log_content\n        .lines()\n        .rev()\n        .take(lines)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .into_iter()\n        .rev()\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\")\n}\n\n/// Analyze log content to understand what went wrong\nfn analyze_log(log_content: \u0026str) -\u003e String {\n    let lines: Vec\u003c\u0026str\u003e = log_content.lines().collect();\n\n    if lines.is_empty() {\n        return \"Log is empty - no execution activity recorded.\".to_string();\n    }\n\n    let mut analysis = Vec::new();\n\n    // Check for common error patterns\n    let error_indicators = [\"error:\", \"failed:\", \"ERROR\", \"FAIL\", \"exception\", \"panic\"];\n    let errors: Vec\u003c\u0026str\u003e = lines\n        .iter()\n        .filter(|line| {\n            error_indicators\n                .iter()\n                .any(|indicator| line.to_lowercase().contains(indicator))\n        })\n        .copied()\n        .collect();\n\n    if !errors.is_empty() {\n        analysis.push(format!(\"Found {} error indicator(s) in log:\", errors.len()));\n        for error in errors.iter().take(3) {\n            analysis.push(format!(\"  - {}\", error.trim()));\n        }\n        if errors.len() \u003e 3 {\n            analysis.push(format!(\"  ... and {} more\", errors.len() - 3));\n        }\n    }\n\n    // Check for tool usage patterns\n    let tool_indicators = [\n        \"\u003cfunction_calls\u003e\",\n        \"tool_name\",\n        \"Bash\",\n        \"Read\",\n        \"Edit\",\n        \"Write\",\n    ];\n    let tool_uses: Vec\u003c\u0026str\u003e = lines\n        .iter()\n        .filter(|line| {\n            tool_indicators\n                .iter()\n                .any(|indicator| line.contains(indicator))\n        })\n        .copied()\n        .collect();\n\n    if !tool_uses.is_empty() {\n        analysis.push(format!(\"\\nAgent made {} tool call(s)\", tool_uses.len()));\n    }\n\n    // Check for completion indicators\n    let completion_indicators = [\"completed\", \"finished\", \"done\", \"success\"];\n    let has_completion = lines.iter().any(|line| {\n        completion_indicators\n            .iter()\n            .any(|indicator| line.to_lowercase().contains(indicator))\n    });\n\n    if has_completion {\n        analysis.push(\"\\nLog contains completion indicators.\".to_string());\n    }\n\n    // Estimate progress\n    let total_lines = lines.len();\n    analysis.push(format!(\"\\nLog contains {} lines of output.\", total_lines));\n\n    if errors.is_empty() \u0026\u0026 !has_completion {\n        analysis.push(\"\\nNo errors detected, but work appears incomplete.\".to_string());\n    }\n\n    if analysis.is_empty() {\n        \"Agent execution started but no significant activity detected.\".to_string()\n    } else {\n        analysis.join(\"\\n\")\n    }\n}\n\n/// Generate a suggestion based on spec and analysis\nfn generate_suggestion(spec: \u0026spec::Spec, analysis: \u0026str) -\u003e String {\n    let mut suggestions: Vec\u003cString\u003e = Vec::new();\n\n    // Check if there are errors\n    if analysis.to_lowercase().contains(\"error\") {\n        suggestions\n            .push(\"Review the errors in the log and address them before resuming.\".to_string());\n    }\n\n    // Check acceptance criteria\n    let unchecked = spec.count_unchecked_checkboxes();\n    if unchecked \u003e 0 {\n        suggestions.push(format!(\n            \"{} acceptance criteria remain unchecked.\",\n            unchecked\n        ));\n    }\n\n    // General suggestions\n    suggestions.push(\"Continue working on this spec manually or adjust the approach.\".to_string());\n    suggestions\n        .push(\"When ready to resume automated work, use `chant work \u003cspec-id\u003e`.\".to_string());\n\n    suggestions.join(\"\\n\")\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":106},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","template.rs"],"content":"//! Template command handlers for chant CLI\n//!\n//! Handles template operations including:\n//! - Listing available templates\n//! - Showing template details\n//! - Creating specs from templates\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::io::{self, Write};\nuse std::process::Command;\n\nuse chant::config::Config;\nuse chant::derivation::{self, DerivationEngine};\nuse chant::id;\nuse chant::spec_template::{find_template, load_all_templates, parse_var_args, TemplateSource};\n\n// ============================================================================\n// TEMPLATE COMMANDS\n// ============================================================================\n\n/// List all available templates\npub fn cmd_template_list() -\u003e Result\u003c()\u003e {\n    let templates = load_all_templates();\n\n    if templates.is_empty() {\n        println!(\"{}\", \"No templates found.\".yellow());\n        println!();\n        println!(\"Templates can be stored in:\");\n        println!(\"  â¢ {} (project)\", \".chant/templates/\".cyan());\n        if let Some(global_dir) = chant::spec_template::global_templates_dir() {\n            println!(\"  â¢ {} (global)\", global_dir.display().to_string().cyan());\n        }\n        return Ok(());\n    }\n\n    println!(\"{}\", \"Available templates:\".bold());\n    println!();\n\n    for template in \u0026templates {\n        let source_indicator = match template.source {\n            TemplateSource::Project =\u003e \"(project)\".green(),\n            TemplateSource::Global =\u003e \"(global)\".blue(),\n        };\n\n        print!(\"  {} \", template.name.cyan().bold());\n        print!(\"{}\", source_indicator);\n        println!();\n\n        if !template.frontmatter.description.is_empty() {\n            println!(\"    {}\", template.frontmatter.description.dimmed());\n        }\n\n        // Show variables summary\n        let required_count = template.required_variables().len();\n        let total_count = template.frontmatter.variables.len();\n        if total_count \u003e 0 {\n            let var_summary = if required_count \u003e 0 {\n                format!(\"{} variables ({} required)\", total_count, required_count)\n            } else {\n                format!(\"{} variables (all optional)\", total_count)\n            };\n            println!(\"    {}\", var_summary.dimmed());\n        }\n        println!();\n    }\n\n    Ok(())\n}\n\n/// Show details of a specific template\npub fn cmd_template_show(name: \u0026str) -\u003e Result\u003c()\u003e {\n    let template = find_template(name)?;\n\n    // Header\n    println!(\"{} {}\", \"Template:\".bold(), template.name.cyan().bold());\n    println!(\n        \"{} {}\",\n        \"Source:\".bold(),\n        match template.source {\n            TemplateSource::Project =\u003e \"project\".green(),\n            TemplateSource::Global =\u003e \"global\".blue(),\n        }\n    );\n    println!(\"{} {}\", \"Path:\".bold(), template.path.display());\n    println!();\n\n    if !template.frontmatter.description.is_empty() {\n        println!(\"{}\", template.frontmatter.description);\n        println!();\n    }\n\n    // Variables\n    if !template.frontmatter.variables.is_empty() {\n        println!(\"{}\", \"Variables:\".bold());\n        for var in \u0026template.frontmatter.variables {\n            let required_tag = if var.required \u0026\u0026 var.default.is_none() {\n                \" (required)\".red().to_string()\n            } else {\n                String::new()\n            };\n\n            print!(\"  â¢ {}{}\", var.name.cyan(), required_tag);\n            if let Some(ref default) = var.default {\n                print!(\" = {}\", default.dimmed());\n            }\n            println!();\n\n            if !var.description.is_empty() {\n                println!(\"    {}\", var.description.dimmed());\n            }\n        }\n        println!();\n    }\n\n    // Spec defaults\n    println!(\"{}\", \"Spec Defaults:\".bold());\n    if let Some(ref spec_type) = template.frontmatter.r#type {\n        println!(\"  type: {}\", spec_type);\n    }\n    if let Some(ref labels) = template.frontmatter.labels {\n        if !labels.is_empty() {\n            println!(\"  labels: {}\", labels.join(\", \"));\n        }\n    }\n    if let Some(ref prompt) = template.frontmatter.prompt {\n        println!(\"  prompt: {}\", prompt);\n    }\n    println!();\n\n    // Body preview\n    println!(\"{}\", \"Template Body:\".bold());\n    println!(\"{}\", \"â\".repeat(40).dimmed());\n    // Show first 20 lines of body\n    let lines: Vec\u003c\u0026str\u003e = template.body.lines().collect();\n    let preview_lines = if lines.len() \u003e 20 {\n        \u0026lines[..20]\n    } else {\n        \u0026lines[..]\n    };\n    for line in preview_lines {\n        println!(\"{}\", line);\n    }\n    if lines.len() \u003e 20 {\n        println!(\n            \"{}\",\n            format!(\"... ({} more lines)\", lines.len() - 20).dimmed()\n        );\n    }\n    println!(\"{}\", \"â\".repeat(40).dimmed());\n\n    Ok(())\n}\n\n/// Create a spec from a template\npub fn cmd_add_from_template(\n    template_name: \u0026str,\n    var_args: \u0026[String],\n    prompt_override: Option\u003c\u0026str\u003e,\n    needs_approval: bool,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let template = find_template(template_name)?;\n\n    // Parse provided variables\n    let mut variables = parse_var_args(var_args)?;\n\n    // Check if we need to prompt for missing required variables\n    let missing_required: Vec\u003c_\u003e = template\n        .required_variables()\n        .iter()\n        .filter(|v| !variables.contains_key(\u0026v.name))\n        .cloned()\n        .collect();\n\n    if !missing_required.is_empty() {\n        // Check if we're in an interactive terminal\n        if atty::is(atty::Stream::Stdin) {\n            println!(\n                \"{} Template '{}' requires the following variables:\",\n                \"â¹\".cyan(),\n                template_name\n            );\n            println!();\n\n            for var in \u0026missing_required {\n                let prompt_text = if !var.description.is_empty() {\n                    format!(\"{} ({})\", var.name, var.description)\n                } else {\n                    var.name.clone()\n                };\n\n                print!(\"  {}: \", prompt_text.cyan());\n                io::stdout().flush()?;\n\n                let mut input = String::new();\n                io::stdin().read_line(\u0026mut input)?;\n                let value = input.trim().to_string();\n\n                if value.is_empty() {\n                    anyhow::bail!(\"Variable '{}' is required and cannot be empty\", var.name);\n                }\n\n                variables.insert(var.name.clone(), value);\n            }\n            println!();\n        } else {\n            // Non-interactive mode - error out with helpful message\n            let var_names: Vec\u003c_\u003e = missing_required.iter().map(|v| v.name.as_str()).collect();\n            anyhow::bail!(\n                \"Missing required variable(s): {}\\n\\n\\\n                 Provide them using --var flags:\\n  \\\n                 chant add --template {} {}\",\n                var_names.join(\", \"),\n                template_name,\n                var_names\n                    .iter()\n                    .map(|n| format!(\"--var {}=\u003cvalue\u003e\", n))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\" \")\n            );\n        }\n    }\n\n    // Render the spec content\n    let mut content = template.render(\u0026variables)?;\n\n    // Add approval if requested\n    if needs_approval {\n        // Insert approval section into frontmatter\n        content = add_approval_to_frontmatter(\u0026content)?;\n    }\n\n    // Override prompt if specified\n    if let Some(prompt) = prompt_override {\n        content = set_prompt_in_frontmatter(\u0026content, prompt)?;\n    }\n\n    // Generate ID and write file\n    let id = id::generate_id(\u0026specs_dir)?;\n    let filename = format!(\"{}.md\", id);\n    let filepath = specs_dir.join(\u0026filename);\n\n    std::fs::write(\u0026filepath, \u0026content)?;\n\n    // Apply derived fields if enterprise config is present\n    let config = Config::load()?;\n    if !config.enterprise.derived.is_empty() {\n        let mut spec = chant::spec::Spec::load(\u0026filepath)?;\n        let context = derivation::build_context(\u0026id, \u0026specs_dir);\n        let engine = DerivationEngine::new(config.enterprise.clone());\n        let derived_fields = engine.derive_fields(\u0026context);\n        spec.add_derived_fields(derived_fields);\n        spec.save(\u0026filepath)?;\n    }\n\n    // Git commit\n    let output = Command::new(\"git\")\n        .args([\"add\", \u0026filepath.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git add for spec file\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        if !stderr.contains(\"ignored\") {\n            anyhow::bail!(\"Failed to stage spec file {}: {}\", id, stderr);\n        }\n    } else {\n        let commit_message = format!(\"chant: Add spec {} (from template {})\", id, template_name);\n        let output = Command::new(\"git\")\n            .args([\"commit\", \"-m\", \u0026commit_message])\n            .output()\n            .context(\"Failed to run git commit for spec file\")?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            if !stderr.contains(\"nothing to commit\") \u0026\u0026 !stderr.contains(\"no changes added\") {\n                anyhow::bail!(\"Failed to commit spec file {}: {}\", id, stderr);\n            }\n        }\n    }\n\n    println!(\n        \"{} {} (from template {})\",\n        \"Created\".green(),\n        id.cyan(),\n        template_name.cyan()\n    );\n    if needs_approval {\n        println!(\"{} Requires approval before work can begin\", \"â¹\".cyan());\n    }\n    println!(\"Edit: {}\", filepath.display());\n\n    Ok(())\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/// Add approval section to spec frontmatter\nfn add_approval_to_frontmatter(content: \u0026str) -\u003e Result\u003cString\u003e {\n    // Find the closing --- of frontmatter\n    let content = content.trim_start();\n    if !content.starts_with(\"---\") {\n        anyhow::bail!(\"Invalid spec content: missing frontmatter\");\n    }\n\n    let after_first = \u0026content[3..];\n    if let Some(end_pos) = after_first.find(\"\\n---\") {\n        let frontmatter = \u0026after_first[..end_pos];\n        let rest = \u0026after_first[end_pos + 4..];\n\n        // Add approval section\n        let new_frontmatter = format!(\n            \"{}{}approval:\\n  required: true\\n  status: pending\\n\",\n            frontmatter,\n            if frontmatter.ends_with('\\n') {\n                \"\"\n            } else {\n                \"\\n\"\n            }\n        );\n\n        Ok(format!(\"---\\n{}---{}\", new_frontmatter, rest))\n    } else {\n        anyhow::bail!(\"Invalid spec content: unclosed frontmatter\");\n    }\n}\n\n/// Set or replace prompt in spec frontmatter\nfn set_prompt_in_frontmatter(content: \u0026str, prompt: \u0026str) -\u003e Result\u003cString\u003e {\n    let content = content.trim_start();\n    if !content.starts_with(\"---\") {\n        anyhow::bail!(\"Invalid spec content: missing frontmatter\");\n    }\n\n    let after_first = \u0026content[3..];\n    if let Some(end_pos) = after_first.find(\"\\n---\") {\n        let frontmatter = \u0026after_first[..end_pos];\n        let rest = \u0026after_first[end_pos + 4..];\n\n        // Check if prompt already exists\n        let new_frontmatter = if frontmatter.contains(\"\\nprompt:\") {\n            // Replace existing prompt\n            let lines: Vec\u003c\u0026str\u003e = frontmatter.lines().collect();\n            let updated: Vec\u003cString\u003e = lines\n                .iter()\n                .map(|line| {\n                    if line.starts_with(\"prompt:\") {\n                        format!(\"prompt: {}\", prompt)\n                    } else {\n                        line.to_string()\n                    }\n                })\n                .collect();\n            updated.join(\"\\n\")\n        } else {\n            // Add new prompt line\n            format!(\n                \"{}{}prompt: {}\",\n                frontmatter,\n                if frontmatter.ends_with('\\n') {\n                    \"\"\n                } else {\n                    \"\\n\"\n                },\n                prompt\n            )\n        };\n\n        Ok(format!(\"---\\n{}\\n---{}\", new_frontmatter.trim(), rest))\n    } else {\n        anyhow::bail!(\"Invalid spec content: unclosed frontmatter\");\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add_approval_to_frontmatter() {\n        let content = \"---\\ntype: code\\nstatus: pending\\n---\\n\\n# Title\\n\";\n        let result = add_approval_to_frontmatter(content).unwrap();\n        assert!(result.contains(\"approval:\"));\n        assert!(result.contains(\"required: true\"));\n        assert!(result.contains(\"status: pending\"));\n    }\n\n    #[test]\n    fn test_set_prompt_in_frontmatter_new() {\n        let content = \"---\\ntype: code\\nstatus: pending\\n---\\n\\n# Title\\n\";\n        let result = set_prompt_in_frontmatter(content, \"custom\").unwrap();\n        assert!(result.contains(\"prompt: custom\"));\n    }\n\n    #[test]\n    fn test_set_prompt_in_frontmatter_replace() {\n        let content = \"---\\ntype: code\\nprompt: old\\nstatus: pending\\n---\\n\\n# Title\\n\";\n        let result = set_prompt_in_frontmatter(content, \"new\").unwrap();\n        assert!(result.contains(\"prompt: new\"));\n        assert!(!result.contains(\"prompt: old\"));\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":1}},{"line":304,"address":[],"length":0,"stats":{"Line":3}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":4}},{"line":344,"address":[],"length":0,"stats":{"Line":6}},{"line":346,"address":[],"length":0,"stats":{"Line":5}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":349,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":8}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":6}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":4}},{"line":374,"address":[],"length":0,"stats":{"Line":0}}],"covered":30,"coverable":185},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","validate.rs"],"content":"//! Unified validation framework for lint/verify/config-validate\n//!\n//! This module provides a common validation framework that unifies:\n//! - Spec linting (structural validation)\n//! - Spec verification (acceptance criteria validation)\n//! - Config validation (configuration file validation)\n\n#![allow(dead_code)] // Framework is being progressively adopted\n\nuse anyhow::Result;\nuse colored::Colorize;\n\n/// Category of validation operation\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ValidationCategory {\n    /// Spec structure and quality\n    Lint,\n    /// Acceptance criteria verification\n    Verify,\n    /// Configuration validation\n    Config,\n}\n\nimpl std::fmt::Display for ValidationCategory {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Lint =\u003e write!(f, \"Lint\"),\n            Self::Verify =\u003e write!(f, \"Verify\"),\n            Self::Config =\u003e write!(f, \"Config\"),\n        }\n    }\n}\n\n/// Severity level for validation issues\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum Severity {\n    /// Informational message\n    Info,\n    /// Warning - should be addressed but not critical\n    Warning,\n    /// Error - must be fixed\n    Error,\n}\n\nimpl std::fmt::Display for Severity {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Info =\u003e write!(f, \"INFO\"),\n            Self::Warning =\u003e write!(f, \"WARN\"),\n            Self::Error =\u003e write!(f, \"ERROR\"),\n        }\n    }\n}\n\n/// A single validation issue\n#[derive(Debug, Clone)]\npub struct ValidationIssue {\n    /// Severity of the issue\n    pub severity: Severity,\n    /// Category of validation that found this issue\n    pub category: ValidationCategory,\n    /// ID of the item being validated (spec ID, config file, etc.)\n    pub item_id: String,\n    /// Message describing the issue\n    pub message: String,\n    /// Optional suggestion for fixing the issue\n    pub suggestion: Option\u003cString\u003e,\n}\n\nimpl ValidationIssue {\n    /// Create a new validation issue\n    pub fn new(\n        severity: Severity,\n        category: ValidationCategory,\n        item_id: impl Into\u003cString\u003e,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            severity,\n            category,\n            item_id: item_id.into(),\n            message: message.into(),\n            suggestion: None,\n        }\n    }\n\n    /// Add a suggestion to this issue\n    pub fn with_suggestion(mut self, suggestion: impl Into\u003cString\u003e) -\u003e Self {\n        self.suggestion = Some(suggestion.into());\n        self\n    }\n\n    /// Display the issue with colored output\n    pub fn display(\u0026self) {\n        let icon = match self.severity {\n            Severity::Info =\u003e \"â¹\".blue(),\n            Severity::Warning =\u003e \"â \".yellow(),\n            Severity::Error =\u003e \"â\".red(),\n        };\n\n        println!(\n            \"  {} {} [{}]: {}\",\n            icon,\n            self.item_id.cyan(),\n            self.category,\n            self.message\n        );\n\n        if let Some(ref suggestion) = self.suggestion {\n            println!(\"      {} {}\", \"â\".cyan(), suggestion);\n        }\n    }\n}\n\n/// Result of a validation operation\n#[derive(Debug)]\npub struct ValidationResult {\n    /// Category of validation performed\n    pub category: ValidationCategory,\n    /// Total items validated\n    pub total: usize,\n    /// Items that passed validation\n    pub passed: usize,\n    /// Items with warnings only\n    pub warned: usize,\n    /// Items that failed validation\n    pub failed: usize,\n    /// All issues found during validation\n    pub issues: Vec\u003cValidationIssue\u003e,\n}\n\nimpl ValidationResult {\n    /// Create a new validation result\n    pub fn new(category: ValidationCategory) -\u003e Self {\n        Self {\n            category,\n            total: 0,\n            passed: 0,\n            warned: 0,\n            failed: 0,\n            issues: Vec::new(),\n        }\n    }\n\n    /// Check if validation passed (no errors)\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.has_errors()\n    }\n\n    /// Check if there are any errors\n    pub fn has_errors(\u0026self) -\u003e bool {\n        self.issues.iter().any(|i| i.severity == Severity::Error)\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(\u0026self) -\u003e bool {\n        self.issues.iter().any(|i| i.severity == Severity::Warning)\n    }\n\n    /// Add an issue to the result\n    pub fn add_issue(\u0026mut self, issue: ValidationIssue) {\n        self.issues.push(issue);\n    }\n\n    /// Display a summary of the validation result\n    pub fn display_summary(\u0026self) {\n        println!();\n        println!(\"{}\", \"â\".repeat(60).cyan());\n\n        let status_icon = if self.is_valid() {\n            \"â\".green()\n        } else {\n            \"â\".red()\n        };\n\n        print!(\"{} {} validation: \", status_icon, self.category);\n\n        if self.total \u003e 0 {\n            print!(\"{} total\", self.total);\n\n            if self.passed \u003e 0 {\n                print!(\", {} {}\", self.passed, \"passed\".green());\n            }\n            if self.warned \u003e 0 {\n                print!(\", {} {}\", self.warned, \"warned\".yellow());\n            }\n            if self.failed \u003e 0 {\n                print!(\", {} {}\", self.failed, \"failed\".red());\n            }\n            println!();\n        } else {\n            println!(\"no items to validate\");\n        }\n\n        // Display error/warning counts\n        let error_count = self\n            .issues\n            .iter()\n            .filter(|i| i.severity == Severity::Error)\n            .count();\n        let warning_count = self\n            .issues\n            .iter()\n            .filter(|i| i.severity == Severity::Warning)\n            .count();\n\n        if error_count \u003e 0 || warning_count \u003e 0 {\n            print!(\"  \");\n            if error_count \u003e 0 {\n                print!(\n                    \"{} {}\",\n                    error_count,\n                    if error_count == 1 { \"error\" } else { \"errors\" }.red()\n                );\n            }\n            if error_count \u003e 0 \u0026\u0026 warning_count \u003e 0 {\n                print!(\", \");\n            }\n            if warning_count \u003e 0 {\n                print!(\n                    \"{} {}\",\n                    warning_count,\n                    if warning_count == 1 {\n                        \"warning\"\n                    } else {\n                        \"warnings\"\n                    }\n                    .yellow()\n                );\n            }\n            println!();\n        }\n\n        println!(\"{}\", \"â\".repeat(60).cyan());\n    }\n\n    /// Exit with appropriate code based on validation result\n    pub fn exit_if_failed(\u0026self) -\u003e Result\u003c()\u003e {\n        if !self.is_valid() {\n            std::process::exit(1);\n        }\n        Ok(())\n    }\n}\n\n/// Trait for types that can be validated\npub trait Validate {\n    /// Perform validation and return issues\n    fn validate(\u0026self) -\u003e Vec\u003cValidationIssue\u003e;\n}\n\n/// Convert from lint Severity to unified Severity\nimpl From\u003ccrate::cmd::spec::lint::Severity\u003e for Severity {\n    fn from(s: crate::cmd::spec::lint::Severity) -\u003e Self {\n        match s {\n            crate::cmd::spec::lint::Severity::Error =\u003e Severity::Error,\n            crate::cmd::spec::lint::Severity::Warning =\u003e Severity::Warning,\n        }\n    }\n}\n\n/// Convert from lint LintDiagnostic to ValidationIssue\nimpl From\u003ccrate::cmd::spec::lint::LintDiagnostic\u003e for ValidationIssue {\n    fn from(diag: crate::cmd::spec::lint::LintDiagnostic) -\u003e Self {\n        let mut issue = ValidationIssue::new(\n            diag.severity.into(),\n            ValidationCategory::Lint,\n            diag.spec_id.clone(),\n            diag.message.clone(),\n        );\n        if let Some(suggestion) = diag.suggestion {\n            issue = issue.with_suggestion(suggestion);\n        }\n        issue\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validation_issue_creation() {\n        let issue = ValidationIssue::new(\n            Severity::Error,\n            ValidationCategory::Lint,\n            \"test-001\",\n            \"Test error\",\n        );\n\n        assert_eq!(issue.severity, Severity::Error);\n        assert_eq!(issue.category, ValidationCategory::Lint);\n        assert_eq!(issue.item_id, \"test-001\");\n        assert_eq!(issue.message, \"Test error\");\n        assert!(issue.suggestion.is_none());\n    }\n\n    #[test]\n    fn test_validation_issue_with_suggestion() {\n        let issue = ValidationIssue::new(\n            Severity::Warning,\n            ValidationCategory::Verify,\n            \"test-002\",\n            \"Test warning\",\n        )\n        .with_suggestion(\"Try this fix\");\n\n        assert_eq!(issue.suggestion, Some(\"Try this fix\".to_string()));\n    }\n\n    #[test]\n    fn test_validation_result_is_valid() {\n        let mut result = ValidationResult::new(ValidationCategory::Lint);\n        result.total = 3;\n        result.passed = 2;\n        result.warned = 1;\n        result.failed = 0;\n\n        // Add a warning\n        result.add_issue(ValidationIssue::new(\n            Severity::Warning,\n            ValidationCategory::Lint,\n            \"test\",\n            \"Warning message\",\n        ));\n\n        assert!(result.is_valid()); // Warnings don't fail validation\n        assert!(result.has_warnings());\n        assert!(!result.has_errors());\n    }\n\n    #[test]\n    fn test_validation_result_with_errors() {\n        let mut result = ValidationResult::new(ValidationCategory::Config);\n        result.total = 2;\n        result.passed = 1;\n        result.failed = 1;\n\n        result.add_issue(ValidationIssue::new(\n            Severity::Error,\n            ValidationCategory::Config,\n            \"config.toml\",\n            \"Invalid configuration\",\n        ));\n\n        assert!(!result.is_valid());\n        assert!(result.has_errors());\n        assert!(!result.has_warnings());\n    }\n\n    #[test]\n    fn test_severity_ordering() {\n        assert!(Severity::Info \u003c Severity::Warning);\n        assert!(Severity::Warning \u003c Severity::Error);\n    }\n\n    #[test]\n    fn test_validation_category_display() {\n        assert_eq!(ValidationCategory::Lint.to_string(), \"Lint\");\n        assert_eq!(ValidationCategory::Verify.to_string(), \"Verify\");\n        assert_eq!(ValidationCategory::Config.to_string(), \"Config\");\n    }\n\n    #[test]\n    fn test_severity_display() {\n        assert_eq!(Severity::Info.to_string(), \"INFO\");\n        assert_eq!(Severity::Warning.to_string(), \"WARN\");\n        assert_eq!(Severity::Error.to_string(), \"ERROR\");\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":16}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":89},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","verify.rs"],"content":"//! Verify command for checking specs against their acceptance criteria.\n//!\n//! This module provides functionality to verify that specs meet their acceptance\n//! criteria, with options for filtering by ID or labels.\n\nuse anyhow::{Context, Result};\nuse chant::config::Config;\nuse chant::prompt;\nuse chant::spec::{load_all_specs, resolve_spec, Spec, SpecStatus};\nuse chrono::Utc;\nuse colored::Colorize;\nuse std::path::PathBuf;\n\nuse crate::cmd::agent;\n\n/// Verification status for a spec\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum VerificationStatus {\n    Pass,\n    Fail,\n    Mixed,\n}\n\nimpl std::fmt::Display for VerificationStatus {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Pass =\u003e write!(f, \"PASS\"),\n            Self::Fail =\u003e write!(f, \"FAIL\"),\n            Self::Mixed =\u003e write!(f, \"MIXED\"),\n        }\n    }\n}\n\n/// Result of verifying an individual criterion\n#[derive(Debug, Clone)]\npub struct CriterionResult {\n    pub criterion: String,\n    pub status: String, // \"PASS\", \"FAIL\", or \"SKIP\"\n    pub note: Option\u003cString\u003e,\n}\n\n/// Result of verifying a single spec\n#[derive(Debug, Clone)]\npub struct SpecVerificationResult {\n    #[allow(dead_code)]\n    pub spec_id: String,\n    #[allow(dead_code)]\n    pub spec_title: Option\u003cString\u003e,\n    pub passed: bool,\n    #[allow(dead_code)]\n    pub total_criteria: usize,\n}\n\n/// Parse verification response from the agent\nfn parse_verification_response(\n    response: \u0026str,\n) -\u003e Result\u003c(VerificationStatus, Vec\u003cCriterionResult\u003e)\u003e {\n    let mut criteria_results = Vec::new();\n    let mut overall_status = VerificationStatus::Pass;\n    let mut in_verification_section = false;\n\n    for line in response.lines() {\n        let trimmed = line.trim();\n\n        // Look for the Verification Summary section\n        if trimmed.contains(\"Verification Summary\") {\n            in_verification_section = true;\n            continue;\n        }\n\n        // Stop at next section (marked by ## heading)\n        if in_verification_section\n            \u0026\u0026 trimmed.starts_with(\"##\")\n            \u0026\u0026 !trimmed.contains(\"Verification Summary\")\n        {\n            break;\n        }\n\n        if !in_verification_section {\n            continue;\n        }\n\n        // Parse criterion lines: \"- [x] Criterion: STATUS â optional note\"\n        if trimmed.starts_with(\"- [\") {\n            // Extract the status and criterion\n            if let Some(rest) = trimmed.strip_prefix(\"- [\") {\n                if let Some(criterion_part) = rest.split_once(']') {\n                    let criterion_line = criterion_part.1.trim();\n\n                    // Parse criterion and status\n                    if let Some(colon_pos) = criterion_line.find(':') {\n                        let criterion_text = criterion_line[..colon_pos].trim().to_string();\n                        let status_part = criterion_line[colon_pos + 1..].trim();\n\n                        // Extract status and optional note\n                        let (status, note) = if let Some(dash_idx) = status_part.find(\" â \") {\n                            let status_text = status_part[..dash_idx].trim().to_uppercase();\n                            let note_text = status_part[dash_idx + \" â \".len()..].trim();\n                            (status_text, Some(note_text.to_string()))\n                        } else {\n                            (status_part.to_uppercase(), None)\n                        };\n\n                        // Validate status\n                        if ![\"PASS\", \"FAIL\", \"SKIP\"].iter().any(|s| status.contains(s)) {\n                            continue;\n                        }\n\n                        // Update overall status based on individual results\n                        if status.contains(\"FAIL\") {\n                            overall_status = VerificationStatus::Fail;\n                        } else if status.contains(\"SKIP\")\n                            \u0026\u0026 overall_status == VerificationStatus::Pass\n                        {\n                            overall_status = VerificationStatus::Mixed;\n                        }\n\n                        criteria_results.push(CriterionResult {\n                            criterion: criterion_text,\n                            status: if status.contains(\"PASS\") {\n                                \"PASS\".to_string()\n                            } else if status.contains(\"FAIL\") {\n                                \"FAIL\".to_string()\n                            } else {\n                                \"SKIP\".to_string()\n                            },\n                            note,\n                        });\n                    }\n                }\n            }\n        }\n\n        // Also look for \"Overall status: X\" line\n        if trimmed.starts_with(\"Overall status:\") {\n            if let Some(status_text) = trimmed.split(':').nth(1) {\n                let status_upper = status_text.trim().to_uppercase();\n                overall_status = if status_upper.contains(\"FAIL\") {\n                    VerificationStatus::Fail\n                } else if status_upper.contains(\"PASS\") {\n                    VerificationStatus::Pass\n                } else {\n                    VerificationStatus::Mixed\n                };\n            }\n        }\n    }\n\n    // If we didn't find any criteria, it's an error\n    if criteria_results.is_empty() {\n        anyhow::bail!(\"Could not parse verification response from agent. Expected format with 'Verification Summary' section.\");\n    }\n\n    Ok((overall_status, criteria_results))\n}\n\n/// Display a summary of verification results for multiple specs\nfn display_verification_summary(results: \u0026[SpecVerificationResult]) {\n    let passed_count = results.iter().filter(|r| r.passed).count();\n    let failed_count = results.len() - passed_count;\n\n    println!(\"\\n{}\", \"â\".repeat(60).cyan());\n    if failed_count == 0 {\n        println!(\n            \"{} Verified {} spec{}: {} {}\",\n            \"â\".green(),\n            results.len(),\n            if results.len() == 1 { \"\" } else { \"s\" },\n            passed_count,\n            \"passed\".green()\n        );\n    } else {\n        println!(\n            \"{} Verified {} spec{}: {} {}, {} {}\",\n            if failed_count \u003e 0 {\n                \"â\".red()\n            } else {\n                \"â\".green()\n            },\n            results.len(),\n            if results.len() == 1 { \"\" } else { \"s\" },\n            passed_count,\n            \"passed\".green(),\n            failed_count,\n            \"failed\".red()\n        );\n    }\n    println!(\"{}\", \"â\".repeat(60).cyan());\n}\n\n/// Extract acceptance criteria section from spec body\nfn extract_acceptance_criteria(spec: \u0026Spec) -\u003e Option\u003cString\u003e {\n    let acceptance_criteria_marker = \"## Acceptance Criteria\";\n    let mut in_ac_section = false;\n    let mut ac_content = String::new();\n    let mut in_code_fence = false;\n\n    for line in spec.body.lines() {\n        let trimmed = line.trim_start();\n\n        // Track code fences\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n        }\n\n        // Look for AC section heading outside code fences\n        if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n            in_ac_section = true;\n            continue;\n        }\n\n        // Stop at next heading\n        if in_ac_section\n            \u0026\u0026 trimmed.starts_with(\"## \")\n            \u0026\u0026 !trimmed.starts_with(acceptance_criteria_marker)\n        {\n            break;\n        }\n\n        if in_ac_section {\n            ac_content.push_str(line);\n            ac_content.push('\\n');\n        }\n    }\n\n    if ac_content.is_empty() {\n        None\n    } else {\n        Some(ac_content)\n    }\n}\n\n/// Execute the verify command\n///\n/// # Arguments\n///\n/// * `id` - Optional spec ID to verify. If None, verifies based on --all or --label filters.\n/// * `all` - If true, verify all specs\n/// * `label` - Labels to filter specs by (OR logic)\n/// * `exit_code` - If true, exit with code 1 if verification fails\n/// * `dry_run` - If true, show what would be verified without making changes\n/// * `prompt` - Custom prompt to use for verification\npub fn cmd_verify(\n    id: Option\u003c\u0026str\u003e,\n    all: bool,\n    label: \u0026[String],\n    exit_code: bool,\n    dry_run: bool,\n    prompt: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = PathBuf::from(\".chant/specs\");\n\n    // Load all available specs\n    let all_specs = load_all_specs(\u0026specs_dir)?;\n\n    // Determine which specs to verify based on arguments\n    let specs_to_verify = if let Some(spec_id) = id {\n        // Verify specific spec by ID\n        let spec = resolve_spec(\u0026specs_dir, spec_id)?;\n\n        // Check if spec is completed\n        if spec.frontmatter.status != SpecStatus::Completed {\n            anyhow::bail!(\n                \"Spec {} is not completed (status: {})\",\n                spec.id,\n                format!(\"{:?}\", spec.frontmatter.status).to_lowercase()\n            );\n        }\n\n        vec![spec]\n    } else if all {\n        // Verify all completed specs\n        let completed: Vec\u003cSpec\u003e = all_specs\n            .into_iter()\n            .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n            .collect();\n\n        if completed.is_empty() {\n            println!(\"No completed specs to verify\");\n            return Ok(());\n        }\n\n        completed\n    } else if !label.is_empty() {\n        // Verify completed specs matching any label\n        let matching: Vec\u003cSpec\u003e = all_specs\n            .into_iter()\n            .filter(|s| {\n                if s.frontmatter.status != SpecStatus::Completed {\n                    return false;\n                }\n\n                // Check if spec has any of the requested labels\n                if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                    label.iter().any(|l| spec_labels.contains(l))\n                } else {\n                    false\n                }\n            })\n            .collect();\n\n        if matching.is_empty() {\n            println!(\n                \"No completed specs with label '{}'\",\n                label.join(\"', '\").yellow()\n            );\n            return Ok(());\n        }\n\n        matching\n    } else {\n        // No filter specified - verify all completed specs\n        let completed: Vec\u003cSpec\u003e = all_specs\n            .into_iter()\n            .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n            .collect();\n\n        if completed.is_empty() {\n            println!(\"No completed specs to verify\");\n            return Ok(());\n        }\n\n        completed\n    };\n\n    // Handle dry-run mode: just show specs that would be verified\n    if dry_run {\n        println!(\"{}\", \"Specs that would be verified (dry-run):\".cyan());\n        for spec in \u0026specs_to_verify {\n            let title = spec.title.as_deref().unwrap_or(\"(no title)\");\n            println!(\"  {} - {}\", spec.id.cyan(), title);\n        }\n        return Ok(());\n    }\n\n    // Load config for agent invocation\n    let config = Config::load().context(\"Failed to load config. Have you run `chant init`?\")?;\n\n    // Verify each spec and track results\n    let mut verification_results = Vec::new();\n\n    for spec in specs_to_verify {\n        let result = verify_spec(\u0026spec, \u0026config, prompt)?;\n        verification_results.push(result);\n    }\n\n    // Display summary if multiple specs were verified\n    if verification_results.len() \u003e 1 {\n        display_verification_summary(\u0026verification_results);\n    }\n\n    // Determine if any failed for exit code handling\n    let any_failed = verification_results.iter().any(|r| !r.passed);\n\n    // Exit with appropriate code if requested\n    if exit_code \u0026\u0026 any_failed {\n        std::process::exit(1);\n    }\n\n    Ok(())\n}\n\n/// Verify a single spec by invoking the agent\nfn verify_spec(\n    spec: \u0026Spec,\n    config: \u0026Config,\n    custom_prompt: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cSpecVerificationResult\u003e {\n    let title = spec.title.as_deref().unwrap_or(\"(no title)\");\n    println!(\"\\n{} {} - {}\", \"Verifying:\".cyan(), spec.id.cyan(), title);\n\n    // Check if spec has acceptance criteria\n    let ac_section = extract_acceptance_criteria(spec);\n    if ac_section.is_none() {\n        println!(\n            \"  {} No acceptance criteria found in spec. Skipping verification.\",\n            \"â \".yellow()\n        );\n        return Ok(SpecVerificationResult {\n            spec_id: spec.id.clone(),\n            spec_title: spec.title.clone(),\n            passed: false,\n            total_criteria: 0,\n        });\n    }\n\n    // Determine which prompt to use\n    let prompt_name = custom_prompt.unwrap_or(\"verify\");\n    let prompt_path = PathBuf::from(format!(\".chant/prompts/{}.md\", prompt_name));\n\n    if !prompt_path.exists() {\n        anyhow::bail!(\n            \"Prompt file not found: {}. Run `chant init` to create default prompts.\",\n            prompt_path.display()\n        );\n    }\n\n    // Assemble the prompt with spec context\n    let message = prompt::assemble(spec, \u0026prompt_path, config)\n        .context(\"Failed to assemble verification prompt\")?;\n\n    // Invoke the agent\n    println!(\"  {} Invoking agent...\", \"â\".cyan());\n\n    let response = match agent::invoke_agent(\u0026message, spec, \"verify\", config) {\n        Ok(output) =\u003e output,\n        Err(e) =\u003e {\n            println!(\"  {} Agent invocation failed: {}\", \"â\".red(), e);\n            return Err(e).context(\"Failed to invoke agent for verification\");\n        }\n    };\n\n    // Parse the response\n    match parse_verification_response(\u0026response) {\n        Ok((overall_status, criteria)) =\u003e {\n            let total_criteria = criteria.len();\n            let passed = overall_status == VerificationStatus::Pass;\n\n            // Display criteria with icons\n            if criteria.is_empty() {\n                println!(\"  {} No criteria to verify\", \"â \".yellow());\n            } else {\n                for (i, criterion) in criteria.iter().enumerate() {\n                    let status_icon = match criterion.status.as_str() {\n                        \"PASS\" =\u003e \"â\".green(),\n                        \"FAIL\" =\u003e \"â\".red(),\n                        \"SKIP\" =\u003e \"~\".yellow(),\n                        _ =\u003e \"?\".bright_yellow(),\n                    };\n\n                    print!(\"  {} {}: {}\", status_icon, i + 1, criterion.criterion);\n                    if let Some(note) = \u0026criterion.note {\n                        print!(\" â {}\", note);\n                    }\n                    println!();\n                }\n            }\n\n            // Display overall result\n            let overall_label = match overall_status {\n                VerificationStatus::Pass =\u003e {\n                    format!(\"{}\", \"â VERIFIED\".green())\n                }\n                VerificationStatus::Fail =\u003e {\n                    format!(\"{}\", \"â FAILED\".red())\n                }\n                VerificationStatus::Mixed =\u003e {\n                    format!(\"{}\", \"~ PARTIAL\".yellow())\n                }\n            };\n\n            println!(\"  {} Overall: {}\", \"â\".cyan(), overall_label);\n\n            // Update spec frontmatter with verification results\n            update_spec_with_verification_results(spec, overall_status, \u0026criteria)?;\n\n            Ok(SpecVerificationResult {\n                spec_id: spec.id.clone(),\n                spec_title: spec.title.clone(),\n                passed,\n                total_criteria,\n            })\n        }\n        Err(e) =\u003e {\n            println!(\n                \"  {} Failed to parse verification response: {}\",\n                \"â\".red(),\n                e\n            );\n            Err(e).context(\"Could not parse agent response\")\n        }\n    }\n}\n\n/// Update spec frontmatter with verification results\nfn update_spec_with_verification_results(\n    spec: \u0026Spec,\n    overall_status: VerificationStatus,\n    criteria: \u0026[CriterionResult],\n) -\u003e Result\u003c()\u003e {\n    // Get current UTC timestamp in ISO 8601 format\n    let now = Utc::now();\n    let timestamp = now.to_rfc3339();\n\n    // Determine verification status string\n    let verification_status = match overall_status {\n        VerificationStatus::Pass =\u003e \"passed\".to_string(),\n        VerificationStatus::Fail =\u003e \"failed\".to_string(),\n        VerificationStatus::Mixed =\u003e \"partial\".to_string(),\n    };\n\n    // Extract failure reasons from FAIL criteria\n    let verification_failures: Option\u003cVec\u003cString\u003e\u003e = {\n        let failures: Vec\u003cString\u003e = criteria\n            .iter()\n            .filter(|c| c.status == \"FAIL\")\n            .map(|c| {\n                if let Some(note) = \u0026c.note {\n                    format!(\"{} â {}\", c.criterion, note)\n                } else {\n                    c.criterion.clone()\n                }\n            })\n            .collect();\n\n        if failures.is_empty() {\n            None\n        } else {\n            Some(failures)\n        }\n    };\n\n    // Create updated spec with new frontmatter\n    let mut updated_spec = spec.clone();\n    updated_spec.frontmatter.last_verified = Some(timestamp);\n    updated_spec.frontmatter.verification_status = Some(verification_status);\n    updated_spec.frontmatter.verification_failures = verification_failures;\n\n    // Save the updated spec to disk\n    let spec_path = PathBuf::from(format!(\".chant/specs/{}.md\", spec.id));\n    updated_spec.save(\u0026spec_path).context(format!(\n        \"Failed to write updated spec to {}\",\n        spec_path.display()\n    ))?;\n\n    println!(\n        \"  {} Frontmatter updated with verification results\",\n        \"â\".cyan()\n    );\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chant::spec::{load_all_specs, Spec, SpecFrontmatter, SpecStatus};\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_filter_completed_spec() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create a completed spec\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Test Spec\".to_string()),\n            body: \"# Test Spec\\n\\nBody content.\".to_string(),\n        };\n\n        spec.save(\u0026specs_dir.join(\"2026-01-26-001-abc.md\")).unwrap();\n\n        // Load and filter - should find completed spec\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        assert_eq!(all_specs.len(), 1);\n        assert_eq!(all_specs[0].id, \"2026-01-26-001-abc\");\n        assert_eq!(all_specs[0].frontmatter.status, SpecStatus::Completed);\n    }\n\n    #[test]\n    fn test_pending_spec_filtered_out() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create a pending spec\n        let spec = Spec {\n            id: \"2026-01-26-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Pending Spec\".to_string()),\n            body: \"# Pending Spec\\n\\nBody content.\".to_string(),\n        };\n\n        spec.save(\u0026specs_dir.join(\"2026-01-26-002-def.md\")).unwrap();\n\n        // Load and filter - should find pending spec but it should not be in completed filter\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        assert_eq!(all_specs.len(), 1);\n        assert_eq!(all_specs[0].frontmatter.status, SpecStatus::Pending);\n\n        // When filtering for completed only, it should be empty\n        let completed: Vec\u003c_\u003e = all_specs\n            .into_iter()\n            .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n            .collect();\n        assert_eq!(completed.len(), 0);\n    }\n\n    #[test]\n    fn test_filter_all_completed_specs() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create multiple completed specs\n        let spec1 = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"First Spec\".to_string()),\n            body: \"# First Spec\\n\\nBody.\".to_string(),\n        };\n\n        let spec2 = Spec {\n            id: \"2026-01-26-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Second Spec\".to_string()),\n            body: \"# Second Spec\\n\\nBody.\".to_string(),\n        };\n\n        // Create a pending spec (should be filtered out)\n        let spec3 = Spec {\n            id: \"2026-01-26-003-ghi\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Pending Spec\".to_string()),\n            body: \"# Pending Spec\\n\\nBody.\".to_string(),\n        };\n\n        spec1\n            .save(\u0026specs_dir.join(\"2026-01-26-001-abc.md\"))\n            .unwrap();\n        spec2\n            .save(\u0026specs_dir.join(\"2026-01-26-002-def.md\"))\n            .unwrap();\n        spec3\n            .save(\u0026specs_dir.join(\"2026-01-26-003-ghi.md\"))\n            .unwrap();\n\n        // Load and filter\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        assert_eq!(all_specs.len(), 3);\n\n        // Filter for completed only\n        let completed: Vec\u003c_\u003e = all_specs\n            .into_iter()\n            .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n            .collect();\n        assert_eq!(completed.len(), 2);\n        assert!(completed.iter().any(|s| s.id == \"2026-01-26-001-abc\"));\n        assert!(completed.iter().any(|s| s.id == \"2026-01-26-002-def\"));\n    }\n\n    #[test]\n    fn test_filter_by_label_completed_only() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create completed spec with label\n        let spec1 = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                labels: Some(vec![\"test\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Labeled Completed\".to_string()),\n            body: \"# Labeled Completed\\n\\nBody.\".to_string(),\n        };\n\n        // Create pending spec with same label (should be filtered out)\n        let spec2 = Spec {\n            id: \"2026-01-26-002-def\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                labels: Some(vec![\"test\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Labeled Pending\".to_string()),\n            body: \"# Labeled Pending\\n\\nBody.\".to_string(),\n        };\n\n        spec1\n            .save(\u0026specs_dir.join(\"2026-01-26-001-abc.md\"))\n            .unwrap();\n        spec2\n            .save(\u0026specs_dir.join(\"2026-01-26-002-def.md\"))\n            .unwrap();\n\n        // Load and filter by label\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        let labels = [\"test\".to_string()];\n\n        let matching: Vec\u003c_\u003e = all_specs\n            .into_iter()\n            .filter(|s| {\n                if s.frontmatter.status != SpecStatus::Completed {\n                    return false;\n                }\n                if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                    labels.iter().any(|l| spec_labels.contains(l))\n                } else {\n                    false\n                }\n            })\n            .collect();\n\n        assert_eq!(matching.len(), 1);\n        assert_eq!(matching[0].id, \"2026-01-26-001-abc\");\n    }\n\n    #[test]\n    fn test_filter_no_completed_specs() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create only pending specs\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Pending Spec\".to_string()),\n            body: \"# Pending Spec\\n\\nBody.\".to_string(),\n        };\n\n        spec.save(\u0026specs_dir.join(\"2026-01-26-001-abc.md\")).unwrap();\n\n        // Load and filter for completed only\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        let completed: Vec\u003c_\u003e = all_specs\n            .into_iter()\n            .filter(|s| s.frontmatter.status == SpecStatus::Completed)\n            .collect();\n\n        assert_eq!(completed.len(), 0);\n    }\n\n    #[test]\n    fn test_nonexistent_spec_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Load from empty directory\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        assert_eq!(all_specs.len(), 0);\n    }\n\n    #[test]\n    fn test_filter_label_no_matches() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        // Create completed spec without the requested label\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                labels: Some(vec![\"other\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Other Label\".to_string()),\n            body: \"# Other Label\\n\\nBody.\".to_string(),\n        };\n\n        spec.save(\u0026specs_dir.join(\"2026-01-26-001-abc.md\")).unwrap();\n\n        // Load and filter by non-matching label\n        let all_specs = load_all_specs(specs_dir).unwrap();\n        let requested_labels = [\"foo\".to_string()];\n\n        let matching: Vec\u003c_\u003e = all_specs\n            .into_iter()\n            .filter(|s| {\n                if s.frontmatter.status != SpecStatus::Completed {\n                    return false;\n                }\n                if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                    requested_labels.iter().any(|l| spec_labels.contains(l))\n                } else {\n                    false\n                }\n            })\n            .collect();\n\n        assert_eq!(matching.len(), 0);\n    }\n\n    #[test]\n    fn test_extract_acceptance_criteria() {\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\n## Acceptance Criteria\\n\\n- [ ] Criterion 1\\n- [ ] Criterion 2\\n\\n## Edge Cases\\n\\nSome content\".to_string(),\n        };\n\n        let ac = extract_acceptance_criteria(\u0026spec).unwrap();\n        assert!(ac.contains(\"Criterion 1\"));\n        assert!(ac.contains(\"Criterion 2\"));\n        assert!(!ac.contains(\"Edge Cases\"));\n    }\n\n    #[test]\n    fn test_extract_acceptance_criteria_none() {\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nNo acceptance criteria here.\".to_string(),\n        };\n\n        let ac = extract_acceptance_criteria(\u0026spec);\n        assert!(ac.is_none());\n    }\n\n    #[test]\n    fn test_parse_verification_response_all_pass() {\n        let response = r#\"## Verification Summary\n\n- [x] Criterion 1: PASS\n- [x] Criterion 2: PASS\n\nOverall status: PASS\"#;\n\n        let (status, criteria) = parse_verification_response(response).unwrap();\n        assert_eq!(status, VerificationStatus::Pass);\n        assert_eq!(criteria.len(), 2);\n        assert_eq!(criteria[0].status, \"PASS\");\n        assert_eq!(criteria[1].status, \"PASS\");\n    }\n\n    #[test]\n    fn test_parse_verification_response_with_fail() {\n        let response = r#\"## Verification Summary\n\n- [x] Criterion 1: PASS\n- [ ] Criterion 2: FAIL\n- [x] Criterion 3: PASS\n\nOverall status: FAIL\"#;\n\n        let (status, criteria) = parse_verification_response(response).unwrap();\n        assert_eq!(status, VerificationStatus::Fail);\n        assert_eq!(criteria.len(), 3);\n        assert_eq!(criteria[0].status, \"PASS\");\n        assert_eq!(criteria[1].status, \"FAIL\");\n        assert_eq!(criteria[2].status, \"PASS\");\n    }\n\n    #[test]\n    fn test_parse_verification_response_with_skip() {\n        let response = r#\"## Verification Summary\n\n- [x] Criterion 1: PASS\n- [x] Criterion 2: SKIP â Unable to verify manually\n- [x] Criterion 3: PASS\n\nOverall status: MIXED\"#;\n\n        let (status, criteria) = parse_verification_response(response).unwrap();\n        assert_eq!(status, VerificationStatus::Mixed);\n        assert_eq!(criteria.len(), 3);\n        assert_eq!(criteria[1].status, \"SKIP\");\n        assert_eq!(\n            criteria[1].note,\n            Some(\"Unable to verify manually\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_verification_response_malformed() {\n        let response = \"Some random output without verification summary\";\n        let result = parse_verification_response(response);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_verification_status_display() {\n        assert_eq!(VerificationStatus::Pass.to_string(), \"PASS\");\n        assert_eq!(VerificationStatus::Fail.to_string(), \"FAIL\");\n        assert_eq!(VerificationStatus::Mixed.to_string(), \"MIXED\");\n    }\n\n    #[test]\n    fn test_frontmatter_update_all_pass() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n        fs::create_dir_all(specs_dir).unwrap();\n\n        let spec = Spec {\n            id: \"2026-01-26-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test Spec\".to_string()),\n            body: \"# Test\\n\\nBody content.\".to_string(),\n        };\n\n        let spec_path = specs_dir.join(\"2026-01-26-001-abc.md\");\n        spec.save(\u0026spec_path).unwrap();\n\n        // Create criteria results with all PASS\n        let criteria = [\n            CriterionResult {\n                criterion: \"Feature X\".to_string(),\n                status: \"PASS\".to_string(),\n                note: None,\n            },\n            CriterionResult {\n                criterion: \"Tests passing\".to_string(),\n                status: \"PASS\".to_string(),\n                note: None,\n            },\n        ];\n\n        // Note: We can't directly call update_spec_with_verification_results from tests\n        // since it's a private function. Instead, we verify the logic manually here.\n        let overall_status = VerificationStatus::Pass;\n\n        let verification_status = match overall_status {\n            VerificationStatus::Pass =\u003e \"passed\",\n            VerificationStatus::Fail =\u003e \"failed\",\n            VerificationStatus::Mixed =\u003e \"partial\",\n        };\n\n        let verification_failures: Option\u003cVec\u003cString\u003e\u003e = {\n            let failures: Vec\u003cString\u003e = criteria\n                .iter()\n                .filter(|c| c.status == \"FAIL\")\n                .map(|c| c.criterion.clone())\n                .collect();\n            if failures.is_empty() {\n                None\n            } else {\n                Some(failures)\n            }\n        };\n\n        assert_eq!(verification_status, \"passed\");\n        assert_eq!(verification_failures, None);\n    }\n\n    #[test]\n    fn test_frontmatter_update_with_failures() {\n        let criteria = [\n            CriterionResult {\n                criterion: \"Feature X\".to_string(),\n                status: \"PASS\".to_string(),\n                note: None,\n            },\n            CriterionResult {\n                criterion: \"Tests passing\".to_string(),\n                status: \"FAIL\".to_string(),\n                note: Some(\"Some tests failed\".to_string()),\n            },\n        ];\n\n        let overall_status = VerificationStatus::Fail;\n\n        let verification_status = match overall_status {\n            VerificationStatus::Pass =\u003e \"passed\",\n            VerificationStatus::Fail =\u003e \"failed\",\n            VerificationStatus::Mixed =\u003e \"partial\",\n        };\n\n        let verification_failures: Option\u003cVec\u003cString\u003e\u003e = {\n            let failures: Vec\u003cString\u003e = criteria\n                .iter()\n                .filter(|c| c.status == \"FAIL\")\n                .map(|c| {\n                    if let Some(note) = \u0026c.note {\n                        format!(\"{} â {}\", c.criterion, note)\n                    } else {\n                        c.criterion.clone()\n                    }\n                })\n                .collect();\n            if failures.is_empty() {\n                None\n            } else {\n                Some(failures)\n            }\n        };\n\n        assert_eq!(verification_status, \"failed\");\n        assert!(verification_failures.is_some());\n        let failures = verification_failures.unwrap();\n        assert_eq!(failures.len(), 1);\n        assert_eq!(failures[0], \"Tests passing â Some tests failed\");\n    }\n\n    #[test]\n    fn test_frontmatter_update_mixed_status() {\n        let criteria = [\n            CriterionResult {\n                criterion: \"Feature X\".to_string(),\n                status: \"PASS\".to_string(),\n                note: None,\n            },\n            CriterionResult {\n                criterion: \"Manual verification\".to_string(),\n                status: \"SKIP\".to_string(),\n                note: Some(\"Could not verify in CI\".to_string()),\n            },\n        ];\n\n        let overall_status = VerificationStatus::Mixed;\n\n        let verification_status = match overall_status {\n            VerificationStatus::Pass =\u003e \"passed\",\n            VerificationStatus::Fail =\u003e \"failed\",\n            VerificationStatus::Mixed =\u003e \"partial\",\n        };\n\n        let verification_failures: Option\u003cVec\u003cString\u003e\u003e = {\n            let failures: Vec\u003cString\u003e = criteria\n                .iter()\n                .filter(|c| c.status == \"FAIL\")\n                .map(|c| c.criterion.clone())\n                .collect();\n            if failures.is_empty() {\n                None\n            } else {\n                Some(failures)\n            }\n        };\n\n        assert_eq!(verification_status, \"partial\");\n        assert_eq!(verification_failures, None);\n    }\n\n    #[test]\n    fn test_timestamp_iso8601_format() {\n        let now = Utc::now();\n        let timestamp = now.to_rfc3339();\n\n        // Verify ISO 8601 format (RFC 3339)\n        // Should contain T and Z or timezone offset\n        assert!(timestamp.contains('T'));\n        assert!(timestamp.contains('Z') || timestamp.contains('+') || timestamp.contains('-'));\n\n        // Should be parseable back\n        assert!(timestamp.parse::\u003cchrono::DateTime\u003cUtc\u003e\u003e().is_ok());\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":29}},{"line":63,"address":[],"length":0,"stats":{"Line":63}},{"line":66,"address":[],"length":0,"stats":{"Line":42}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":18}},{"line":73,"address":[],"length":0,"stats":{"Line":34}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":34}},{"line":86,"address":[],"length":0,"stats":{"Line":16}},{"line":87,"address":[],"length":0,"stats":{"Line":16}},{"line":88,"address":[],"length":0,"stats":{"Line":24}},{"line":91,"address":[],"length":0,"stats":{"Line":16}},{"line":92,"address":[],"length":0,"stats":{"Line":24}},{"line":93,"address":[],"length":0,"stats":{"Line":24}},{"line":96,"address":[],"length":0,"stats":{"Line":25}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":14}},{"line":105,"address":[],"length":0,"stats":{"Line":49}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":9}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":8}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":16}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":12}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":34}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":9}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":8}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":13}},{"line":199,"address":[],"length":0,"stats":{"Line":33}},{"line":202,"address":[],"length":0,"stats":{"Line":22}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":44}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":10}},{"line":214,"address":[],"length":0,"stats":{"Line":10}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":13}},{"line":221,"address":[],"length":0,"stats":{"Line":16}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}}],"covered":76,"coverable":233},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","watch.rs"],"content":"//! Watch command for monitoring and managing spec lifecycle\n//!\n//! Continuously monitors in-progress specs and automatically handles\n//! finalization, merging, and failure recovery. Watch mode is monitor-only:\n//! it does not spawn agents or create specs, only orchestrates lifecycle operations.\n\nuse anyhow::{Context, Result};\nuse chrono::Local;\nuse colored::Colorize;\nuse std::fs::{self, OpenOptions};\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\n\nuse chant::config::Config;\nuse chant::spec::{self, is_completed, is_failed, SpecStatus};\n\nuse crate::cmd;\n\n/// Logger for watch command with structured output and file persistence\npub struct WatchLogger {\n    log_file: Option\u003cstd::fs::File\u003e,\n    log_path: PathBuf,\n    #[allow(dead_code)]\n    stdout_only: bool,\n}\n\nimpl WatchLogger {\n    /// Initialize the watch logger with log file at `.chant/logs/watch.log`\n    pub fn init() -\u003e Result\u003cSelf\u003e {\n        let log_dir = PathBuf::from(\".chant/logs\");\n        let log_path = log_dir.join(\"watch.log\");\n\n        // Create log directory if it doesn't exist\n        if !log_dir.exists() {\n            fs::create_dir_all(\u0026log_dir).with_context(|| {\n                format!(\"Failed to create log directory: {}\", log_dir.display())\n            })?;\n        }\n\n        // Try to open log file in append mode\n        let (log_file, stdout_only) =\n            match OpenOptions::new().create(true).append(true).open(\u0026log_path) {\n                Ok(file) =\u003e (Some(file), false),\n                Err(e) =\u003e {\n                    // Log file unwritable - fall back to stdout-only mode\n                    eprintln!(\n                        \"Warning: Could not open log file at {}: {}\",\n                        log_path.display(),\n                        e\n                    );\n                    eprintln!(\"Continuing with stdout-only logging\");\n                    (None, true)\n                }\n            };\n\n        Ok(WatchLogger {\n            log_file,\n            log_path,\n            stdout_only,\n        })\n    }\n\n    /// Log an event with timestamp to both stdout and file\n    pub fn log_event(\u0026mut self, message: \u0026str) -\u003e Result\u003c()\u003e {\n        let timestamp = Local::now().format(\"[%H:%M:%S]\");\n        let formatted = format!(\"{} {}\", timestamp, message);\n\n        // Write to stdout\n        println!(\"{}\", formatted);\n\n        // Write to file if available\n        if let Some(ref mut file) = self.log_file {\n            writeln!(file, \"{}\", formatted).with_context(|| {\n                format!(\"Failed to write to log file: {}\", self.log_path.display())\n            })?;\n\n            // Flush to ensure visibility during long runs\n            file.flush().with_context(|| {\n                format!(\"Failed to flush log file: {}\", self.log_path.display())\n            })?;\n        }\n\n        Ok(())\n    }\n\n    /// Get the path to the log file\n    #[allow(dead_code)]\n    pub fn log_path(\u0026self) -\u003e \u0026PathBuf {\n        \u0026self.log_path\n    }\n\n    /// Check if logger is in stdout-only mode (file logging failed)\n    #[allow(dead_code)]\n    pub fn is_stdout_only(\u0026self) -\u003e bool {\n        self.stdout_only\n    }\n}\n\n/// Main entry point for watch command\npub fn run_watch(once: bool, dry_run: bool, poll_interval: Option\u003cu64\u003e) -\u003e Result\u003c()\u003e {\n    let _specs_dir = cmd::ensure_initialized()?;\n    let config = Config::load()?;\n\n    // Use command-line override or config value\n    let poll_interval_ms = poll_interval.unwrap_or(config.watch.poll_interval_ms);\n\n    // Warn if poll interval is very short\n    if poll_interval_ms \u003c 1000 {\n        eprintln!(\n            \"{} Poll interval {}ms is very short (\u003c 1s)\",\n            \"â \".yellow(),\n            poll_interval_ms\n        );\n    }\n\n    // Initialize logger\n    let mut logger = WatchLogger::init()?;\n    logger.log_event(\u0026format!(\n        \"Watch started (poll_interval={}ms, once={}, dry_run={})\",\n        poll_interval_ms, once, dry_run\n    ))?;\n\n    // Set up signal handler for graceful shutdown\n    let shutdown = Arc::new(AtomicBool::new(false));\n    let shutdown_clone = shutdown.clone();\n\n    ctrlc::set_handler(move || {\n        shutdown_clone.store(true, Ordering::SeqCst);\n    })\n    .context(\"Failed to set signal handler\")?;\n\n    // Main event loop\n    loop {\n        // Check for shutdown signal\n        if shutdown.load(Ordering::SeqCst) {\n            logger.log_event(\"Shutdown signal received, exiting gracefully\")?;\n            break;\n        }\n\n        // Query in-progress specs\n        let specs = spec::load_all_specs(\u0026PathBuf::from(\".chant/specs\"))?;\n        let in_progress_specs: Vec\u003c_\u003e = specs\n            .iter()\n            .filter(|s| matches!(s.frontmatter.status, SpecStatus::InProgress))\n            .collect();\n\n        if in_progress_specs.is_empty() {\n            logger.log_event(\"No in-progress specs, waiting...\")?;\n        } else {\n            logger.log_event(\u0026format!(\n                \"Checking {} in-progress spec(s)\",\n                in_progress_specs.len()\n            ))?;\n\n            // Check each spec for completion or failure\n            for spec in \u0026in_progress_specs {\n                let spec_id = \u0026spec.id;\n\n                // Check if completed\n                if is_completed(spec_id)? {\n                    logger.log_event(\u0026format!(\"Spec {} is completed\", spec_id.cyan()))?;\n\n                    if dry_run {\n                        logger.log_event(\u0026format!(\n                            \"  {} would finalize {}\",\n                            \"â\".dimmed(),\n                            spec_id\n                        ))?;\n                    } else {\n                        // Handle completion (finalize + merge)\n                        match crate::cmd::lifecycle::handle_completed(spec_id) {\n                            Ok(()) =\u003e {\n                                logger.log_event(\u0026format!(\n                                    \"  {} finalized and merged\",\n                                    \"â\".green()\n                                ))?;\n                            }\n                            Err(e) =\u003e {\n                                logger.log_event(\u0026format!(\n                                    \"  {} failed to finalize: {}\",\n                                    \"â\".red(),\n                                    e\n                                ))?;\n                            }\n                        }\n                    }\n                    continue;\n                }\n\n                // Check if failed\n                if is_failed(spec_id)? {\n                    logger.log_event(\u0026format!(\"Spec {} has failed\", spec_id.cyan()))?;\n\n                    if dry_run {\n                        logger.log_event(\u0026format!(\n                            \"  {} would handle failure for {}\",\n                            \"â\".dimmed(),\n                            spec_id\n                        ))?;\n                    } else {\n                        // Handle failure (retry or permanent failure)\n                        match crate::cmd::lifecycle::handle_failed(spec_id, \u0026config.watch.failure) {\n                            Ok(()) =\u003e {\n                                logger.log_event(\u0026format!(\"  {} failure handled\", \"â\".green()))?;\n                            }\n                            Err(e) =\u003e {\n                                logger.log_event(\u0026format!(\n                                    \"  {} failed to handle failure: {}\",\n                                    \"â\".red(),\n                                    e\n                                ))?;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Exit after one iteration if --once flag is set\n        if once {\n            logger.log_event(\"Single pass complete, exiting\")?;\n            break;\n        }\n\n        // Sleep for poll interval\n        std::thread::sleep(std::time::Duration::from_millis(poll_interval_ms));\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serial_test::serial;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    #[serial]\n    fn test_logger_creates_directory() {\n        let tmp = TempDir::new().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        // Create .chant directory (but not logs subdirectory)\n        let chant_dir = tmp.path().join(\".chant\");\n        fs::create_dir(\u0026chant_dir).unwrap();\n\n        std::env::set_current_dir(tmp.path()).unwrap();\n\n        let logger = WatchLogger::init().unwrap();\n        assert!(PathBuf::from(\".chant/logs\").exists());\n        assert!(!logger.is_stdout_only());\n\n        std::env::set_current_dir(\u0026original_dir).unwrap();\n    }\n\n    #[test]\n    #[serial]\n    fn test_logger_writes_to_file() {\n        let tmp = TempDir::new().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        let chant_dir = tmp.path().join(\".chant\");\n        fs::create_dir(\u0026chant_dir).unwrap();\n\n        std::env::set_current_dir(tmp.path()).unwrap();\n\n        let mut logger = WatchLogger::init().unwrap();\n        logger.log_event(\"Test message\").unwrap();\n\n        // Read using relative path while still in tmp directory\n        let contents = fs::read_to_string(\".chant/logs/watch.log\").unwrap();\n\n        std::env::set_current_dir(\u0026original_dir).unwrap();\n\n        assert!(contents.contains(\"Test message\"));\n        assert!(contents.contains(\"[\"));\n        assert!(contents.contains(\"]\"));\n    }\n\n    #[test]\n    #[serial]\n    fn test_logger_multiple_events() {\n        let tmp = TempDir::new().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        let chant_dir = tmp.path().join(\".chant\");\n        fs::create_dir(\u0026chant_dir).unwrap();\n\n        std::env::set_current_dir(tmp.path()).unwrap();\n\n        let mut logger = WatchLogger::init().unwrap();\n        logger.log_event(\"Event 1\").unwrap();\n        logger.log_event(\"Event 2\").unwrap();\n        logger.log_event(\"Event 3\").unwrap();\n\n        // Read using relative path while still in tmp directory\n        let contents = fs::read_to_string(\".chant/logs/watch.log\").unwrap();\n\n        std::env::set_current_dir(\u0026original_dir).unwrap();\n\n        assert!(contents.contains(\"Event 1\"));\n        assert!(contents.contains(\"Event 2\"));\n        assert!(contents.contains(\"Event 3\"));\n\n        // Count lines\n        let line_count = contents.lines().count();\n        assert_eq!(line_count, 3);\n    }\n\n    #[test]\n    #[serial]\n    fn test_logger_appends_to_existing_file() {\n        let tmp = TempDir::new().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        let logs_dir = tmp.path().join(\".chant/logs\");\n        fs::create_dir_all(\u0026logs_dir).unwrap();\n        let log_path = logs_dir.join(\"watch.log\");\n        fs::write(\u0026log_path, \"Existing content\\n\").unwrap();\n\n        std::env::set_current_dir(tmp.path()).unwrap();\n\n        let mut logger = WatchLogger::init().unwrap();\n        logger.log_event(\"New event\").unwrap();\n\n        let contents = fs::read_to_string(\u0026log_path).unwrap();\n        assert!(contents.contains(\"Existing content\"));\n        assert!(contents.contains(\"New event\"));\n\n        std::env::set_current_dir(\u0026original_dir).unwrap();\n    }\n\n    #[test]\n    #[serial]\n    fn test_timestamp_format() {\n        let tmp = TempDir::new().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        let chant_dir = tmp.path().join(\".chant\");\n        fs::create_dir(\u0026chant_dir).unwrap();\n\n        std::env::set_current_dir(tmp.path()).unwrap();\n\n        let mut logger = WatchLogger::init().unwrap();\n        logger.log_event(\"Test\").unwrap();\n\n        // Read using relative path while still in tmp directory\n        let contents = fs::read_to_string(\".chant/logs/watch.log\").unwrap();\n\n        std::env::set_current_dir(\u0026original_dir).unwrap();\n\n        // Should match [HH:MM:SS] format\n        assert!(contents.starts_with(\"[\"));\n        let parts: Vec\u003c\u0026str\u003e = contents.split(']').collect();\n        assert!(parts.len() \u003e= 2);\n        // Timestamp should be in format [HH:MM:SS]\n        let timestamp = parts[0].trim_start_matches('[');\n        let time_parts: Vec\u003c\u0026str\u003e = timestamp.split(':').collect();\n        assert_eq!(time_parts.len(), 3); // HH:MM:SS\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":12}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":45,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":18}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}}],"covered":22,"coverable":98},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","work","chain.rs"],"content":"//! Chain execution mode for specs\n//!\n//! This module handles sequential execution of specs, processing them one at a time\n//! and stopping on the first failure. It supports:\n//! - Graceful interruption with Ctrl+C\n//! - Filtering by labels\n//! - Execution limits\n//! - Both specific spec IDs and all ready specs modes\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse indicatif::{ProgressBar, ProgressStyle};\nuse std::path::Path;\n\nuse chant::config::Config;\nuse chant::spec::{self, Spec, SpecStatus};\nuse chant::spec_group;\n\nuse crate::cmd;\nuse crate::cmd::finalize::{append_agent_output, finalize_spec};\nuse crate::cmd::git_ops::{commit_transcript, create_or_switch_branch};\n\n// ============================================================================\n// CHAIN INTERRUPTION HANDLING\n// ============================================================================\n\nstatic CHAIN_INTERRUPTED: std::sync::atomic::AtomicBool = std::sync::atomic::AtomicBool::new(false);\n\n/// Set up SIGINT handler for graceful chain interruption\nfn setup_chain_signal_handler() {\n    CHAIN_INTERRUPTED.store(false, std::sync::atomic::Ordering::SeqCst);\n    let _ = ctrlc::set_handler(move || {\n        if CHAIN_INTERRUPTED.load(std::sync::atomic::Ordering::SeqCst) {\n            // Already interrupted once, force exit\n            eprintln!(\"\\n{} Force exit\", \"â\".red());\n            std::process::exit(130);\n        }\n        eprintln!(\n            \"\\n{} Interrupt received - finishing current spec before stopping...\",\n            \"â\".yellow()\n        );\n        eprintln!(\"  {} Press Ctrl+C again to force exit\", \"â\".dimmed());\n        CHAIN_INTERRUPTED.store(true, std::sync::atomic::Ordering::SeqCst);\n    });\n}\n\n/// Check if chain execution was interrupted\nfn is_chain_interrupted() -\u003e bool {\n    CHAIN_INTERRUPTED.load(std::sync::atomic::Ordering::SeqCst)\n}\n\n// ============================================================================\n// SPEC DISCOVERY AND FILTERING\n// ============================================================================\n\n/// Find the next ready spec respecting filters\nfn find_next_ready_spec(\n    specs_dir: \u0026Path,\n    labels: \u0026[String],\n    skip_spec_id: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cOption\u003cSpec\u003e\u003e {\n    let all_specs = spec::load_all_specs(specs_dir)?;\n\n    // Filter to ready specs\n    let mut ready_specs: Vec\u003cSpec\u003e = all_specs\n        .iter()\n        .filter(|s| {\n            // Exclude cancelled specs\n            s.frontmatter.status != SpecStatus::Cancelled\n                // Must be ready (dependencies satisfied)\n                \u0026\u0026 s.is_ready(\u0026all_specs)\n                // Skip the specified spec (if any - used when a specific starting spec was provided)\n                \u0026\u0026 skip_spec_id.is_none_or(|id| s.id != id)\n        })\n        .cloned()\n        .collect();\n\n    // Filter by labels if specified\n    if !labels.is_empty() {\n        ready_specs.retain(|s| {\n            if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                labels.iter().any(|l| spec_labels.contains(l))\n            } else {\n                false\n            }\n        });\n    }\n\n    // Sort by spec ID to ensure chronological order (IDs are date-based: YYYY-MM-DD-NNN-xxx)\n    ready_specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    // Return the first (oldest) ready spec\n    Ok(ready_specs.into_iter().next())\n}\n\n/// Count total ready specs matching filters\nfn count_ready_specs(specs_dir: \u0026Path, labels: \u0026[String]) -\u003e Result\u003cusize\u003e {\n    let all_specs = spec::load_all_specs(specs_dir)?;\n\n    let mut ready_specs: Vec\u003c\u0026Spec\u003e = all_specs\n        .iter()\n        .filter(|s| s.frontmatter.status != SpecStatus::Cancelled \u0026\u0026 s.is_ready(\u0026all_specs))\n        .collect();\n\n    if !labels.is_empty() {\n        ready_specs.retain(|s| {\n            if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                labels.iter().any(|l| spec_labels.contains(l))\n            } else {\n                false\n            }\n        });\n    }\n\n    Ok(ready_specs.len())\n}\n\n// ============================================================================\n// CHAIN EXECUTION\n// ============================================================================\n\n/// Execute a single spec in chain mode (simplified version of cmd_work for single spec)\n#[allow(clippy::too_many_arguments)]\nfn execute_single_spec_in_chain(\n    spec_id: \u0026str,\n    specs_dir: \u0026Path,\n    prompts_dir: \u0026Path,\n    config: \u0026Config,\n    prompt_name: Option\u003c\u0026str\u003e,\n    cli_branch: Option\u003c\u0026str\u003e,\n    skip_deps: bool,\n    skip_criteria: bool,\n    allow_no_commits: bool,\n    skip_approval: bool,\n) -\u003e Result\u003c()\u003e {\n    // Resolve spec\n    let mut spec = spec::resolve_spec(specs_dir, spec_id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Reject cancelled specs\n    if spec.frontmatter.status == SpecStatus::Cancelled {\n        anyhow::bail!(\n            \"Cannot work on cancelled spec '{}'. Cancelled specs are not eligible for execution.\",\n            spec.id\n        );\n    }\n\n    // Check approval requirements\n    if spec.requires_approval() \u0026\u0026 !skip_approval {\n        let approval = spec.frontmatter.approval.as_ref().unwrap();\n        if approval.status == spec::ApprovalStatus::Rejected {\n            let by_info = approval\n                .by\n                .as_ref()\n                .map(|b| format!(\" by {}\", b))\n                .unwrap_or_default();\n            anyhow::bail!(\n                \"Cannot work on spec '{}' - it has been rejected{}. \\\n                 Address the feedback and get approval first.\",\n                spec.id,\n                by_info\n            );\n        } else {\n            anyhow::bail!(\n                \"Spec '{}' requires approval before work can begin. Use --skip-approval to bypass.\",\n                spec.id\n            );\n        }\n    }\n\n    // Check if already completed\n    if spec.frontmatter.status == SpecStatus::Completed \u0026\u0026 !(skip_deps || skip_criteria) {\n        println!(\n            \"{} Spec {} already completed, skipping.\",\n            \"â\".cyan(),\n            spec.id\n        );\n        return Ok(());\n    }\n\n    // Check if dependencies are satisfied\n    let all_specs = spec::load_all_specs(specs_dir)?;\n    if !spec.is_ready(\u0026all_specs) \u0026\u0026 !skip_deps {\n        let blockers = spec.get_blocking_dependencies(\u0026all_specs, specs_dir);\n        if !blockers.is_empty() {\n            let blocking_ids: Vec\u003cString\u003e = blockers.iter().map(|b| b.spec_id.clone()).collect();\n            anyhow::bail!(\n                \"Spec '{}' is blocked by dependencies: {}\",\n                spec.id,\n                blocking_ids.join(\", \")\n            );\n        }\n    }\n\n    // Handle branch creation if requested\n    let create_branch = cli_branch.is_some();\n    let use_branch_prefix = cli_branch.unwrap_or(\u0026config.defaults.branch_prefix);\n    let _branch_name = if create_branch {\n        let branch_name = format!(\"{}{}\", use_branch_prefix, spec.id);\n        create_or_switch_branch(\u0026branch_name)?;\n        spec.frontmatter.branch = Some(branch_name.clone());\n        Some(branch_name)\n    } else {\n        None\n    };\n\n    // Resolve prompt\n    let resolved_prompt_name = prompt_name\n        .map(std::string::ToString::to_string)\n        .or_else(|| spec.frontmatter.prompt.clone())\n        .or_else(|| super::auto_select_prompt_for_type(\u0026spec, prompts_dir))\n        .unwrap_or_else(|| config.defaults.prompt.clone());\n\n    let prompt_path = prompts_dir.join(format!(\"{}.md\", resolved_prompt_name));\n    if !prompt_path.exists() {\n        anyhow::bail!(\"Prompt not found: {}\", resolved_prompt_name);\n    }\n\n    // Update status to in_progress\n    spec.frontmatter.status = SpecStatus::InProgress;\n    spec.save(\u0026spec_path)?;\n\n    // Mark driver as in_progress if this is a member spec\n    spec::mark_driver_in_progress(specs_dir, \u0026spec.id)?;\n\n    // Assemble prompt\n    let message = chant::prompt::assemble(\u0026spec, \u0026prompt_path, config)?;\n\n    // Select agent for execution\n    let agent_command =\n        if config.defaults.rotation_strategy != \"none\" \u0026\u0026 !config.parallel.agents.is_empty() {\n            match cmd::agent_rotation::select_agent_for_work(\n                \u0026config.defaults.rotation_strategy,\n                \u0026config.parallel,\n            ) {\n                Ok(cmd) =\u003e Some(cmd),\n                Err(e) =\u003e {\n                    println!(\"{} Failed to select agent: {}\", \"â \".yellow(), e);\n                    None\n                }\n            }\n        } else {\n            None\n        };\n\n    // Invoke agent\n    let result = if let Some(agent_cmd) = agent_command {\n        cmd::agent::invoke_agent_with_command_override(\n            \u0026message,\n            \u0026spec,\n            \u0026resolved_prompt_name,\n            config,\n            Some(\u0026agent_cmd),\n        )\n    } else {\n        cmd::agent::invoke_agent(\u0026message, \u0026spec, \u0026resolved_prompt_name, config)\n    };\n\n    match result {\n        Ok(agent_output) =\u003e {\n            // Reload spec (it may have been modified by the agent)\n            let mut spec = spec::resolve_spec(specs_dir, \u0026spec.id)?;\n\n            // Check for commits\n            let found_commits = match if allow_no_commits {\n                cmd::commits::get_commits_for_spec_allow_no_commits(\u0026spec.id)\n            } else {\n                cmd::commits::get_commits_for_spec(\u0026spec.id)\n            } {\n                Ok(commits) =\u003e {\n                    if commits.is_empty() {\n                        spec.frontmatter.status = SpecStatus::Failed;\n                        spec.save(\u0026spec_path)?;\n                        anyhow::bail!(\"No commits found - agent did not make any changes\");\n                    }\n                    commits\n                }\n                Err(e) =\u003e {\n                    if allow_no_commits {\n                        vec![]\n                    } else {\n                        spec.frontmatter.status = SpecStatus::Failed;\n                        spec.save(\u0026spec_path)?;\n                        return Err(e);\n                    }\n                }\n            };\n\n            // Check acceptance criteria\n            let unchecked_count = spec.count_unchecked_checkboxes();\n            if unchecked_count \u003e 0 \u0026\u0026 !skip_criteria {\n                spec.frontmatter.status = SpecStatus::Failed;\n                spec.save(\u0026spec_path)?;\n                anyhow::bail!(\"Spec has {} unchecked acceptance criteria\", unchecked_count);\n            }\n\n            // Auto-finalize the spec\n            let all_specs = spec::load_all_specs(specs_dir)?;\n            let commits_to_pass = if found_commits.is_empty() {\n                None\n            } else {\n                Some(found_commits)\n            };\n            finalize_spec(\n                \u0026mut spec,\n                \u0026spec_path,\n                config,\n                \u0026all_specs,\n                allow_no_commits,\n                commits_to_pass,\n            )?;\n\n            // Check if driver should be auto-completed\n            let all_specs = spec::load_all_specs(specs_dir)?;\n            if spec::auto_complete_driver_if_ready(\u0026spec.id, \u0026all_specs, specs_dir)? {\n                println!(\n                    \"  {} Auto-completed driver spec: {}\",\n                    \"â\".green(),\n                    spec::extract_driver_id(\u0026spec.id).unwrap()\n                );\n            }\n\n            // Append agent output to spec body\n            append_agent_output(\u0026mut spec, \u0026agent_output);\n            spec.save(\u0026spec_path)?;\n\n            // Create transcript commit\n            commit_transcript(\u0026spec.id, \u0026spec_path)?;\n\n            Ok(())\n        }\n        Err(e) =\u003e {\n            // Update spec to failed\n            let mut spec = spec::resolve_spec(specs_dir, \u0026spec.id)?;\n            spec.frontmatter.status = SpecStatus::Failed;\n            spec.save(\u0026spec_path)?;\n            Err(e)\n        }\n    }\n}\n\n/// Chain execution mode: loop through ready specs until none remain or failure\npub fn cmd_work_chain(\n    specs_dir: \u0026Path,\n    prompts_dir: \u0026Path,\n    config: \u0026Config,\n    options: ChainOptions,\n) -\u003e Result\u003c()\u003e {\n    // Set up signal handler for graceful interruption\n    setup_chain_signal_handler();\n\n    // If specific IDs are provided, chain through ONLY those specs in order\n    if !options.specific_ids.is_empty() {\n        return cmd_work_chain_specific_ids(specs_dir, prompts_dir, config, \u0026options);\n    }\n\n    // No specific IDs - chain through all ready specs (existing behavior)\n    cmd_work_chain_all_ready(specs_dir, prompts_dir, config, \u0026options)\n}\n\n/// Chain through specific spec IDs in order\nfn cmd_work_chain_specific_ids(\n    specs_dir: \u0026Path,\n    prompts_dir: \u0026Path,\n    config: \u0026Config,\n    options: \u0026ChainOptions,\n) -\u003e Result\u003c()\u003e {\n    use std::time::Instant;\n\n    // Validate all IDs upfront and fail fast if any are invalid\n    let mut resolved_specs = Vec::new();\n    for spec_id in options.specific_ids {\n        match spec::resolve_spec(specs_dir, spec_id) {\n            Ok(spec) =\u003e resolved_specs.push(spec),\n            Err(e) =\u003e {\n                anyhow::bail!(\"Invalid spec ID '{}': {}\", spec_id, e);\n            }\n        }\n    }\n\n    let total = resolved_specs.len();\n    println!(\n        \"\\n{} Starting chain execution ({} specified specs)...\\n\",\n        \"â\".cyan(),\n        total\n    );\n\n    // Create progress bar\n    let pb = ProgressBar::new(total as u64);\n    pb.set_style(\n        ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} {msg}\")\n            .unwrap()\n            .progress_chars(\"=\u003e-\"),\n    );\n\n    // Note: --label filter is ignored when specific IDs are provided\n    if !options.labels.is_empty() {\n        println!(\n            \"{} Note: --label filter ignored when specific spec IDs are provided\\n\",\n            \"â\".dimmed()\n        );\n    }\n\n    let mut all_specs = spec::load_all_specs(specs_dir)?;\n    let mut completed = 0;\n    let mut skipped = 0;\n    let mut failed_spec: Option\u003c(String, String)\u003e = None;\n    let start_time = Instant::now();\n\n    for spec in resolved_specs.iter() {\n        // Check for interrupt\n        if is_chain_interrupted() {\n            println!(\"\\n{} Chain interrupted by user\", \"â\".yellow());\n            break;\n        }\n\n        // Check max limit\n        if options.max_specs \u003e 0 \u0026\u0026 completed \u003e= options.max_specs {\n            println!(\n                \"\\n{} Reached maximum chain limit ({})\",\n                \"â\".green(),\n                options.max_specs\n            );\n            break;\n        }\n\n        // Get fresh spec state from all_specs\n        let current_spec = all_specs\n            .iter()\n            .find(|s| s.id == spec.id)\n            .cloned()\n            .unwrap_or_else(|| spec.clone());\n\n        // Check if spec is ready\n        if !current_spec.is_ready(\u0026all_specs) \u0026\u0026 !options.skip_deps {\n            println!(\n                \"{} Skipping {}: not ready (dependencies not satisfied)\",\n                \"â \".yellow(),\n                current_spec.id\n            );\n            skipped += 1;\n            continue;\n        }\n\n        // Check if spec is already completed\n        if current_spec.frontmatter.status == SpecStatus::Completed\n            \u0026\u0026 !(options.skip_deps || options.skip_criteria)\n        {\n            println!(\n                \"{} Skipping {}: already completed\",\n                \"â \".yellow(),\n                current_spec.id\n            );\n            skipped += 1;\n            continue;\n        }\n\n        // Check if spec is cancelled\n        if current_spec.frontmatter.status == SpecStatus::Cancelled {\n            println!(\"{} Skipping {}: cancelled\", \"â \".yellow(), current_spec.id);\n            skipped += 1;\n            continue;\n        }\n\n        pb.set_message(format!(\n            \"{}: {}\",\n            current_spec.id,\n            current_spec.title.as_deref().unwrap_or(\"\")\n        ));\n\n        let spec_start = Instant::now();\n        match execute_single_spec_in_chain(\n            \u0026spec.id,\n            specs_dir,\n            prompts_dir,\n            config,\n            options.prompt_name,\n            options.cli_branch,\n            options.skip_deps,\n            options.skip_criteria,\n            options.allow_no_commits,\n            options.skip_approval,\n        ) {\n            Ok(()) =\u003e {\n                let elapsed = spec_start.elapsed();\n                pb.inc(1);\n                pb.println(format!(\n                    \"{} Completed {} in {:.1}s\",\n                    \"â\".green(),\n                    spec.id,\n                    elapsed.as_secs_f64()\n                ));\n                completed += 1;\n                // Reload all specs to get fresh dependency state for next iteration\n                all_specs = spec::load_all_specs(specs_dir)?;\n            }\n            Err(e) =\u003e {\n                pb.println(format!(\"{} Failed {}: {}\", \"â\".red(), spec.id, e));\n                failed_spec = Some((spec.id.clone(), e.to_string()));\n                break; // Stop chain on first failure\n            }\n        }\n    }\n\n    // Finish progress bar\n    pb.finish_and_clear();\n\n    // Print summary\n    let total_elapsed = start_time.elapsed();\n    println!(\"{}\", \"â\".repeat(60).dimmed());\n    println!(\"{}\", \"Chain execution complete:\".bold());\n    println!(\n        \"  {} Chained through {} spec(s) in {:.1}s\",\n        \"â\".green(),\n        completed,\n        total_elapsed.as_secs_f64()\n    );\n\n    if skipped \u003e 0 {\n        println!(\"  {} Skipped {} spec(s)\", \"â\".yellow(), skipped);\n    }\n\n    if let Some((spec_id, error)) = \u0026failed_spec {\n        println!(\"  {} Stopped due to failure in {}\", \"â\".red(), spec_id);\n        println!(\"    Error: {}\", error);\n        println!(\"{}\", \"â\".repeat(60).dimmed());\n        // Exit with error code\n        std::process::exit(1);\n    }\n\n    if is_chain_interrupted() {\n        println!(\"  {} Interrupted by user\", \"â\".yellow());\n    }\n\n    println!(\"{}\", \"â\".repeat(60).dimmed());\n\n    Ok(())\n}\n\n/// Chain through all ready specs (original behavior when no specific IDs provided)\nfn cmd_work_chain_all_ready(\n    specs_dir: \u0026Path,\n    prompts_dir: \u0026Path,\n    config: \u0026Config,\n    options: \u0026ChainOptions,\n) -\u003e Result\u003c()\u003e {\n    use std::time::Instant;\n\n    // Count total ready specs for progress display\n    let initial_total = count_ready_specs(specs_dir, options.labels)?;\n\n    if initial_total == 0 {\n        if !options.labels.is_empty() {\n            println!(\"No ready specs with specified labels.\");\n        } else {\n            println!(\"No ready specs to execute.\");\n        }\n        return Ok(());\n    }\n\n    println!(\n        \"\\n{} Starting chain execution ({} ready specs)...\\n\",\n        \"â\".cyan(),\n        initial_total\n    );\n\n    // Create progress bar (indeterminate since total may change)\n    let pb = ProgressBar::new(initial_total as u64);\n    pb.set_style(\n        ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} {msg}\")\n            .unwrap()\n            .progress_chars(\"=\u003e-\"),\n    );\n\n    let mut completed = 0;\n    let mut failed_spec: Option\u003c(String, String)\u003e = None;\n    let start_time = Instant::now();\n\n    // Chain loop: continue until interrupted, max reached, no more specs, or failure\n    while failed_spec.is_none() {\n        // Check for interrupt\n        if is_chain_interrupted() {\n            println!(\"\\n{} Chain interrupted by user\", \"â\".yellow());\n            break;\n        }\n\n        // Check max limit\n        if options.max_specs \u003e 0 \u0026\u0026 completed \u003e= options.max_specs {\n            println!(\n                \"\\n{} Reached maximum chain limit ({})\",\n                \"â\".green(),\n                options.max_specs\n            );\n            break;\n        }\n\n        // Find next ready spec\n        let next_spec = find_next_ready_spec(specs_dir, options.labels, None)?;\n\n        let spec = match next_spec {\n            Some(s) =\u003e s,\n            None =\u003e {\n                println!(\"\\n{} No more ready specs\", \"â\".green());\n                break;\n            }\n        };\n\n        // Get current count for progress display\n        let current_total = count_ready_specs(specs_dir, options.labels)?;\n        let display_total = initial_total.max(completed + current_total);\n\n        // Update progress bar\n        pb.set_length(display_total as u64);\n        pb.set_message(format!(\n            \"{}: {}\",\n            spec.id,\n            spec.title.as_deref().unwrap_or(\"\")\n        ));\n\n        let spec_start = Instant::now();\n        match execute_single_spec_in_chain(\n            \u0026spec.id,\n            specs_dir,\n            prompts_dir,\n            config,\n            options.prompt_name,\n            options.cli_branch,\n            options.skip_deps,\n            options.skip_criteria,\n            options.allow_no_commits,\n            options.skip_approval,\n        ) {\n            Ok(()) =\u003e {\n                let elapsed = spec_start.elapsed();\n                pb.inc(1);\n                pb.println(format!(\n                    \"{} Completed {} in {:.1}s\",\n                    \"â\".green(),\n                    spec.id,\n                    elapsed.as_secs_f64()\n                ));\n                completed += 1;\n            }\n            Err(e) =\u003e {\n                pb.println(format!(\"{} Failed {}: {}\", \"â\".red(), spec.id, e));\n                failed_spec = Some((spec.id, e.to_string()));\n            }\n        }\n    }\n\n    // Finish progress bar\n    pb.finish_and_clear();\n\n    // Print summary\n    let total_elapsed = start_time.elapsed();\n    println!(\"{}\", \"â\".repeat(60).dimmed());\n    println!(\"{}\", \"Chain execution complete:\".bold());\n    println!(\n        \"  {} Chained through {} spec(s) in {:.1}s\",\n        \"â\".green(),\n        completed,\n        total_elapsed.as_secs_f64()\n    );\n\n    if let Some((spec_id, error)) = \u0026failed_spec {\n        println!(\"  {} Stopped due to failure in {}\", \"â\".red(), spec_id);\n        println!(\"    Error: {}\", error);\n        println!(\"{}\", \"â\".repeat(60).dimmed());\n        // Exit with error code\n        std::process::exit(1);\n    }\n\n    if is_chain_interrupted() {\n        println!(\"  {} Interrupted by user\", \"â\".yellow());\n    }\n\n    println!(\"{}\", \"â\".repeat(60).dimmed());\n\n    Ok(())\n}\n\n// ============================================================================\n// CHAIN OPTIONS STRUCT\n// ============================================================================\n\n/// Options for chain execution mode\npub struct ChainOptions\u003c'a\u003e {\n    /// Maximum number of specs to chain (0 = unlimited)\n    pub max_specs: usize,\n    /// Labels to filter specs (ignored when specific_ids is not empty)\n    pub labels: \u0026'a [String],\n    /// Prompt name override\n    pub prompt_name: Option\u003c\u0026'a str\u003e,\n    /// CLI branch prefix override\n    pub cli_branch: Option\u003c\u0026'a str\u003e,\n    /// Skip dependency checks\n    pub skip_deps: bool,\n    /// Skip acceptance criteria validation\n    pub skip_criteria: bool,\n    /// Allow spec completion without matching commits\n    pub allow_no_commits: bool,\n    /// Skip approval check\n    pub skip_approval: bool,\n    /// Specific spec IDs to chain through (if empty, chains through all ready specs)\n    pub specific_ids: \u0026'a [String],\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":8}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":6}},{"line":197,"address":[],"length":0,"stats":{"Line":8}},{"line":198,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":5}},{"line":353,"address":[],"length":0,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":15}},{"line":358,"address":[],"length":0,"stats":{"Line":10}},{"line":362,"address":[],"length":0,"stats":{"Line":3}},{"line":371,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":8}},{"line":373,"address":[],"length":0,"stats":{"Line":10}},{"line":374,"address":[],"length":0,"stats":{"Line":16}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":376,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":382,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":4}},{"line":391,"address":[],"length":0,"stats":{"Line":2}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":3}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":6}},{"line":406,"address":[],"length":0,"stats":{"Line":4}},{"line":407,"address":[],"length":0,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":409,"address":[],"length":0,"stats":{"Line":4}},{"line":411,"address":[],"length":0,"stats":{"Line":5}},{"line":413,"address":[],"length":0,"stats":{"Line":3}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":3}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":6}},{"line":431,"address":[],"length":0,"stats":{"Line":11}},{"line":433,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":7}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":447,"address":[],"length":0,"stats":{"Line":2}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":6}},{"line":469,"address":[],"length":0,"stats":{"Line":8}},{"line":472,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":4}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":4}},{"line":477,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":4}},{"line":479,"address":[],"length":0,"stats":{"Line":4}},{"line":480,"address":[],"length":0,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":4}},{"line":482,"address":[],"length":0,"stats":{"Line":2}},{"line":483,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":2}},{"line":499,"address":[],"length":0,"stats":{"Line":10}},{"line":500,"address":[],"length":0,"stats":{"Line":8}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":4}},{"line":510,"address":[],"length":0,"stats":{"Line":6}},{"line":511,"address":[],"length":0,"stats":{"Line":4}},{"line":512,"address":[],"length":0,"stats":{"Line":6}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":4}},{"line":517,"address":[],"length":0,"stats":{"Line":4}},{"line":520,"address":[],"length":0,"stats":{"Line":3}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":524,"address":[],"length":0,"stats":{"Line":6}},{"line":525,"address":[],"length":0,"stats":{"Line":6}},{"line":526,"address":[],"length":0,"stats":{"Line":2}},{"line":527,"address":[],"length":0,"stats":{"Line":4}},{"line":529,"address":[],"length":0,"stats":{"Line":2}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":8}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":554,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":2}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}}],"covered":112,"coverable":320},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","work","mod.rs"],"content":"//! Work command execution for chant CLI\n//!\n//! Handles spec execution including:\n//! - Single spec execution with agent invocation\n//! - Chain execution for sequential spec processing\n//! - Parallel spec execution with thread pools\n//! - Interactive wizard for spec selection\n//! - Spec finalization and status management\n//! - Branch and PR creation\n//! - Worktree management\n\nuse anyhow::Result;\nuse std::path::Path;\n\nuse chant::spec::Spec;\n\n// Submodules\npub mod chain;\npub mod parallel;\npub mod single;\npub mod wizard;\n\n// Re-export public types from submodules\npub use chain::{cmd_work_chain, ChainOptions};\npub use parallel::{cmd_work_parallel, ParallelOptions};\npub use single::cmd_work;\npub use wizard::{auto_select_prompt_for_type, run_wizard, WizardSelection};\n\n// ============================================================================\n// SHARED HELPER FUNCTIONS\n// ============================================================================\n\n/// Load all ready specs from the specs directory\npub(crate) fn load_ready_specs(specs_dir: \u0026Path) -\u003e Result\u003cVec\u003cSpec\u003e\u003e {\n    let all_specs = chant::spec::load_all_specs(specs_dir)?;\n    let ready_specs: Vec\u003cSpec\u003e = all_specs\n        .iter()\n        .filter(|s| s.is_ready(\u0026all_specs))\n        .cloned()\n        .collect();\n    Ok(ready_specs)\n}\n\n/// List all available prompts from the prompts directory\npub(crate) fn list_available_prompts(prompts_dir: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut prompts = Vec::new();\n    if prompts_dir.exists() \u0026\u0026 prompts_dir.is_dir() {\n        for entry in std::fs::read_dir(prompts_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n            if path.is_file() \u0026\u0026 path.extension().is_some_and(|ext| ext == \"md\") {\n                if let Some(stem) = path.file_stem() {\n                    prompts.push(stem.to_string_lossy().to_string());\n                }\n            }\n        }\n    }\n    prompts.sort();\n    Ok(prompts)\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","work","parallel.rs"],"content":"//! Parallel spec execution for chant CLI\n//!\n//! Handles concurrent execution of multiple specs using agent rotation\n//! with thread pool management, worktree isolation, and cleanup handling.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse rand::Rng;\nuse std::collections::{HashMap, HashSet};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nuse chant::config::Config;\nuse chant::conflict;\nuse chant::spec::{self, Spec, SpecStatus};\nuse chant::worktree;\n\nuse crate::cmd;\nuse crate::cmd::commits::get_commits_for_spec;\nuse crate::cmd::finalize::finalize_spec;\n\n// ============================================================================\n// PARALLEL EXECUTION TYPES\n// ============================================================================\n\n/// Result of a single spec execution in parallel mode\n#[derive(Clone)]\nstruct ParallelResult {\n    spec_id: String,\n    success: bool,\n    commits: Option\u003cVec\u003cString\u003e\u003e,\n    error: Option\u003cString\u003e,\n    worktree_path: Option\u003cPathBuf\u003e,\n    branch_name: Option\u003cString\u003e,\n    is_direct_mode: bool,\n    agent_completed: bool, // Whether agent work completed (separate from merge status)\n}\n\n/// Options for parallel execution\n#[derive(Default)]\npub struct ParallelOptions\u003c'a\u003e {\n    /// Override maximum total concurrent agents\n    pub max_override: Option\u003cusize\u003e,\n    /// Skip cleanup prompt after execution\n    pub no_cleanup: bool,\n    /// Force cleanup prompt even on success\n    pub force_cleanup: bool,\n    /// Labels to filter specs\n    pub labels: \u0026'a [String],\n    /// CLI branch prefix override\n    pub branch_prefix: Option\u003c\u0026'a str\u003e,\n    /// Prompt name override\n    pub prompt_name: Option\u003c\u0026'a str\u003e,\n    /// Specific spec IDs to run (if empty, runs all ready specs)\n    pub specific_ids: \u0026'a [String],\n    /// Disable auto-merge after parallel execution\n    pub no_merge: bool,\n    /// Disable auto-rebase before merge in parallel execution\n    pub no_rebase: bool,\n}\n\n/// Assignment of a spec to an agent\n#[derive(Debug, Clone)]\nstruct AgentAssignment {\n    spec_id: String,\n    agent_name: String,\n    agent_command: String,\n}\n\n/// Severity level for parallel execution pitfalls\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PitfallSeverity {\n    High,\n    Medium,\n    Low,\n}\n\n/// A detected pitfall from parallel execution\n#[derive(Debug, Clone)]\npub struct Pitfall {\n    pub spec_id: Option\u003cString\u003e,\n    pub message: String,\n    pub severity: PitfallSeverity,\n    #[allow(dead_code)]\n    pub pitfall_type: PitfallType,\n}\n\n/// Types of parallel execution pitfalls\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PitfallType {\n    ApiConcurrencyError,\n    MergeConflict,\n    PartialFailure,\n    #[allow(dead_code)]\n    UncommittedChanges,\n    StaleWorktree,\n    AgentError,\n}\n\n// ============================================================================\n// MODEL OVERRIDE WARNING\n// ============================================================================\n\n/// Check if a warning should be shown when parallel mode uses agent rotation\n/// with user-specified model preferences that will be ignored.\n///\n/// Returns true if a warning should be shown, false otherwise.\nfn should_warn_model_override_in_parallel(\n    config: \u0026Config,\n    prompt_name: Option\u003c\u0026str\u003e,\n    chant_model_set: bool,\n    anthropic_model_set: bool,\n) -\u003e bool {\n    // Check if using agent rotation (multiple agents or non-\"none\" rotation strategy)\n    let uses_agent_rotation =\n        config.parallel.agents.len() \u003e 1 || config.defaults.rotation_strategy != \"none\";\n\n    // If not using agent rotation, no warning needed\n    if !uses_agent_rotation {\n        return false;\n    }\n\n    // Check if user has set model preferences\n    let config_model_set = config.defaults.model.is_some();\n\n    // Check if user specified a non-default prompt\n    let user_specified_prompt = prompt_name\n        .map(|p| p != \"standard\" \u0026\u0026 p != config.defaults.prompt.as_str())\n        .unwrap_or(false);\n\n    // If any model preference is set or custom prompt is specified, warn\n    chant_model_set || anthropic_model_set || config_model_set || user_specified_prompt\n}\n\n/// Warn when parallel execution uses agent rotation and user has set model preferences\n/// that will be ignored because each agent has its own CLI profile with its own model.\nfn warn_model_override_in_parallel(config: \u0026Config, prompt_name: Option\u003c\u0026str\u003e) {\n    let chant_model_set = std::env::var(\"CHANT_MODEL\").is_ok();\n    let anthropic_model_set = std::env::var(\"ANTHROPIC_MODEL\").is_ok();\n\n    if !should_warn_model_override_in_parallel(\n        config,\n        prompt_name,\n        chant_model_set,\n        anthropic_model_set,\n    ) {\n        return;\n    }\n\n    // Print warning\n    eprintln!(\n        \"{} Note: Parallel mode uses agent CLI profile models, not config/prompt settings\",\n        \"â ï¸ \".yellow()\n    );\n    eprintln!(\"   The prompt instructions are used, but model selection comes from:\");\n\n    // List agents and their config sources\n    let agents = if config.parallel.agents.is_empty() {\n        vec![chant::config::AgentConfig::default()]\n    } else {\n        config.parallel.agents.clone()\n    };\n\n    for agent in \u0026agents {\n        eprintln!(\n            \"   - {} â model from `{} config show`\",\n            agent.name, agent.command\n        );\n    }\n    eprintln!();\n    eprintln!(\"   To change which model is used:\");\n    for agent in \u0026agents {\n        eprintln!(\n            \"   $ {} config set model \u003copus|sonnet|haiku\u003e\",\n            agent.command\n        );\n    }\n    eprintln!();\n}\n\n// ============================================================================\n// AGENT DISTRIBUTION\n// ============================================================================\n\n/// Distribute specs across agents respecting per-agent and total limits\nfn distribute_specs_to_agents(\n    specs: \u0026[Spec],\n    config: \u0026Config,\n    max_override: Option\u003cusize\u003e,\n) -\u003e Vec\u003cAgentAssignment\u003e {\n    use chant::config::AgentConfig;\n\n    let agents = if config.parallel.agents.is_empty() {\n        vec![AgentConfig::default()]\n    } else {\n        config.parallel.agents.clone()\n    };\n\n    let total_max = max_override.unwrap_or_else(|| config.parallel.total_capacity());\n\n    // Track current allocation per agent\n    let mut agent_allocations: Vec\u003cusize\u003e = vec![0; agents.len()];\n    let mut assignments = Vec::new();\n\n    for spec in specs {\n        if assignments.len() \u003e= total_max {\n            break;\n        }\n\n        // Find agent with most remaining capacity (least-loaded-first strategy)\n        let mut best_agent_idx = None;\n        let mut best_remaining_capacity = 0;\n\n        for (idx, agent) in agents.iter().enumerate() {\n            let remaining = agent.max_concurrent.saturating_sub(agent_allocations[idx]);\n            if remaining \u003e best_remaining_capacity {\n                best_remaining_capacity = remaining;\n                best_agent_idx = Some(idx);\n            }\n        }\n\n        if let Some(idx) = best_agent_idx {\n            agent_allocations[idx] += 1;\n            assignments.push(AgentAssignment {\n                spec_id: spec.id.clone(),\n                agent_name: agents[idx].name.clone(),\n                agent_command: agents[idx].command.clone(),\n            });\n        }\n    }\n\n    assignments\n}\n\n// ============================================================================\n// PARALLEL EXECUTION CLEANUP STATE\n// ============================================================================\n\n/// Tracks active worktrees during parallel execution for cleanup on interrupt.\nstruct ParallelExecutionState {\n    /// Worktrees created this run, keyed by spec_id\n    active_worktrees: Arc\u003cMutex\u003cHashMap\u003cString, PathBuf\u003e\u003e\u003e,\n    /// Specs that completed agent work (preserve their branches)\n    completed_specs: Arc\u003cMutex\u003cHashSet\u003cString\u003e\u003e\u003e,\n}\n\nimpl ParallelExecutionState {\n    fn new() -\u003e Self {\n        Self {\n            active_worktrees: Arc::new(Mutex::new(HashMap::new())),\n            completed_specs: Arc::new(Mutex::new(HashSet::new())),\n        }\n    }\n\n    fn register_worktree(\u0026self, spec_id: \u0026str, path: PathBuf) {\n        if let Ok(mut worktrees) = self.active_worktrees.lock() {\n            worktrees.insert(spec_id.to_string(), path);\n        }\n    }\n\n    fn mark_completed(\u0026self, spec_id: \u0026str) {\n        if let Ok(mut completed) = self.completed_specs.lock() {\n            completed.insert(spec_id.to_string());\n        }\n    }\n\n    fn cleanup_incomplete(\u0026self) {\n        let active = match self.active_worktrees.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return,\n        };\n        let completed = match self.completed_specs.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return,\n        };\n\n        for (spec_id, path) in active.iter() {\n            if !completed.contains(spec_id) {\n                eprintln!(\n                    \"\\n{} Cleaning up incomplete worktree for spec {}: {}\",\n                    \"â\".yellow(),\n                    spec_id.cyan(),\n                    path.display()\n                );\n\n                // Remove worktree\n                if let Err(e) = worktree::remove_worktree(path) {\n                    eprintln!(\"{} Failed to remove worktree: {}\", \"â \".yellow(), e);\n                }\n\n                // Delete branch since work didn't complete\n                let branch = format!(\"chant/{}\", spec_id);\n                if let Err(e) = chant::git::delete_branch(\u0026branch, false) {\n                    eprintln!(\"{} Failed to delete branch {}: {}\", \"â \".yellow(), branch, e);\n                }\n            }\n        }\n    }\n}\n\n/// Set up SIGINT handler for parallel execution cleanup.\nfn setup_parallel_cleanup_handlers(state: Arc\u003cParallelExecutionState\u003e) {\n    // SIGINT handler\n    let state_clone = state.clone();\n    let _ = ctrlc::set_handler(move || {\n        eprintln!(\n            \"\\n{} Interrupt received, cleaning up incomplete worktrees...\",\n            \"â\".yellow()\n        );\n        state_clone.cleanup_incomplete();\n        eprintln!(\"{} Cleanup complete, exiting\", \"â\".green());\n        std::process::exit(130);\n    });\n\n    // Panic hook for crashes\n    let state_clone = state.clone();\n    let default_hook = std::panic::take_hook();\n    std::panic::set_hook(Box::new(move |info| {\n        state_clone.cleanup_incomplete();\n        default_hook(info);\n    }));\n}\n\n// ============================================================================\n// PUBLIC API - MAIN PARALLEL EXECUTION FUNCTION\n// ============================================================================\n\n/// Helper function to auto-select prompt based on spec type\nfn auto_select_prompt_for_type(_spec: \u0026Spec, _prompts_dir: \u0026Path) -\u003e Option\u003cString\u003e {\n    // This function is defined in the original work.rs\n    // For now, we'll return None to use default\n    None\n}\n\npub fn cmd_work_parallel(\n    specs_dir: \u0026Path,\n    prompts_dir: \u0026Path,\n    config: \u0026Config,\n    options: ParallelOptions,\n) -\u003e Result\u003c()\u003e {\n    // Initialize parallel execution state for cleanup on interrupt\n    let execution_state = Arc::new(ParallelExecutionState::new());\n    setup_parallel_cleanup_handlers(execution_state.clone());\n\n    // Load specs: either specific IDs or all ready specs\n    let ready_specs: Vec\u003cSpec\u003e = if !options.specific_ids.is_empty() {\n        // Resolve specific IDs\n        let mut specs = Vec::new();\n        for id in options.specific_ids {\n            match spec::resolve_spec(specs_dir, id) {\n                Ok(s) =\u003e specs.push(s),\n                Err(e) =\u003e {\n                    println!(\"{} Failed to resolve spec '{}': {}\", \"â\".red(), id, e);\n                    return Err(e);\n                }\n            }\n        }\n        specs\n    } else {\n        // Load all ready specs\n        let all_specs = spec::load_all_specs(specs_dir)?;\n        let mut specs: Vec\u003cSpec\u003e = all_specs\n            .iter()\n            .filter(|s| s.frontmatter.status != SpecStatus::Cancelled \u0026\u0026 s.is_ready(\u0026all_specs))\n            .cloned()\n            .collect();\n\n        // Filter by labels if specified\n        if !options.labels.is_empty() {\n            specs.retain(|s| {\n                if let Some(spec_labels) = \u0026s.frontmatter.labels {\n                    options.labels.iter().any(|l| spec_labels.contains(l))\n                } else {\n                    false\n                }\n            });\n        }\n        specs\n    };\n\n    if ready_specs.is_empty() {\n        if !options.specific_ids.is_empty() {\n            println!(\"No specs resolved from provided IDs.\");\n        } else if !options.labels.is_empty() {\n            println!(\"No ready specs with specified labels.\");\n        } else {\n            println!(\"No ready specs to execute.\");\n        }\n        return Ok(());\n    }\n\n    // Distribute specs across configured agents\n    let assignments = distribute_specs_to_agents(\u0026ready_specs, config, options.max_override);\n\n    if assignments.len() \u003c ready_specs.len() {\n        println!(\n            \"{} Warning: Only {} of {} ready specs will be executed (capacity limit)\",\n            \"â \".yellow(),\n            assignments.len(),\n            ready_specs.len()\n        );\n    }\n\n    // Warn if user has set model preferences that will be ignored by agent CLI profiles\n    warn_model_override_in_parallel(config, options.prompt_name);\n\n    // Show agent distribution\n    println!(\n        \"{} Starting {} specs in parallel...\\n\",\n        \"â\".cyan(),\n        assignments.len()\n    );\n\n    // Group assignments by agent for display\n    let mut agent_counts: HashMap\u003c\u0026str, usize\u003e = HashMap::new();\n    for assignment in \u0026assignments {\n        *agent_counts.entry(\u0026assignment.agent_name).or_insert(0) += 1;\n    }\n    for (agent_name, count) in \u0026agent_counts {\n        println!(\"  {} {}: {} specs\", \"â¢\".dimmed(), agent_name, count);\n    }\n    println!();\n\n    // Create multi-progress for parallel execution\n    let multi_progress = Arc::new(MultiProgress::new());\n    let main_pb = multi_progress.add(ProgressBar::new(assignments.len() as u64));\n    main_pb.set_style(\n        ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} specs completed\")\n            .unwrap()\n            .progress_chars(\"=\u003e-\"),\n    );\n\n    // Resolve prompt name for all specs\n    let default_prompt = \u0026config.defaults.prompt;\n\n    // Create channels for collecting results\n    let (tx, rx) = mpsc::channel::\u003cParallelResult\u003e();\n\n    // Spawn threads for each assignment\n    let mut handles = Vec::new();\n\n    // Create a map of spec_id to spec for quick lookup\n    let spec_map: HashMap\u003c\u0026str, \u0026Spec\u003e = ready_specs.iter().map(|s| (s.id.as_str(), s)).collect();\n\n    for assignment in assignments.iter() {\n        let spec = match spec_map.get(assignment.spec_id.as_str()) {\n            Some(s) =\u003e *s,\n            None =\u003e continue,\n        };\n\n        // Determine prompt for this spec: explicit \u003e frontmatter \u003e auto-select by type \u003e default\n        let spec_prompt = options\n            .prompt_name\n            .map(|s| s.to_string())\n            .or_else(|| spec.frontmatter.prompt.clone())\n            .or_else(|| auto_select_prompt_for_type(spec, prompts_dir))\n            .unwrap_or_else(|| default_prompt.to_string());\n\n        let prompt_path = prompts_dir.join(format!(\"{}.md\", spec_prompt));\n        if !prompt_path.exists() {\n            println!(\n                \"{} [{}] Prompt not found: {}\",\n                \"â\".red(),\n                spec.id,\n                spec_prompt\n            );\n            continue;\n        }\n        let spec_prompt = spec_prompt.as_str();\n\n        // Update spec status to in_progress\n        let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n        let mut spec_clone = spec.clone();\n        spec_clone.frontmatter.status = SpecStatus::InProgress;\n        if let Err(e) = spec_clone.save(\u0026spec_path) {\n            println!(\"{} [{}] Failed to update status: {}\", \"â\".red(), spec.id, e);\n            continue;\n        }\n\n        println!(\n            \"[{}] Working with prompt '{}' via {}\",\n            spec.id.cyan(),\n            spec_prompt,\n            assignment.agent_name.dimmed()\n        );\n\n        // Determine branch mode\n        // Priority: CLI --branch flag \u003e spec frontmatter.branch\n        // IMPORTANT: Parallel execution forces branch mode internally for isolation\n        let (is_direct_mode, branch_prefix) = if let Some(cli_prefix) = options.branch_prefix {\n            // CLI --branch specified with explicit prefix\n            (false, cli_prefix.to_string())\n        } else if let Some(spec_branch) = \u0026spec.frontmatter.branch {\n            // Spec has explicit branch prefix\n            (false, spec_branch.clone())\n        } else {\n            // Parallel execution forces branch mode\n            // This prevents merge race conditions during parallel work\n            // Use config's branch_prefix to stay consistent with merge command expectations\n            (false, config.defaults.branch_prefix.clone())\n        };\n\n        // Determine branch name based on mode\n        let branch_name = if is_direct_mode {\n            // Direct mode uses config prefix (this branch is currently unused)\n            format!(\"{}{}\", config.defaults.branch_prefix, spec.id)\n        } else {\n            format!(\"{}{}\", branch_prefix, spec.id)\n        };\n\n        // Create worktree\n        let worktree_result = worktree::create_worktree(\u0026spec.id, \u0026branch_name);\n        let (worktree_path, branch_for_cleanup) = match worktree_result {\n            Ok(path) =\u003e {\n                // Register worktree for cleanup on interrupt\n                execution_state.register_worktree(\u0026spec.id, path.clone());\n\n                // Copy the updated spec file to the worktree\n                if let Err(e) = worktree::copy_spec_to_worktree(\u0026spec.id, \u0026path) {\n                    println!(\n                        \"{} [{}] Failed to copy spec to worktree: {}\",\n                        \"â\".red(),\n                        spec.id,\n                        e\n                    );\n                    // Clean up worktree since we failed\n                    let _ = worktree::remove_worktree(\u0026path);\n                    // Update spec to failed\n                    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n                    if let Ok(mut failed_spec) = spec::resolve_spec(specs_dir, \u0026spec.id) {\n                        failed_spec.frontmatter.status = SpecStatus::Failed;\n                        let _ = failed_spec.save(\u0026spec_path);\n                    }\n                    // Send failed result without spawning thread\n                    let _ = tx.send(ParallelResult {\n                        spec_id: spec.id.clone(),\n                        success: false,\n                        commits: None,\n                        error: Some(e.to_string()),\n                        worktree_path: None,\n                        branch_name: None,\n                        is_direct_mode,\n                        agent_completed: false,\n                    });\n                    continue;\n                }\n\n                (Some(path), Some(branch_name.clone()))\n            }\n            Err(e) =\u003e {\n                println!(\n                    \"{} [{}] Failed to create worktree: {}\",\n                    \"â\".red(),\n                    spec.id,\n                    e\n                );\n                // Update spec to failed\n                let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n                if let Ok(mut failed_spec) = spec::resolve_spec(specs_dir, \u0026spec.id) {\n                    failed_spec.frontmatter.status = SpecStatus::Failed;\n                    let _ = failed_spec.save(\u0026spec_path);\n                }\n                // Send failed result without spawning thread\n                let _ = tx.send(ParallelResult {\n                    spec_id: spec.id.clone(),\n                    success: false,\n                    commits: None,\n                    error: Some(e.to_string()),\n                    worktree_path: None,\n                    branch_name: None,\n                    is_direct_mode,\n                    agent_completed: false,\n                });\n                continue;\n            }\n        };\n\n        // Assemble the prompt message with worktree context\n        // Now that we know the worktree path and branch, we can provide this context to the agent\n        let worktree_ctx = chant::prompt::WorktreeContext {\n            worktree_path: worktree_path.clone(),\n            branch_name: Some(branch_name.clone()),\n            is_isolated: true, // Parallel execution always uses isolated worktrees\n        };\n        let message = match chant::prompt::assemble_with_context(\n            \u0026spec_clone,\n            \u0026prompt_path,\n            config,\n            \u0026worktree_ctx,\n        ) {\n            Ok(m) =\u003e m,\n            Err(e) =\u003e {\n                println!(\n                    \"{} [{}] Failed to assemble prompt: {}\",\n                    \"â\".red(),\n                    spec.id,\n                    e\n                );\n                // Clean up worktree since we failed\n                if let Some(ref path) = worktree_path {\n                    let _ = worktree::remove_worktree(path);\n                }\n                continue;\n            }\n        };\n\n        // Clone data for the thread\n        let tx_clone = tx.clone();\n        let spec_id = spec.id.clone();\n        let specs_dir_clone = specs_dir.to_path_buf();\n        let prompt_name_clone = spec_prompt.to_string();\n        let config_model = config.defaults.model.clone();\n        let worktree_path_clone = worktree_path.clone();\n        let branch_for_cleanup_clone = branch_for_cleanup.clone();\n        let is_direct_mode_clone = is_direct_mode;\n        let agent_command = assignment.agent_command.clone();\n        let config_clone = config.clone();\n        let branch_name_clone = branch_for_cleanup.clone();\n        let execution_state_clone = execution_state.clone();\n\n        let handle = thread::spawn(move || {\n            let result = cmd::agent::invoke_agent_with_command(\n                \u0026message,\n                \u0026spec_id,\n                \u0026prompt_name_clone,\n                config_model.as_deref(),\n                worktree_path_clone.as_deref(),\n                \u0026agent_command,\n                branch_name_clone.as_deref(),\n            );\n            let (success, commits, error, agent_completed) = match result {\n                Ok(_) =\u003e {\n                    // Agent work succeeded - get commits\n                    let commits = get_commits_for_spec(\u0026spec_id).ok();\n\n                    // Mark spec as completed for cleanup tracking\n                    execution_state_clone.mark_completed(\u0026spec_id);\n\n                    // In branch mode: DON'T finalize in worktree - defer to post-merge phase\n                    // This prevents the race condition where feature branch shows Completed\n                    // but main doesn't have the finalization yet.\n                    //\n                    // In direct mode (no worktree): finalize on main branch directly\n                    if !is_direct_mode_clone {\n                        // Branch mode: skip finalization here, it will happen after merge\n                        eprintln!(\n                            \"{} [{}] Agent work completed, deferring finalization to post-merge\",\n                            \"â\".cyan(),\n                            spec_id\n                        );\n\n                        // Remove worktree - the branch is preserved for merging\n                        if let Some(ref path) = worktree_path_clone {\n                            if let Err(e) = worktree::remove_worktree(path) {\n                                eprintln!(\n                                    \"{} [{}] Warning: Failed to remove worktree: {}\",\n                                    \"â \".yellow(),\n                                    spec_id,\n                                    e\n                                );\n                            }\n                        }\n\n                        // Return success with agent_completed=true but the spec is NOT finalized yet\n                        // Finalization will happen in the merge phase on main branch\n                        (true, commits, None, true)\n                    } else {\n                        // Direct mode (no worktree) - finalize on main branch directly\n                        eprintln!(\n                            \"{} [{}] Finalizing spec on main branch (direct mode)\",\n                            \"â\".cyan(),\n                            spec_id\n                        );\n\n                        let spec_path = specs_dir_clone.join(format!(\"{}.md\", spec_id));\n                        let finalize_result =\n                            if let Ok(mut spec) = spec::resolve_spec(\u0026specs_dir_clone, \u0026spec_id) {\n                                let all_specs =\n                                    spec::load_all_specs(\u0026specs_dir_clone).unwrap_or_default();\n                                let commits_to_finalize = commits.clone();\n                                finalize_spec(\n                                    \u0026mut spec,\n                                    \u0026spec_path,\n                                    \u0026config_clone,\n                                    \u0026all_specs,\n                                    false,\n                                    commits_to_finalize,\n                                )\n                            } else {\n                                Err(anyhow::anyhow!(\"Failed to load spec for finalization\"))\n                            };\n\n                        match finalize_result {\n                            Ok(()) =\u003e {\n                                eprintln!(\"{} [{}] â Finalization complete\", \"â\".green(), spec_id);\n                                (true, commits, None, true)\n                            }\n                            Err(e) =\u003e {\n                                eprintln!(\n                                    \"{} [{}] â Cannot finalize spec: {}\",\n                                    \"â\".red(),\n                                    spec_id,\n                                    e\n                                );\n                                // Mark as needs attention instead of completed\n                                let spec_path = specs_dir_clone.join(format!(\"{}.md\", spec_id));\n                                if let Ok(mut failed_spec) =\n                                    spec::resolve_spec(\u0026specs_dir_clone, \u0026spec_id)\n                                {\n                                    eprintln!(\n                                        \"{} [{}] Marking spec as NeedsAttention due to finalization error\",\n                                        \"â\".yellow(),\n                                        spec_id\n                                    );\n                                    failed_spec.frontmatter.status = SpecStatus::NeedsAttention;\n                                    let _ = failed_spec.save(\u0026spec_path);\n                                }\n                                (false, commits, Some(e.to_string()), false)\n                            }\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    // Agent failed - cleanup worktree\n                    if let Some(ref path) = worktree_path_clone {\n                        if !is_direct_mode_clone {\n                            let _ = worktree::remove_worktree(path);\n                        }\n                    }\n\n                    // Update spec to failed\n                    let spec_path = specs_dir_clone.join(format!(\"{}.md\", spec_id));\n                    if let Ok(mut spec) = spec::resolve_spec(\u0026specs_dir_clone, \u0026spec_id) {\n                        spec.frontmatter.status = SpecStatus::Failed;\n                        let _ = spec.save(\u0026spec_path);\n                    }\n\n                    (false, None, Some(e.to_string()), false)\n                }\n            };\n\n            let _ = tx_clone.send(ParallelResult {\n                spec_id,\n                success,\n                commits,\n                error,\n                worktree_path: worktree_path_clone,\n                branch_name: branch_for_cleanup_clone,\n                is_direct_mode: is_direct_mode_clone,\n                agent_completed,\n            });\n        });\n\n        handles.push(handle);\n\n        // Apply stagger delay with jitter between spawning agents to avoid API rate limiting\n        if config.parallel.stagger_delay_ms \u003e 0 {\n            let mut rng = rand::thread_rng();\n            let jitter = if config.parallel.stagger_jitter_ms \u003e 0 {\n                // Generate random jitter from -jitter to +jitter\n                rng.gen_range(\n                    -(config.parallel.stagger_jitter_ms as i64)\n                        ..=(config.parallel.stagger_jitter_ms as i64),\n                )\n            } else {\n                0\n            };\n\n            // Calculate actual delay: base_delay + jitter, but ensure it's non-negative\n            let delay_ms = (config.parallel.stagger_delay_ms as i64 + jitter).max(0) as u64;\n            thread::sleep(Duration::from_millis(delay_ms));\n        }\n    }\n\n    // Drop the original sender so the receiver knows when all threads are done\n    drop(tx);\n\n    // Collect results from threads\n    let mut completed = 0;\n    let mut failed = 0;\n    let mut all_results = Vec::new();\n    let mut branch_mode_branches = Vec::new();\n    let mut direct_mode_results = Vec::new();\n\n    for result in rx {\n        main_pb.inc(1);\n        if result.success {\n            completed += 1;\n            if let Some(ref commits) = result.commits {\n                let commits_str = commits.join(\", \");\n                main_pb.println(format!(\n                    \"[{}] {} Completed (commits: {})\",\n                    result.spec_id.cyan(),\n                    \"â\".green(),\n                    commits_str\n                ));\n            } else {\n                main_pb.println(format!(\n                    \"[{}] {} Completed\",\n                    result.spec_id.cyan(),\n                    \"â\".green()\n                ));\n            }\n\n            // Collect branch info\n            if result.is_direct_mode {\n                direct_mode_results.push(result.clone());\n            } else if let Some(ref branch) = result.branch_name {\n                branch_mode_branches.push((result.spec_id.clone(), branch.clone()));\n            }\n        } else {\n            failed += 1;\n            let error_msg = result.error.as_deref().unwrap_or(\"Unknown error\");\n            main_pb.println(format!(\n                \"[{}] {} Failed: {}\",\n                result.spec_id.cyan(),\n                \"â\".red(),\n                error_msg\n            ));\n        }\n        all_results.push(result);\n    }\n\n    // Finish progress bar\n    main_pb.finish_and_clear();\n\n    // Wait for all threads to finish\n    for handle in handles {\n        let _ = handle.join();\n    }\n\n    // =========================================================================\n    // SERIALIZED MERGE PHASE - Handle all direct mode merges sequentially\n    // =========================================================================\n\n    let mut merged_count = 0;\n    let mut merge_failed = Vec::new();\n\n    for result in \u0026direct_mode_results {\n        if let Some(ref branch) = result.branch_name {\n            println!(\"[{}] Merging to main...\", result.spec_id.cyan());\n            let merge_result = worktree::merge_and_cleanup(branch, options.no_rebase);\n\n            if merge_result.success {\n                merged_count += 1;\n                println!(\"[{}] {} Merged to main\", result.spec_id.cyan(), \"â\".green());\n\n                // Cleanup worktree after successful merge\n                if let Some(ref path) = result.worktree_path {\n                    let _ = worktree::remove_worktree(path);\n                }\n            } else {\n                // Merge failed - preserve branch and worktree\n                merge_failed.push((result.spec_id.clone(), merge_result.has_conflict));\n\n                // Update spec status to indicate merge pending\n                let spec_path = specs_dir.join(format!(\"{}.md\", result.spec_id));\n                if let Ok(mut spec) = spec::resolve_spec(specs_dir, \u0026result.spec_id) {\n                    spec.frontmatter.status = SpecStatus::NeedsAttention;\n                    let _ = spec.save(\u0026spec_path);\n                }\n\n                // Don't cleanup worktree - needed for manual merge\n\n                let error_msg = merge_result\n                    .error\n                    .as_deref()\n                    .unwrap_or(\"Unknown merge error\");\n                let branch_name = branch.as_str();\n                println!(\n                    \"[{}] {} Merge failed (branch preserved):\\n  {}\\n  Next Steps:\\n    1. Auto-resolve: chant merge {} --rebase --auto\\n    2. Merge manually: chant merge {}\\n    3. Inspect: git log {} --oneline -3\",\n                    result.spec_id.cyan(),\n                    \"â \".yellow(),\n                    error_msg,\n                    result.spec_id,\n                    result.spec_id,\n                    branch_name\n                );\n\n                // Check for actual conflicts that need resolution spec\n                if merge_result.has_conflict {\n                    if let Ok(conflicting_files) = conflict::detect_conflicting_files() {\n                        let all_specs = spec::load_all_specs(specs_dir).unwrap_or_default();\n                        let blocked_specs =\n                            conflict::get_blocked_specs(\u0026conflicting_files, \u0026all_specs);\n\n                        let source_branch = branch.to_string();\n                        let (spec_title, _) =\n                            conflict::extract_spec_context(specs_dir, \u0026result.spec_id)\n                                .unwrap_or((None, String::new()));\n                        let diff_summary =\n                            conflict::get_diff_summary(\u0026source_branch, \"main\").unwrap_or_default();\n\n                        let context = conflict::ConflictContext {\n                            source_branch,\n                            target_branch: \"main\".to_string(),\n                            conflicting_files,\n                            source_spec_id: result.spec_id.clone(),\n                            source_spec_title: spec_title,\n                            diff_summary,\n                        };\n\n                        if let Ok(conflict_spec_id) =\n                            conflict::create_conflict_spec(specs_dir, \u0026context, blocked_specs)\n                        {\n                            println!(\n                                \"[{}] Created conflict resolution spec: {}\",\n                                result.spec_id.cyan(),\n                                conflict_spec_id\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // BRANCH MODE MERGE PHASE - Auto-merge branch mode branches unless --no-merge\n    // =========================================================================\n\n    let mut branch_mode_merged = 0;\n    let mut branch_mode_failed: Vec\u003c(String, bool)\u003e = Vec::new();\n    let mut branch_mode_skipped: Vec\u003c(String, String)\u003e = Vec::new();\n\n    if !options.no_merge \u0026\u0026 !branch_mode_branches.is_empty() {\n        println!(\n            \"\\n{} Auto-merging {} branch mode branch(es)...\",\n            \"â\".cyan(),\n            branch_mode_branches.len()\n        );\n\n        for (spec_id, branch) in \u0026branch_mode_branches {\n            println!(\"[{}] Merging to main...\", spec_id.cyan());\n            let merge_result = worktree::merge_and_cleanup(branch, options.no_rebase);\n\n            if merge_result.success {\n                // Merge succeeded - NOW finalize on main branch\n                // This is the fix for the race condition: finalization happens AFTER merge\n                println!(\n                    \"[{}] Merge succeeded, finalizing on main...\",\n                    spec_id.cyan()\n                );\n\n                let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n                let finalize_result = if let Ok(mut spec) = spec::resolve_spec(specs_dir, spec_id) {\n                    let all_specs = spec::load_all_specs(specs_dir).unwrap_or_default();\n                    // Get commits for the spec (now on main after merge)\n                    let commits = get_commits_for_spec(spec_id).ok();\n                    finalize_spec(\u0026mut spec, \u0026spec_path, config, \u0026all_specs, false, commits)\n                } else {\n                    Err(anyhow::anyhow!(\"Failed to load spec for finalization\"))\n                };\n\n                match finalize_result {\n                    Ok(()) =\u003e {\n                        branch_mode_merged += 1;\n                        println!(\"[{}] {} Merged and finalized\", spec_id.cyan(), \"â\".green());\n                    }\n                    Err(e) =\u003e {\n                        // Finalization failed AFTER successful merge\n                        // The work is merged but not marked complete\n                        eprintln!(\n                            \"[{}] {} Merged but finalization failed: {}\",\n                            spec_id.cyan(),\n                            \"â \".yellow(),\n                            e\n                        );\n\n                        // Mark as NeedsAttention with clear error context\n                        let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n                        if let Ok(mut spec) = spec::resolve_spec(specs_dir, spec_id) {\n                            spec.frontmatter.status = SpecStatus::NeedsAttention;\n                            let _ = spec.save(\u0026spec_path);\n                        }\n\n                        // Track as failed for reporting\n                        branch_mode_failed.push((spec_id.clone(), false));\n                    }\n                }\n            } else {\n                // Merge failed - preserve branch, spec stays in_progress\n                branch_mode_failed.push((spec_id.clone(), merge_result.has_conflict));\n\n                // DON'T mark as NeedsAttention here - keep spec in_progress\n                // The spec status is still in_progress from when the agent started work\n                // This is intentional: the work completed but merge failed\n                // User needs to resolve merge conflict and then re-run finalization\n\n                let error_msg = merge_result\n                    .error\n                    .as_deref()\n                    .unwrap_or(\"Unknown merge error\");\n                println!(\n                    \"[{}] {} Merge failed (branch preserved):\\n  {}\\n  Next Steps:\\n    1. Auto-resolve: chant merge {} --rebase --auto\\n    2. Merge manually: chant merge {}\\n    3. Inspect: git log {} --oneline -3\",\n                    spec_id.cyan(),\n                    \"â \".yellow(),\n                    error_msg,\n                    spec_id,\n                    spec_id,\n                    branch\n                );\n\n                // Check for actual conflicts that need resolution spec\n                if merge_result.has_conflict {\n                    if let Ok(conflicting_files) = conflict::detect_conflicting_files() {\n                        let all_specs = spec::load_all_specs(specs_dir).unwrap_or_default();\n                        let blocked_specs =\n                            conflict::get_blocked_specs(\u0026conflicting_files, \u0026all_specs);\n\n                        let source_branch = branch.to_string();\n                        let (spec_title, _) = conflict::extract_spec_context(specs_dir, spec_id)\n                            .unwrap_or((None, String::new()));\n                        let diff_summary =\n                            conflict::get_diff_summary(\u0026source_branch, \"main\").unwrap_or_default();\n\n                        let context = conflict::ConflictContext {\n                            source_branch,\n                            target_branch: \"main\".to_string(),\n                            conflicting_files,\n                            source_spec_id: spec_id.clone(),\n                            source_spec_title: spec_title,\n                            diff_summary,\n                        };\n\n                        if let Ok(conflict_spec_id) =\n                            conflict::create_conflict_spec(specs_dir, \u0026context, blocked_specs)\n                        {\n                            println!(\n                                \"[{}] Created conflict resolution spec: {}\",\n                                spec_id.cyan(),\n                                conflict_spec_id\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    } else if options.no_merge \u0026\u0026 !branch_mode_branches.is_empty() {\n        // --no-merge specified, skip auto-merge\n        branch_mode_skipped = branch_mode_branches.clone();\n    }\n\n    // =========================================================================\n    // CLEANUP PHASE - Remove worktrees for successful specs\n    // =========================================================================\n\n    cleanup_successful_worktrees(\u0026all_results);\n\n    // Auto-complete drivers if all their members completed\n    let all_specs = spec::load_all_specs(specs_dir).unwrap_or_default();\n\n    for result in \u0026all_results {\n        if result.success {\n            // Check if this completed spec triggers driver auto-completion\n            if let Ok(true) =\n                spec::auto_complete_driver_if_ready(\u0026result.spec_id, \u0026all_specs, specs_dir)\n            {\n                if let Some(driver_id) = spec::extract_driver_id(\u0026result.spec_id) {\n                    println!(\n                        \"[{}] {} Auto-completed driver spec: {}\",\n                        result.spec_id.cyan(),\n                        \"â\".green(),\n                        driver_id\n                    );\n                }\n            }\n        }\n    }\n\n    // Print summary\n    println!(\"\\n{}\", \"â\".repeat(60).dimmed());\n    println!(\"{}\", \"Parallel execution complete:\".bold());\n    println!(\"  {} {} specs completed work\", \"â\".green(), completed);\n\n    // Report direct mode merges (if any)\n    if !direct_mode_results.is_empty() {\n        println!(\"  {} {} branches merged to main\", \"â\".green(), merged_count);\n\n        if !merge_failed.is_empty() {\n            println!(\n                \"  {} {} branches preserved (merge pending)\",\n                \"â\".yellow(),\n                merge_failed.len()\n            );\n            for (spec_id, has_conflict) in \u0026merge_failed {\n                let indicator = if *has_conflict { \"â¡\" } else { \"â\" };\n                println!(\"    {} {}\", indicator.yellow(), spec_id);\n            }\n        }\n    }\n\n    // Report branch mode merges\n    if branch_mode_merged \u003e 0 {\n        println!(\n            \"  {} {} branch mode specs merged to main\",\n            \"â\".green(),\n            branch_mode_merged\n        );\n    }\n\n    if !branch_mode_failed.is_empty() {\n        println!(\n            \"  {} {} branch mode specs need attention (merge failed)\",\n            \"â \".yellow(),\n            branch_mode_failed.len()\n        );\n        for (spec_id, has_conflict) in \u0026branch_mode_failed {\n            let indicator = if *has_conflict { \"â¡\" } else { \"â\" };\n            println!(\"    {} {}\", indicator.yellow(), spec_id);\n        }\n    }\n\n    // Show branches that were skipped due to --no-merge\n    if !branch_mode_skipped.is_empty() {\n        println!(\n            \"  {} {} branches preserved (--no-merge)\",\n            \"â\".cyan(),\n            branch_mode_skipped.len()\n        );\n    }\n\n    if failed \u003e 0 {\n        println!(\"  {} {} specs failed\", \"â\".red(), failed);\n    }\n    println!(\"{}\", \"â\".repeat(60).dimmed());\n\n    // Show branch mode information (only if --no-merge was used)\n    if !branch_mode_skipped.is_empty() {\n        println!(\n            \"\\n{} Branch mode branches preserved for manual merging:\",\n            \"â\".cyan()\n        );\n        for (_spec_id, branch) in \u0026branch_mode_skipped {\n            println!(\"  {} {}\", \"â¢\".yellow(), branch);\n        }\n        println!(\"\\nUse {} to merge branches later.\", \"chant merge\".bold());\n    }\n\n    // Show next steps for merge failures (direct mode or branch mode)\n    let all_merge_failed = !merge_failed.is_empty() || !branch_mode_failed.is_empty();\n    if all_merge_failed {\n        println!(\"\\n{} Next steps for merge-pending branches:\", \"â\".cyan());\n        println!(\"  1. Review each branch:  git log \u003cbranch\u003e --oneline -5\");\n        println!(\"  2. Auto-resolve conflicts:  chant merge --all --rebase --auto\");\n        println!(\"  3. Or merge sequentially:  chant merge \u003cspec-id\u003e\");\n        println!(\"  4. List worktrees:  git worktree list\");\n        println!(\"\\n  Documentation: See 'chant merge --help' for more options\");\n    }\n\n    // Detect parallel pitfalls\n    let pitfalls = detect_parallel_pitfalls(\u0026all_results, specs_dir);\n\n    // Offer cleanup if issues found (and cleanup is enabled)\n    let should_offer_cleanup = if options.force_cleanup {\n        true\n    } else if options.no_cleanup {\n        false\n    } else {\n        config.parallel.cleanup.enabled \u0026\u0026 !pitfalls.is_empty()\n    };\n\n    if should_offer_cleanup \u0026\u0026 !pitfalls.is_empty() {\n        println!(\"\\n{} Issues detected:\", \"â\".yellow());\n        for pitfall in \u0026pitfalls {\n            let severity_icon = match pitfall.severity {\n                PitfallSeverity::High =\u003e \"â\".red(),\n                PitfallSeverity::Medium =\u003e \"â \".yellow(),\n                PitfallSeverity::Low =\u003e \"â\".dimmed(),\n            };\n            if let Some(ref spec_id) = pitfall.spec_id {\n                println!(\"  {} [{}] {}\", severity_icon, spec_id, pitfall.message);\n            } else {\n                println!(\"  {} {}\", severity_icon, pitfall.message);\n            }\n        }\n\n        if config.parallel.cleanup.auto_run {\n            println!(\"\\n{} Running cleanup agent...\", \"â\".cyan());\n            // Auto-run cleanup would be implemented here\n        } else {\n            println!(\n                \"\\n{} Run {} to analyze and resolve issues.\",\n                \"â\".cyan(),\n                \"chant cleanup\".bold()\n            );\n        }\n    }\n\n    if failed \u003e 0 {\n        std::process::exit(1);\n    }\n\n    // Ensure main repo is back on main branch after merge phase\n    let _ = chant::git::ensure_on_main_branch(\u0026config.defaults.main_branch);\n\n    Ok(())\n}\n\n// ============================================================================\n// WORKTREE CLEANUP\n// ============================================================================\n\n/// Clean up worktrees for successfully completed specs\nfn cleanup_successful_worktrees(results: \u0026[ParallelResult]) {\n    let mut cleaned_count = 0;\n    let mut failed_cleanup = Vec::new();\n\n    for result in results {\n        // Only cleanup worktrees for successful specs that aren't direct mode merge-pending\n        if result.success \u0026\u0026 result.agent_completed {\n            if let Some(ref path) = result.worktree_path {\n                if path.exists() {\n                    match worktree::remove_worktree(path) {\n                        Ok(()) =\u003e {\n                            cleaned_count += 1;\n                            eprintln!(\n                                \"{} [{}] Cleaned up worktree: {}\",\n                                \"â\".green(),\n                                result.spec_id,\n                                path.display()\n                            );\n                        }\n                        Err(e) =\u003e {\n                            failed_cleanup.push((result.spec_id.clone(), e.to_string()));\n                            eprintln!(\n                                \"{} [{}] Failed to cleanup worktree: {}\",\n                                \"â \".yellow(),\n                                result.spec_id,\n                                e\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if cleaned_count \u003e 0 {\n        eprintln!(\n            \"{} Cleaned up {} worktree{}\",\n            \"â\".green(),\n            cleaned_count,\n            if cleaned_count == 1 { \"\" } else { \"s\" }\n        );\n    }\n\n    if !failed_cleanup.is_empty() {\n        eprintln!(\n            \"\\n{} Failed to cleanup {} worktree{}:\",\n            \"â \".yellow(),\n            failed_cleanup.len(),\n            if failed_cleanup.len() == 1 { \"\" } else { \"s\" }\n        );\n        for (spec_id, error) in failed_cleanup {\n            eprintln!(\"  {} [{}]: {}\", \"â\".yellow(), spec_id, error);\n        }\n        eprintln!(\n            \"\\nRun {} to manually cleanup orphan worktrees.\",\n            \"chant cleanup --worktrees\".bold()\n        );\n    }\n}\n\n// ============================================================================\n// PARALLEL PITFALL DETECTION\n// ============================================================================\n\n/// Detect pitfalls from parallel execution results\nfn detect_parallel_pitfalls(results: \u0026[ParallelResult], specs_dir: \u0026Path) -\u003e Vec\u003cPitfall\u003e {\n    let mut pitfalls = Vec::new();\n\n    // Check for failures\n    for result in results {\n        if !result.success {\n            let error_msg = result.error.as_deref().unwrap_or(\"Unknown error\");\n\n            // Check for API concurrency errors\n            if error_msg.contains(\"429\")\n                || error_msg.contains(\"concurrency\")\n                || error_msg.contains(\"rate limit\")\n            {\n                pitfalls.push(Pitfall {\n                    spec_id: Some(result.spec_id.clone()),\n                    message: format!(\"API concurrency error (retryable): {}\", error_msg),\n                    severity: PitfallSeverity::High,\n                    pitfall_type: PitfallType::ApiConcurrencyError,\n                });\n            } else {\n                pitfalls.push(Pitfall {\n                    spec_id: Some(result.spec_id.clone()),\n                    message: format!(\"Agent error: {}\", error_msg),\n                    severity: PitfallSeverity::High,\n                    pitfall_type: PitfallType::AgentError,\n                });\n            }\n        }\n\n        // Check for worktrees that weren't cleaned up\n        if let Some(ref path) = result.worktree_path {\n            if path.exists() {\n                pitfalls.push(Pitfall {\n                    spec_id: Some(result.spec_id.clone()),\n                    message: format!(\"Worktree not cleaned up: {}\", path.display()),\n                    severity: PitfallSeverity::Low,\n                    pitfall_type: PitfallType::StaleWorktree,\n                });\n            }\n        }\n    }\n\n    // Check for merge conflict indicators in specs\n    if let Ok(all_specs) = spec::load_all_specs(specs_dir) {\n        for spec in \u0026all_specs {\n            if spec.frontmatter.status == SpecStatus::NeedsAttention {\n                // Check if it's a conflict resolution spec\n                let title_lower = spec\n                    .title\n                    .as_ref()\n                    .map(|t| t.to_lowercase())\n                    .unwrap_or_default();\n                if title_lower.contains(\"conflict\") || title_lower.contains(\"merge\") {\n                    pitfalls.push(Pitfall {\n                        spec_id: Some(spec.id.clone()),\n                        message: \"Merge conflict requires resolution\".to_string(),\n                        severity: PitfallSeverity::High,\n                        pitfall_type: PitfallType::MergeConflict,\n                    });\n                }\n            }\n        }\n    }\n\n    // Check for partial failure (some succeeded, some failed)\n    let succeeded = results.iter().filter(|r| r.success).count();\n    let failed_count = results.iter().filter(|r| !r.success).count();\n    if succeeded \u003e 0 \u0026\u0026 failed_count \u003e 0 {\n        pitfalls.push(Pitfall {\n            spec_id: None,\n            message: format!(\n                \"Partial failure: {} succeeded, {} failed\",\n                succeeded, failed_count\n            ),\n            severity: PitfallSeverity::Medium,\n            pitfall_type: PitfallType::PartialFailure,\n        });\n    }\n\n    pitfalls\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1146,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1161,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1184,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1188,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1212,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1232,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1305,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1341,"address":[],"length":0,"stats":{"Line":0}},{"line":1342,"address":[],"length":0,"stats":{"Line":0}},{"line":1343,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":639},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","work","single.rs"],"content":"//! Single-spec execution for the work command\n//!\n//! Handles the execution of individual specs with features including:\n//! - Approval requirement checking\n//! - Re-finalization mode support\n//! - Quality score assessment\n//! - Agent invocation and output validation\n//! - Auto-finalization with acceptance criteria verification\n\nuse anyhow::{Context, Result};\nuse atty;\nuse colored::Colorize;\nuse std::path::{Path, PathBuf};\n\nuse chant::config::Config;\nuse chant::paths::PROMPTS_DIR;\nuse chant::prompt;\nuse chant::spec::{self, BlockingDependency, Spec, SpecStatus};\nuse chant::validation;\nuse chant::worktree;\n\nuse crate::cmd;\nuse crate::cmd::finalize::{\n    append_agent_output, confirm_re_finalize, finalize_spec, re_finalize_spec,\n};\nuse crate::cmd::git_ops::commit_transcript;\nuse crate::cmd::spec as spec_cmd;\n\n/// Print detailed error message for blocked spec dependencies.\n///\n/// Shows each blocking dependency with status indicator, title, and status details.\n/// Includes actionable next steps and warnings for potentially stale blocked status.\nfn print_blocking_dependencies_error(spec_id: \u0026str, blockers: \u0026[BlockingDependency]) {\n    eprintln!(\n        \"\\n{} Spec {} is blocked by dependencies\\n\",\n        \"Error:\".red().bold(),\n        spec_id.cyan()\n    );\n    eprintln!(\"Blocking dependencies:\");\n\n    for blocker in blockers {\n        // Status indicator\n        let status_indicator = match blocker.status {\n            SpecStatus::Completed =\u003e \"â\".green(),\n            SpecStatus::InProgress =\u003e \"â\".yellow(),\n            SpecStatus::Failed =\u003e \"â\".red(),\n            SpecStatus::Blocked =\u003e \"â\".magenta(),\n            _ =\u003e \"â\".white(),\n        };\n\n        // Title display\n        let title_display = blocker.title.as_deref().unwrap_or(\"\");\n        let sibling_marker = if blocker.is_sibling { \" (sibling)\" } else { \"\" };\n\n        eprintln!(\n            \"  {} {} {}{}\",\n            status_indicator,\n            blocker.spec_id.cyan(),\n            title_display,\n            sibling_marker.dimmed()\n        );\n        eprintln!(\n            \"    Status: {}\",\n            format!(\"{:?}\", blocker.status).to_lowercase()\n        );\n\n        // Show completed_at if available and warn about potential stale blocking\n        if let Some(ref completed_at) = blocker.completed_at {\n            eprintln!(\"    Completed at: {}\", completed_at);\n            if blocker.status == SpecStatus::Completed {\n                eprintln!(\n                    \"    {} This dependency is complete but spec still shows as blocked - this may be a bug\",\n                    \"â ï¸\".yellow()\n                );\n            }\n        }\n    }\n\n    eprintln!(\"\\nNext steps:\");\n    eprintln!(\n        \"  1. Run '{}' to update dependency status\",\n        \"chant refresh\".cyan()\n    );\n    eprintln!(\n        \"  2. Use '{}' to override dependency checks\",\n        format!(\"chant work {} --skip-deps\", spec_id).cyan()\n    );\n    eprintln!(\n        \"  3. Check dependency details with '{}'\",\n        \"chant show \u003cdep-id\u003e\".cyan()\n    );\n\n    // Check if any dependencies are marked complete but still blocking\n    let has_complete_blockers = blockers.iter().any(|b| b.status == SpecStatus::Completed);\n    if has_complete_blockers {\n        eprintln!(\n            \"\\n{} If the dependency is truly complete, this is likely a dependency resolution bug\",\n            \"Tip:\".yellow().bold()\n        );\n    }\n    eprintln!();\n}\n\n/// Format a grade enum for display with color coding\nfn format_grade\u003cT: std::fmt::Display\u003e(grade: \u0026T) -\u003e colored::ColoredString {\n    let grade_str = format!(\"{}\", grade);\n    match grade_str.as_str() {\n        \"A\" =\u003e grade_str.green(),\n        \"B\" =\u003e grade_str.green(),\n        \"C\" =\u003e grade_str.yellow(),\n        \"D\" =\u003e grade_str.red(),\n        _ =\u003e grade_str.white(),\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn cmd_work(\n    ids: \u0026[String],\n    prompt_name: Option\u003c\u0026str\u003e,\n    no_branch: bool,\n    skip_deps: bool,\n    skip_criteria: bool,\n    parallel: bool,\n    labels: \u0026[String],\n    finalize: bool,\n    allow_no_commits: bool,\n    max_parallel: Option\u003cusize\u003e,\n    no_cleanup: bool,\n    force_cleanup: bool,\n    skip_approval: bool,\n    chain: bool,\n    chain_max: usize,\n    no_merge: bool,\n    no_rebase: bool,\n) -\u003e Result\u003c()\u003e {\n    let specs_dir = crate::cmd::ensure_initialized()?;\n    let prompts_dir = PathBuf::from(PROMPTS_DIR);\n    let config = Config::load()?;\n\n    // Handle parallel execution mode (with specific IDs or all ready specs)\n    if parallel {\n        let options = super::ParallelOptions {\n            max_override: max_parallel,\n            no_cleanup,\n            force_cleanup,\n            labels,\n            branch_prefix: None,\n            prompt_name,\n            specific_ids: ids,\n            no_merge,\n            no_rebase,\n        };\n        return super::cmd_work_parallel(\u0026specs_dir, \u0026prompts_dir, \u0026config, options);\n    }\n\n    // Handle chain mode: loop through ready specs until none remain or failure\n    if chain {\n        let chain_options = super::ChainOptions {\n            max_specs: chain_max,\n            labels,\n            prompt_name,\n            cli_branch: None,\n            skip_deps,\n            skip_criteria,\n            allow_no_commits,\n            skip_approval,\n            specific_ids: ids,\n        };\n        return super::cmd_work_chain(\u0026specs_dir, \u0026prompts_dir, \u0026config, chain_options);\n    }\n\n    // Reject multiple IDs without --chain or --parallel\n    if ids.len() \u003e 1 {\n        anyhow::bail!(\n            \"Multiple spec IDs provided without --chain or --parallel.\\n\\\n             Use --chain to execute specs sequentially: chant work --chain {} {}\\n\\\n             Use --parallel to execute specs concurrently: chant work --parallel {} {}\",\n            ids[0],\n            ids[1],\n            ids[0],\n            ids[1]\n        );\n    }\n\n    // If no ID and not parallel, check for TTY\n    let (final_id, final_prompt, _final_branch) = if ids.is_empty() {\n        // If not a TTY, print usage hint instead of launching wizard\n        if !atty::is(atty::Stream::Stdin) {\n            print_work_usage_hint();\n            return Ok(());\n        }\n        match super::run_wizard(\u0026specs_dir, \u0026prompts_dir)? {\n            Some(super::WizardSelection::SingleSpec {\n                spec_id,\n                prompt,\n                create_branch,\n            }) =\u003e (spec_id, Some(prompt), create_branch),\n            Some(super::WizardSelection::Parallel) =\u003e {\n                // User selected parallel mode via wizard\n                let options = super::ParallelOptions {\n                    max_override: max_parallel,\n                    no_cleanup,\n                    force_cleanup,\n                    labels,\n                    branch_prefix: None,\n                    prompt_name,\n                    specific_ids: \u0026[],\n                    no_merge,\n                    no_rebase,\n                };\n                return super::cmd_work_parallel(\u0026specs_dir, \u0026prompts_dir, \u0026config, options);\n            }\n            None =\u003e return Ok(()),\n        }\n    } else {\n        (ids[0].clone(), None, false)\n    };\n\n    let id = \u0026final_id;\n\n    // Resolve spec\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n\n    // Reject cancelled specs\n    if spec.frontmatter.status == SpecStatus::Cancelled {\n        anyhow::bail!(\n            \"Cannot work on cancelled spec '{}'. Cancelled specs are not eligible for execution.\",\n            spec.id\n        );\n    }\n\n    // Check approval requirements\n    if spec.requires_approval() \u0026\u0026 !skip_approval {\n        let approval = spec.frontmatter.approval.as_ref().unwrap();\n        if approval.status == spec::ApprovalStatus::Rejected {\n            let by_info = approval\n                .by\n                .as_ref()\n                .map(|b| format!(\" by {}\", b))\n                .unwrap_or_default();\n            anyhow::bail!(\n                \"Cannot work on spec '{}' - it has been rejected{}. \\\n                 Address the feedback and get approval first.\",\n                spec.id,\n                by_info\n            );\n        } else {\n            // Status is Pending\n            eprintln!(\n                \"\\n{} Spec {} requires approval before work can begin\\n\",\n                \"Error:\".red().bold(),\n                spec.id.cyan()\n            );\n            eprintln!(\"This spec has 'approval.required: true' but has not been approved yet.\");\n            eprintln!(\"\\nNext steps:\");\n            eprintln!(\n                \"  1. Get approval: {}\",\n                format!(\"chant approve {} --by \u003cname\u003e\", spec.id).cyan()\n            );\n            eprintln!(\n                \"  2. Or bypass with: {}\",\n                format!(\"chant work {} --skip-approval\", spec.id).cyan()\n            );\n            eprintln!();\n            anyhow::bail!(\"Spec requires approval\");\n        }\n    }\n\n    // Handle re-finalization mode\n    if finalize {\n        // Re-finalize flag requires the spec to be in_progress, completed, or failed\n        // Allow failed too - agents often leave specs in failed state when they actually completed the work\n        if spec.frontmatter.status != SpecStatus::InProgress\n            \u0026\u0026 spec.frontmatter.status != SpecStatus::Completed\n            \u0026\u0026 spec.frontmatter.status != SpecStatus::Failed\n        {\n            anyhow::bail!(\n                \"Cannot re-finalize spec '{}' with status '{:?}'. Must be in_progress, completed, or failed.\",\n                spec.id,\n                spec.frontmatter.status\n            );\n        }\n\n        // Ask for confirmation (unless --skip-criteria is used)\n        if !confirm_re_finalize(\u0026spec.id, skip_criteria)? {\n            println!(\"Re-finalization cancelled.\");\n            return Ok(());\n        }\n\n        // Check if this spec has an active worktree - if so, finalize there\n        if let Some(worktree_path) = worktree::get_active_worktree(\u0026spec.id) {\n            println!(\n                \"{} Re-finalizing spec {} in worktree...\",\n                \"â\".cyan(),\n                spec.id\n            );\n\n            // Get the spec path in the worktree\n            let worktree_spec_path = worktree_path\n                .join(\".chant/specs\")\n                .join(format!(\"{}.md\", spec.id));\n\n            // Load the spec from the worktree\n            let mut worktree_spec = spec::Spec::load(\u0026worktree_spec_path)\n                .context(\"Failed to load spec from worktree\")?;\n\n            // Re-finalize in the worktree\n            re_finalize_spec(\n                \u0026mut worktree_spec,\n                \u0026worktree_spec_path,\n                \u0026config,\n                allow_no_commits,\n            )?;\n\n            // Commit the finalization changes in the worktree\n            let commit_message = format!(\"chant({}): finalize spec\", spec.id);\n            worktree::commit_in_worktree(\u0026worktree_path, \u0026commit_message)?;\n\n            println!(\"{} Spec re-finalized in worktree!\", \"â\".green());\n\n            if let Some(commits) = \u0026worktree_spec.frontmatter.commits {\n                for commit in commits {\n                    println!(\"Commit: {}\", commit);\n                }\n            }\n            if let Some(completed_at) = \u0026worktree_spec.frontmatter.completed_at {\n                println!(\"Completed at: {}\", completed_at);\n            }\n            if let Some(model) = \u0026worktree_spec.frontmatter.model {\n                println!(\"Model: {}\", model);\n            }\n            println!(\"Worktree: {}\", worktree_path.display());\n        } else {\n            // No active worktree - finalize on current branch\n            println!(\"{} Re-finalizing spec {}...\", \"â\".cyan(), spec.id);\n            re_finalize_spec(\u0026mut spec, \u0026spec_path, \u0026config, allow_no_commits)?;\n            println!(\"{} Spec re-finalized!\", \"â\".green());\n\n            if let Some(commits) = \u0026spec.frontmatter.commits {\n                for commit in commits {\n                    println!(\"Commit: {}\", commit);\n                }\n            }\n            if let Some(completed_at) = \u0026spec.frontmatter.completed_at {\n                println!(\"Completed at: {}\", completed_at);\n            }\n            if let Some(model) = \u0026spec.frontmatter.model {\n                println!(\"Model: {}\", model);\n            }\n\n            // If this is a member spec, check if driver should be auto-completed\n            let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n            if spec::auto_complete_driver_if_ready(\u0026spec.id, \u0026all_specs, \u0026specs_dir)? {\n                println!(\n                    \"\\n{} Auto-completed driver spec: {}\",\n                    \"â\".green(),\n                    spec::extract_driver_id(\u0026spec.id).unwrap()\n                );\n            }\n        }\n\n        return Ok(());\n    }\n\n    // Check if already completed\n    if spec.frontmatter.status == SpecStatus::Completed \u0026\u0026 !(skip_deps || skip_criteria) {\n        println!(\"{} Spec already completed.\", \"â \".yellow());\n        println!(\n            \"Use {} or {} to bypass.\",\n            \"--skip-deps\".cyan(),\n            \"--skip-criteria\".cyan()\n        );\n        return Ok(());\n    }\n\n    // Check if in progress\n    if spec.frontmatter.status == SpecStatus::InProgress \u0026\u0026 !(skip_deps || skip_criteria) {\n        println!(\"{} Spec already in progress.\", \"â \".yellow());\n        return Ok(());\n    }\n\n    // Check if dependencies are satisfied\n    let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n    if !spec.is_ready(\u0026all_specs) {\n        // Get detailed blocking dependency information\n        let blockers = spec.get_blocking_dependencies(\u0026all_specs, \u0026specs_dir);\n\n        if !blockers.is_empty() {\n            if skip_deps {\n                // Print warning when skipping dependency checks\n                eprintln!(\n                    \"{} Warning: Skipping dependency checks for spec\",\n                    \"â \".yellow()\n                );\n                let blocking_ids: Vec\u003cString\u003e = blockers\n                    .iter()\n                    .map(|b| format!(\"{} ({:?})\", b.spec_id, b.status).to_lowercase())\n                    .collect();\n                eprintln!(\"  Skipping dependencies: {}\", blocking_ids.join(\", \"));\n            } else {\n                // Print detailed error message\n                print_blocking_dependencies_error(\u0026spec.id, \u0026blockers);\n                anyhow::bail!(\"Spec blocked by dependencies\");\n            }\n        }\n    }\n\n    // Calculate quality score before starting work (unless --skip-criteria is used)\n    if !skip_criteria {\n        use chant::score::traffic_light;\n        use chant::scoring::TrafficLight;\n\n        let quality_score = chant::scoring::calculate_spec_score(\u0026spec, \u0026all_specs, \u0026config);\n\n        match quality_score.traffic_light {\n            TrafficLight::Refine =\u003e {\n                // Red status: Show warning and require user confirmation\n                eprintln!(\n                    \"\\n{} Spec {} has quality issues that may cause problems\\n\",\n                    \"Warning:\".red().bold(),\n                    spec.id.cyan()\n                );\n\n                // Show dimension grades\n                eprintln!(\"Quality Assessment:\");\n                eprintln!(\n                    \"  Complexity:    {}\",\n                    format_grade(\u0026quality_score.complexity)\n                );\n                eprintln!(\n                    \"  Confidence:    {}\",\n                    format_grade(\u0026quality_score.confidence)\n                );\n                eprintln!(\n                    \"  Splittability: {}\",\n                    format_grade(\u0026quality_score.splittability)\n                );\n                eprintln!(\n                    \"  AC Quality:    {}\",\n                    format_grade(\u0026quality_score.ac_quality)\n                );\n                if let Some(iso) = quality_score.isolation {\n                    eprintln!(\"  Isolation:     {}\", format_grade(\u0026iso));\n                }\n\n                // Show suggestions\n                let suggestions = traffic_light::generate_suggestions(\u0026quality_score);\n                if !suggestions.is_empty() {\n                    eprintln!(\"\\nSuggestions:\");\n                    for suggestion in \u0026suggestions {\n                        eprintln!(\"  â¢ {}\", suggestion);\n                    }\n                }\n\n                // Show detailed guidance\n                let guidance = traffic_light::generate_detailed_guidance(\u0026quality_score);\n                if !guidance.is_empty() {\n                    eprint!(\"{}\", guidance);\n                }\n\n                eprintln!();\n\n                // Prompt user for confirmation (unless non-interactive)\n                if atty::is(atty::Stream::Stdin) {\n                    use std::io::{self, Write};\n\n                    print!(\"Continue anyway? [y/N] \");\n                    io::stdout().flush()?;\n\n                    let mut input = String::new();\n                    io::stdin().read_line(\u0026mut input)?;\n                    let input = input.trim().to_lowercase();\n\n                    if input != \"y\" \u0026\u0026 input != \"yes\" {\n                        println!(\"Work cancelled.\");\n                        return Ok(());\n                    }\n                } else {\n                    // Non-interactive mode: abort (user should use --skip-criteria to bypass)\n                    eprintln!(\n                        \"\\n{} Cannot proceed in non-interactive mode with quality issues.\",\n                        \"Error:\".red().bold()\n                    );\n                    eprintln!(\"Use {} to bypass quality checks.\", \"--skip-criteria\".cyan());\n                    anyhow::bail!(\"Spec quality check failed\");\n                }\n            }\n            TrafficLight::Review =\u003e {\n                // Yellow status: Show info message but proceed automatically\n                println!(\n                    \"{} Spec quality: {} - Some dimensions need attention\",\n                    \"â¹\".yellow(),\n                    \"Review\".yellow()\n                );\n\n                // Show which dimensions are at C level\n                let mut review_dims = Vec::new();\n                if matches!(quality_score.complexity, chant::scoring::ComplexityGrade::C) {\n                    review_dims.push(format!(\n                        \"Complexity: {}\",\n                        format_grade(\u0026quality_score.complexity)\n                    ));\n                }\n                if matches!(quality_score.confidence, chant::scoring::ConfidenceGrade::C) {\n                    review_dims.push(format!(\n                        \"Confidence: {}\",\n                        format_grade(\u0026quality_score.confidence)\n                    ));\n                }\n                if matches!(quality_score.ac_quality, chant::scoring::ACQualityGrade::C) {\n                    review_dims.push(format!(\n                        \"AC Quality: {}\",\n                        format_grade(\u0026quality_score.ac_quality)\n                    ));\n                }\n                if matches!(\n                    quality_score.splittability,\n                    chant::scoring::SplittabilityGrade::C\n                ) {\n                    review_dims.push(format!(\n                        \"Splittability: {}\",\n                        format_grade(\u0026quality_score.splittability)\n                    ));\n                }\n\n                if !review_dims.is_empty() {\n                    for dim in review_dims {\n                        println!(\"  â¢ {}\", dim);\n                    }\n                }\n                println!();\n            }\n            TrafficLight::Ready =\u003e {\n                // Green status: Proceed silently (no message)\n            }\n        }\n    }\n\n    // Worktree mode is now the default unless --no-branch is specified\n    let use_worktree = !no_branch;\n\n    // Handle worktree creation if enabled\n    let _worktree_path = if use_worktree {\n        // Create worktree for this spec\n        let branch_name = format!(\"chant/{}\", spec.id);\n        let worktree_path = worktree::create_worktree(\u0026spec.id, \u0026branch_name)?;\n        worktree::copy_spec_to_worktree(\u0026spec.id, \u0026worktree_path)?;\n        spec.frontmatter.branch = Some(branch_name);\n        println!(\"{} Worktree: {}\", \"â\".cyan(), worktree_path.display());\n        Some(worktree_path)\n    } else {\n        None\n    };\n\n    // Resolve prompt: CLI \u003e wizard \u003e frontmatter \u003e auto-select by type \u003e default\n    let resolved_prompt_name = prompt_name\n        .map(std::string::ToString::to_string)\n        .or(final_prompt)\n        .or_else(|| spec.frontmatter.prompt.clone())\n        .or_else(|| auto_select_prompt_for_type(\u0026spec, \u0026prompts_dir))\n        .unwrap_or_else(|| config.defaults.prompt.clone());\n\n    let prompt_path = prompts_dir.join(format!(\"{}.md\", resolved_prompt_name));\n    if !prompt_path.exists() {\n        anyhow::bail!(\"Prompt not found: {}\", resolved_prompt_name);\n    }\n    let prompt_name = resolved_prompt_name.as_str();\n\n    // Update status to in_progress\n    spec.frontmatter.status = SpecStatus::InProgress;\n    spec.save(\u0026spec_path)?;\n\n    // If this is a member spec, mark the driver spec as in_progress if it's pending\n    spec::mark_driver_in_progress(\u0026specs_dir, \u0026spec.id)?;\n\n    println!(\n        \"{} {} with prompt '{}'\",\n        \"Working\".cyan(),\n        spec.id,\n        prompt_name\n    );\n\n    // Assemble prompt\n    let message = prompt::assemble(\u0026spec, \u0026prompt_path, \u0026config)?;\n\n    // Select agent for single spec execution based on rotation strategy\n    let agent_command =\n        if config.defaults.rotation_strategy != \"none\" \u0026\u0026 !config.parallel.agents.is_empty() {\n            // Use rotation to select an agent\n            match cmd::agent_rotation::select_agent_for_work(\n                \u0026config.defaults.rotation_strategy,\n                \u0026config.parallel,\n            ) {\n                Ok(cmd) =\u003e Some(cmd),\n                Err(e) =\u003e {\n                    println!(\"{} Failed to select agent: {}\", \"â \".yellow(), e);\n                    None\n                }\n            }\n        } else {\n            None\n        };\n\n    // Invoke agent\n    let result = if let Some(agent_cmd) = agent_command {\n        cmd::agent::invoke_agent_with_command_override(\n            \u0026message,\n            \u0026spec,\n            prompt_name,\n            \u0026config,\n            Some(\u0026agent_cmd),\n        )\n    } else {\n        cmd::agent::invoke_agent(\u0026message, \u0026spec, prompt_name, \u0026config)\n    };\n\n    match result {\n        Ok(agent_output) =\u003e {\n            // Reload spec (it may have been modified by the agent)\n            let mut spec = spec::resolve_spec(\u0026specs_dir, \u0026spec.id)?;\n\n            // Auto-finalize logic after agent exits:\n            // 1. Check if agent made a commit (indicates work was done)\n            // 2. Run lint checks on the spec\n            // 3. If all criteria checked, auto-finalize\n            // 4. If criteria unchecked, fail with clear message\n\n            // Check for commits and store them for finalization\n            let found_commits = match if allow_no_commits {\n                cmd::commits::get_commits_for_spec_allow_no_commits(\u0026spec.id)\n            } else {\n                cmd::commits::get_commits_for_spec(\u0026spec.id)\n            } {\n                Ok(commits) =\u003e {\n                    if commits.is_empty() {\n                        println!(\n                            \"\\n{} No commits found - agent did not make any changes.\",\n                            \"â \".yellow()\n                        );\n                        // Mark as failed since no work was done\n                        spec.frontmatter.status = SpecStatus::Failed;\n                        spec.save(\u0026spec_path)?;\n                        anyhow::bail!(\"Cannot complete spec without commits - did the agent make any changes?\");\n                    }\n                    commits\n                }\n                Err(e) =\u003e {\n                    if allow_no_commits {\n                        println!(\n                            \"\\n{} No matching commits found, using HEAD as fallback.\",\n                            \"â\".cyan()\n                        );\n                        // Will use HEAD fallback in finalize\n                        vec![]\n                    } else {\n                        println!(\"\\n{} {}\", \"â \".yellow(), e);\n                        // Mark as failed since we need commits\n                        spec.frontmatter.status = SpecStatus::Failed;\n                        spec.save(\u0026spec_path)?;\n                        return Err(e);\n                    }\n                }\n            };\n\n            // Run lint on the spec to check acceptance criteria and get warnings\n            let lint_result = spec_cmd::lint_specific_specs(\u0026specs_dir, \u0026[spec.id.clone()])?;\n\n            // Check if all acceptance criteria are checked\n            let unchecked_count = spec.count_unchecked_checkboxes();\n            if unchecked_count \u003e 0 {\n                println!(\n                    \"\\n{} Found {} unchecked acceptance {}.\",\n                    \"â \".yellow(),\n                    unchecked_count,\n                    if unchecked_count == 1 {\n                        \"criterion\"\n                    } else {\n                        \"criteria\"\n                    }\n                );\n\n                // Show which criteria are unchecked\n                println!(\"Please check off all acceptance criteria before completing.\");\n                println!(\"Use {} to skip this validation.\", \"--skip-criteria\".cyan());\n\n                // Mark as failed since we can't complete with unchecked items\n                spec.frontmatter.status = SpecStatus::Failed;\n                spec.save(\u0026spec_path)?;\n                anyhow::bail!(\n                    \"Cannot auto-finalize spec with {} unchecked acceptance criteria\",\n                    unchecked_count\n                );\n            }\n\n            // Show lint warnings if any (but allow finalization if criteria are checked)\n            if lint_result.warned \u003e 0 {\n                println!(\n                    \"\\n{} Lint check found {} warning(s), but criteria are all checked - proceeding with finalization.\",\n                    \"â\".cyan(),\n                    lint_result.warned\n                );\n            }\n\n            // Validate output against schema if output_schema is defined\n            if let Some(ref schema_path_str) = spec.frontmatter.output_schema {\n                let schema_path = Path::new(schema_path_str);\n                if schema_path.exists() {\n                    match validation::validate_agent_output(\u0026spec.id, schema_path, \u0026agent_output) {\n                        Ok(result) =\u003e {\n                            if result.is_valid {\n                                println!(\n                                    \"\\n{} Output validation passed (schema: {})\",\n                                    \"â\".green(),\n                                    schema_path_str\n                                );\n                            } else {\n                                println!(\n                                    \"\\n{} Output validation failed (schema: {})\",\n                                    \"â\".red(),\n                                    schema_path_str\n                                );\n                                for error in \u0026result.errors {\n                                    println!(\"  - {}\", error);\n                                }\n                                println!(\"  â Review .chant/logs/{}.log for details\", spec.id);\n\n                                // Check if strict validation is enabled\n                                if config.validation.strict_output_validation {\n                                    spec.frontmatter.status = SpecStatus::NeedsAttention;\n                                    spec.save(\u0026spec_path)?;\n                                    anyhow::bail!(\n                                        \"Output validation failed: {} error(s)\",\n                                        result.errors.len()\n                                    );\n                                } else {\n                                    println!(\n                                        \"  {} Proceeding anyway (strict_output_validation=false)\",\n                                        \"â\".cyan()\n                                    );\n                                }\n                            }\n                        }\n                        Err(e) =\u003e {\n                            println!(\"\\n{} Failed to validate output: {}\", \"â \".yellow(), e);\n                            if config.validation.strict_output_validation {\n                                spec.frontmatter.status = SpecStatus::NeedsAttention;\n                                spec.save(\u0026spec_path)?;\n                                return Err(e);\n                            }\n                        }\n                    }\n                } else {\n                    println!(\n                        \"\\n{} Output schema file not found: {}\",\n                        \"â \".yellow(),\n                        schema_path_str\n                    );\n                }\n            }\n\n            // All criteria are checked, auto-finalize the spec\n            println!(\n                \"\\n{} Auto-finalizing spec (all acceptance criteria checked)...\",\n                \"â\".cyan()\n            );\n            let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n            // Pass the commits we already retrieved to avoid fetching twice\n            let commits_to_pass = if found_commits.is_empty() {\n                None // Let finalize fetch with fallback\n            } else {\n                Some(found_commits)\n            };\n            finalize_spec(\n                \u0026mut spec,\n                \u0026spec_path,\n                \u0026config,\n                \u0026all_specs,\n                allow_no_commits,\n                commits_to_pass,\n            )?;\n\n            // If this is a member spec, check if driver should be auto-completed\n            // Reload specs to get the freshly-saved completed status\n            let all_specs = spec::load_all_specs(\u0026specs_dir)?;\n            if spec::auto_complete_driver_if_ready(\u0026spec.id, \u0026all_specs, \u0026specs_dir)? {\n                println!(\n                    \"\\n{} Auto-completed driver spec: {}\",\n                    \"â\".green(),\n                    spec::extract_driver_id(\u0026spec.id).unwrap()\n                );\n            }\n\n            println!(\"\\n{} Spec completed!\", \"â\".green());\n            if let Some(commits) = \u0026spec.frontmatter.commits {\n                for commit in commits {\n                    println!(\"Commit: {}\", commit);\n                }\n            }\n            if let Some(model) = \u0026spec.frontmatter.model {\n                println!(\"Model: {}\", model);\n            }\n\n            // Append agent output to spec body (after finalization so finalized spec is the base)\n            append_agent_output(\u0026mut spec, \u0026agent_output);\n\n            spec.save(\u0026spec_path)?;\n\n            // Create a follow-up commit for the transcript\n            commit_transcript(\u0026spec.id, \u0026spec_path)?;\n        }\n        Err(e) =\u003e {\n            // Update spec to failed\n            let mut spec = spec::resolve_spec(\u0026specs_dir, \u0026spec.id)?;\n            spec.frontmatter.status = SpecStatus::Failed;\n            spec.save(\u0026spec_path)?;\n\n            println!(\"\\n{} Spec failed: {}\", \"â\".red(), e);\n            return Err(e);\n        }\n    }\n\n    // Ensure main repo is back on main branch\n    let _ = chant::git::ensure_on_main_branch(\u0026config.defaults.main_branch);\n\n    Ok(())\n}\n\n/// Print usage hint for work command in non-TTY contexts\nfn print_work_usage_hint() {\n    println!(\"Usage: chant work \u003cSPEC_ID\u003e\\n\");\n    println!(\"Examples:\");\n    println!(\"  chant work 2026-01-27-001-abc\");\n    println!(\"  chant work 001-abc\");\n    println!(\"  chant work --parallel\\n\");\n    println!(\"Run 'chant work --help' for all options.\");\n}\n\n/// Auto-select a prompt based on spec type if the prompt file exists.\n/// Returns None if no auto-selected prompt is appropriate or available.\nfn auto_select_prompt_for_type(spec: \u0026Spec, prompts_dir: \u0026Path) -\u003e Option\u003cString\u003e {\n    let auto_prompt = match spec.frontmatter.r#type.as_str() {\n        \"documentation\" =\u003e Some(\"documentation\"),\n        _ =\u003e None,\n    };\n\n    // Check if the auto-selected prompt actually exists\n    if let Some(prompt_name) = auto_prompt {\n        let prompt_path = prompts_dir.join(format!(\"{}.md\", prompt_name));\n        if prompt_path.exists() {\n            return Some(prompt_name.to_string());\n        }\n    }\n\n    None\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":16}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":9}},{"line":109,"address":[],"length":0,"stats":{"Line":7}},{"line":110,"address":[],"length":0,"stats":{"Line":12}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":11}},{"line":136,"address":[],"length":0,"stats":{"Line":22}},{"line":137,"address":[],"length":0,"stats":{"Line":22}},{"line":138,"address":[],"length":0,"stats":{"Line":22}},{"line":141,"address":[],"length":0,"stats":{"Line":11}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":11}},{"line":169,"address":[],"length":0,"stats":{"Line":25}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":30}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":219,"address":[],"length":0,"stats":{"Line":12}},{"line":222,"address":[],"length":0,"stats":{"Line":24}},{"line":223,"address":[],"length":0,"stats":{"Line":18}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":5}},{"line":338,"address":[],"length":0,"stats":{"Line":3}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":3}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":5}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":5}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":5}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":15}},{"line":385,"address":[],"length":0,"stats":{"Line":10}},{"line":387,"address":[],"length":0,"stats":{"Line":20}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":390,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":4}},{"line":396,"address":[],"length":0,"stats":{"Line":6}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":400,"address":[],"length":0,"stats":{"Line":6}},{"line":403,"address":[],"length":0,"stats":{"Line":6}},{"line":404,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":3}},{"line":414,"address":[],"length":0,"stats":{"Line":15}},{"line":416,"address":[],"length":0,"stats":{"Line":3}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":421,"address":[],"length":0,"stats":{"Line":3}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":433,"address":[],"length":0,"stats":{"Line":2}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":3}},{"line":449,"address":[],"length":0,"stats":{"Line":1}},{"line":450,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":7}},{"line":452,"address":[],"length":0,"stats":{"Line":3}},{"line":457,"address":[],"length":0,"stats":{"Line":3}},{"line":458,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":462,"address":[],"length":0,"stats":{"Line":1}},{"line":465,"address":[],"length":0,"stats":{"Line":2}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":1}},{"line":483,"address":[],"length":0,"stats":{"Line":3}},{"line":485,"address":[],"length":0,"stats":{"Line":3}},{"line":486,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":493,"address":[],"length":0,"stats":{"Line":4}},{"line":494,"address":[],"length":0,"stats":{"Line":4}},{"line":498,"address":[],"length":0,"stats":{"Line":4}},{"line":499,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":4}},{"line":506,"address":[],"length":0,"stats":{"Line":8}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":508,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":4}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":2}},{"line":521,"address":[],"length":0,"stats":{"Line":8}},{"line":522,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":2}},{"line":527,"address":[],"length":0,"stats":{"Line":2}},{"line":528,"address":[],"length":0,"stats":{"Line":10}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":4}},{"line":544,"address":[],"length":0,"stats":{"Line":4}},{"line":546,"address":[],"length":0,"stats":{"Line":4}},{"line":547,"address":[],"length":0,"stats":{"Line":8}},{"line":548,"address":[],"length":0,"stats":{"Line":6}},{"line":549,"address":[],"length":0,"stats":{"Line":4}},{"line":550,"address":[],"length":0,"stats":{"Line":8}},{"line":551,"address":[],"length":0,"stats":{"Line":2}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":4}},{"line":560,"address":[],"length":0,"stats":{"Line":6}},{"line":561,"address":[],"length":0,"stats":{"Line":8}},{"line":562,"address":[],"length":0,"stats":{"Line":6}},{"line":564,"address":[],"length":0,"stats":{"Line":6}},{"line":565,"address":[],"length":0,"stats":{"Line":2}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":6}},{"line":571,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":6}},{"line":575,"address":[],"length":0,"stats":{"Line":6}},{"line":577,"address":[],"length":0,"stats":{"Line":2}},{"line":579,"address":[],"length":0,"stats":{"Line":4}},{"line":585,"address":[],"length":0,"stats":{"Line":10}},{"line":588,"address":[],"length":0,"stats":{"Line":2}},{"line":589,"address":[],"length":0,"stats":{"Line":2}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":606,"address":[],"length":0,"stats":{"Line":4}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":10}},{"line":618,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":2}},{"line":621,"address":[],"length":0,"stats":{"Line":8}},{"line":630,"address":[],"length":0,"stats":{"Line":2}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":4}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":2}},{"line":649,"address":[],"length":0,"stats":{"Line":2}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":6}},{"line":659,"address":[],"length":0,"stats":{"Line":2}},{"line":660,"address":[],"length":0,"stats":{"Line":6}},{"line":661,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":2}},{"line":842,"address":[],"length":0,"stats":{"Line":4}},{"line":843,"address":[],"length":0,"stats":{"Line":2}},{"line":844,"address":[],"length":0,"stats":{"Line":2}},{"line":848,"address":[],"length":0,"stats":{"Line":2}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":2}}],"covered":175,"coverable":395},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","work","wizard.rs"],"content":"//! Interactive wizard for selecting specs and prompts\n\nuse anyhow::Result;\nuse dialoguer::Select;\nuse std::path::Path;\n\nuse chant::spec::Spec;\n\n/// Result of the wizard selection\npub enum WizardSelection {\n    /// Run a single spec\n    SingleSpec {\n        spec_id: String,\n        prompt: String,\n        create_branch: bool,\n    },\n    /// Run all ready specs in parallel\n    Parallel,\n}\n\n/// Run the interactive wizard for selecting a spec\npub fn run_wizard(specs_dir: \u0026Path, prompts_dir: \u0026Path) -\u003e Result\u003cOption\u003cWizardSelection\u003e\u003e {\n    // Load ready specs\n    let ready_specs = super::load_ready_specs(specs_dir)?;\n\n    if ready_specs.is_empty() {\n        println!(\"No ready specs to execute.\");\n        return Ok(None);\n    }\n\n    // Build spec selection items\n    let spec_items: Vec\u003cString\u003e = ready_specs\n        .iter()\n        .map(|s| {\n            if let Some(title) = \u0026s.title {\n                format!(\"{}  {}\", s.id, title)\n            } else {\n                s.id.clone()\n            }\n        })\n        .collect();\n\n    // Add parallel option at the end\n    let mut all_items = spec_items.clone();\n    all_items.push(\"[Run all ready specs in parallel]\".to_string());\n\n    // Show spec selection\n    let selection = Select::new()\n        .with_prompt(\"? Select spec to work\")\n        .items(\u0026all_items)\n        .default(0)\n        .interact()?;\n\n    // Check if parallel mode was selected\n    if selection == all_items.len() - 1 {\n        return Ok(Some(WizardSelection::Parallel));\n    }\n\n    let selected_spec = ready_specs[selection].clone();\n\n    // Show prompt selection\n    let available_prompts = super::list_available_prompts(prompts_dir)?;\n\n    if available_prompts.is_empty() {\n        anyhow::bail!(\"No prompts found in {}\", prompts_dir.display());\n    }\n\n    let prompt_selection = Select::new()\n        .with_prompt(\"? Select prompt\")\n        .items(\u0026available_prompts)\n        .default(0)\n        .interact()?;\n\n    let selected_prompt = available_prompts[prompt_selection].clone();\n\n    // Show branch confirmation\n    let create_branch = dialoguer::Confirm::new()\n        .with_prompt(\"Create feature branch\")\n        .default(false)\n        .interact()?;\n\n    Ok(Some(WizardSelection::SingleSpec {\n        spec_id: selected_spec.id,\n        prompt: selected_prompt,\n        create_branch,\n    }))\n}\n\n/// Auto-select a prompt based on spec type if the prompt file exists.\n/// Returns None if no auto-selected prompt is appropriate or available.\npub fn auto_select_prompt_for_type(spec: \u0026Spec, prompts_dir: \u0026Path) -\u003e Option\u003cString\u003e {\n    let auto_prompt = match spec.frontmatter.r#type.as_str() {\n        \"documentation\" =\u003e Some(\"documentation\"),\n        _ =\u003e None,\n    };\n\n    // Check if the auto-selected prompt actually exists\n    if let Some(prompt_name) = auto_prompt {\n        let prompt_path = prompts_dir.join(format!(\"{}.md\", prompt_name));\n        if prompt_path.exists() {\n            return Some(prompt_name.to_string());\n        }\n    }\n\n    None\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":2}}],"covered":6,"coverable":37},{"path":["/","Users","alex","Documents","checkouts","chant","src","cmd","worktree.rs"],"content":"//! Worktree status command for debugging worktree state.\n//!\n//! Provides a status view of all chant-related git worktrees,\n//! showing their associated specs, branches, and health status.\n\nuse anyhow::Result;\nuse colored::Colorize;\nuse std::path::PathBuf;\nuse std::process::Command;\n\nuse crate::cmd::cleanup::{format_age_secs, format_bytes};\nuse chant::paths::SPECS_DIR;\nuse chant::spec::{Spec, SpecStatus};\n\n/// Information about a git worktree from `git worktree list --porcelain`\n#[derive(Debug, Clone)]\nstruct GitWorktreeEntry {\n    /// Path to the worktree\n    path: PathBuf,\n    /// HEAD commit hash\n    head: String,\n    /// Branch name (without refs/heads/ prefix)\n    branch: Option\u003cString\u003e,\n    /// Whether the worktree is prunable\n    prunable: bool,\n    /// Reason for being prunable\n    prunable_reason: Option\u003cString\u003e,\n}\n\n/// Parse the output of `git worktree list --porcelain`\nfn parse_worktree_list(output: \u0026str) -\u003e Vec\u003cGitWorktreeEntry\u003e {\n    let mut entries = Vec::new();\n    let mut current: Option\u003cGitWorktreeEntry\u003e = None;\n\n    for line in output.lines() {\n        if line.starts_with(\"worktree \") {\n            // Save previous entry if exists\n            if let Some(entry) = current.take() {\n                entries.push(entry);\n            }\n            // Start new entry\n            let path = line.strip_prefix(\"worktree \").unwrap_or(\"\");\n            current = Some(GitWorktreeEntry {\n                path: PathBuf::from(path),\n                head: String::new(),\n                branch: None,\n                prunable: false,\n                prunable_reason: None,\n            });\n        } else if let Some(ref mut entry) = current {\n            if line.starts_with(\"HEAD \") {\n                entry.head = line.strip_prefix(\"HEAD \").unwrap_or(\"\").to_string();\n            } else if line.starts_with(\"branch \") {\n                let branch = line.strip_prefix(\"branch \").unwrap_or(\"\");\n                // Strip refs/heads/ prefix if present\n                let branch = branch.strip_prefix(\"refs/heads/\").unwrap_or(branch);\n                entry.branch = Some(branch.to_string());\n            } else if line.starts_with(\"prunable \") {\n                entry.prunable = true;\n                entry.prunable_reason =\n                    Some(line.strip_prefix(\"prunable \").unwrap_or(\"\").to_string());\n            } else if line == \"prunable\" {\n                entry.prunable = true;\n            }\n        }\n    }\n\n    // Don't forget the last entry\n    if let Some(entry) = current {\n        entries.push(entry);\n    }\n\n    entries\n}\n\n/// Extract spec ID from a worktree path or branch name\nfn extract_spec_id(entry: \u0026GitWorktreeEntry) -\u003e Option\u003cString\u003e {\n    // Try to extract from branch name (chant/SPEC-ID)\n    if let Some(ref branch) = entry.branch {\n        if let Some(spec_id) = branch.strip_prefix(\"chant/\") {\n            return Some(spec_id.to_string());\n        }\n    }\n\n    // Try to extract from path (/tmp/chant-SPEC-ID)\n    if let Some(dir_name) = entry.path.file_name() {\n        let name = dir_name.to_string_lossy();\n        if let Some(spec_id) = name.strip_prefix(\"chant-\") {\n            return Some(spec_id.to_string());\n        }\n    }\n\n    None\n}\n\n/// Information about a spec's current state\n#[derive(Debug)]\nstruct SpecInfo {\n    title: String,\n    status: SpecStatus,\n}\n\n/// Look up spec information from the specs directory\nfn lookup_spec(spec_id: \u0026str) -\u003e Option\u003cSpecInfo\u003e {\n    let specs_dir = PathBuf::from(SPECS_DIR);\n    if !specs_dir.exists() {\n        return None;\n    }\n\n    // Try to find the spec file\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    if !spec_path.exists() {\n        // Check archive\n        let archive_path = specs_dir\n            .parent()?\n            .join(\"archive\")\n            .join(format!(\"{}.md\", spec_id));\n        if archive_path.exists() {\n            if let Ok(spec) = Spec::load(\u0026archive_path) {\n                return Some(SpecInfo {\n                    title: spec.title.unwrap_or_else(|| \"(untitled)\".to_string()),\n                    status: spec.frontmatter.status,\n                });\n            }\n        }\n        return None;\n    }\n\n    if let Ok(spec) = Spec::load(\u0026spec_path) {\n        Some(SpecInfo {\n            title: spec.title.unwrap_or_else(|| \"(untitled)\".to_string()),\n            status: spec.frontmatter.status,\n        })\n    } else {\n        None\n    }\n}\n\n/// Get size of a directory recursively\nfn dir_size(path: \u0026PathBuf) -\u003e u64 {\n    if !path.exists() {\n        return 0;\n    }\n\n    match std::fs::metadata(path) {\n        Ok(metadata) if metadata.is_file() =\u003e metadata.len(),\n        Ok(metadata) if metadata.is_dir() =\u003e std::fs::read_dir(path)\n            .into_iter()\n            .flatten()\n            .filter_map(|entry| entry.ok())\n            .map(|entry| dir_size(\u0026entry.path()))\n            .sum(),\n        _ =\u003e 0,\n    }\n}\n\n/// Get age of a path in seconds\nfn path_age_secs(path: \u0026PathBuf) -\u003e u64 {\n    match std::fs::metadata(path) {\n        Ok(metadata) =\u003e match metadata.modified() {\n            Ok(modified_time) =\u003e match std::time::SystemTime::now().duration_since(modified_time) {\n                Ok(duration) =\u003e duration.as_secs(),\n                Err(_) =\u003e 0,\n            },\n            Err(_) =\u003e 0,\n        },\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Format spec status with color\nfn format_status(status: \u0026SpecStatus) -\u003e String {\n    match status {\n        SpecStatus::Pending =\u003e \"pending\".dimmed().to_string(),\n        SpecStatus::Ready =\u003e \"ready\".cyan().to_string(),\n        SpecStatus::InProgress =\u003e \"in_progress\".yellow().to_string(),\n        SpecStatus::Paused =\u003e \"paused\".cyan().to_string(),\n        SpecStatus::Completed =\u003e \"completed\".green().to_string(),\n        SpecStatus::Failed =\u003e \"failed\".red().to_string(),\n        SpecStatus::NeedsAttention =\u003e \"needs_attention\".red().bold().to_string(),\n        SpecStatus::Blocked =\u003e \"blocked\".magenta().to_string(),\n        SpecStatus::Cancelled =\u003e \"cancelled\".dimmed().to_string(),\n    }\n}\n\n/// Execute the worktree status command\npub fn cmd_worktree_status() -\u003e Result\u003c()\u003e {\n    // Get worktree list from git\n    let output = Command::new(\"git\")\n        .args([\"worktree\", \"list\", \"--porcelain\"])\n        .output()?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to list worktrees: {}\", stderr);\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let all_worktrees = parse_worktree_list(\u0026stdout);\n\n    // Filter to chant-related worktrees (skip main worktree)\n    let chant_worktrees: Vec\u003c_\u003e = all_worktrees\n        .into_iter()\n        .filter(|wt| {\n            // Include if path contains \"chant-\" or branch starts with \"chant/\"\n            let path_match = wt\n                .path\n                .file_name()\n                .map(|n| n.to_string_lossy().starts_with(\"chant-\"))\n                .unwrap_or(false);\n            let branch_match = wt\n                .branch\n                .as_ref()\n                .map(|b| b.starts_with(\"chant/\"))\n                .unwrap_or(false);\n            path_match || branch_match\n        })\n        .collect();\n\n    if chant_worktrees.is_empty() {\n        println!(\"{}\", \"No chant worktrees found.\".dimmed());\n        return Ok(());\n    }\n\n    println!(\n        \"{} {} chant worktree{}:\\n\",\n        \"Found\".cyan(),\n        chant_worktrees.len(),\n        if chant_worktrees.len() == 1 { \"\" } else { \"s\" }\n    );\n\n    for wt in \u0026chant_worktrees {\n        let spec_id = extract_spec_id(wt);\n        let spec_info = spec_id.as_ref().and_then(|id| lookup_spec(id));\n\n        // Print worktree path\n        print!(\"  {}\", wt.path.display().to_string().bold());\n\n        // Print prunable warning\n        if wt.prunable {\n            print!(\" {}\", \"[prunable]\".red());\n        }\n        println!();\n\n        // Print branch\n        if let Some(ref branch) = wt.branch {\n            println!(\"    Branch: {}\", branch.cyan());\n        }\n\n        // Print HEAD (shortened)\n        let short_head = if wt.head.len() \u003e= 7 {\n            \u0026wt.head[..7]\n        } else {\n            \u0026wt.head\n        };\n        println!(\"    HEAD:   {}\", short_head.dimmed());\n\n        // Print spec info if available\n        if let Some(ref id) = spec_id {\n            println!(\"    Spec:   {}\", id.yellow());\n            if let Some(ref info) = spec_info {\n                println!(\"    Title:  {}\", info.title);\n                println!(\"    Status: {}\", format_status(\u0026info.status));\n            } else {\n                println!(\"    Status: {} (spec not found)\", \"unknown\".red());\n            }\n        }\n\n        // Print size and age\n        let size = dir_size(\u0026wt.path);\n        let age = path_age_secs(\u0026wt.path);\n        println!(\n            \"    Size:   {}  Age: {}\",\n            format_bytes(size).yellow(),\n            format_age_secs(age).dimmed()\n        );\n\n        // Print prunable reason if available\n        if let Some(ref reason) = wt.prunable_reason {\n            println!(\"    Reason: {}\", reason.red());\n        }\n\n        println!();\n    }\n\n    // Summary\n    let prunable_count = chant_worktrees.iter().filter(|wt| wt.prunable).count();\n    if prunable_count \u003e 0 {\n        println!(\n            \"{} {} prunable worktree{} (run {} to clean up)\",\n            \"â \".yellow(),\n            prunable_count,\n            if prunable_count == 1 { \"\" } else { \"s\" },\n            \"chant cleanup\".cyan()\n        );\n    }\n\n    let total_size: u64 = chant_worktrees.iter().map(|wt| dir_size(\u0026wt.path)).sum();\n    println!(\n        \"Total disk usage: {}\",\n        format_bytes(total_size).bold().yellow()\n    );\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_worktree_list_basic() {\n        let output = r#\"worktree /Users/test/project\nHEAD abc123def456\nbranch refs/heads/main\n\nworktree /tmp/chant-2026-01-27-001-abc\nHEAD def456abc789\nbranch refs/heads/chant/2026-01-27-001-abc\n\"#;\n        let entries = parse_worktree_list(output);\n        assert_eq!(entries.len(), 2);\n\n        assert_eq!(entries[0].path, PathBuf::from(\"/Users/test/project\"));\n        assert_eq!(entries[0].head, \"abc123def456\");\n        assert_eq!(entries[0].branch, Some(\"main\".to_string()));\n        assert!(!entries[0].prunable);\n\n        assert_eq!(\n            entries[1].path,\n            PathBuf::from(\"/tmp/chant-2026-01-27-001-abc\")\n        );\n        assert_eq!(entries[1].head, \"def456abc789\");\n        assert_eq!(\n            entries[1].branch,\n            Some(\"chant/2026-01-27-001-abc\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_parse_worktree_list_prunable() {\n        let output = r#\"worktree /tmp/chant-2026-01-27-001-abc\nHEAD def456abc789\nbranch refs/heads/chant/2026-01-27-001-abc\nprunable gitdir file points to non-existent location\n\"#;\n        let entries = parse_worktree_list(output);\n        assert_eq!(entries.len(), 1);\n        assert!(entries[0].prunable);\n        assert_eq!(\n            entries[0].prunable_reason,\n            Some(\"gitdir file points to non-existent location\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_extract_spec_id_from_branch() {\n        let entry = GitWorktreeEntry {\n            path: PathBuf::from(\"/tmp/chant-2026-01-27-001-abc\"),\n            head: \"abc123\".to_string(),\n            branch: Some(\"chant/2026-01-27-001-abc\".to_string()),\n            prunable: false,\n            prunable_reason: None,\n        };\n        assert_eq!(\n            extract_spec_id(\u0026entry),\n            Some(\"2026-01-27-001-abc\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_extract_spec_id_from_path() {\n        let entry = GitWorktreeEntry {\n            path: PathBuf::from(\"/tmp/chant-2026-01-27-001-abc\"),\n            head: \"abc123\".to_string(),\n            branch: None,\n            prunable: false,\n            prunable_reason: None,\n        };\n        assert_eq!(\n            extract_spec_id(\u0026entry),\n            Some(\"2026-01-27-001-abc\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_extract_spec_id_no_match() {\n        let entry = GitWorktreeEntry {\n            path: PathBuf::from(\"/Users/test/project\"),\n            head: \"abc123\".to_string(),\n            branch: Some(\"main\".to_string()),\n            prunable: false,\n            prunable_reason: None,\n        };\n        assert_eq!(extract_spec_id(\u0026entry), None);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":55}},{"line":36,"address":[],"length":0,"stats":{"Line":86}},{"line":38,"address":[],"length":0,"stats":{"Line":21}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":42,"address":[],"length":0,"stats":{"Line":55}},{"line":43,"address":[],"length":0,"stats":{"Line":22}},{"line":44,"address":[],"length":0,"stats":{"Line":33}},{"line":45,"address":[],"length":0,"stats":{"Line":22}},{"line":46,"address":[],"length":0,"stats":{"Line":11}},{"line":47,"address":[],"length":0,"stats":{"Line":11}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":50,"address":[],"length":0,"stats":{"Line":64}},{"line":51,"address":[],"length":0,"stats":{"Line":75}},{"line":52,"address":[],"length":0,"stats":{"Line":44}},{"line":53,"address":[],"length":0,"stats":{"Line":64}},{"line":54,"address":[],"length":0,"stats":{"Line":66}},{"line":56,"address":[],"length":0,"stats":{"Line":66}},{"line":57,"address":[],"length":0,"stats":{"Line":22}},{"line":58,"address":[],"length":0,"stats":{"Line":32}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":18}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":13}},{"line":80,"address":[],"length":0,"stats":{"Line":11}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":24}},{"line":141,"address":[],"length":0,"stats":{"Line":24}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":48}},{"line":146,"address":[],"length":0,"stats":{"Line":112}},{"line":147,"address":[],"length":0,"stats":{"Line":48}},{"line":150,"address":[],"length":0,"stats":{"Line":40}},{"line":151,"address":[],"length":0,"stats":{"Line":40}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":199,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":206,"address":[],"length":0,"stats":{"Line":16}},{"line":207,"address":[],"length":0,"stats":{"Line":8}},{"line":208,"address":[],"length":0,"stats":{"Line":8}},{"line":209,"address":[],"length":0,"stats":{"Line":24}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":16}},{"line":212,"address":[],"length":0,"stats":{"Line":8}},{"line":213,"address":[],"length":0,"stats":{"Line":8}},{"line":214,"address":[],"length":0,"stats":{"Line":24}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":8}},{"line":221,"address":[],"length":0,"stats":{"Line":3}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":7}},{"line":233,"address":[],"length":0,"stats":{"Line":12}},{"line":234,"address":[],"length":0,"stats":{"Line":24}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":12}},{"line":247,"address":[],"length":0,"stats":{"Line":8}},{"line":251,"address":[],"length":0,"stats":{"Line":8}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":259,"address":[],"length":0,"stats":{"Line":8}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":8}},{"line":270,"address":[],"length":0,"stats":{"Line":12}},{"line":271,"address":[],"length":0,"stats":{"Line":12}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":287,"address":[],"length":0,"stats":{"Line":12}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":23}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":301,"address":[],"length":0,"stats":{"Line":6}},{"line":304,"address":[],"length":0,"stats":{"Line":3}}],"covered":108,"coverable":149},{"path":["/","Users","alex","Documents","checkouts","chant","src","config","defaults.rs"],"content":"//! Default values and configuration structs with default implementations.\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::provider::ProviderType;\n\n/// Macro to generate default functions for serde attributes\nmacro_rules! default_fn {\n    ($name:ident, $type:ty, $value:expr) =\u003e {\n        pub(crate) fn $name() -\u003e $type {\n            $value\n        }\n    };\n}\n\n// =========================================================================\n// DEFAULT VALUE FUNCTIONS\n// =========================================================================\n\ndefault_fn!(default_complexity_criteria, usize, 10);\ndefault_fn!(default_complexity_files, usize, 5);\ndefault_fn!(default_complexity_words, usize, 50);\ndefault_fn!(default_simple_criteria, usize, 1);\ndefault_fn!(default_simple_files, usize, 1);\ndefault_fn!(default_simple_words, usize, 3);\ndefault_fn!(default_max_retries, usize, 3);\ndefault_fn!(default_retry_delay_ms, u64, 60_000); // 60 seconds\ndefault_fn!(default_backoff_multiplier, f64, 2.0);\ndefault_fn!(default_poll_interval_ms, u64, 5000); // 5 seconds\ndefault_fn!(default_site_output_dir, String, \"./public/\".to_string());\ndefault_fn!(default_site_base_url, String, \"/\".to_string());\ndefault_fn!(default_site_title, String, \"Project Specs\".to_string());\ndefault_fn!(\n    default_include_statuses,\n    Vec\u003cString\u003e,\n    vec![\n        \"completed\".to_string(),\n        \"in_progress\".to_string(),\n        \"pending\".to_string(),\n    ]\n);\ndefault_fn!(default_true, bool, true);\ndefault_fn!(default_agent_weight, usize, 1);\ndefault_fn!(default_agent_name, String, \"main\".to_string());\ndefault_fn!(default_agent_command, String, \"claude\".to_string());\ndefault_fn!(default_max_concurrent, usize, 2);\ndefault_fn!(default_stagger_delay_ms, u64, 1000); // Default 1 second between agent spawns\ndefault_fn!(default_stagger_jitter_ms, u64, 200); // Default 20% of stagger_delay_ms (200ms is 20% of 1000ms)\ndefault_fn!(default_cleanup_enabled, bool, true);\ndefault_fn!(\n    default_cleanup_prompt,\n    String,\n    \"parallel-cleanup\".to_string()\n);\ndefault_fn!(default_rotation_strategy, String, \"none\".to_string());\ndefault_fn!(default_prompt, String, \"bootstrap\".to_string());\ndefault_fn!(default_branch_prefix, String, \"chant/\".to_string());\ndefault_fn!(default_main_branch, String, \"main\".to_string());\n\n// =========================================================================\n// CONFIG STRUCTS WITH DEFAULTS\n// =========================================================================\n\n/// Thresholds for linter complexity heuristics\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct LintThresholds {\n    /// Max acceptance criteria for complex specs (default: 10)\n    #[serde(default = \"default_complexity_criteria\")]\n    pub complexity_criteria: usize,\n    /// Max target files for complex specs (default: 5)\n    #[serde(default = \"default_complexity_files\")]\n    pub complexity_files: usize,\n    /// Max words in title for complex specs (default: 50)\n    #[serde(default = \"default_complexity_words\")]\n    pub complexity_words: usize,\n    /// Min acceptance criteria for simple specs (default: 1)\n    #[serde(default = \"default_simple_criteria\")]\n    pub simple_criteria: usize,\n    /// Min target files for simple specs (default: 1)\n    #[serde(default = \"default_simple_files\")]\n    pub simple_files: usize,\n    /// Min words in title for simple specs (default: 3)\n    #[serde(default = \"default_simple_words\")]\n    pub simple_words: usize,\n}\n\nimpl Default for LintThresholds {\n    fn default() -\u003e Self {\n        Self {\n            complexity_criteria: default_complexity_criteria(),\n            complexity_files: default_complexity_files(),\n            complexity_words: default_complexity_words(),\n            simple_criteria: default_simple_criteria(),\n            simple_files: default_simple_files(),\n            simple_words: default_simple_words(),\n        }\n    }\n}\n\n/// Linter configuration for spec validation\n#[derive(Debug, Clone, Deserialize, Serialize, Default)]\npub struct LintConfig {\n    /// Thresholds for complexity heuristics\n    #[serde(default)]\n    pub thresholds: LintThresholds,\n    /// List of rule names to disable (skip during linting)\n    #[serde(default)]\n    pub disable: Vec\u003cString\u003e,\n}\n\n/// Failure handling strategy for permanent failures\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum OnPermanentFailure {\n    /// Skip the failed spec and continue watching others\n    #[default]\n    Skip,\n    /// Stop the watch command entirely\n    Stop,\n}\n\n/// Configuration for failure handling in watch command\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct FailureConfig {\n    /// Maximum number of retry attempts for transient errors\n    #[serde(default = \"default_max_retries\")]\n    pub max_retries: usize,\n    /// Delay in milliseconds before first retry\n    #[serde(default = \"default_retry_delay_ms\")]\n    pub retry_delay_ms: u64,\n    /// Multiplier for exponential backoff (must be \u003e= 1.0)\n    #[serde(default = \"default_backoff_multiplier\")]\n    pub backoff_multiplier: f64,\n    /// Regex patterns for errors that should be retried\n    #[serde(default)]\n    pub retryable_patterns: Vec\u003cString\u003e,\n    /// Action to take on permanent failure\n    #[serde(default)]\n    pub on_permanent_failure: OnPermanentFailure,\n}\n\nimpl Default for FailureConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: default_max_retries(),\n            retry_delay_ms: default_retry_delay_ms(),\n            backoff_multiplier: default_backoff_multiplier(),\n            retryable_patterns: vec![],\n            on_permanent_failure: OnPermanentFailure::default(),\n        }\n    }\n}\n\n/// Configuration for watch command behavior\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct WatchConfig {\n    /// Poll interval in milliseconds\n    #[serde(default = \"default_poll_interval_ms\")]\n    pub poll_interval_ms: u64,\n    /// Failure handling configuration\n    #[serde(default)]\n    pub failure: FailureConfig,\n}\n\nimpl Default for WatchConfig {\n    fn default() -\u003e Self {\n        Self {\n            poll_interval_ms: default_poll_interval_ms(),\n            failure: FailureConfig::default(),\n        }\n    }\n}\n\n/// Configuration for what specs to include in the site\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SiteIncludeConfig {\n    /// Statuses to include (default: completed, in_progress, pending)\n    #[serde(default = \"default_include_statuses\")]\n    pub statuses: Vec\u003cString\u003e,\n    /// Labels to include (empty = all)\n    #[serde(default)]\n    pub labels: Vec\u003cString\u003e,\n}\n\nimpl Default for SiteIncludeConfig {\n    fn default() -\u003e Self {\n        Self {\n            statuses: default_include_statuses(),\n            labels: vec![],\n        }\n    }\n}\n\n/// Configuration for what to exclude from the site\n#[derive(Debug, Clone, Deserialize, Serialize, Default)]\npub struct SiteExcludeConfig {\n    /// Labels to exclude from output\n    #[serde(default)]\n    pub labels: Vec\u003cString\u003e,\n    /// Fields to redact from output (e.g., cost_usd, tokens)\n    #[serde(default)]\n    pub fields: Vec\u003cString\u003e,\n}\n\n/// Feature toggles for site pages\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SiteFeaturesConfig {\n    /// Generate changelog page\n    #[serde(default = \"default_true\")]\n    pub changelog: bool,\n    /// Generate dependency graph page\n    #[serde(default = \"default_true\")]\n    pub dependency_graph: bool,\n    /// Generate timeline page\n    #[serde(default = \"default_true\")]\n    pub timeline: bool,\n    /// Generate status index pages\n    #[serde(default = \"default_true\")]\n    pub status_indexes: bool,\n    /// Generate label index pages\n    #[serde(default = \"default_true\")]\n    pub label_indexes: bool,\n}\n\nimpl Default for SiteFeaturesConfig {\n    fn default() -\u003e Self {\n        Self {\n            changelog: true,\n            dependency_graph: true,\n            timeline: true,\n            status_indexes: true,\n            label_indexes: true,\n        }\n    }\n}\n\n/// Graph detail level for dependency visualization\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum GraphDetailLevel {\n    /// Show only spec IDs\n    Minimal,\n    /// Show IDs and titles\n    Titles,\n    /// Show IDs, titles, status, and labels\n    #[default]\n    Full,\n}\n\n/// Configuration for dependency graph visualization\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SiteGraphConfig {\n    /// Level of detail in the graph\n    #[serde(default)]\n    pub detail: GraphDetailLevel,\n}\n\nimpl Default for SiteGraphConfig {\n    fn default() -\u003e Self {\n        Self {\n            detail: GraphDetailLevel::Full,\n        }\n    }\n}\n\n/// Timeline grouping option\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum TimelineGroupBy {\n    /// Group by day\n    #[default]\n    Day,\n    /// Group by week\n    Week,\n    /// Group by month\n    Month,\n}\n\n/// Configuration for timeline visualization\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SiteTimelineConfig {\n    /// How to group timeline entries\n    #[serde(default)]\n    pub group_by: TimelineGroupBy,\n    /// Whether to include pending specs in timeline\n    #[serde(default)]\n    pub include_pending: bool,\n}\n\nimpl Default for SiteTimelineConfig {\n    fn default() -\u003e Self {\n        Self {\n            group_by: TimelineGroupBy::Day,\n            include_pending: false,\n        }\n    }\n}\n\n/// Configuration for static site generation\n#[derive(Debug, Clone, Deserialize, Serialize, Default)]\npub struct SiteConfig {\n    /// Output directory for generated site (default: ./public/)\n    #[serde(default = \"default_site_output_dir\")]\n    pub output_dir: String,\n    /// Base URL for the site (default: /)\n    #[serde(default = \"default_site_base_url\")]\n    pub base_url: String,\n    /// Site title (default: \"Project Specs\")\n    #[serde(default = \"default_site_title\")]\n    pub title: String,\n    /// Content filtering - what to include\n    #[serde(default)]\n    pub include: SiteIncludeConfig,\n    /// Content filtering - what to exclude\n    #[serde(default)]\n    pub exclude: SiteExcludeConfig,\n    /// Feature toggles for different page types\n    #[serde(default)]\n    pub features: SiteFeaturesConfig,\n    /// Graph visualization options\n    #[serde(default)]\n    pub graph: SiteGraphConfig,\n    /// Timeline visualization options\n    #[serde(default)]\n    pub timeline: SiteTimelineConfig,\n}\n\n/// Configuration for a single agent (Claude account/command)\n#[derive(Debug, Deserialize, Clone)]\npub struct AgentConfig {\n    /// Name of the agent (for display and attribution)\n    #[serde(default = \"default_agent_name\")]\n    pub name: String,\n    /// Shell command to invoke this agent (e.g., \"claude\", \"claude-alt1\")\n    #[serde(default = \"default_agent_command\")]\n    pub command: String,\n    /// Maximum concurrent instances for this agent\n    #[serde(default = \"default_max_concurrent\")]\n    pub max_concurrent: usize,\n    /// Weight for agent rotation selection (higher = more likely to be selected)\n    #[serde(default = \"default_agent_weight\")]\n    pub weight: usize,\n}\n\nimpl Default for AgentConfig {\n    fn default() -\u003e Self {\n        Self {\n            name: default_agent_name(),\n            command: default_agent_command(),\n            max_concurrent: default_max_concurrent(),\n            weight: default_agent_weight(),\n        }\n    }\n}\n\n/// Configuration for post-parallel cleanup\n#[derive(Debug, Deserialize, Clone)]\npub struct CleanupConfig {\n    /// Whether cleanup is enabled\n    #[serde(default = \"default_cleanup_enabled\")]\n    pub enabled: bool,\n    /// Prompt to use for cleanup agent\n    #[serde(default = \"default_cleanup_prompt\")]\n    pub prompt: String,\n    /// Whether to automatically run cleanup without confirmation\n    #[serde(default)]\n    pub auto_run: bool,\n}\n\nimpl Default for CleanupConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: default_cleanup_enabled(),\n            prompt: default_cleanup_prompt(),\n            auto_run: false,\n        }\n    }\n}\n\n/// Configuration for parallel execution with multiple agents\n#[derive(Debug, Deserialize, Clone)]\npub struct ParallelConfig {\n    /// List of available agents (Claude accounts/commands)\n    #[serde(default)]\n    pub agents: Vec\u003cAgentConfig\u003e,\n    /// Cleanup configuration\n    #[serde(default)]\n    pub cleanup: CleanupConfig,\n    /// Delay in milliseconds between spawning each agent to avoid API rate limiting\n    #[serde(default = \"default_stagger_delay_ms\")]\n    pub stagger_delay_ms: u64,\n    /// Jitter in milliseconds for spawn delays (default: 20% of stagger_delay_ms)\n    #[serde(default = \"default_stagger_jitter_ms\")]\n    pub stagger_jitter_ms: u64,\n}\n\nimpl ParallelConfig {\n    /// Calculate total capacity as sum of all agent max_concurrent values\n    pub fn total_capacity(\u0026self) -\u003e usize {\n        self.agents.iter().map(|a| a.max_concurrent).sum()\n    }\n}\n\nimpl Default for ParallelConfig {\n    fn default() -\u003e Self {\n        Self {\n            agents: vec![AgentConfig::default()],\n            cleanup: CleanupConfig::default(),\n            stagger_delay_ms: default_stagger_delay_ms(),\n            stagger_jitter_ms: default_stagger_jitter_ms(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct DefaultsConfig {\n    #[serde(default = \"default_prompt\")]\n    pub prompt: String,\n    #[serde(default = \"default_branch_prefix\")]\n    pub branch_prefix: String,\n    /// Default model name to use when env vars are not set\n    #[serde(default)]\n    pub model: Option\u003cString\u003e,\n    /// Default model name for split operations (defaults to sonnet)\n    #[serde(default)]\n    pub split_model: Option\u003cString\u003e,\n    /// Default main branch name for merges (defaults to \"main\")\n    #[serde(default = \"default_main_branch\")]\n    pub main_branch: String,\n    /// Default provider (claude, ollama, openai)\n    #[serde(default)]\n    pub provider: ProviderType,\n    /// Agent rotation strategy for single spec execution (none, random, round-robin)\n    #[serde(default = \"default_rotation_strategy\")]\n    pub rotation_strategy: String,\n    /// List of prompt extensions to append to all prompts\n    #[serde(default)]\n    pub prompt_extensions: Vec\u003cString\u003e,\n}\n\nimpl Default for DefaultsConfig {\n    fn default() -\u003e Self {\n        Self {\n            prompt: default_prompt(),\n            branch_prefix: default_branch_prefix(),\n            model: None,\n            split_model: None,\n            main_branch: default_main_branch(),\n            provider: ProviderType::Claude,\n            rotation_strategy: default_rotation_strategy(),\n            prompt_extensions: vec![],\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":5635}},{"line":88,"address":[],"length":0,"stats":{"Line":269}},{"line":90,"address":[],"length":0,"stats":{"Line":538}},{"line":91,"address":[],"length":0,"stats":{"Line":538}},{"line":92,"address":[],"length":0,"stats":{"Line":538}},{"line":93,"address":[],"length":0,"stats":{"Line":538}},{"line":94,"address":[],"length":0,"stats":{"Line":269}},{"line":95,"address":[],"length":0,"stats":{"Line":269}},{"line":143,"address":[],"length":0,"stats":{"Line":236}},{"line":145,"address":[],"length":0,"stats":{"Line":472}},{"line":146,"address":[],"length":0,"stats":{"Line":472}},{"line":147,"address":[],"length":0,"stats":{"Line":472}},{"line":148,"address":[],"length":0,"stats":{"Line":236}},{"line":149,"address":[],"length":0,"stats":{"Line":236}},{"line":166,"address":[],"length":0,"stats":{"Line":234}},{"line":168,"address":[],"length":0,"stats":{"Line":234}},{"line":169,"address":[],"length":0,"stats":{"Line":234}},{"line":186,"address":[],"length":0,"stats":{"Line":243}},{"line":188,"address":[],"length":0,"stats":{"Line":243}},{"line":189,"address":[],"length":0,"stats":{"Line":243}},{"line":226,"address":[],"length":0,"stats":{"Line":243}},{"line":259,"address":[],"length":0,"stats":{"Line":243}},{"line":291,"address":[],"length":0,"stats":{"Line":243}},{"line":346,"address":[],"length":0,"stats":{"Line":236}},{"line":348,"address":[],"length":0,"stats":{"Line":472}},{"line":349,"address":[],"length":0,"stats":{"Line":472}},{"line":350,"address":[],"length":0,"stats":{"Line":236}},{"line":351,"address":[],"length":0,"stats":{"Line":236}},{"line":371,"address":[],"length":0,"stats":{"Line":256}},{"line":373,"address":[],"length":0,"stats":{"Line":256}},{"line":374,"address":[],"length":0,"stats":{"Line":256}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":6}},{"line":405,"address":[],"length":0,"stats":{"Line":236}},{"line":407,"address":[],"length":0,"stats":{"Line":708}},{"line":408,"address":[],"length":0,"stats":{"Line":472}},{"line":409,"address":[],"length":0,"stats":{"Line":236}},{"line":410,"address":[],"length":0,"stats":{"Line":236}},{"line":442,"address":[],"length":0,"stats":{"Line":51}},{"line":444,"address":[],"length":0,"stats":{"Line":102}},{"line":445,"address":[],"length":0,"stats":{"Line":102}},{"line":448,"address":[],"length":0,"stats":{"Line":102}},{"line":450,"address":[],"length":0,"stats":{"Line":51}},{"line":451,"address":[],"length":0,"stats":{"Line":51}}],"covered":44,"coverable":44},{"path":["/","Users","alex","Documents","checkouts","chant","src","config","mod.rs"],"content":"//! Configuration management for chant projects.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: reference/config.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse serde::Deserialize;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse crate::provider::ProviderConfig;\nuse crate::spec::split_frontmatter;\n\npub mod defaults;\npub mod providers;\npub mod validation;\n\npub use defaults::*;\npub use providers::*;\npub use validation::*;\n\n#[derive(Debug, Clone, Deserialize)]\npub struct Config {\n    pub project: ProjectConfig,\n    #[serde(default)]\n    pub defaults: DefaultsConfig,\n    #[serde(default)]\n    pub providers: ProviderConfig,\n    #[serde(default)]\n    pub parallel: ParallelConfig,\n    #[serde(default)]\n    pub repos: Vec\u003cRepoConfig\u003e,\n    #[serde(default)]\n    pub enterprise: EnterpriseConfig,\n    #[serde(default)]\n    pub approval: ApprovalConfig,\n    #[serde(default)]\n    pub validation: OutputValidationConfig,\n    #[serde(default)]\n    pub site: SiteConfig,\n    #[serde(default)]\n    pub lint: LintConfig,\n    #[serde(default)]\n    pub watch: WatchConfig,\n}\n\nimpl Config {\n    /// Load configuration with full merge semantics.\n    /// Merge order (later overrides earlier):\n    /// 1. Global config (~/.config/chant/config.md)\n    /// 2. Project config (.chant/config.md)\n    /// 3. Project agents config (.chant/agents.md) - only for parallel.agents\n    pub fn load() -\u003e Result\u003cSelf\u003e {\n        Self::load_merged_from(\n            global_config_path().as_deref(),\n            Path::new(\".chant/config.md\"),\n            Some(Path::new(\".chant/agents.md\")),\n        )\n    }\n\n    pub fn load_from(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read config from {}\", path.display()))?;\n\n        Self::parse(\u0026content)\n    }\n\n    pub fn parse(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        // Extract YAML frontmatter using shared function\n        let (frontmatter, _body) = split_frontmatter(content);\n        let frontmatter = frontmatter.context(\"Failed to extract frontmatter from config\")?;\n\n        let config: Config =\n            serde_yaml::from_str(\u0026frontmatter).context(\"Failed to parse config frontmatter\")?;\n\n        // Validate watch config\n        config.watch.validate()?;\n\n        Ok(config)\n    }\n\n    /// Load merged configuration from global and project configs.\n    /// Project config values override global config values.\n    pub fn load_merged() -\u003e Result\u003cSelf\u003e {\n        Self::load_merged_from(\n            global_config_path().as_deref(),\n            Path::new(\".chant/config.md\"),\n            Some(Path::new(\".chant/agents.md\")),\n        )\n    }\n\n    /// Load merged configuration from specified global, project, and agents config paths.\n    /// Merge order (later overrides earlier):\n    /// 1. Global config\n    /// 2. Project config\n    /// 3. Agents config (only for parallel.agents section)\n    pub fn load_merged_from(\n        global_path: Option\u003c\u0026Path\u003e,\n        project_path: \u0026Path,\n        agents_path: Option\u003c\u0026Path\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        // Load global config if it exists\n        let global_config = global_path\n            .filter(|p| p.exists())\n            .map(PartialConfig::load_from)\n            .transpose()?\n            .unwrap_or_default();\n\n        // Load project config as partial (required, but as partial for merging)\n        let project_config = PartialConfig::load_from(project_path)?;\n\n        // Load agents config if it exists (optional, gitignored)\n        let agents_config = agents_path\n            .filter(|p| p.exists())\n            .map(AgentsConfig::load_from)\n            .transpose()?;\n\n        // Merge: global \u003c project \u003c agents (for parallel.agents only)\n        let mut config = global_config.merge_with(project_config);\n\n        // Apply agents override if present\n        if let Some(agents) = agents_config {\n            if let Some(parallel) = agents.parallel {\n                if !parallel.agents.is_empty() {\n                    config.parallel.agents = parallel.agents;\n                }\n            }\n        }\n\n        Ok(config)\n    }\n}\n\n/// Returns the path to the global config file at ~/.config/chant/config.md\npub fn global_config_path() -\u003e Option\u003cPathBuf\u003e {\n    std::env::var(\"HOME\")\n        .ok()\n        .map(|home| PathBuf::from(home).join(\".config/chant/config.md\"))\n}\n\n/// Agents-only config for project-specific agent overrides (.chant/agents.md)\n/// This file is gitignored and contains only the parallel.agents section\n#[derive(Debug, Deserialize, Default)]\nstruct AgentsConfig {\n    pub parallel: Option\u003cAgentsParallelConfig\u003e,\n}\n\n/// Parallel config subset for agents.md - only contains agents list\n#[derive(Debug, Deserialize, Default)]\nstruct AgentsParallelConfig {\n    #[serde(default)]\n    pub agents: Vec\u003cAgentConfig\u003e,\n}\n\nimpl AgentsConfig {\n    fn load_from(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read agents config from {}\", path.display()))?;\n\n        Self::parse(\u0026content)\n    }\n\n    fn parse(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let (frontmatter, _body) = split_frontmatter(content);\n        let frontmatter =\n            frontmatter.context(\"Failed to extract frontmatter from agents config\")?;\n\n        serde_yaml::from_str(\u0026frontmatter).context(\"Failed to parse agents config frontmatter\")\n    }\n}\n\n/// Partial config for merging - all fields optional\n#[derive(Debug, Deserialize, Default)]\nstruct PartialConfig {\n    pub project: Option\u003cPartialProjectConfig\u003e,\n    pub defaults: Option\u003cPartialDefaultsConfig\u003e,\n    pub parallel: Option\u003cParallelConfig\u003e,\n    pub repos: Option\u003cVec\u003cRepoConfig\u003e\u003e,\n    pub enterprise: Option\u003cEnterpriseConfig\u003e,\n    pub approval: Option\u003cApprovalConfig\u003e,\n    pub validation: Option\u003cOutputValidationConfig\u003e,\n    pub site: Option\u003cSiteConfig\u003e,\n    pub lint: Option\u003cLintConfig\u003e,\n    pub watch: Option\u003cWatchConfig\u003e,\n}\n\n#[derive(Debug, Deserialize, Default)]\nstruct PartialProjectConfig {\n    pub name: Option\u003cString\u003e,\n    pub prefix: Option\u003cString\u003e,\n    pub silent: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize, Default)]\nstruct PartialDefaultsConfig {\n    pub prompt: Option\u003cString\u003e,\n    pub branch_prefix: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub split_model: Option\u003cString\u003e,\n    pub main_branch: Option\u003cString\u003e,\n    pub provider: Option\u003ccrate::provider::ProviderType\u003e,\n    pub rotation_strategy: Option\u003cString\u003e,\n    pub prompt_extensions: Option\u003cVec\u003cString\u003e\u003e,\n}\n\nimpl PartialConfig {\n    fn load_from(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read config from {}\", path.display()))?;\n\n        Self::parse(\u0026content)\n    }\n\n    fn parse(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let (frontmatter, _body) = split_frontmatter(content);\n        let frontmatter = frontmatter.context(\"Failed to extract frontmatter from config\")?;\n\n        serde_yaml::from_str(\u0026frontmatter).context(\"Failed to parse config frontmatter\")\n    }\n\n    /// Merge this global config with a project config, returning the merged result.\n    /// Values from the project config take precedence over global.\n    fn merge_with(self, project: PartialConfig) -\u003e Config {\n        let global_project = self.project.unwrap_or_default();\n        let global_defaults = self.defaults.unwrap_or_default();\n        let project_project = project.project.unwrap_or_default();\n        let project_defaults = project.defaults.unwrap_or_default();\n\n        Config {\n            project: ProjectConfig {\n                // Project name is required in project config\n                name: project_project.name.unwrap_or_default(),\n                // Project prefix overrides global prefix\n                prefix: project_project.prefix.or(global_project.prefix),\n                // Project silent overrides global silent\n                silent: project_project\n                    .silent\n                    .or(global_project.silent)\n                    .unwrap_or(false),\n            },\n            defaults: DefaultsConfig {\n                // Project value \u003e global value \u003e default\n                prompt: project_defaults\n                    .prompt\n                    .or(global_defaults.prompt)\n                    .unwrap_or_else(defaults::default_prompt),\n                branch_prefix: project_defaults\n                    .branch_prefix\n                    .or(global_defaults.branch_prefix)\n                    .unwrap_or_else(defaults::default_branch_prefix),\n                model: project_defaults.model.or(global_defaults.model),\n                split_model: project_defaults.split_model.or(global_defaults.split_model),\n                main_branch: project_defaults\n                    .main_branch\n                    .or(global_defaults.main_branch)\n                    .unwrap_or_else(defaults::default_main_branch),\n                provider: project_defaults\n                    .provider\n                    .or(global_defaults.provider)\n                    .unwrap_or_default(),\n                rotation_strategy: project_defaults\n                    .rotation_strategy\n                    .or(global_defaults.rotation_strategy)\n                    .unwrap_or_else(defaults::default_rotation_strategy),\n                prompt_extensions: project_defaults\n                    .prompt_extensions\n                    .or(global_defaults.prompt_extensions)\n                    .unwrap_or_default(),\n            },\n            providers: Default::default(),\n            // Parallel config: project overrides global, or use default\n            parallel: project.parallel.or(self.parallel).unwrap_or_default(),\n            // Repos: project overrides global, or use default\n            repos: project\n                .repos\n                .unwrap_or_else(|| self.repos.unwrap_or_default()),\n            // Enterprise config: project overrides global, or use default\n            enterprise: project.enterprise.or(self.enterprise).unwrap_or_default(),\n            // Approval config: project overrides global, or use default\n            approval: project.approval.or(self.approval).unwrap_or_default(),\n            // Validation config: project overrides global, or use default\n            validation: project.validation.or(self.validation).unwrap_or_default(),\n            // Site config: project overrides global, or use default\n            site: project.site.or(self.site).unwrap_or_default(),\n            // Lint config: project overrides global, or use default\n            lint: project.lint.or(self.lint).unwrap_or_default(),\n            // Watch config: project overrides global, or use default\n            watch: project.watch.or(self.watch).unwrap_or_default(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":168}},{"line":57,"address":[],"length":0,"stats":{"Line":336}},{"line":58,"address":[],"length":0,"stats":{"Line":168}},{"line":59,"address":[],"length":0,"stats":{"Line":168}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":43}},{"line":72,"address":[],"length":0,"stats":{"Line":129}},{"line":73,"address":[],"length":0,"stats":{"Line":129}},{"line":75,"address":[],"length":0,"stats":{"Line":78}},{"line":76,"address":[],"length":0,"stats":{"Line":129}},{"line":79,"address":[],"length":0,"stats":{"Line":80}},{"line":81,"address":[],"length":0,"stats":{"Line":37}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":189}},{"line":105,"address":[],"length":0,"stats":{"Line":377}},{"line":106,"address":[],"length":0,"stats":{"Line":557}},{"line":107,"address":[],"length":0,"stats":{"Line":189}},{"line":112,"address":[],"length":0,"stats":{"Line":564}},{"line":115,"address":[],"length":0,"stats":{"Line":373}},{"line":116,"address":[],"length":0,"stats":{"Line":533}},{"line":117,"address":[],"length":0,"stats":{"Line":187}},{"line":121,"address":[],"length":0,"stats":{"Line":744}},{"line":124,"address":[],"length":0,"stats":{"Line":189}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":186}},{"line":137,"address":[],"length":0,"stats":{"Line":169}},{"line":138,"address":[],"length":0,"stats":{"Line":169}},{"line":140,"address":[],"length":0,"stats":{"Line":507}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":9}},{"line":162,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":18}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":13}},{"line":170,"address":[],"length":0,"stats":{"Line":15}},{"line":209,"address":[],"length":0,"stats":{"Line":372}},{"line":210,"address":[],"length":0,"stats":{"Line":1114}},{"line":211,"address":[],"length":0,"stats":{"Line":380}},{"line":213,"address":[],"length":0,"stats":{"Line":740}},{"line":216,"address":[],"length":0,"stats":{"Line":372}},{"line":217,"address":[],"length":0,"stats":{"Line":1116}},{"line":218,"address":[],"length":0,"stats":{"Line":1116}},{"line":220,"address":[],"length":0,"stats":{"Line":1113}},{"line":225,"address":[],"length":0,"stats":{"Line":186}},{"line":226,"address":[],"length":0,"stats":{"Line":558}},{"line":227,"address":[],"length":0,"stats":{"Line":558}},{"line":228,"address":[],"length":0,"stats":{"Line":558}},{"line":229,"address":[],"length":0,"stats":{"Line":558}},{"line":232,"address":[],"length":0,"stats":{"Line":186}},{"line":243,"address":[],"length":0,"stats":{"Line":186}},{"line":272,"address":[],"length":0,"stats":{"Line":186}},{"line":274,"address":[],"length":0,"stats":{"Line":744}},{"line":276,"address":[],"length":0,"stats":{"Line":186}},{"line":280,"address":[],"length":0,"stats":{"Line":744}},{"line":282,"address":[],"length":0,"stats":{"Line":744}},{"line":284,"address":[],"length":0,"stats":{"Line":744}},{"line":286,"address":[],"length":0,"stats":{"Line":744}},{"line":288,"address":[],"length":0,"stats":{"Line":744}},{"line":290,"address":[],"length":0,"stats":{"Line":744}}],"covered":64,"coverable":69},{"path":["/","Users","alex","Documents","checkouts","chant","src","config","providers.rs"],"content":"//! Provider configuration management.\n\nuse serde::Deserialize;\n\n/// Configuration for a single repository in cross-repo dependency resolution\n#[derive(Debug, Clone, Deserialize)]\npub struct RepoConfig {\n    pub name: String,\n    pub path: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ProjectConfig {\n    pub name: String,\n    pub prefix: Option\u003cString\u003e,\n    #[serde(default)]\n    pub silent: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","config","tests.rs"],"content":"use super::*;\nuse std::fs;\nuse tempfile::TempDir;\n\n#[test]\nfn test_parse_config() {\n    let content = r#\"---\nproject:\n  name: test-project\n\ndefaults:\n  prompt: standard\n---\n\n# Config\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.project.name, \"test-project\");\n    assert_eq!(config.defaults.prompt, \"standard\");\n}\n\n#[test]\nfn test_parse_minimal_config() {\n    let content = r#\"---\nproject:\n  name: minimal\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.project.name, \"minimal\");\n    assert_eq!(config.defaults.prompt, \"bootstrap\"); // default\n}\n\n#[test]\nfn test_global_config_path() {\n    std::env::set_var(\"HOME\", \"/home/testuser\");\n    let path = global_config_path().unwrap();\n    // Use PathBuf for cross-platform comparison\n    let expected = std::path::PathBuf::from(\"/home/testuser\")\n        .join(\".config\")\n        .join(\"chant\")\n        .join(\"config.md\");\n    assert_eq!(path, expected);\n}\n\n#[test]\nfn test_load_merged_no_global() {\n    let tmp = TempDir::new().unwrap();\n    let project_path = tmp.path().join(\"config.md\");\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\ndefaults:\n  prompt: custom\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(None, \u0026project_path, None).unwrap();\n    assert_eq!(config.project.name, \"my-project\");\n    assert_eq!(config.defaults.prompt, \"custom\");\n}\n\n#[test]\nfn test_load_merged_with_global() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    fs::write(\n        \u0026global_path,\n        r#\"---\nproject:\n  prefix: global-prefix\ndefaults:\n  branch_prefix: global/\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n\n    // Project name from project config\n    assert_eq!(config.project.name, \"my-project\");\n    // Prefix from global (not set in project)\n    assert_eq!(config.project.prefix.as_deref(), Some(\"global-prefix\"));\n    // branch_prefix from global (project uses default)\n    assert_eq!(config.defaults.branch_prefix, \"global/\");\n}\n\n#[test]\nfn test_load_merged_project_overrides_global() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    fs::write(\n        \u0026global_path,\n        r#\"---\ndefaults:\n  prompt: global-prompt\n  branch_prefix: global/\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\ndefaults:\n  prompt: project-prompt\n  branch_prefix: project/\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n\n    // Project values should override global\n    assert_eq!(config.defaults.prompt, \"project-prompt\");\n    assert_eq!(config.defaults.branch_prefix, \"project/\");\n}\n\n#[test]\nfn test_load_merged_global_not_exists() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"nonexistent.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.project.name, \"my-project\");\n}\n\n#[test]\nfn test_parse_defaults_model() {\n    let content = r#\"---\nproject:\n  name: test-project\ndefaults:\n  model: claude-sonnet-4\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.defaults.model, Some(\"claude-sonnet-4\".to_string()));\n}\n\n#[test]\nfn test_defaults_model_none_when_not_specified() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.defaults.model, None);\n}\n\n#[test]\nfn test_config_merge_priority() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Test case 1: defaults.model - global used when project doesn't specify\n    fs::write(\n        \u0026global_path,\n        r#\"---\ndefaults:\n  model: claude-opus-4\n---\n\"#,\n    )\n    .unwrap();\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.defaults.model, Some(\"claude-opus-4\".to_string()));\n\n    // Test case 2: defaults.model - project overrides global\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\ndefaults:\n  model: claude-sonnet-4\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.defaults.model, Some(\"claude-sonnet-4\".to_string()));\n}\n\n// =========================================================================\n// PARALLEL CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_parse_parallel_config() {\n    let content = r#\"---\nproject:\n  name: test-project\nparallel:\n  agents:\n    - name: main\n      command: claude\n      max_concurrent: 2\n    - name: alt1\n      command: claude-alt1\n      max_concurrent: 3\n  cleanup:\n    enabled: true\n    prompt: custom-cleanup\n    auto_run: true\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.parallel.agents.len(), 2);\n    assert_eq!(config.parallel.agents[0].name, \"main\");\n    assert_eq!(config.parallel.agents[0].command, \"claude\");\n    assert_eq!(config.parallel.agents[0].max_concurrent, 2);\n    assert_eq!(config.parallel.agents[1].name, \"alt1\");\n    assert_eq!(config.parallel.agents[1].command, \"claude-alt1\");\n    assert_eq!(config.parallel.agents[1].max_concurrent, 3);\n    assert_eq!(config.parallel.total_capacity(), 5); // 2 + 3\n    assert!(config.parallel.cleanup.enabled);\n    assert_eq!(config.parallel.cleanup.prompt, \"custom-cleanup\");\n    assert!(config.parallel.cleanup.auto_run);\n}\n\n#[test]\nfn test_parallel_config_defaults() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Should have default values\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"main\");\n    assert_eq!(config.parallel.agents[0].command, \"claude\");\n    assert_eq!(config.parallel.agents[0].max_concurrent, 2);\n    assert_eq!(config.parallel.total_capacity(), 2); // Single agent with default max_concurrent\n    assert!(config.parallel.cleanup.enabled);\n    assert_eq!(config.parallel.cleanup.prompt, \"parallel-cleanup\");\n    assert!(!config.parallel.cleanup.auto_run);\n}\n\n#[test]\nfn test_parallel_config_partial_agent() {\n    let content = r#\"---\nproject:\n  name: test-project\nparallel:\n  agents:\n    - name: custom-agent\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Agent with only name should get default command, max_concurrent, and weight\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"custom-agent\");\n    assert_eq!(config.parallel.agents[0].command, \"claude\");\n    assert_eq!(config.parallel.agents[0].max_concurrent, 2);\n    assert_eq!(config.parallel.agents[0].weight, 1);\n}\n\n#[test]\nfn test_parse_agent_weight() {\n    let content = r#\"---\nproject:\n  name: test-project\nparallel:\n  agents:\n    - name: main\n      command: claude\n      weight: 2\n    - name: alt1\n      command: claude-alt1\n      weight: 1\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.parallel.agents[0].weight, 2);\n    assert_eq!(config.parallel.agents[1].weight, 1);\n}\n\n#[test]\nfn test_parse_rotation_strategy() {\n    let content = r#\"---\nproject:\n  name: test-project\ndefaults:\n  rotation_strategy: round-robin\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.defaults.rotation_strategy, \"round-robin\");\n}\n\n#[test]\nfn test_rotation_strategy_defaults_to_none() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.defaults.rotation_strategy, \"none\");\n}\n\n// =========================================================================\n// ENTERPRISE CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_parse_enterprise_config() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise:\n  derived:\n    environment:\n      from: branch\n      pattern: \"^(dev|staging|prod)$\"\n      validate:\n        type: enum\n        values:\n          - dev\n          - staging\n          - prod\n    team:\n      from: env\n      pattern: \"TEAM_NAME\"\n  required:\n    - environment\n    - team\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Check enterprise config exists\n    assert!(!config.enterprise.derived.is_empty());\n    assert_eq!(config.enterprise.derived.len(), 2);\n    assert!(!config.enterprise.required.is_empty());\n    assert_eq!(config.enterprise.required.len(), 2);\n\n    // Check environment field derivation\n    let env_field = config.enterprise.derived.get(\"environment\").unwrap();\n    assert!(matches!(env_field.from, DerivationSource::Branch));\n    assert_eq!(env_field.pattern, \"^(dev|staging|prod)$\");\n    assert!(env_field.validate.is_some());\n\n    // Check team field derivation\n    let team_field = config.enterprise.derived.get(\"team\").unwrap();\n    assert!(matches!(team_field.from, DerivationSource::Env));\n    assert_eq!(team_field.pattern, \"TEAM_NAME\");\n    assert!(team_field.validate.is_none());\n\n    // Check required fields\n    assert!(config\n        .enterprise\n        .required\n        .contains(\u0026\"environment\".to_string()));\n    assert!(config.enterprise.required.contains(\u0026\"team\".to_string()));\n}\n\n#[test]\nfn test_parse_enterprise_config_with_path_source() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise:\n  derived:\n    project_code:\n      from: path\n      pattern: \"^([a-z]{3})-\"\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    let field = config.enterprise.derived.get(\"project_code\").unwrap();\n    assert!(matches!(field.from, DerivationSource::Path));\n    assert_eq!(field.pattern, \"^([a-z]{3})-\");\n}\n\n#[test]\nfn test_parse_enterprise_config_with_git_user_source() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise:\n  derived:\n    author:\n      from: git_user\n      pattern: \"name\"\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    let field = config.enterprise.derived.get(\"author\").unwrap();\n    assert!(matches!(field.from, DerivationSource::GitUser));\n    assert_eq!(field.pattern, \"name\");\n}\n\n#[test]\nfn test_config_without_enterprise_section() {\n    let content = r#\"---\nproject:\n  name: test-project\ndefaults:\n  prompt: custom\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Enterprise should default to empty\n    assert!(config.enterprise.derived.is_empty());\n    assert!(config.enterprise.required.is_empty());\n}\n\n#[test]\nfn test_enterprise_config_empty_derived() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise:\n  required:\n    - field1\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Derived should be empty but required should have values\n    assert!(config.enterprise.derived.is_empty());\n    assert_eq!(config.enterprise.required.len(), 1);\n}\n\n#[test]\nfn test_enterprise_config_minimal() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise: {}\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Both should be empty\n    assert!(config.enterprise.derived.is_empty());\n    assert!(config.enterprise.required.is_empty());\n}\n\n#[test]\nfn test_validation_rule_enum() {\n    let content = r#\"---\nproject:\n  name: test-project\nenterprise:\n  derived:\n    region:\n      from: env\n      pattern: \"REGION\"\n      validate:\n        type: enum\n        values:\n          - us-east-1\n          - us-west-2\n          - eu-central-1\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    let field = config.enterprise.derived.get(\"region\").unwrap();\n    assert!(field.validate.is_some());\n\n    if let Some(ValidationRule::Enum { values }) = \u0026field.validate {\n        assert_eq!(values.len(), 3);\n        assert!(values.contains(\u0026\"us-east-1\".to_string()));\n        assert!(values.contains(\u0026\"us-west-2\".to_string()));\n        assert!(values.contains(\u0026\"eu-central-1\".to_string()));\n    } else {\n        panic!(\"Expected Enum validation rule\");\n    }\n}\n\n#[test]\nfn test_config_merge_priority_enterprise() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Global enterprise config used when project doesn't specify\n    fs::write(\n        \u0026global_path,\n        r#\"---\nenterprise:\n  derived:\n    global_field:\n      from: branch\n      pattern: \"pattern1\"\n  required:\n    - global_field\n---\n\"#,\n    )\n    .unwrap();\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert!(config.enterprise.derived.contains_key(\"global_field\"));\n    assert_eq!(config.enterprise.required.len(), 1);\n\n    // Project enterprise overrides global\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\nenterprise:\n  derived:\n    project_field:\n      from: env\n      pattern: \"pattern2\"\n  required:\n    - project_field\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert!(config.enterprise.derived.contains_key(\"project_field\"));\n    assert!(!config.enterprise.derived.contains_key(\"global_field\"));\n    assert_eq!(config.enterprise.required.len(), 1);\n    assert!(config\n        .enterprise\n        .required\n        .contains(\u0026\"project_field\".to_string()));\n}\n\n// =========================================================================\n// APPROVAL CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_parse_approval_config_manual() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval:\n  rejection_action: manual\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.approval.rejection_action, RejectionAction::Manual);\n}\n\n#[test]\nfn test_parse_approval_config_dependency() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval:\n  rejection_action: dependency\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(\n        config.approval.rejection_action,\n        RejectionAction::Dependency\n    );\n}\n\n#[test]\nfn test_parse_approval_config_group() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval:\n  rejection_action: group\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.approval.rejection_action, RejectionAction::Group);\n}\n\n#[test]\nfn test_approval_config_defaults_to_manual() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.approval.rejection_action, RejectionAction::Manual);\n    assert!(!config.approval.require_approval_for_agent_work);\n}\n\n#[test]\nfn test_approval_config_require_approval_for_agent_work() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval:\n  require_approval_for_agent_work: true\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert!(config.approval.require_approval_for_agent_work);\n}\n\n#[test]\nfn test_approval_config_require_approval_for_agent_work_false() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval:\n  require_approval_for_agent_work: false\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert!(!config.approval.require_approval_for_agent_work);\n}\n\n#[test]\nfn test_approval_config_empty_section() {\n    let content = r#\"---\nproject:\n  name: test-project\napproval: {}\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n    assert_eq!(config.approval.rejection_action, RejectionAction::Manual);\n}\n\n#[test]\nfn test_rejection_action_display() {\n    assert_eq!(format!(\"{}\", RejectionAction::Manual), \"manual\");\n    assert_eq!(format!(\"{}\", RejectionAction::Dependency), \"dependency\");\n    assert_eq!(format!(\"{}\", RejectionAction::Group), \"group\");\n}\n\n#[test]\nfn test_config_merge_priority_approval() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Global approval config used when project doesn't specify\n    fs::write(\n        \u0026global_path,\n        r#\"---\napproval:\n  rejection_action: dependency\n---\n\"#,\n    )\n    .unwrap();\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(\n        config.approval.rejection_action,\n        RejectionAction::Dependency\n    );\n\n    // Project approval overrides global\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\napproval:\n  rejection_action: group\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.approval.rejection_action, RejectionAction::Group);\n}\n\n// =========================================================================\n// AGENTS CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_agents_config_overrides_project() {\n    let tmp = TempDir::new().unwrap();\n    let project_path = tmp.path().join(\"config.md\");\n    let agents_path = tmp.path().join(\"agents.md\");\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\nparallel:\n  agents:\n    - name: project-agent\n      command: claude\n      max_concurrent: 1\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026agents_path,\n        r#\"---\nparallel:\n  agents:\n    - name: override-agent\n      command: claude-override\n      max_concurrent: 5\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(None, \u0026project_path, Some(\u0026agents_path)).unwrap();\n\n    // Agents file should override project agents\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"override-agent\");\n    assert_eq!(config.parallel.agents[0].command, \"claude-override\");\n    assert_eq!(config.parallel.agents[0].max_concurrent, 5);\n}\n\n#[test]\nfn test_agents_config_overrides_global() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"config.md\");\n    let agents_path = tmp.path().join(\"agents.md\");\n\n    fs::write(\n        \u0026global_path,\n        r#\"---\nparallel:\n  agents:\n    - name: global-agent\n      command: claude-global\n      max_concurrent: 2\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026agents_path,\n        r#\"---\nparallel:\n  agents:\n    - name: local-agent\n      command: claude-local\n      max_concurrent: 3\n---\n\"#,\n    )\n    .unwrap();\n\n    let config =\n        Config::load_merged_from(Some(\u0026global_path), \u0026project_path, Some(\u0026agents_path)).unwrap();\n\n    // Agents file should override global agents\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"local-agent\");\n    assert_eq!(config.parallel.agents[0].command, \"claude-local\");\n    assert_eq!(config.parallel.agents[0].max_concurrent, 3);\n}\n\n#[test]\nfn test_agents_config_not_exists_uses_global() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"config.md\");\n    let agents_path = tmp.path().join(\"nonexistent.md\");\n\n    fs::write(\n        \u0026global_path,\n        r#\"---\nparallel:\n  agents:\n    - name: global-agent\n      command: claude-global\n      max_concurrent: 2\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    let config =\n        Config::load_merged_from(Some(\u0026global_path), \u0026project_path, Some(\u0026agents_path)).unwrap();\n\n    // Should use global agents when agents file doesn't exist\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"global-agent\");\n}\n\n#[test]\nfn test_agents_config_empty_agents_uses_defaults() {\n    let tmp = TempDir::new().unwrap();\n    let project_path = tmp.path().join(\"config.md\");\n    let agents_path = tmp.path().join(\"agents.md\");\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\nparallel:\n  agents:\n    - name: project-agent\n      command: claude-project\n---\n\"#,\n    )\n    .unwrap();\n\n    // Empty agents list should not override\n    fs::write(\n        \u0026agents_path,\n        r#\"---\nparallel:\n  agents: []\n---\n\"#,\n    )\n    .unwrap();\n\n    let config = Config::load_merged_from(None, \u0026project_path, Some(\u0026agents_path)).unwrap();\n\n    // Empty agents list should not override, use project agents\n    assert_eq!(config.parallel.agents.len(), 1);\n    assert_eq!(config.parallel.agents[0].name, \"project-agent\");\n}\n\n// =========================================================================\n// LINT CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_parse_lint_config_with_thresholds() {\n    let content = r#\"---\nproject:\n  name: test-project\nlint:\n  thresholds:\n    complexity_criteria: 15\n    complexity_files: 8\n    complexity_words: 75\n    simple_criteria: 2\n    simple_files: 2\n    simple_words: 5\n  disable:\n    - rule1\n    - rule2\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.lint.thresholds.complexity_criteria, 15);\n    assert_eq!(config.lint.thresholds.complexity_files, 8);\n    assert_eq!(config.lint.thresholds.complexity_words, 75);\n    assert_eq!(config.lint.thresholds.simple_criteria, 2);\n    assert_eq!(config.lint.thresholds.simple_files, 2);\n    assert_eq!(config.lint.thresholds.simple_words, 5);\n    assert_eq!(config.lint.disable.len(), 2);\n    assert!(config.lint.disable.contains(\u0026\"rule1\".to_string()));\n    assert!(config.lint.disable.contains(\u0026\"rule2\".to_string()));\n}\n\n#[test]\nfn test_lint_config_defaults() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Should have default threshold values\n    assert_eq!(config.lint.thresholds.complexity_criteria, 10);\n    assert_eq!(config.lint.thresholds.complexity_files, 5);\n    assert_eq!(config.lint.thresholds.complexity_words, 50);\n    assert_eq!(config.lint.thresholds.simple_criteria, 1);\n    assert_eq!(config.lint.thresholds.simple_files, 1);\n    assert_eq!(config.lint.thresholds.simple_words, 3);\n    assert!(config.lint.disable.is_empty());\n}\n\n#[test]\nfn test_lint_config_partial_thresholds() {\n    let content = r#\"---\nproject:\n  name: test-project\nlint:\n  thresholds:\n    complexity_criteria: 20\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Only complexity_criteria should be overridden, others use defaults\n    assert_eq!(config.lint.thresholds.complexity_criteria, 20);\n    assert_eq!(config.lint.thresholds.complexity_files, 5);\n    assert_eq!(config.lint.thresholds.complexity_words, 50);\n    assert_eq!(config.lint.thresholds.simple_criteria, 1);\n    assert_eq!(config.lint.thresholds.simple_files, 1);\n    assert_eq!(config.lint.thresholds.simple_words, 3);\n}\n\n#[test]\nfn test_lint_config_disable_only() {\n    let content = r#\"---\nproject:\n  name: test-project\nlint:\n  disable:\n    - no-empty-title\n    - complexity-check\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Thresholds should use defaults\n    assert_eq!(config.lint.thresholds.complexity_criteria, 10);\n    // Disable list should be populated\n    assert_eq!(config.lint.disable.len(), 2);\n    assert!(config.lint.disable.contains(\u0026\"no-empty-title\".to_string()));\n    assert!(config\n        .lint\n        .disable\n        .contains(\u0026\"complexity-check\".to_string()));\n}\n\n#[test]\nfn test_lint_config_empty_section() {\n    let content = r#\"---\nproject:\n  name: test-project\nlint: {}\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Should use all defaults\n    assert_eq!(config.lint.thresholds.complexity_criteria, 10);\n    assert!(config.lint.disable.is_empty());\n}\n\n#[test]\nfn test_config_merge_priority_lint() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Global lint config used when project doesn't specify\n    fs::write(\n        \u0026global_path,\n        r#\"---\nlint:\n  thresholds:\n    complexity_criteria: 15\n  disable:\n    - global-rule\n---\n\"#,\n    )\n    .unwrap();\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.lint.thresholds.complexity_criteria, 15);\n    assert!(config.lint.disable.contains(\u0026\"global-rule\".to_string()));\n\n    // Project lint config overrides global\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\nlint:\n  thresholds:\n    complexity_criteria: 25\n  disable:\n    - project-rule\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.lint.thresholds.complexity_criteria, 25);\n    assert!(config.lint.disable.contains(\u0026\"project-rule\".to_string()));\n    assert!(!config.lint.disable.contains(\u0026\"global-rule\".to_string()));\n}\n\n// =========================================================================\n// WATCH CONFIG TESTS\n// =========================================================================\n\n#[test]\nfn test_parse_watch_config_all_fields() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  poll_interval_ms: 10000\n  failure:\n    max_retries: 5\n    retry_delay_ms: 30000\n    backoff_multiplier: 1.5\n    retryable_patterns:\n      - \"network timeout\"\n      - \"connection refused\"\n    on_permanent_failure: stop\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.watch.poll_interval_ms, 10000);\n    assert_eq!(config.watch.failure.max_retries, 5);\n    assert_eq!(config.watch.failure.retry_delay_ms, 30000);\n    assert_eq!(config.watch.failure.backoff_multiplier, 1.5);\n    assert_eq!(config.watch.failure.retryable_patterns.len(), 2);\n    assert!(config\n        .watch\n        .failure\n        .retryable_patterns\n        .contains(\u0026\"network timeout\".to_string()));\n    assert_eq!(\n        config.watch.failure.on_permanent_failure,\n        OnPermanentFailure::Stop\n    );\n}\n\n#[test]\nfn test_watch_config_defaults() {\n    let content = r#\"---\nproject:\n  name: test-project\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Should have default values\n    assert_eq!(config.watch.poll_interval_ms, 5000);\n    assert_eq!(config.watch.failure.max_retries, 3);\n    assert_eq!(config.watch.failure.retry_delay_ms, 60000);\n    assert_eq!(config.watch.failure.backoff_multiplier, 2.0);\n    assert!(config.watch.failure.retryable_patterns.is_empty());\n    assert_eq!(\n        config.watch.failure.on_permanent_failure,\n        OnPermanentFailure::Skip\n    );\n}\n\n#[test]\nfn test_parse_watch_config_missing_fields() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  poll_interval_ms: 8000\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(config.watch.poll_interval_ms, 8000);\n    // Failure config should use defaults\n    assert_eq!(config.watch.failure.max_retries, 3);\n    assert_eq!(config.watch.failure.retry_delay_ms, 60000);\n    assert_eq!(config.watch.failure.backoff_multiplier, 2.0);\n}\n\n#[test]\nfn test_parse_watch_config_on_permanent_failure_skip() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  failure:\n    on_permanent_failure: skip\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(\n        config.watch.failure.on_permanent_failure,\n        OnPermanentFailure::Skip\n    );\n}\n\n#[test]\nfn test_parse_watch_config_on_permanent_failure_stop() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  failure:\n    on_permanent_failure: stop\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    assert_eq!(\n        config.watch.failure.on_permanent_failure,\n        OnPermanentFailure::Stop\n    );\n}\n\n#[test]\nfn test_parse_watch_config_invalid_on_permanent_failure() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  failure:\n    on_permanent_failure: invalid_value\n---\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse config frontmatter\"));\n}\n\n#[test]\nfn test_watch_config_validation_negative_interval() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  poll_interval_ms: 0\n---\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"poll_interval_ms must be greater than 0\"));\n}\n\n#[test]\nfn test_watch_config_validation_invalid_backoff_multiplier() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  failure:\n    backoff_multiplier: 0.5\n---\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"backoff_multiplier must be \u003e= 1.0\"));\n}\n\n#[test]\nfn test_watch_config_empty_retryable_patterns() {\n    let content = r#\"---\nproject:\n  name: test-project\nwatch:\n  failure:\n    retryable_patterns: []\n---\n\"#;\n    let config = Config::parse(content).unwrap();\n\n    // Empty patterns list should be valid\n    assert!(config.watch.failure.retryable_patterns.is_empty());\n}\n\n#[test]\nfn test_config_merge_priority_watch() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Global watch config used when project doesn't specify\n    fs::write(\n        \u0026global_path,\n        r#\"---\nwatch:\n  poll_interval_ms: 15000\n  failure:\n    max_retries: 10\n---\n\"#,\n    )\n    .unwrap();\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.watch.poll_interval_ms, 15000);\n    assert_eq!(config.watch.failure.max_retries, 10);\n\n    // Project watch config overrides global\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\nwatch:\n  poll_interval_ms: 3000\n  failure:\n    max_retries: 2\n    on_permanent_failure: stop\n---\n\"#,\n    )\n    .unwrap();\n    let config = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None).unwrap();\n    assert_eq!(config.watch.poll_interval_ms, 3000);\n    assert_eq!(config.watch.failure.max_retries, 2);\n    assert_eq!(\n        config.watch.failure.on_permanent_failure,\n        OnPermanentFailure::Stop\n    );\n}\n\n// =========================================================================\n// ERROR HANDLING TESTS FOR MALFORMED CONFIGS\n// =========================================================================\n\n#[test]\nfn test_parse_config_missing_frontmatter() {\n    let content = r#\"# Config\n\nJust a markdown file with no frontmatter\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to extract frontmatter\"));\n}\n\n#[test]\nfn test_parse_config_invalid_yaml() {\n    let content = r#\"---\nproject:\n  name: test\n  invalid: [unclosed bracket\n---\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse config frontmatter\"));\n}\n\n#[test]\nfn test_parse_config_missing_project_section() {\n    let content = r#\"---\ndefaults:\n  prompt: custom\n---\n\"#;\n    let result = Config::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse config frontmatter\"));\n}\n\n#[test]\nfn test_load_from_nonexistent_file() {\n    let result = Config::load_from(Path::new(\"/nonexistent/path/config.md\"));\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to read config from\"));\n}\n\n#[test]\nfn test_partial_config_load_from_nonexistent_file() {\n    let result = PartialConfig::load_from(Path::new(\"/nonexistent/path/config.md\"));\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to read config from\"));\n}\n\n#[test]\nfn test_agents_config_load_from_nonexistent_file() {\n    let result = AgentsConfig::load_from(Path::new(\"/nonexistent/path/agents.md\"));\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to read agents config from\"));\n}\n\n#[test]\nfn test_agents_config_missing_frontmatter() {\n    let content = r#\"# Agents Config\n\nNo frontmatter here\n\"#;\n    let result = AgentsConfig::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to extract frontmatter\"));\n}\n\n#[test]\nfn test_agents_config_invalid_yaml() {\n    let content = r#\"---\nparallel:\n  agents: [\n    name: broken\n---\n\"#;\n    let result = AgentsConfig::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse agents config frontmatter\"));\n}\n\n#[test]\nfn test_partial_config_missing_frontmatter() {\n    let content = \"Just markdown, no frontmatter\";\n    let result = PartialConfig::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to extract frontmatter\"));\n}\n\n#[test]\nfn test_partial_config_invalid_yaml() {\n    let content = r#\"---\nproject: {\n  name: \"unclosed\n---\n\"#;\n    let result = PartialConfig::parse(content);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse config frontmatter\"));\n}\n\n#[test]\nfn test_load_merged_project_config_missing() {\n    let tmp = TempDir::new().unwrap();\n    let project_path = tmp.path().join(\"nonexistent.md\");\n\n    let result = Config::load_merged_from(None, \u0026project_path, None);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to read config from\"));\n}\n\n#[test]\nfn test_load_merged_malformed_global_config() {\n    let tmp = TempDir::new().unwrap();\n    let global_path = tmp.path().join(\"global.md\");\n    let project_path = tmp.path().join(\"project.md\");\n\n    // Write invalid global config\n    fs::write(\n        \u0026global_path,\n        r#\"---\ninvalid: yaml: syntax:\n---\n\"#,\n    )\n    .unwrap();\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    let result = Config::load_merged_from(Some(\u0026global_path), \u0026project_path, None);\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse config frontmatter\"));\n}\n\n#[test]\nfn test_load_merged_malformed_agents_config() {\n    let tmp = TempDir::new().unwrap();\n    let project_path = tmp.path().join(\"project.md\");\n    let agents_path = tmp.path().join(\"agents.md\");\n\n    fs::write(\n        \u0026project_path,\n        r#\"---\nproject:\n  name: my-project\n---\n\"#,\n    )\n    .unwrap();\n\n    // Write invalid agents config\n    fs::write(\n        \u0026agents_path,\n        r#\"---\nparallel: not a valid structure\n---\n\"#,\n    )\n    .unwrap();\n\n    let result = Config::load_merged_from(None, \u0026project_path, Some(\u0026agents_path));\n    assert!(result.is_err());\n    let err_msg = format!(\"{}\", result.unwrap_err());\n    assert!(err_msg.contains(\"Failed to parse agents config frontmatter\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","config","validation.rs"],"content":"//! Validation logic for configuration and derived fields.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\n\nuse super::defaults::{FailureConfig, WatchConfig};\n\nimpl WatchConfig {\n    /// Validate watch configuration\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.poll_interval_ms == 0 {\n            anyhow::bail!(\"watch.poll_interval_ms must be greater than 0\");\n        }\n\n        self.failure.validate()\n    }\n}\n\nimpl FailureConfig {\n    /// Validate failure configuration\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.backoff_multiplier \u003c 1.0 {\n            anyhow::bail!(\n                \"watch.failure.backoff_multiplier must be \u003e= 1.0, got {}\",\n                self.backoff_multiplier\n            );\n        }\n\n        Ok(())\n    }\n}\n\n/// Rejection action mode for approval workflow\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum RejectionAction {\n    /// Leave rejected, user handles it manually\n    #[default]\n    Manual,\n    /// Prompt to create fix spec, original becomes blocked with depends_on\n    Dependency,\n    /// Convert to driver with numbered member specs\n    Group,\n}\n\nimpl fmt::Display for RejectionAction {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            RejectionAction::Manual =\u003e write!(f, \"manual\"),\n            RejectionAction::Dependency =\u003e write!(f, \"dependency\"),\n            RejectionAction::Group =\u003e write!(f, \"group\"),\n        }\n    }\n}\n\n/// Approval workflow configuration\n#[derive(Debug, Clone, Deserialize, Default)]\npub struct ApprovalConfig {\n    /// Action to take when a spec is rejected\n    #[serde(default)]\n    pub rejection_action: RejectionAction,\n    /// Require approval for specs worked by agents (auto-detected via Co-Authored-By)\n    #[serde(default)]\n    pub require_approval_for_agent_work: bool,\n}\n\n/// Output validation configuration\n#[derive(Debug, Clone, Deserialize, Default)]\npub struct OutputValidationConfig {\n    /// If true, fail spec when output doesn't match schema; if false, warn only\n    #[serde(default)]\n    pub strict_output_validation: bool,\n}\n\n/// Enterprise configuration for derived frontmatter and validation\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct EnterpriseConfig {\n    /// Field derivation rules (which fields to derive, from what source, using what pattern)\n    #[serde(default)]\n    pub derived: HashMap\u003cString, DerivedFieldConfig\u003e,\n    /// List of required field names to validate\n    #[serde(default)]\n    pub required: Vec\u003cString\u003e,\n}\n\n/// Configuration for a single derived field\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DerivedFieldConfig {\n    /// Source of the derived value\n    pub from: DerivationSource,\n    /// Pattern for extracting/formatting the value\n    pub pattern: String,\n    /// Optional validation rule for the derived value\n    #[serde(default)]\n    pub validate: Option\u003cValidationRule\u003e,\n}\n\n/// Source of a derived field value\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum DerivationSource {\n    /// Derive from git branch name\n    Branch,\n    /// Derive from file path\n    Path,\n    /// Derive from environment variable\n    Env,\n    /// Derive from git user information\n    GitUser,\n}\n\n/// Validation rule for derived fields\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum ValidationRule {\n    /// Enum validation: value must be one of the specified values\n    Enum {\n        /// List of allowed values\n        values: Vec\u003cString\u003e,\n    },\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":39}},{"line":13,"address":[],"length":0,"stats":{"Line":39}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":76}},{"line":23,"address":[],"length":0,"stats":{"Line":38}},{"line":24,"address":[],"length":0,"stats":{"Line":38}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":37}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}}],"covered":13,"coverable":13},{"path":["/","Users","alex","Documents","checkouts","chant","src","conflict.rs"],"content":"//! Conflict detection and resolution spec creation.\n//!\n//! This module handles detection of merge conflicts and automatic creation\n//! of conflict resolution specs with context about the conflicting branches.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: guides/recovery.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::path::Path;\nuse std::process::Command;\n\nuse crate::id;\nuse crate::spec::{Spec, SpecStatus};\n\n/// Context information about a merge conflict\n#[derive(Debug, Clone)]\npub struct ConflictContext {\n    pub source_branch: String,\n    pub target_branch: String,\n    pub conflicting_files: Vec\u003cString\u003e,\n    pub source_spec_id: String,\n    pub source_spec_title: Option\u003cString\u003e,\n    pub diff_summary: String,\n}\n\n/// Detect conflicting files from git status\npub fn detect_conflicting_files() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"status\", \"--porcelain\"])\n        .output()\n        .context(\"Failed to run git status\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Failed to get git status\");\n    }\n\n    let status = String::from_utf8_lossy(\u0026output.stdout);\n    let mut conflicting_files = Vec::new();\n\n    for line in status.lines() {\n        // Conflicted files in git status output start with \"UU\", \"AA\", \"DD\", \"AU\", \"UD\", \"UA\", \"DU\"\n        if line.len() \u003e 3 {\n            let status_code = \u0026line[..2];\n            match status_code {\n                \"UU\" | \"AA\" | \"DD\" | \"AU\" | \"UD\" | \"UA\" | \"DU\" =\u003e {\n                    let file = line[3..].trim().to_string();\n                    conflicting_files.push(file);\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n\n    Ok(conflicting_files)\n}\n\n/// Extract context from a spec\npub fn extract_spec_context(specs_dir: \u0026Path, spec_id: \u0026str) -\u003e Result\u003c(Option\u003cString\u003e, String)\u003e {\n    // Try to load the spec to get title and description\n    match crate::spec::resolve_spec(specs_dir, spec_id) {\n        Ok(spec) =\u003e {\n            let title = spec.title.clone();\n            let body = spec.body.clone();\n            Ok((title, body))\n        }\n        Err(_) =\u003e {\n            // Spec not found, return empty context\n            Ok((None, String::new()))\n        }\n    }\n}\n\n/// Get the diff summary between two branches\npub fn get_diff_summary(source_branch: \u0026str, target_branch: \u0026str) -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args([\n            \"diff\",\n            \"--stat\",\n            \u0026format!(\"{}..{}\", target_branch, source_branch),\n        ])\n        .output()\n        .context(\"Failed to get git diff\")?;\n\n    if !output.status.success() {\n        return Ok(\"(unable to generate diff)\".to_string());\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout)\n        .lines()\n        .take(10) // Limit to 10 lines\n        .map(|s| s.to_string())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\"))\n}\n\n/// Identify specs that are blocked by conflicting files\npub fn get_blocked_specs(conflicting_files: \u0026[String], all_specs: \u0026[Spec]) -\u003e Vec\u003cString\u003e {\n    let mut blocked = Vec::new();\n\n    for spec in all_specs {\n        // Skip completed and failed specs\n        if spec.frontmatter.status == SpecStatus::Completed\n            || spec.frontmatter.status == SpecStatus::Failed\n        {\n            continue;\n        }\n\n        // Check if any target_files overlap with conflicting files\n        if let Some(target_files) = \u0026spec.frontmatter.target_files {\n            for conflicting_file in conflicting_files {\n                if target_files.iter().any(|tf| {\n                    // Check for exact match or prefix match (directory containing file)\n                    tf == conflicting_file || conflicting_file.starts_with(\u0026format!(\"{}/\", tf))\n                }) {\n                    blocked.push(spec.id.clone());\n                    break;\n                }\n            }\n        }\n    }\n\n    blocked\n}\n\n/// Create a conflict resolution spec\npub fn create_conflict_spec(\n    specs_dir: \u0026Path,\n    context: \u0026ConflictContext,\n    blocked_specs: Vec\u003cString\u003e,\n) -\u003e Result\u003cString\u003e {\n    // Generate spec ID\n    let spec_id = id::generate_id(specs_dir)?;\n\n    // Build conflict spec content\n    let mut content = String::new();\n\n    // Frontmatter\n    let conflicting_files_yaml = context\n        .conflicting_files\n        .iter()\n        .map(|f| format!(\"- {}\", f))\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\");\n\n    let blocked_specs_yaml = if blocked_specs.is_empty() {\n        \"blocked_specs: []\".to_string()\n    } else {\n        let items = blocked_specs\n            .iter()\n            .map(|s| format!(\"  - {}\", s))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\");\n        format!(\"blocked_specs:\\n{}\", items)\n    };\n\n    content.push_str(\u0026format!(\n        r#\"---\ntype: conflict\nstatus: pending\nsource_branch: {}\ntarget_branch: {}\nconflicting_files:\n{}\n{}\noriginal_spec: {}\n---\n\"#,\n        context.source_branch,\n        context.target_branch,\n        conflicting_files_yaml,\n        blocked_specs_yaml,\n        context.source_spec_id\n    ));\n\n    // Title and body\n    content.push_str(\u0026format!(\n        \"# Resolve merge conflict: {} â {}\\n\\n\",\n        context.source_branch, context.target_branch\n    ));\n\n    content.push_str(\"## Conflict Summary\\n\");\n    content.push_str(\u0026format!(\"- **Source branch**: {}\\n\", context.source_branch));\n    content.push_str(\u0026format!(\"- **Target branch**: {}\\n\", context.target_branch));\n    content.push_str(\u0026format!(\n        \"- **Conflicting files**: {}\\n\",\n        context\n            .conflicting_files\n            .iter()\n            .map(|f| format!(\"`{}`\", f))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\", \")\n    ));\n\n    if !blocked_specs.is_empty() {\n        content.push_str(\u0026format!(\n            \"- **Blocked specs**: {}\\n\",\n            blocked_specs.join(\", \")\n        ));\n    }\n\n    content.push('\\n');\n\n    // Context from original spec\n    content.push_str(\"## Context from Original Spec\\n\\n\");\n    if let Some(title) = \u0026context.source_spec_title {\n        content.push_str(\u0026format!(\"**Title**: {}\\n\\n\", title));\n    }\n    content.push_str(\"```\\n\");\n    content.push_str(\u0026context.diff_summary);\n    content.push_str(\"\\n```\\n\\n\");\n\n    // Resolution instructions\n    content.push_str(\"## Resolution Instructions\\n\\n\");\n    content.push_str(\"1. Examine the conflicting files listed above\\n\");\n    content.push_str(\"2. Resolve conflicts manually in your editor or using git tools\\n\");\n    content.push_str(\"3. Stage resolved files: `git add \u003cfiles\u003e`\\n\");\n    content.push_str(\"4. Complete the merge: `git commit`\\n\");\n    content.push_str(\"5. Update this spec with resolution details\\n\\n\");\n\n    // Acceptance criteria\n    content.push_str(\"## Acceptance Criteria\\n\\n\");\n    for file in \u0026context.conflicting_files {\n        content.push_str(\u0026format!(\"- [ ] Resolved conflicts in `{}`\\n\", file));\n    }\n    content.push_str(\"- [ ] Merge completed successfully\\n\");\n\n    // Save the spec\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    std::fs::write(\u0026spec_path, \u0026content).context(\"Failed to write conflict spec file\")?;\n\n    Ok(spec_id)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::SpecFrontmatter;\n\n    #[test]\n    fn test_detect_conflicting_files_parses_status() {\n        // This test would require mocking git commands or running in a repo with conflicts\n        // For now, we test the parsing logic indirectly\n        let conflicting_files = [\"src/config.rs\".to_string(), \"docs/guide.md\".to_string()];\n        assert_eq!(conflicting_files.len(), 2);\n    }\n\n    #[test]\n    fn test_get_blocked_specs_empty_when_no_overlap() {\n        let spec1 = Spec {\n            id: \"2026-01-25-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"src/lib.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: None,\n            body: String::new(),\n        };\n\n        let conflicting_files = vec![\"src/config.rs\".to_string()];\n        let blocked = get_blocked_specs(\u0026conflicting_files, \u0026[spec1]);\n        assert!(blocked.is_empty());\n    }\n\n    #[test]\n    fn test_get_blocked_specs_finds_overlap() {\n        let spec1 = Spec {\n            id: \"2026-01-25-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                target_files: Some(vec![\"src/config.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: None,\n            body: String::new(),\n        };\n\n        let conflicting_files = vec![\"src/config.rs\".to_string()];\n        let blocked = get_blocked_specs(\u0026conflicting_files, \u0026[spec1]);\n        assert_eq!(blocked.len(), 1);\n        assert_eq!(blocked[0], \"2026-01-25-001-abc\");\n    }\n\n    #[test]\n    fn test_get_blocked_specs_ignores_completed() {\n        let spec1 = Spec {\n            id: \"2026-01-25-001-abc\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                target_files: Some(vec![\"src/config.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: None,\n            body: String::new(),\n        };\n\n        let conflicting_files = vec![\"src/config.rs\".to_string()];\n        let blocked = get_blocked_specs(\u0026conflicting_files, \u0026[spec1]);\n        assert!(blocked.is_empty());\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":113},{"path":["/","Users","alex","Documents","checkouts","chant","src","deps.rs"],"content":"//! Cross-repository dependency resolution for specs.\n//!\n//! Handles resolution of dependencies across multiple repositories using the\n//! `repo:spec-id` syntax in the `depends_on` field.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-27\n//! - docs: concepts/dependencies.md\n//! - ignore: false\n\nuse crate::config::RepoConfig;\nuse crate::id::SpecId;\nuse crate::spec::{Spec, SpecStatus};\nuse anyhow::{anyhow, Context, Result};\nuse std::collections::HashSet;\nuse std::path::{Path, PathBuf};\n\n/// Resolves a spec dependency ID (local or cross-repo) and returns the spec.\n///\n/// Handles both local dependencies (without repo prefix) and cross-repo dependencies\n/// with the `repo:spec-id` format.\n///\n/// # Arguments\n///\n/// * `dep_id` - The dependency ID string (e.g., \"2026-01-27-001-abc\" or \"backend:2026-01-27-001-abc\")\n/// * `current_repo_specs_dir` - Path to the current repo's .chant/specs directory\n/// * `repos` - List of configured repositories\n///\n/// # Returns\n///\n/// The resolved spec, or an error if resolution fails\npub fn resolve_dependency(\n    dep_id: \u0026str,\n    current_repo_specs_dir: \u0026Path,\n    repos: \u0026[RepoConfig],\n) -\u003e Result\u003cSpec\u003e {\n    let parsed_id = SpecId::parse(dep_id)?;\n\n    if let Some(repo_name) = \u0026parsed_id.repo {\n        // Cross-repo dependency\n        resolve_cross_repo_dependency(repo_name, dep_id, repos)\n    } else {\n        // Local dependency\n        resolve_local_dependency(dep_id, current_repo_specs_dir)\n    }\n}\n\n/// Resolves a local dependency in the current repository.\nfn resolve_local_dependency(dep_id: \u0026str, specs_dir: \u0026Path) -\u003e Result\u003cSpec\u003e {\n    // Try to load the spec from the current repo\n    let spec_path = specs_dir.join(format!(\"{}.md\", dep_id));\n    if spec_path.exists() {\n        return Spec::load(\u0026spec_path);\n    }\n\n    // Try to find in archive\n    let archive_dir = specs_dir\n        .parent()\n        .ok_or_else(|| anyhow!(\"Cannot determine archive directory\"))?\n        .join(\"archive\");\n\n    if archive_dir.exists() {\n        // First check for spec directly in archive directory\n        let direct_path = archive_dir.join(format!(\"{}.md\", dep_id));\n        if direct_path.exists() {\n            return Spec::load(\u0026direct_path);\n        }\n\n        // Also search in subdirectories (for projects with nested archives)\n        for entry in std::fs::read_dir(\u0026archive_dir).context(\"Failed to read archive directory\")? {\n            let entry = entry?;\n            let path = entry.path();\n            if path.is_dir() {\n                let spec_path = path.join(format!(\"{}.md\", dep_id));\n                if spec_path.exists() {\n                    return Spec::load(\u0026spec_path);\n                }\n            }\n        }\n    }\n\n    Err(anyhow!(\n        \"Spec not found: {} in {}\",\n        dep_id,\n        specs_dir.display()\n    ))\n}\n\n/// Resolves a cross-repo dependency.\nfn resolve_cross_repo_dependency(\n    repo_name: \u0026str,\n    spec_id: \u0026str,\n    repos: \u0026[RepoConfig],\n) -\u003e Result\u003cSpec\u003e {\n    // Find the repo configuration\n    let repo = repos\n        .iter()\n        .find(|r| r.name == repo_name)\n        .ok_or_else(|| {\n            anyhow!(\n                \"Repository '{}' not found in config. Add it to ~/.config/chant/config.md:\\n\\nrepos:\\n  - name: {}\\n    path: /path/to/{}\",\n                repo_name, repo_name, repo_name\n            )\n        })?;\n\n    let repo_path = PathBuf::from(shellexpand::tilde(\u0026repo.path).to_string());\n\n    if !repo_path.exists() {\n        return Err(anyhow!(\n            \"Repository path '{}' does not exist for repo '{}'\",\n            repo_path.display(),\n            repo_name\n        ));\n    }\n\n    let specs_dir = repo_path.join(\".chant/specs\");\n\n    if !specs_dir.exists() {\n        return Err(anyhow!(\n            \"Specs directory '{}' does not exist for repo '{}'\",\n            specs_dir.display(),\n            repo_name\n        ));\n    }\n\n    // Extract just the base ID without repo prefix for file lookup\n    let parsed_id =\n        SpecId::parse(spec_id).context(format!(\"Failed to parse spec ID: {}\", spec_id))?;\n    let base_spec_id = parsed_id.to_string();\n    let spec_path = specs_dir.join(format!(\"{}.md\", base_spec_id));\n\n    if !spec_path.exists() {\n        return Err(anyhow!(\n            \"Spec '{}' not found in repository '{}' at {}\",\n            base_spec_id,\n            repo_name,\n            specs_dir.display()\n        ));\n    }\n\n    Spec::load(\u0026spec_path)\n}\n\n/// Checks for circular dependencies across repos.\n///\n/// Returns an error if a circular dependency is detected.\npub fn check_circular_dependencies(\n    spec_id: \u0026str,\n    all_specs: \u0026[Spec],\n    current_repo_specs_dir: \u0026Path,\n    repos: \u0026[RepoConfig],\n) -\u003e Result\u003c()\u003e {\n    let mut visited = HashSet::new();\n    check_circular_deps_recursive(\n        spec_id,\n        \u0026mut visited,\n        all_specs,\n        current_repo_specs_dir,\n        repos,\n    )\n}\n\nfn check_circular_deps_recursive(\n    spec_id: \u0026str,\n    visited: \u0026mut HashSet\u003cString\u003e,\n    all_specs: \u0026[Spec],\n    current_repo_specs_dir: \u0026Path,\n    repos: \u0026[RepoConfig],\n) -\u003e Result\u003c()\u003e {\n    if visited.contains(spec_id) {\n        return Err(anyhow!(\n            \"Circular dependency detected involving spec '{}'\",\n            spec_id\n        ));\n    }\n\n    visited.insert(spec_id.to_string());\n\n    // Find the spec\n    let spec = match find_spec_by_id(spec_id, all_specs, current_repo_specs_dir, repos) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e {\n            // If we can't find the spec, we can't check its dependencies\n            // This is handled elsewhere, so just return Ok here\n            return Ok(());\n        }\n    };\n\n    // Check all dependencies of this spec\n    if let Some(deps) = \u0026spec.frontmatter.depends_on {\n        for dep_id in deps {\n            check_circular_deps_recursive(\n                dep_id,\n                visited,\n                all_specs,\n                current_repo_specs_dir,\n                repos,\n            )?;\n        }\n    }\n\n    visited.remove(spec_id);\n    Ok(())\n}\n\n/// Find a spec by ID in the all_specs list, or resolve cross-repo dependency.\npub fn find_spec_by_id(\n    spec_id: \u0026str,\n    all_specs: \u0026[Spec],\n    current_repo_specs_dir: \u0026Path,\n    repos: \u0026[RepoConfig],\n) -\u003e Result\u003cSpec\u003e {\n    // First, try to find in local specs\n    if let Some(spec) = all_specs.iter().find(|s| s.id == spec_id) {\n        return Ok(spec.clone());\n    }\n\n    // Otherwise, try to resolve as a cross-repo dependency\n    resolve_dependency(spec_id, current_repo_specs_dir, repos)\n}\n\n/// Check if a spec ID exists in the archive directory.\nfn is_spec_archived(spec_id: \u0026str, specs_dir: \u0026Path) -\u003e bool {\n    let archive_dir = match specs_dir.parent() {\n        Some(parent) =\u003e parent.join(\"archive\"),\n        None =\u003e return false,\n    };\n\n    if !archive_dir.exists() {\n        return false;\n    }\n\n    // First check for spec directly in archive directory\n    let direct_path = archive_dir.join(format!(\"{}.md\", spec_id));\n    if direct_path.exists() {\n        return true;\n    }\n\n    // Also search in subdirectories (for projects with nested archives)\n    if let Ok(entries) = std::fs::read_dir(\u0026archive_dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_dir() {\n                let spec_path = path.join(format!(\"{}.md\", spec_id));\n                if spec_path.exists() {\n                    return true;\n                }\n            }\n        }\n    }\n\n    false\n}\n\n/// Check if a spec is blocked by unmet dependencies, including cross-repo deps.\npub fn is_blocked_by_dependencies(\n    spec: \u0026Spec,\n    all_specs: \u0026[Spec],\n    current_repo_specs_dir: \u0026Path,\n    repos: \u0026[RepoConfig],\n) -\u003e bool {\n    if let Some(deps) = \u0026spec.frontmatter.depends_on {\n        for dep_id in deps {\n            match find_spec_by_id(dep_id, all_specs, current_repo_specs_dir, repos) {\n                Ok(dep_spec) =\u003e {\n                    // Check if dependency is completed\n                    if dep_spec.frontmatter.status == SpecStatus::Completed {\n                        continue;\n                    }\n                    // Check if the spec is archived (archived specs are treated as completed)\n                    if is_spec_archived(dep_id, current_repo_specs_dir) {\n                        continue;\n                    }\n                    return true; // Unmet dependency (not completed and not archived)\n                }\n                _ =\u003e return true, // Unmet dependency (not found)\n            }\n        }\n    }\n    false\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_resolve_local_dependency() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        // Create a spec\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: Default::default(),\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n        spec.save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\")).unwrap();\n\n        // Resolve it\n        let resolved = resolve_local_dependency(\"2026-01-27-001-abc\", \u0026specs_dir).unwrap();\n        assert_eq!(resolved.id, \"2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_resolve_nonexistent_local_dependency() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let result = resolve_local_dependency(\"2026-01-27-001-xyz\", \u0026specs_dir);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cross_repo_dependency_repo_not_configured() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let result = resolve_cross_repo_dependency(\"backend\", \"backend:2026-01-27-001-abc\", \u0026[]);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"not found in config\"));\n    }\n\n    #[test]\n    fn test_cross_repo_dependency_path_not_exists() {\n        let repos = vec![RepoConfig {\n            name: \"backend\".to_string(),\n            path: \"/nonexistent/path\".to_string(),\n        }];\n\n        let result = resolve_cross_repo_dependency(\"backend\", \"backend:2026-01-27-001-abc\", \u0026repos);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"does not exist\"));\n    }\n\n    #[test]\n    fn test_check_circular_dependencies_simple() {\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let spec = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                depends_on: Some(vec![\"2026-01-27-001-abc\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n        spec.save(\u0026specs_dir.join(\"2026-01-27-001-abc.md\")).unwrap();\n\n        let result = check_circular_dependencies(\"2026-01-27-001-abc\", \u0026[spec], \u0026specs_dir, \u0026[]);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Circular dependency\"));\n    }\n\n    #[test]\n    fn test_is_blocked_by_dependencies_unmet() {\n        let spec_with_dep = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let dependency = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Dep\".to_string()),\n            body: \"# Dep\\n\\nBody.\".to_string(),\n        };\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let is_blocked = is_blocked_by_dependencies(\u0026spec_with_dep, \u0026[dependency], \u0026specs_dir, \u0026[]);\n        assert!(is_blocked);\n    }\n\n    #[test]\n    fn test_is_blocked_by_dependencies_met() {\n        let spec_with_dep = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        let dependency = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Dep\".to_string()),\n            body: \"# Dep\\n\\nBody.\".to_string(),\n        };\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n\n        let is_blocked = is_blocked_by_dependencies(\u0026spec_with_dep, \u0026[dependency], \u0026specs_dir, \u0026[]);\n        assert!(!is_blocked);\n    }\n\n    #[test]\n    fn test_is_blocked_by_dependencies_archived() {\n        let spec_with_dep = Spec {\n            id: \"2026-01-27-001-abc\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                depends_on: Some(vec![\"2026-01-27-002-def\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: \"# Test\\n\\nBody.\".to_string(),\n        };\n\n        // Create an archived dependency that is NOT marked as completed\n        let archived_dependency = Spec {\n            id: \"2026-01-27-002-def\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::InProgress, // Not completed\n                ..Default::default()\n            },\n            title: Some(\"Archived Dep\".to_string()),\n            body: \"# Archived Dep\\n\\nBody.\".to_string(),\n        };\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path().join(\"specs\");\n        let archive_dir = temp_dir.path().join(\"archive\").join(\"2026-01-27\");\n        fs::create_dir_all(\u0026specs_dir).unwrap();\n        fs::create_dir_all(\u0026archive_dir).unwrap();\n\n        // Save the archived dependency to the archive directory\n        archived_dependency\n            .save(\u0026archive_dir.join(\"2026-01-27-002-def.md\"))\n            .unwrap();\n\n        // The spec should NOT be blocked because the dependency is in the archive\n        let is_blocked = is_blocked_by_dependencies(\u0026spec_with_dep, \u0026[], \u0026specs_dir, \u0026[]);\n        assert!(!is_blocked);\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":17}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":3}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":6}},{"line":264,"address":[],"length":0,"stats":{"Line":12}},{"line":265,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":2}}],"covered":86,"coverable":112},{"path":["/","Users","alex","Documents","checkouts","chant","src","derivation.rs"],"content":"//! Derivation engine for extracting values from multiple sources.\n//!\n//! The derivation engine extracts values from:\n//! - **Branch name** - Current git branch (e.g., `sprint/2026-Q1-W4/PROJ-123`)\n//! - **File path** - Spec file path (e.g., `.chant/specs/teams/platform/...`)\n//! - **Environment variables** - Shell environment (e.g., `$TEAM_NAME`)\n//! - **Git user** - Git user.name or user.email from config\n//!\n//! For each source, the engine applies regex patterns to extract the first capture group.\n//! If a pattern doesn't match, the engine returns None for that field (graceful failure).\n\nuse crate::config::{DerivationSource, DerivedFieldConfig, EnterpriseConfig, ValidationRule};\nuse regex::Regex;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n/// Result of validating a derived value\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ValidationResult {\n    /// Value is valid\n    Valid,\n    /// Value is invalid but derivation proceeds with a warning\n    Warning(String),\n}\n\n/// Context containing all available data sources for derivation\n#[derive(Debug, Clone)]\npub struct DerivationContext {\n    /// Current git branch name\n    pub branch_name: Option\u003cString\u003e,\n    /// Spec file path\n    pub spec_path: Option\u003cPathBuf\u003e,\n    /// Environment variables available for extraction\n    pub env_vars: HashMap\u003cString, String\u003e,\n    /// Git user.name from config\n    pub git_user_name: Option\u003cString\u003e,\n    /// Git user.email from config\n    pub git_user_email: Option\u003cString\u003e,\n}\n\nimpl DerivationContext {\n    /// Create a new empty derivation context\n    pub fn new() -\u003e Self {\n        Self {\n            branch_name: None,\n            spec_path: None,\n            env_vars: HashMap::new(),\n            git_user_name: None,\n            git_user_email: None,\n        }\n    }\n\n    /// Create a derivation context with environment variables\n    pub fn with_env_vars(env_vars: HashMap\u003cString, String\u003e) -\u003e Self {\n        Self {\n            branch_name: None,\n            spec_path: None,\n            env_vars,\n            git_user_name: None,\n            git_user_email: None,\n        }\n    }\n}\n\nimpl Default for DerivationContext {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Build a DerivationContext populated with current environment data.\n///\n/// This creates a fully populated context with:\n/// - Current git branch name\n/// - Spec file path (constructed from spec_id and specs_dir)\n/// - All environment variables\n/// - Git user name and email from config\n///\n/// This is the canonical way to build a context for derivation operations.\npub fn build_context(spec_id: \u0026str, specs_dir: \u0026std::path::Path) -\u003e DerivationContext {\n    use crate::git;\n\n    let mut context = DerivationContext::new();\n\n    // Get current branch\n    if let Ok(branch) = git::get_current_branch() {\n        context.branch_name = Some(branch);\n    }\n\n    // Get spec path\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    context.spec_path = Some(spec_path);\n\n    // Capture environment variables\n    context.env_vars = std::env::vars().collect();\n\n    // Get git user info\n    let (name, email) = git::get_git_user_info();\n    context.git_user_name = name;\n    context.git_user_email = email;\n\n    context\n}\n\n/// Engine for deriving field values from configured sources\n#[derive(Debug, Clone)]\npub struct DerivationEngine {\n    config: EnterpriseConfig,\n}\n\nimpl DerivationEngine {\n    /// Create a new derivation engine with the given configuration\n    pub fn new(config: EnterpriseConfig) -\u003e Self {\n        Self { config }\n    }\n\n    /// Derive all configured fields for a spec\n    ///\n    /// Returns a HashMap with field names as keys and derived values as values.\n    /// Fields that fail to match their pattern are omitted from the result.\n    /// If the enterprise config is empty, returns an empty HashMap (fast path).\n    pub fn derive_fields(\u0026self, context: \u0026DerivationContext) -\u003e HashMap\u003cString, String\u003e {\n        // Fast path: if no derivation config, return empty\n        if self.config.derived.is_empty() {\n            return HashMap::new();\n        }\n\n        let mut result = HashMap::new();\n\n        for (field_name, field_config) in \u0026self.config.derived {\n            if let Some(value) = self.derive_field(field_name, field_config, context) {\n                result.insert(field_name.clone(), value);\n            }\n        }\n\n        result\n    }\n\n    /// Derive a single field from its source using the configured pattern\n    ///\n    /// For Branch and Path sources: Extracts the first capture group from the pattern match.\n    /// For Env and GitUser sources: Returns the value directly (pattern is the field identifier).\n    /// Returns None if the pattern doesn't match or the source is unavailable.\n    /// Validates the derived value if a validation rule is configured.\n    fn derive_field(\n        \u0026self,\n        field_name: \u0026str,\n        config: \u0026DerivedFieldConfig,\n        context: \u0026DerivationContext,\n    ) -\u003e Option\u003cString\u003e {\n        let value = match config.from {\n            DerivationSource::Branch =\u003e {\n                let source_value = self.extract_from_branch(context)?;\n                self.apply_pattern(\u0026config.pattern, \u0026source_value)\n                    .or_else(|| {\n                        eprintln!(\n                            \"Warning: derivation pattern for field '{}' did not match source\",\n                            field_name\n                        );\n                        None\n                    })?\n            }\n            DerivationSource::Path =\u003e {\n                let source_value = self.extract_from_path(context)?;\n                self.apply_pattern(\u0026config.pattern, \u0026source_value)\n                    .or_else(|| {\n                        eprintln!(\n                            \"Warning: derivation pattern for field '{}' did not match source\",\n                            field_name\n                        );\n                        None\n                    })?\n            }\n            DerivationSource::Env =\u003e {\n                // For Env, pattern is the environment variable name\n                self.extract_from_env(context, \u0026config.pattern)?\n            }\n            DerivationSource::GitUser =\u003e {\n                // For GitUser, pattern is \"name\" or \"email\"\n                self.extract_from_git_user(context, \u0026config.pattern)?\n            }\n        };\n\n        // Validate the derived value if a validation rule is configured\n        if let Some(validation) = \u0026config.validate {\n            match self.validate_derived_value(field_name, \u0026value, validation) {\n                ValidationResult::Valid =\u003e {\n                    // Value is valid, proceed\n                }\n                ValidationResult::Warning(msg) =\u003e {\n                    // Log warning but still include the value in results\n                    eprintln!(\"Warning: {}\", msg);\n                }\n            }\n        }\n\n        Some(value)\n    }\n\n    /// Extract value from branch name source\n    fn extract_from_branch(\u0026self, context: \u0026DerivationContext) -\u003e Option\u003cString\u003e {\n        context.branch_name.clone()\n    }\n\n    /// Extract value from file path source\n    fn extract_from_path(\u0026self, context: \u0026DerivationContext) -\u003e Option\u003cString\u003e {\n        context\n            .spec_path\n            .as_ref()\n            .and_then(|path| path.to_str().map(|s| s.to_string()))\n    }\n\n    /// Extract value from environment variable source\n    ///\n    /// The pattern parameter is treated as the environment variable name\n    fn extract_from_env(\u0026self, context: \u0026DerivationContext, env_name: \u0026str) -\u003e Option\u003cString\u003e {\n        context.env_vars.get(env_name).cloned()\n    }\n\n    /// Extract value from git user source\n    ///\n    /// The pattern parameter can be \"name\" for user.name or \"email\" for user.email\n    fn extract_from_git_user(\n        \u0026self,\n        context: \u0026DerivationContext,\n        field_type: \u0026str,\n    ) -\u003e Option\u003cString\u003e {\n        match field_type {\n            \"name\" =\u003e context.git_user_name.clone(),\n            \"email\" =\u003e context.git_user_email.clone(),\n            _ =\u003e None,\n        }\n    }\n\n    /// Apply regex pattern to extract the first capture group\n    ///\n    /// Returns None if pattern is invalid or doesn't match\n    fn apply_pattern(\u0026self, pattern: \u0026str, source: \u0026str) -\u003e Option\u003cString\u003e {\n        let regex = Regex::new(pattern).ok()?;\n        regex\n            .captures(source)?\n            .get(1)\n            .map(|m| m.as_str().to_string())\n    }\n\n    /// Validate a derived value against its validation rule\n    ///\n    /// Returns Valid if the value passes validation, or Warning if it fails.\n    /// Does not prevent the value from being included in results.\n    fn validate_derived_value(\n        \u0026self,\n        field_name: \u0026str,\n        value: \u0026str,\n        validation: \u0026ValidationRule,\n    ) -\u003e ValidationResult {\n        match validation {\n            ValidationRule::Enum { values } =\u003e {\n                if values.contains(\u0026value.to_string()) {\n                    ValidationResult::Valid\n                } else {\n                    ValidationResult::Warning(format!(\n                        \"Field '{}' value '{}' is not in allowed enum values: {}\",\n                        field_name,\n                        value,\n                        values.join(\", \")\n                    ))\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    fn create_test_engine(derived: HashMap\u003cString, DerivedFieldConfig\u003e) -\u003e DerivationEngine {\n        DerivationEngine::new(EnterpriseConfig {\n            derived,\n            required: vec![],\n        })\n    }\n\n    // =========================================================================\n    // TEST HELPERS FOR SOURCE TYPE TESTS\n    // =========================================================================\n\n    /// Test helper for derivation source tests\n    fn assert_derive_from_source(\n        field_name: \u0026str,\n        config: DerivedFieldConfig,\n        context: DerivationContext,\n        expected: Option\u003c\u0026str\u003e,\n    ) {\n        let mut derived = HashMap::new();\n        derived.insert(field_name.to_string(), config);\n        let engine = create_test_engine(derived);\n        let result = engine.derive_fields(\u0026context);\n\n        match expected {\n            Some(val) =\u003e assert_eq!(result.get(field_name), Some(\u0026val.to_string())),\n            None =\u003e assert!(!result.contains_key(field_name)),\n        }\n    }\n\n    // =========================================================================\n    // BRANCH NAME EXTRACTION TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_derive_from_branch_basic() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: r\"^(dev|staging|prod)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"prod/feature-123\".to_string());\n\n        assert_derive_from_source(\"env\", config, context, Some(\"prod\"));\n    }\n\n    #[test]\n    fn test_derive_from_branch_with_capture_group() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: r\"sprint/.*/(PROJ-\\d+)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"sprint/2026-Q1-W4/PROJ-123\".to_string());\n\n        assert_derive_from_source(\"project\", config, context, Some(\"PROJ-123\"));\n    }\n\n    #[test]\n    fn test_derive_from_branch_no_match() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: r\"^(dev|staging|prod)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"feature/my-branch\".to_string());\n\n        assert_derive_from_source(\"env\", config, context, None);\n    }\n\n    #[test]\n    fn test_derive_from_branch_missing() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: r\"^(dev|staging|prod)\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::new(); // No branch_name\n\n        assert_derive_from_source(\"env\", config, context, None);\n    }\n\n    // =========================================================================\n    // FILE PATH EXTRACTION TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_derive_from_path_basic() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: r\"specs/([a-z]+)/\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/platform/feature.md\"));\n\n        assert_derive_from_source(\"team\", config, context, Some(\"platform\"));\n    }\n\n    #[test]\n    fn test_derive_from_path_with_multiple_captures() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: r\"specs/([a-z]+)/([A-Z0-9]+)-\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/teams/PROJ-123-feature.md\"));\n\n        // Should extract first capture group only\n        assert_derive_from_source(\"project\", config, context, Some(\"teams\"));\n    }\n\n    #[test]\n    fn test_derive_from_path_no_match() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: r\"specs/([a-z]+)/\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/feature.md\"));\n\n        assert_derive_from_source(\"team\", config, context, None);\n    }\n\n    #[test]\n    fn test_derive_from_path_missing() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: r\"specs/([a-z]+)/\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::new(); // No spec_path\n\n        assert_derive_from_source(\"team\", config, context, None);\n    }\n\n    // =========================================================================\n    // ENVIRONMENT VARIABLE EXTRACTION TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_derive_from_env_basic() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"TEAM_NAME\".to_string(),\n            validate: None,\n        };\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"platform\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        assert_derive_from_source(\"team\", config, context, Some(\"platform\"));\n    }\n\n    #[test]\n    fn test_derive_from_env_with_pattern_match() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"ENVIRONMENT\".to_string(),\n            validate: None,\n        };\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"ENVIRONMENT\".to_string(), \"production\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        assert_derive_from_source(\"env_name\", config, context, Some(\"production\"));\n    }\n\n    #[test]\n    fn test_derive_from_env_missing_variable() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"TEAM_NAME\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::new(); // No env vars\n\n        assert_derive_from_source(\"team\", config, context, None);\n    }\n\n    #[test]\n    fn test_derive_from_env_undefined_variable() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"TEAM_NAME\".to_string(),\n            validate: None,\n        };\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"OTHER_VAR\".to_string(), \"value\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        assert_derive_from_source(\"team\", config, context, None);\n    }\n\n    // =========================================================================\n    // GIT USER EXTRACTION TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_derive_from_git_user_name() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::GitUser,\n            pattern: \"name\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.git_user_name = Some(\"John Doe\".to_string());\n\n        assert_derive_from_source(\"author\", config, context, Some(\"John Doe\"));\n    }\n\n    #[test]\n    fn test_derive_from_git_user_email() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::GitUser,\n            pattern: \"email\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.git_user_email = Some(\"john@example.com\".to_string());\n\n        assert_derive_from_source(\"author_email\", config, context, Some(\"john@example.com\"));\n    }\n\n    #[test]\n    fn test_derive_from_git_user_invalid_field() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::GitUser,\n            pattern: \"invalid\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.git_user_name = Some(\"John Doe\".to_string());\n\n        assert_derive_from_source(\"author\", config, context, None);\n    }\n\n    #[test]\n    fn test_derive_from_git_user_missing_name() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::GitUser,\n            pattern: \"name\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::new(); // No git_user_name\n\n        assert_derive_from_source(\"author\", config, context, None);\n    }\n\n    // =========================================================================\n    // GRACEFUL FAILURE TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_invalid_regex_pattern() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"test\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: \"[invalid regex\".to_string(), // Invalid regex\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"test\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        // Invalid regex should result in None (graceful failure)\n        assert!(!result.contains_key(\"test\"));\n    }\n\n    // =========================================================================\n    // EMPTY CONFIG TEST\n    // =========================================================================\n\n    #[test]\n    fn test_empty_config_returns_empty_map() {\n        let engine = create_test_engine(HashMap::new());\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"main\".to_string());\n        context.spec_path = Some(PathBuf::from(\".chant/specs/test.md\"));\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEST_VAR\".to_string(), \"value\".to_string());\n        context.env_vars = env_vars;\n        context.git_user_name = Some(\"Test User\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        assert!(result.is_empty());\n    }\n\n    // =========================================================================\n    // MULTIPLE FIELDS TEST\n    // =========================================================================\n\n    #[test]\n    fn test_derive_multiple_fields() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"env\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: r\"^(dev|staging|prod)\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"author\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::GitUser,\n                pattern: \"name\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"prod/feature\".to_string());\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"platform\".to_string());\n        context.env_vars = env_vars;\n        context.git_user_name = Some(\"Jane Doe\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.len(), 3);\n        assert_eq!(result.get(\"env\"), Some(\u0026\"prod\".to_string()));\n        assert_eq!(result.get(\"team\"), Some(\u0026\"platform\".to_string()));\n        assert_eq!(result.get(\"author\"), Some(\u0026\"Jane Doe\".to_string()));\n    }\n\n    #[test]\n    fn test_derive_multiple_fields_partial_success() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"env\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: r\"^(dev|staging|prod)\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"MISSING_VAR\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"author\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::GitUser,\n                pattern: \"name\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"prod/feature\".to_string());\n        context.git_user_name = Some(\"Jane Doe\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        // Only env and author should be derived\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.get(\"env\"), Some(\u0026\"prod\".to_string()));\n        assert!(!result.contains_key(\"team\"));\n        assert_eq!(result.get(\"author\"), Some(\u0026\"Jane Doe\".to_string()));\n    }\n\n    // =========================================================================\n    // VALIDATION TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_enum_validation_valid_value() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\n                        \"platform\".to_string(),\n                        \"frontend\".to_string(),\n                        \"backend\".to_string(),\n                    ],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"platform\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        let result = engine.derive_fields(\u0026context);\n        // Field should be included even with validation\n        assert_eq!(result.get(\"team\"), Some(\u0026\"platform\".to_string()));\n    }\n\n    #[test]\n    fn test_enum_validation_invalid_value() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\n                        \"platform\".to_string(),\n                        \"frontend\".to_string(),\n                        \"backend\".to_string(),\n                    ],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"invalid-team\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        let result = engine.derive_fields(\u0026context);\n        // Field should still be included even if validation fails\n        assert_eq!(result.get(\"team\"), Some(\u0026\"invalid-team\".to_string()));\n    }\n\n    #[test]\n    fn test_enum_validation_with_branch_source() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"environment\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: r\"^(dev|staging|prod)\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\"dev\".to_string(), \"staging\".to_string(), \"prod\".to_string()],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"staging/new-feature\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"environment\"), Some(\u0026\"staging\".to_string()));\n    }\n\n    #[test]\n    fn test_enum_validation_with_branch_source_invalid() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"environment\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: r\"^([a-z]+)\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\"dev\".to_string(), \"staging\".to_string(), \"prod\".to_string()],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"testing/new-feature\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        // Value should still be included even though \"testing\" is not in enum\n        assert_eq!(result.get(\"environment\"), Some(\u0026\"testing\".to_string()));\n    }\n\n    #[test]\n    fn test_validation_skipped_when_no_rule_configured() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: None, // No validation rule\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"any-value\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        let result = engine.derive_fields(\u0026context);\n        // Field should be included without validation\n        assert_eq!(result.get(\"team\"), Some(\u0026\"any-value\".to_string()));\n    }\n\n    #[test]\n    fn test_enum_validation_with_path_source() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Path,\n                pattern: r\"specs/([a-z]+)/\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\n                        \"platform\".to_string(),\n                        \"frontend\".to_string(),\n                        \"backend\".to_string(),\n                    ],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/backend/feature.md\"));\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"team\"), Some(\u0026\"backend\".to_string()));\n    }\n\n    #[test]\n    fn test_enum_validation_case_sensitive() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\"Platform\".to_string(), \"Frontend\".to_string()],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"platform\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        let result = engine.derive_fields(\u0026context);\n        // \"platform\" does not match \"Platform\" (case sensitive)\n        // Field should still be included\n        assert_eq!(result.get(\"team\"), Some(\u0026\"platform\".to_string()));\n    }\n\n    #[test]\n    fn test_multiple_fields_with_mixed_validation() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\"platform\".to_string(), \"frontend\".to_string()],\n                }),\n            },\n        );\n        derived.insert(\n            \"environment\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: r\"^(dev|staging|prod)\".to_string(),\n                validate: None, // No validation\n            },\n        );\n        derived.insert(\n            \"author\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::GitUser,\n                pattern: \"name\".to_string(),\n                validate: Some(ValidationRule::Enum {\n                    values: vec![\"Alice\".to_string(), \"Bob\".to_string()],\n                }),\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"backend\".to_string()); // Invalid\n        context.env_vars = env_vars;\n        context.branch_name = Some(\"prod/feature\".to_string());\n        context.git_user_name = Some(\"Charlie\".to_string()); // Invalid\n\n        let result = engine.derive_fields(\u0026context);\n        // All three should be included despite validation warnings\n        assert_eq!(result.len(), 3);\n        assert_eq!(result.get(\"team\"), Some(\u0026\"backend\".to_string()));\n        assert_eq!(result.get(\"environment\"), Some(\u0026\"prod\".to_string()));\n        assert_eq!(result.get(\"author\"), Some(\u0026\"Charlie\".to_string()));\n    }\n\n    // =========================================================================\n    // UNICODE HANDLING TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_branch_with_unicode_characters() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"project\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: \"feature/([^/]+)/\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"description\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Branch,\n                pattern: \"feature/[^/]+/(.+)\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"feature/é¡¹ç®-123/amÃ©lioration\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"project\"), Some(\u0026\"é¡¹ç®-123\".to_string()));\n        assert_eq!(result.get(\"description\"), Some(\u0026\"amÃ©lioration\".to_string()));\n    }\n\n    #[test]\n    fn test_env_value_with_unicode() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"author\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"AUTHOR_NAME\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"TEAM_NAME\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"desc\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Env,\n                pattern: \"DESCRIPTION\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"AUTHOR_NAME\".to_string(), \"JosÃ© GarcÃ­a\".to_string());\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"ÐÐ»Ð°ÑÑÐ¾ÑÐ¼Ð°\".to_string());\n        env_vars.insert(\"DESCRIPTION\".to_string(), \"Fix ð in parser\".to_string());\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"author\"), Some(\u0026\"JosÃ© GarcÃ­a\".to_string()));\n        assert_eq!(result.get(\"team\"), Some(\u0026\"ÐÐ»Ð°ÑÑÐ¾ÑÐ¼Ð°\".to_string()));\n        assert_eq!(result.get(\"desc\"), Some(\u0026\"Fix ð in parser\".to_string()));\n    }\n\n    #[test]\n    fn test_git_user_with_unicode() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"author\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::GitUser,\n                pattern: \"name\".to_string(),\n                validate: None,\n            },\n        );\n        derived.insert(\n            \"email\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::GitUser,\n                pattern: \"email\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.git_user_name = Some(\"FranÃ§ois MÃ¼ller\".to_string());\n        context.git_user_email = Some(\"franÃ§ois.mÃ¼ller@example.com\".to_string());\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"author\"), Some(\u0026\"FranÃ§ois MÃ¼ller\".to_string()));\n        assert_eq!(\n            result.get(\"email\"),\n            Some(\u0026\"franÃ§ois.mÃ¼ller@example.com\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_path_with_unicode_directory_names() {\n        let mut derived = HashMap::new();\n        derived.insert(\n            \"team\".to_string(),\n            DerivedFieldConfig {\n                from: DerivationSource::Path,\n                pattern: \"specs/([^/]+)/\".to_string(),\n                validate: None,\n            },\n        );\n\n        let engine = create_test_engine(derived);\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/å¹³å°/ææ¡£.md\"));\n\n        let result = engine.derive_fields(\u0026context);\n        assert_eq!(result.get(\"team\"), Some(\u0026\"å¹³å°\".to_string()));\n    }\n\n    // =========================================================================\n    // SPECIAL CHARACTERS IN VALUES TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_special_characters_branch_with_slashes_hyphens_dots() {\n        let config1 = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: \"([A-Z]+-\\\\d+)\".to_string(),\n            validate: None,\n        };\n        let config2 = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: \"feature/(.+)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"feature/ABC-123/user-name.test\".to_string());\n\n        assert_derive_from_source(\"ticket\", config1, context.clone(), Some(\"ABC-123\"));\n        assert_derive_from_source(\n            \"full_path\",\n            config2,\n            context,\n            Some(\"ABC-123/user-name.test\"),\n        );\n    }\n\n    #[test]\n    fn test_special_characters_env_value_with_spaces_and_quotes() {\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TEAM_NAME\".to_string(), \"Platform Team\".to_string());\n        env_vars.insert(\n            \"DESCRIPTION\".to_string(),\n            \"This is a \\\"test\\\" value\".to_string(),\n        );\n        env_vars.insert(\n            \"NOTES\".to_string(),\n            \"Value with 'single' and \\\"double\\\" quotes\".to_string(),\n        );\n\n        let config1 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"TEAM_NAME\".to_string(),\n            validate: None,\n        };\n        let config2 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"DESCRIPTION\".to_string(),\n            validate: None,\n        };\n        let config3 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"NOTES\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        assert_derive_from_source(\"team\", config1, context.clone(), Some(\"Platform Team\"));\n        assert_derive_from_source(\n            \"desc\",\n            config2,\n            context.clone(),\n            Some(\"This is a \\\"test\\\" value\"),\n        );\n        assert_derive_from_source(\n            \"notes\",\n            config3,\n            context,\n            Some(\"Value with 'single' and \\\"double\\\" quotes\"),\n        );\n    }\n\n    #[test]\n    fn test_special_characters_path_with_dots_and_hyphens() {\n        let config1 = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: \"specs/([^/]+)/\".to_string(),\n            validate: None,\n        };\n        let config2 = DerivedFieldConfig {\n            from: DerivationSource::Path,\n            pattern: \"/([^/]+\\\\.md)$\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.spec_path = Some(PathBuf::from(\".chant/specs/platform-team/feature.v2.md\"));\n\n        assert_derive_from_source(\"component\", config1, context.clone(), Some(\"platform-team\"));\n        assert_derive_from_source(\"filename\", config2, context, Some(\"feature.v2.md\"));\n    }\n\n    #[test]\n    fn test_special_characters_value_with_regex_metacharacters() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: \"feature/(.+)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"feature/fix-[bug]-in-(parser)\".to_string());\n\n        assert_derive_from_source(\n            \"description\",\n            config,\n            context,\n            Some(\"fix-[bug]-in-(parser)\"),\n        );\n    }\n\n    #[test]\n    fn test_special_characters_env_value_with_commas_and_special_chars() {\n        let mut env_vars = HashMap::new();\n        env_vars.insert(\"TAGS\".to_string(), \"bug,feature,urgent\".to_string());\n        env_vars.insert(\"EXPRESSION\".to_string(), \"value = 1 + 2 * 3\".to_string());\n        env_vars.insert(\n            \"PATH_LIKE\".to_string(),\n            \"/usr/bin:/usr/local/bin\".to_string(),\n        );\n\n        let config1 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"TAGS\".to_string(),\n            validate: None,\n        };\n        let config2 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"EXPRESSION\".to_string(),\n            validate: None,\n        };\n        let config3 = DerivedFieldConfig {\n            from: DerivationSource::Env,\n            pattern: \"PATH_LIKE\".to_string(),\n            validate: None,\n        };\n        let context = DerivationContext::with_env_vars(env_vars);\n\n        assert_derive_from_source(\"tags\", config1, context.clone(), Some(\"bug,feature,urgent\"));\n        assert_derive_from_source(\"expr\", config2, context.clone(), Some(\"value = 1 + 2 * 3\"));\n        assert_derive_from_source(\"path\", config3, context, Some(\"/usr/bin:/usr/local/bin\"));\n    }\n\n    #[test]\n    fn test_special_characters_branch_with_multiple_regex_metacharacters() {\n        let config = DerivedFieldConfig {\n            from: DerivationSource::Branch,\n            pattern: \"fix/(.+)\".to_string(),\n            validate: None,\n        };\n        let mut context = DerivationContext::new();\n        context.branch_name = Some(\"fix/handle-$var.and^chars+more*stuff\".to_string());\n\n        assert_derive_from_source(\n            \"desc\",\n            config,\n            context,\n            Some(\"handle-$var.and^chars+more*stuff\"),\n        );\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":35}},{"line":47,"address":[],"length":0,"stats":{"Line":70}},{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":14}},{"line":86,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":5}},{"line":91,"address":[],"length":0,"stats":{"Line":28}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":95,"address":[],"length":0,"stats":{"Line":21}},{"line":98,"address":[],"length":0,"stats":{"Line":21}},{"line":99,"address":[],"length":0,"stats":{"Line":14}},{"line":100,"address":[],"length":0,"stats":{"Line":14}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":113,"address":[],"length":0,"stats":{"Line":51}},{"line":122,"address":[],"length":0,"stats":{"Line":51}},{"line":124,"address":[],"length":0,"stats":{"Line":102}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":100}},{"line":130,"address":[],"length":0,"stats":{"Line":180}},{"line":131,"address":[],"length":0,"stats":{"Line":358}},{"line":132,"address":[],"length":0,"stats":{"Line":196}},{"line":136,"address":[],"length":0,"stats":{"Line":50}},{"line":145,"address":[],"length":0,"stats":{"Line":65}},{"line":151,"address":[],"length":0,"stats":{"Line":114}},{"line":153,"address":[],"length":0,"stats":{"Line":68}},{"line":154,"address":[],"length":0,"stats":{"Line":64}},{"line":155,"address":[],"length":0,"stats":{"Line":20}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":40}},{"line":165,"address":[],"length":0,"stats":{"Line":36}},{"line":166,"address":[],"length":0,"stats":{"Line":10}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":124}},{"line":180,"address":[],"length":0,"stats":{"Line":38}},{"line":185,"address":[],"length":0,"stats":{"Line":57}},{"line":186,"address":[],"length":0,"stats":{"Line":32}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":5}},{"line":197,"address":[],"length":0,"stats":{"Line":49}},{"line":201,"address":[],"length":0,"stats":{"Line":17}},{"line":202,"address":[],"length":0,"stats":{"Line":34}},{"line":206,"address":[],"length":0,"stats":{"Line":10}},{"line":207,"address":[],"length":0,"stats":{"Line":10}},{"line":208,"address":[],"length":0,"stats":{"Line":10}},{"line":210,"address":[],"length":0,"stats":{"Line":54}},{"line":216,"address":[],"length":0,"stats":{"Line":29}},{"line":217,"address":[],"length":0,"stats":{"Line":116}},{"line":223,"address":[],"length":0,"stats":{"Line":9}},{"line":228,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":21}},{"line":230,"address":[],"length":0,"stats":{"Line":7}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":25}},{"line":239,"address":[],"length":0,"stats":{"Line":100}},{"line":240,"address":[],"length":0,"stats":{"Line":23}},{"line":241,"address":[],"length":0,"stats":{"Line":48}},{"line":243,"address":[],"length":0,"stats":{"Line":67}},{"line":250,"address":[],"length":0,"stats":{"Line":8}},{"line":256,"address":[],"length":0,"stats":{"Line":8}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":24}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":10}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":5}},{"line":264,"address":[],"length":0,"stats":{"Line":5}},{"line":265,"address":[],"length":0,"stats":{"Line":10}}],"covered":71,"coverable":73},{"path":["/","Users","alex","Documents","checkouts","chant","src","diagnose.rs"],"content":"//! Diagnostic utilities for checking spec execution status.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: guides/recovery.md, reference/cli.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\nuse crate::paths::SPECS_DIR;\nuse crate::spec::{Spec, SpecStatus};\nuse crate::worktree::get_active_worktree;\n\n/// A single diagnostic check result.\n#[derive(Debug, Clone)]\npub struct CheckResult {\n    pub name: String,\n    pub passed: bool,\n    pub details: Option\u003cString\u003e,\n}\n\nimpl CheckResult {\n    pub fn pass(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            passed: true,\n            details: None,\n        }\n    }\n\n    pub fn pass_with_details(name: impl Into\u003cString\u003e, details: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            passed: true,\n            details: Some(details.into()),\n        }\n    }\n\n    pub fn fail(name: impl Into\u003cString\u003e, details: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            passed: false,\n            details: Some(details.into()),\n        }\n    }\n}\n\n/// Full diagnostic report for a spec.\n#[derive(Debug, Clone)]\npub struct DiagnosticReport {\n    pub spec_id: String,\n    pub status: SpecStatus,\n    pub checks: Vec\u003cCheckResult\u003e,\n    pub diagnosis: String,\n    pub suggestion: Option\u003cString\u003e,\n    pub location: String,\n}\n\nimpl DiagnosticReport {\n    /// Returns true if all diagnostic checks passed. Used in tests.\n    pub fn all_passed(\u0026self) -\u003e bool {\n        self.checks.iter().all(|c| c.passed)\n    }\n\n    /// Returns the list of failed checks. Used in tests.\n    pub fn failed_checks(\u0026self) -\u003e Vec\u003c\u0026CheckResult\u003e {\n        self.checks.iter().filter(|c| !c.passed).collect()\n    }\n}\n\n/// Check if a spec file exists and is valid.\nfn check_spec_file(spec_file: \u0026Path) -\u003e CheckResult {\n    if !spec_file.exists() {\n        return CheckResult::fail(\"Spec file\", \"Does not exist\");\n    }\n\n    match fs::read_to_string(spec_file) {\n        Ok(content) =\u003e {\n            // Try to parse as a spec to validate YAML\n            match Spec::parse(\n                spec_file\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"unknown\"),\n                \u0026content,\n            ) {\n                Ok(_) =\u003e CheckResult::pass_with_details(\"Spec file\", \"Valid YAML\"),\n                Err(e) =\u003e CheckResult::fail(\"Spec file\", format!(\"Invalid YAML: {}\", e)),\n            }\n        }\n        Err(e) =\u003e CheckResult::fail(\"Spec file\", format!(\"Cannot read: {}\", e)),\n    }\n}\n\n/// Check if a log file exists and get its age.\nfn check_log_file(spec_id: \u0026str, base_path: \u0026Path) -\u003e CheckResult {\n    let log_file = base_path\n        .join(\".chant/.store\")\n        .join(format!(\"{}.log\", spec_id));\n\n    let location_hint = if base_path.to_string_lossy().contains(\"/tmp/chant-\") {\n        \"worktree\"\n    } else {\n        \"main\"\n    };\n\n    if !log_file.exists() {\n        return CheckResult::fail(\n            \"Log file\",\n            format!(\"Does not exist (checked in {})\", location_hint),\n        );\n    }\n\n    match fs::metadata(\u0026log_file) {\n        Ok(metadata) =\u003e {\n            let size = metadata.len();\n\n            let age_str = match metadata.modified() {\n                Ok(modified_time) =\u003e match modified_time.elapsed() {\n                    Ok(elapsed) =\u003e {\n                        let secs: u64 = elapsed.as_secs();\n                        if secs \u003c 60 {\n                            \"just now\".to_string()\n                        } else if secs \u003c 3600 {\n                            format!(\"{} minutes ago\", secs / 60)\n                        } else if secs \u003c 86400 {\n                            format!(\"{} hours ago\", secs / 3600)\n                        } else {\n                            format!(\"{} days ago\", secs / 86400)\n                        }\n                    }\n                    Err(_) =\u003e \"unknown age\".to_string(),\n                },\n                Err(_) =\u003e \"unknown age\".to_string(),\n            };\n\n            CheckResult::pass_with_details(\n                \"Log file\",\n                format!(\n                    \"Exists ({} bytes), last modified: {} (checked in {})\",\n                    size, age_str, location_hint\n                ),\n            )\n        }\n        Err(e) =\u003e CheckResult::fail(\"Log file\", format!(\"Cannot read metadata: {}\", e)),\n    }\n}\n\n/// Check if there's a lock file.\nfn check_lock_file(spec_id: \u0026str, base_path: \u0026Path) -\u003e CheckResult {\n    let lock_file = base_path\n        .join(\".chant/.locks\")\n        .join(format!(\"{}.lock\", spec_id));\n\n    let location_hint = if base_path.to_string_lossy().contains(\"/tmp/chant-\") {\n        \"worktree\"\n    } else {\n        \"main\"\n    };\n\n    if lock_file.exists() {\n        CheckResult::pass_with_details(\n            \"Lock file\",\n            format!(\n                \"Present (spec may be running) (checked in {})\",\n                location_hint\n            ),\n        )\n    } else {\n        CheckResult::pass_with_details(\n            \"Lock file\",\n            format!(\"Not present (checked in {})\", location_hint),\n        )\n    }\n}\n\n/// Check if a git commit exists for this spec.\nfn check_git_commit(spec_id: \u0026str) -\u003e CheckResult {\n    let output = Command::new(\"git\")\n        .args([\"log\", \"--grep\", \u0026format!(\"chant({})\", spec_id), \"--oneline\"])\n        .output();\n\n    match output {\n        Ok(output) =\u003e {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let commit_line = stdout.lines().next();\n\n            if let Some(line) = commit_line {\n                // Extract commit hash (first 7 chars)\n                let commit_hash = line.split_whitespace().next().unwrap_or(\"unknown\");\n                CheckResult::pass_with_details(\"Git commit\", format!(\"Found: {}\", commit_hash))\n            } else {\n                CheckResult::fail(\"Git commit\", \"No matching commit found\")\n            }\n        }\n        Err(_) =\u003e CheckResult::fail(\"Git commit\", \"Cannot run git log\"),\n    }\n}\n\n/// Check if acceptance criteria are all satisfied.\nfn check_acceptance_criteria(spec: \u0026Spec) -\u003e CheckResult {\n    let unchecked = spec.count_unchecked_checkboxes();\n\n    if unchecked == 0 {\n        CheckResult::pass_with_details(\"Acceptance criteria\", \"All satisfied\")\n    } else {\n        CheckResult::fail(\n            \"Acceptance criteria\",\n            format!(\"{} unchecked items remaining\", unchecked),\n        )\n    }\n}\n\n/// Check for common status mismatches.\nfn check_status_consistency(spec: \u0026Spec, commit_exists: bool, unchecked: usize) -\u003e CheckResult {\n    match spec.frontmatter.status {\n        SpecStatus::InProgress =\u003e {\n            if commit_exists {\n                CheckResult::fail(\n                    \"Status consistency\",\n                    \"Status is in_progress but commit exists (should be completed?)\",\n                )\n            } else {\n                CheckResult::pass(\"Status consistency\")\n            }\n        }\n        SpecStatus::Paused =\u003e CheckResult::pass_with_details(\n            \"Status consistency\",\n            \"Paused (work stopped mid-execution)\",\n        ),\n        SpecStatus::Completed =\u003e {\n            if !commit_exists {\n                CheckResult::fail(\n                    \"Status consistency\",\n                    \"Status is completed but no commit found\",\n                )\n            } else if unchecked \u003e 0 {\n                CheckResult::fail(\n                    \"Status consistency\",\n                    \"Status is completed but acceptance criteria unchecked\",\n                )\n            } else {\n                CheckResult::pass(\"Status consistency\")\n            }\n        }\n        SpecStatus::Pending =\u003e {\n            if commit_exists {\n                CheckResult::fail(\"Status consistency\", \"Status is pending but commit exists\")\n            } else {\n                CheckResult::pass(\"Status consistency\")\n            }\n        }\n        SpecStatus::Failed =\u003e {\n            CheckResult::pass_with_details(\"Status consistency\", \"Marked as failed\")\n        }\n        SpecStatus::NeedsAttention =\u003e {\n            CheckResult::pass_with_details(\"Status consistency\", \"Marked as needs attention\")\n        }\n        SpecStatus::Ready =\u003e {\n            if commit_exists {\n                CheckResult::fail(\"Status consistency\", \"Status is ready but commit exists\")\n            } else {\n                CheckResult::pass(\"Status consistency\")\n            }\n        }\n        SpecStatus::Blocked =\u003e {\n            CheckResult::pass_with_details(\"Status consistency\", \"Blocked by unmet dependencies\")\n        }\n        SpecStatus::Cancelled =\u003e CheckResult::pass_with_details(\n            \"Status consistency\",\n            \"Marked as cancelled (preserved but excluded from list and work)\",\n        ),\n    }\n}\n\n/// Run all diagnostic checks on a spec.\npub fn diagnose_spec(spec_id: \u0026str) -\u003e Result\u003cDiagnosticReport\u003e {\n    // Check if spec has an active worktree\n    let (base_path, location) = if let Some(worktree) = get_active_worktree(spec_id) {\n        (\n            worktree.clone(),\n            format!(\"worktree: {}\", worktree.display()),\n        )\n    } else {\n        (PathBuf::from(\".\"), \"main repository\".to_string())\n    };\n\n    let specs_dir = base_path.join(SPECS_DIR);\n    let spec_file = specs_dir.join(format!(\"{}.md\", spec_id));\n\n    // Load the spec\n    let spec = Spec::load(\u0026spec_file).context(\"Failed to load spec\")?;\n\n    // Run checks\n    let mut checks = Vec::new();\n\n    // 1. Spec file check\n    checks.push(check_spec_file(\u0026spec_file));\n\n    // 2. Log file check\n    checks.push(check_log_file(spec_id, \u0026base_path));\n\n    // 3. Lock file check\n    checks.push(check_lock_file(spec_id, \u0026base_path));\n\n    // 4. Git commit check\n    let commit_result = check_git_commit(spec_id);\n    let commit_exists = commit_result.passed;\n    checks.push(commit_result);\n\n    // 5. Acceptance criteria check\n    let criteria_result = check_acceptance_criteria(\u0026spec);\n    let unchecked = spec.count_unchecked_checkboxes();\n    checks.push(criteria_result);\n\n    // 6. Status consistency check\n    checks.push(check_status_consistency(\u0026spec, commit_exists, unchecked));\n\n    // Determine diagnosis and suggestion\n    let (diagnosis, suggestion) = diagnose_issues(\u0026spec, \u0026checks);\n\n    Ok(DiagnosticReport {\n        spec_id: spec_id.to_string(),\n        status: spec.frontmatter.status.clone(),\n        checks,\n        diagnosis,\n        suggestion,\n        location,\n    })\n}\n\n/// Generate a diagnosis message and suggestion based on check results.\nfn diagnose_issues(spec: \u0026Spec, checks: \u0026[CheckResult]) -\u003e (String, Option\u003cString\u003e) {\n    let failed = checks.iter().filter(|c| !c.passed).collect::\u003cVec\u003c_\u003e\u003e();\n\n    if failed.is_empty() {\n        return (\"All checks passed. Spec appears healthy.\".to_string(), None);\n    }\n\n    // Look for specific patterns\n    if spec.frontmatter.status == SpecStatus::InProgress {\n        // Check for the common \"stuck in progress\" pattern\n        let has_commit = checks.iter().any(|c| c.name == \"Git commit\" \u0026\u0026 c.passed);\n        let all_criteria_met = checks\n            .iter()\n            .find(|c| c.name == \"Acceptance criteria\")\n            .map(|c| c.passed)\n            .unwrap_or(false);\n\n        if has_commit \u0026\u0026 all_criteria_met {\n            return (\n                \"Spec appears complete but wasn't finalized.\".to_string(),\n                Some(format!(\n                    \"Run `just chant work {} --finalize` to fix.\",\n                    \u0026spec.id\n                )),\n            );\n        }\n\n        if has_commit \u0026\u0026 !all_criteria_met {\n            return (\n                \"Spec has a commit but acceptance criteria not all satisfied.\".to_string(),\n                Some(\"Complete the unchecked acceptance criteria and re-run the spec.\".to_string()),\n            );\n        }\n\n        return (\n            \"Spec is in progress but has issues.\".to_string(),\n            Some(format!(\"Check the log: `just chant log {}`\", \u0026spec.id)),\n        );\n    }\n\n    // Generic diagnosis for failed checks\n    let check_names = failed\n        .iter()\n        .map(|c| c.name.as_str())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\", \");\n\n    (\n        format!(\"Spec has issues: {}\", check_names),\n        Some(format!(\"Run `just chant log {}` for details\", \u0026spec.id)),\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_check_result_creation() {\n        let pass = CheckResult::pass(\"Test\");\n        assert!(pass.passed);\n        assert_eq!(pass.name, \"Test\");\n        assert_eq!(pass.details, None);\n\n        let fail = CheckResult::fail(\"Test\", \"Failed\");\n        assert!(!fail.passed);\n        assert_eq!(fail.details, Some(\"Failed\".to_string()));\n    }\n\n    #[test]\n    fn test_spec_file_check_missing() {\n        let result = check_spec_file(Path::new(\"nonexistent.md\"));\n        assert!(!result.passed);\n        assert!(result.details.is_some());\n    }\n\n    #[test]\n    fn test_diagnostic_report_all_passed() {\n        let report = DiagnosticReport {\n            spec_id: \"test\".to_string(),\n            status: SpecStatus::Completed,\n            checks: vec![CheckResult::pass(\"Check 1\"), CheckResult::pass(\"Check 2\")],\n            diagnosis: \"All good\".to_string(),\n            suggestion: None,\n            location: \"main repository\".to_string(),\n        };\n\n        assert!(report.all_passed());\n        assert_eq!(report.failed_checks().len(), 0);\n    }\n\n    #[test]\n    fn test_diagnostic_report_some_failed() {\n        let report = DiagnosticReport {\n            spec_id: \"test\".to_string(),\n            status: SpecStatus::InProgress,\n            checks: vec![\n                CheckResult::pass(\"Check 1\"),\n                CheckResult::fail(\"Check 2\", \"Bad\"),\n            ],\n            diagnosis: \"Some issues\".to_string(),\n            suggestion: None,\n            location: \"main repository\".to_string(),\n        };\n\n        assert!(!report.all_passed());\n        assert_eq!(report.failed_checks().len(), 1);\n    }\n\n    #[test]\n    fn test_status_consistency_in_progress_with_commit() {\n        use crate::spec::SpecFrontmatter;\n\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::InProgress,\n                ..Default::default()\n            },\n            title: None,\n            body: String::new(),\n        };\n\n        let result = check_status_consistency(\u0026spec, true, 0);\n        assert!(!result.passed);\n        assert!(result\n            .details\n            .unwrap()\n            .contains(\"in_progress but commit exists\"));\n    }\n\n    #[test]\n    fn test_status_consistency_completed_no_commit() {\n        use crate::spec::SpecFrontmatter;\n\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: None,\n            body: String::new(),\n        };\n\n        let result = check_status_consistency(\u0026spec, false, 0);\n        assert!(!result.passed);\n        assert!(result\n            .details\n            .unwrap()\n            .contains(\"completed but no commit found\"));\n    }\n\n    #[test]\n    fn test_acceptance_criteria_all_satisfied() {\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: Default::default(),\n            title: None,\n            body: \"## Acceptance Criteria\\n\\n- [x] Item 1\\n- [x] Item 2\".to_string(),\n        };\n\n        let result = check_acceptance_criteria(\u0026spec);\n        assert!(result.passed);\n    }\n\n    #[test]\n    fn test_acceptance_criteria_some_unchecked() {\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: Default::default(),\n            title: None,\n            body: \"## Acceptance Criteria\\n\\n- [ ] Item 1\\n- [x] Item 2\".to_string(),\n        };\n\n        let result = check_acceptance_criteria(\u0026spec);\n        assert!(!result.passed);\n        assert!(result\n            .details\n            .unwrap()\n            .contains(\"1 unchecked items remaining\"));\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":18}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":148},{"path":["/","Users","alex","Documents","checkouts","chant","src","formatters.rs"],"content":"//! Output formatters for status data\n//!\n//! Provides formatters that transform StatusData into different output formats.\n\nuse crate::status::{AttentionItem, InProgressItem, ReadyItem, StatusData, TodayActivity};\nuse crate::ui;\n\n/// Format StatusData as regular multi-section text output\npub fn format_regular_status(data: \u0026StatusData) -\u003e String {\n    let mut output = vec![\n        ui::colors::heading(\"Chant Status\").to_string(),\n        ui::format::separator(12),\n        String::new(),\n        format_counts(\u0026data.counts),\n        String::new(),\n    ];\n\n    // Today section\n    if data.today.completed \u003e 0 || data.today.started \u003e 0 || data.today.created \u003e 0 {\n        output.push(ui::colors::heading(\"Today\").to_string());\n        output.push(ui::format::separator(5));\n        output.push(format_today(\u0026data.today));\n        output.push(String::new());\n    }\n\n    // Attention section (only if there are items)\n    if !data.attention.is_empty() {\n        output.push(ui::colors::heading(\"Attention\").to_string());\n        output.push(ui::format::separator(9));\n        for item in \u0026data.attention {\n            output.push(format_attention_item(item));\n        }\n        output.push(String::new());\n    }\n\n    // In Progress section (only if there are items)\n    if !data.in_progress.is_empty() {\n        output.push(ui::colors::heading(\"In Progress\").to_string());\n        output.push(ui::format::separator(11));\n        for item in \u0026data.in_progress {\n            output.push(format_in_progress_item(item));\n        }\n        output.push(String::new());\n    }\n\n    // Ready section\n    output.push(ui::colors::heading(\u0026format!(\"Ready ({})\", data.ready_count)).to_string());\n    output.push(ui::format::separator(6));\n    if data.ready_count == 0 {\n        output.push(ui::colors::secondary(\"  (no specs ready)\").to_string());\n    } else {\n        for item in \u0026data.ready {\n            output.push(format_ready_item(item));\n        }\n        if data.ready_count \u003e 5 {\n            let remaining = data.ready_count - 5;\n            output\n                .push(ui::colors::secondary(\u0026format!(\"  ... and {} more\", remaining)).to_string());\n        }\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Format counts section with aligned numbers\nfn format_counts(counts: \u0026std::collections::HashMap\u003cString, usize\u003e) -\u003e String {\n    let pending = counts.get(\"pending\").copied().unwrap_or(0);\n    let in_progress = counts.get(\"in_progress\").copied().unwrap_or(0);\n    let completed = counts.get(\"completed\").copied().unwrap_or(0);\n    let failed = counts.get(\"failed\").copied().unwrap_or(0);\n    let blocked = counts.get(\"blocked\").copied().unwrap_or(0);\n    let ready = counts.get(\"ready\").copied().unwrap_or(0);\n\n    format!(\n        \"  {:\u003c12} {}\\n  {:\u003c12} {}\\n  {:\u003c12} {}\\n  {:\u003c12} {}\\n  {:\u003c12} {}\\n  {:\u003c12} {}\",\n        \"Pending:\",\n        pending,\n        \"Ready:\",\n        ready,\n        \"In Progress:\",\n        in_progress,\n        \"Completed:\",\n        completed,\n        \"Failed:\",\n        failed,\n        \"Blocked:\",\n        blocked,\n    )\n}\n\n/// Format today's activity\nfn format_today(today: \u0026TodayActivity) -\u003e String {\n    let mut parts = Vec::new();\n\n    if today.completed \u003e 0 {\n        parts.push(ui::colors::success(\u0026format!(\"+{} completed\", today.completed)).to_string());\n    }\n    if today.started \u003e 0 {\n        parts.push(ui::colors::warning(\u0026format!(\"+{} started\", today.started)).to_string());\n    }\n    if today.created \u003e 0 {\n        parts.push(ui::colors::info(\u0026format!(\"+{} created\", today.created)).to_string());\n    }\n\n    if parts.is_empty() {\n        ui::colors::secondary(\"  (no activity today)\").to_string()\n    } else {\n        format!(\"  {}\", parts.join(\", \"))\n    }\n}\n\n/// Format an attention item (failed or blocked)\nfn format_attention_item(item: \u0026AttentionItem) -\u003e String {\n    let symbol = ui::attention_symbol(\u0026item.status);\n\n    let title = item.title.as_deref().unwrap_or(\"(untitled)\");\n    let truncated_title = ui::format::truncate_title(title, 60);\n\n    format!(\n        \"  {} {}  {} ({})\",\n        symbol,\n        ui::colors::identifier(\u0026item.id),\n        truncated_title,\n        ui::colors::secondary(\u0026item.ago)\n    )\n}\n\n/// Format an in-progress item\nfn format_in_progress_item(item: \u0026InProgressItem) -\u003e String {\n    let title = item.title.as_deref().unwrap_or(\"(untitled)\");\n    let truncated_title = ui::format::truncate_title(title, 60);\n\n    let elapsed_str = ui::format::elapsed_minutes(item.elapsed_minutes);\n\n    format!(\n        \"  {} {}  ({})\",\n        ui::colors::identifier(\u0026item.id),\n        truncated_title,\n        ui::colors::secondary(\u0026elapsed_str)\n    )\n}\n\n/// Format a ready item\nfn format_ready_item(item: \u0026ReadyItem) -\u003e String {\n    let title = item.title.as_deref().unwrap_or(\"(untitled)\");\n    let truncated_title = ui::format::truncate_title(title, 60);\n\n    format!(\"  {} {}\", ui::colors::identifier(\u0026item.id), truncated_title)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_format_counts() {\n        let mut counts = HashMap::new();\n        counts.insert(\"pending\".to_string(), 5);\n        counts.insert(\"in_progress\".to_string(), 2);\n        counts.insert(\"completed\".to_string(), 10);\n        counts.insert(\"failed\".to_string(), 1);\n        counts.insert(\"blocked\".to_string(), 0);\n        counts.insert(\"ready\".to_string(), 3);\n\n        let result = format_counts(\u0026counts);\n        assert!(result.contains(\"Pending:\"));\n        assert!(result.contains(\"5\"));\n        assert!(result.contains(\"Ready:\"));\n        assert!(result.contains(\"3\"));\n    }\n\n    #[test]\n    fn test_format_today_all_activity() {\n        let today = TodayActivity {\n            completed: 2,\n            started: 1,\n            created: 3,\n        };\n\n        let result = format_today(\u0026today);\n        assert!(result.contains(\"+2 completed\"));\n        assert!(result.contains(\"+1 started\"));\n        assert!(result.contains(\"+3 created\"));\n    }\n\n    #[test]\n    fn test_format_today_no_activity() {\n        let today = TodayActivity {\n            completed: 0,\n            started: 0,\n            created: 0,\n        };\n\n        let result = format_today(\u0026today);\n        assert!(result.contains(\"no activity\"));\n    }\n\n    #[test]\n    fn test_format_regular_status_empty() {\n        let data = StatusData::default();\n        let result = format_regular_status(\u0026data);\n\n        assert!(result.contains(\"Chant Status\"));\n        assert!(result.contains(\"Ready (0)\"));\n        assert!(result.contains(\"no specs ready\"));\n        // Should not contain Attention section header\n        assert!(!result.contains(\"Attention\\nâââââââââ\"));\n        // Should contain In Progress in counts but not as a section header with underline\n        assert!(result.contains(\"In Progress:\"));\n        assert!(!result.contains(\"In Progress\\nâââââââââââ\"));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":2}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":12}},{"line":68,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}}],"covered":34,"coverable":72},{"path":["/","Users","alex","Documents","checkouts","chant","src","git.rs"],"content":"//! Git operations for branch management and merging.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: reference/git.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::process::Command;\n\n/// Get a git config value by key.\n///\n/// Returns `Some(value)` if the config key exists and has a non-empty value,\n/// `None` otherwise.\npub fn get_git_config(key: \u0026str) -\u003e Option\u003cString\u003e {\n    let output = Command::new(\"git\").args([\"config\", key]).output().ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let value = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    if value.is_empty() {\n        None\n    } else {\n        Some(value)\n    }\n}\n\n/// Get git user name and email from config.\n///\n/// Returns a tuple of (user.name, user.email), where each is `Some` if configured.\npub fn get_git_user_info() -\u003e (Option\u003cString\u003e, Option\u003cString\u003e) {\n    (get_git_config(\"user.name\"), get_git_config(\"user.email\"))\n}\n\n/// Get the current branch name.\n/// Returns the branch name for the current HEAD, including \"HEAD\" for detached HEAD state.\npub fn get_current_branch() -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", \"--abbrev-ref\", \"HEAD\"])\n        .output()\n        .context(\"Failed to run git rev-parse\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Failed to get current branch\");\n    }\n\n    let branch = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    Ok(branch)\n}\n\n/// Ensure the main repo is on the main branch.\n///\n/// Call this at command boundaries to prevent branch drift.\n/// Uses config's main_branch setting (defaults to \"main\").\n///\n/// Warns but does not fail if checkout fails (e.g., dirty worktree).\npub fn ensure_on_main_branch(main_branch: \u0026str) -\u003e Result\u003c()\u003e {\n    let current = get_current_branch()?;\n\n    if current != main_branch {\n        let output = Command::new(\"git\")\n            .args([\"checkout\", main_branch])\n            .output()\n            .context(\"Failed to checkout main branch\")?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            // Don't fail hard - just warn\n            eprintln!(\"Warning: Could not return to {}: {}\", main_branch, stderr);\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a branch exists in the repository.\npub fn branch_exists(branch_name: \u0026str) -\u003e Result\u003cbool\u003e {\n    let output = Command::new(\"git\")\n        .args([\"branch\", \"--list\", branch_name])\n        .output()\n        .context(\"Failed to check if branch exists\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Failed to check if branch exists\");\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    Ok(!stdout.trim().is_empty())\n}\n\n/// Check if a branch has been merged into a target branch.\n///\n/// # Arguments\n/// * `branch_name` - The branch to check\n/// * `target_branch` - The target branch to check against (e.g., \"main\")\n///\n/// # Returns\n/// * `Ok(true)` if the branch has been merged into the target\n/// * `Ok(false)` if the branch exists but hasn't been merged\n/// * `Err(_)` if git operations fail\npub fn is_branch_merged(branch_name: \u0026str, target_branch: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Use git branch --merged to check if the branch is in the list of merged branches\n    let output = Command::new(\"git\")\n        .args([\"branch\", \"--merged\", target_branch, \"--list\", branch_name])\n        .output()\n        .context(\"Failed to check if branch is merged\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Failed to check if branch is merged\");\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    Ok(!stdout.trim().is_empty())\n}\n\n/// Checkout a specific branch or commit.\n/// If branch is \"HEAD\", it's a detached HEAD checkout.\nfn checkout_branch(branch: \u0026str, dry_run: bool) -\u003e Result\u003c()\u003e {\n    if dry_run {\n        return Ok(());\n    }\n\n    let output = Command::new(\"git\")\n        .args([\"checkout\", branch])\n        .output()\n        .context(\"Failed to run git checkout\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to checkout {}: {}\", branch, stderr);\n    }\n\n    Ok(())\n}\n\n/// Check if branches have diverged (i.e., fast-forward is not possible).\n///\n/// Returns true if branches have diverged (fast-forward not possible).\n/// Returns false if a fast-forward merge is possible.\n///\n/// Fast-forward is possible when HEAD is an ancestor of or equal to spec_branch.\n/// Branches have diverged when HEAD has commits not in spec_branch.\nfn branches_have_diverged(spec_branch: \u0026str) -\u003e Result\u003cbool\u003e {\n    let output = Command::new(\"git\")\n        .args([\"merge-base\", \"--is-ancestor\", \"HEAD\", spec_branch])\n        .output()\n        .context(\"Failed to check if branches have diverged\")?;\n\n    // merge-base --is-ancestor returns 0 if HEAD is ancestor of spec_branch (fast-forward possible)\n    // Returns non-zero if HEAD is not ancestor of spec_branch (branches have diverged)\n    Ok(!output.status.success())\n}\n\n/// Result of a merge attempt with conflict details.\n#[derive(Debug)]\npub struct MergeAttemptResult {\n    /// Whether merge succeeded\n    pub success: bool,\n    /// Type of conflict if any\n    pub conflict_type: Option\u003ccrate::merge_errors::ConflictType\u003e,\n    /// Files with conflicts if any\n    pub conflicting_files: Vec\u003cString\u003e,\n    /// Git stderr output\n    pub stderr: String,\n}\n\n/// Merge a branch using appropriate strategy based on divergence.\n///\n/// Strategy:\n/// 1. Check if branches have diverged\n/// 2. If diverged: Use --no-ff to create a merge commit\n/// 3. If clean fast-forward possible: Use fast-forward merge\n/// 4. If conflicts exist: Return details about the conflict\n///\n/// Returns MergeAttemptResult with success status and conflict details.\nfn merge_branch_ff_only(spec_branch: \u0026str, dry_run: bool) -\u003e Result\u003cMergeAttemptResult\u003e {\n    if dry_run {\n        return Ok(MergeAttemptResult {\n            success: true,\n            conflict_type: None,\n            conflicting_files: vec![],\n            stderr: String::new(),\n        });\n    }\n\n    // Check if branches have diverged\n    let diverged = branches_have_diverged(spec_branch)?;\n\n    let merge_message = format!(\"Merge {}\", spec_branch);\n\n    let mut cmd = Command::new(\"git\");\n    if diverged {\n        // Branches have diverged - use --no-ff to create a merge commit\n        cmd.args([\"merge\", \"--no-ff\", spec_branch, \"-m\", \u0026merge_message]);\n    } else {\n        // Can do fast-forward merge\n        cmd.args([\"merge\", \"--ff-only\", spec_branch]);\n    }\n\n    let output = cmd.output().context(\"Failed to run git merge\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n\n        // Get git status to classify conflict and find files\n        let status_output = Command::new(\"git\")\n            .args([\"status\", \"--porcelain\"])\n            .output()\n            .ok()\n            .map(|o| String::from_utf8_lossy(\u0026o.stdout).to_string());\n\n        let conflict_type =\n            crate::merge_errors::classify_conflict_type(\u0026stderr, status_output.as_deref());\n\n        let conflicting_files = status_output\n            .as_deref()\n            .map(crate::merge_errors::parse_conflicting_files)\n            .unwrap_or_default();\n\n        // Abort the merge to restore clean state\n        let _ = Command::new(\"git\").args([\"merge\", \"--abort\"]).output();\n\n        return Ok(MergeAttemptResult {\n            success: false,\n            conflict_type: Some(conflict_type),\n            conflicting_files,\n            stderr,\n        });\n    }\n\n    Ok(MergeAttemptResult {\n        success: true,\n        conflict_type: None,\n        conflicting_files: vec![],\n        stderr: String::new(),\n    })\n}\n\n/// Delete a branch.\n/// Returns Ok(()) on success, or an error if deletion fails.\npub fn delete_branch(branch_name: \u0026str, dry_run: bool) -\u003e Result\u003c()\u003e {\n    if dry_run {\n        return Ok(());\n    }\n\n    let output = Command::new(\"git\")\n        .args([\"branch\", \"-d\", branch_name])\n        .output()\n        .context(\"Failed to run git branch -d\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to delete branch {}: {}\", branch_name, stderr);\n    }\n\n    Ok(())\n}\n\n/// Result of a rebase operation\n#[derive(Debug)]\npub struct RebaseResult {\n    /// Whether rebase succeeded\n    pub success: bool,\n    /// Files with conflicts (if any)\n    pub conflicting_files: Vec\u003cString\u003e,\n}\n\n/// Rebase a branch onto another branch.\n/// Returns RebaseResult with success status and any conflicting files.\npub fn rebase_branch(spec_branch: \u0026str, onto_branch: \u0026str) -\u003e Result\u003cRebaseResult\u003e {\n    // First checkout the spec branch\n    checkout_branch(spec_branch, false)?;\n\n    // Attempt rebase\n    let output = Command::new(\"git\")\n        .args([\"rebase\", onto_branch])\n        .output()\n        .context(\"Failed to run git rebase\")?;\n\n    if output.status.success() {\n        return Ok(RebaseResult {\n            success: true,\n            conflicting_files: vec![],\n        });\n    }\n\n    // Rebase failed - check for conflicts\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    if stderr.contains(\"CONFLICT\") || stderr.contains(\"conflict\") {\n        // Get list of conflicting files\n        let conflicting_files = get_conflicting_files()?;\n\n        // Abort rebase to restore clean state\n        let _ = Command::new(\"git\").args([\"rebase\", \"--abort\"]).output();\n\n        return Ok(RebaseResult {\n            success: false,\n            conflicting_files,\n        });\n    }\n\n    // Other rebase error\n    let _ = Command::new(\"git\").args([\"rebase\", \"--abort\"]).output();\n    anyhow::bail!(\"Rebase failed: {}\", stderr);\n}\n\n/// Get list of files with conflicts from git status\npub fn get_conflicting_files() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"status\", \"--porcelain\"])\n        .output()\n        .context(\"Failed to run git status\")?;\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut files = Vec::new();\n\n    for line in stdout.lines() {\n        // Conflict markers: UU, AA, DD, AU, UD, UA, DU\n        if line.len() \u003e= 3 {\n            let status = \u0026line[0..2];\n            if status.contains('U') || status == \"AA\" || status == \"DD\" {\n                let file = line[3..].trim();\n                files.push(file.to_string());\n            }\n        }\n    }\n\n    Ok(files)\n}\n\n/// Continue a rebase after conflicts have been resolved\npub fn rebase_continue() -\u003e Result\u003cbool\u003e {\n    let output = Command::new(\"git\")\n        .args([\"rebase\", \"--continue\"])\n        .env(\"GIT_EDITOR\", \"true\") // Skip editor for commit message\n        .output()\n        .context(\"Failed to run git rebase --continue\")?;\n\n    Ok(output.status.success())\n}\n\n/// Abort an in-progress rebase\npub fn rebase_abort() -\u003e Result\u003c()\u003e {\n    let _ = Command::new(\"git\").args([\"rebase\", \"--abort\"]).output();\n    Ok(())\n}\n\n/// Stage a file for commit\npub fn stage_file(file_path: \u0026str) -\u003e Result\u003c()\u003e {\n    let output = Command::new(\"git\")\n        .args([\"add\", file_path])\n        .output()\n        .context(\"Failed to run git add\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage file {}: {}\", file_path, stderr);\n    }\n\n    Ok(())\n}\n\n/// Merge a single spec's branch into the main branch.\n///\n/// This function:\n/// 1. Saves the current branch\n/// 2. Checks if main branch exists\n/// 3. Checks out main branch\n/// 4. Merges spec branch with fast-forward only\n/// 5. Optionally deletes spec branch if requested\n/// 6. Returns to original branch\n///\n/// In dry-run mode, no actual git commands are executed.\npub fn merge_single_spec(\n    spec_id: \u0026str,\n    spec_branch: \u0026str,\n    main_branch: \u0026str,\n    should_delete_branch: bool,\n    dry_run: bool,\n) -\u003e Result\u003cMergeResult\u003e {\n    // In dry_run mode, try to get current branch but don't fail if we're not in a repo\n    if dry_run {\n        let original_branch = get_current_branch().unwrap_or_default();\n        return Ok(MergeResult {\n            spec_id: spec_id.to_string(),\n            success: true,\n            original_branch,\n            merged_to: main_branch.to_string(),\n            branch_deleted: should_delete_branch,\n            branch_delete_warning: None,\n            dry_run: true,\n        });\n    }\n\n    // Save current branch\n    let original_branch = get_current_branch()?;\n\n    // Check if main branch exists\n    if !dry_run \u0026\u0026 !branch_exists(main_branch)? {\n        anyhow::bail!(\n            \"{}\",\n            crate::merge_errors::main_branch_not_found(main_branch)\n        );\n    }\n\n    // Check if spec branch exists\n    if !dry_run \u0026\u0026 !branch_exists(spec_branch)? {\n        anyhow::bail!(\n            \"{}\",\n            crate::merge_errors::branch_not_found(spec_id, spec_branch)\n        );\n    }\n\n    // Checkout main branch\n    if let Err(e) = checkout_branch(main_branch, dry_run) {\n        // Try to return to original branch before failing\n        let _ = checkout_branch(\u0026original_branch, false);\n        return Err(e);\n    }\n\n    // Perform merge\n    let merge_result = match merge_branch_ff_only(spec_branch, dry_run) {\n        Ok(result) =\u003e result,\n        Err(e) =\u003e {\n            // Try to return to original branch before failing\n            let _ = checkout_branch(\u0026original_branch, false);\n            return Err(e);\n        }\n    };\n\n    if !merge_result.success \u0026\u0026 !dry_run {\n        // Merge had conflicts - return to original branch\n        let _ = checkout_branch(\u0026original_branch, false);\n\n        // Use detailed error message with conflict type and file list\n        let conflict_type = merge_result\n            .conflict_type\n            .unwrap_or(crate::merge_errors::ConflictType::Unknown);\n\n        anyhow::bail!(\n            \"{}\",\n            crate::merge_errors::merge_conflict_detailed(\n                spec_id,\n                spec_branch,\n                main_branch,\n                conflict_type,\n                \u0026merge_result.conflicting_files\n            )\n        );\n    }\n\n    let merge_success = merge_result.success;\n\n    // Delete branch if requested and merge was successful\n    let mut branch_delete_warning: Option\u003cString\u003e = None;\n    let mut branch_actually_deleted = false;\n    if should_delete_branch \u0026\u0026 merge_success {\n        if let Err(e) = delete_branch(spec_branch, dry_run) {\n            // Log warning but don't fail overall\n            branch_delete_warning = Some(format!(\"Warning: Failed to delete branch: {}\", e));\n        } else {\n            branch_actually_deleted = true;\n        }\n    }\n\n    // Return to original branch, BUT not if:\n    // 1. We're already on main (no need to switch)\n    // 2. The original branch was the spec branch that we just deleted\n    let should_checkout_original = original_branch != main_branch\n        \u0026\u0026 !(branch_actually_deleted \u0026\u0026 original_branch == spec_branch);\n\n    if should_checkout_original {\n        if let Err(e) = checkout_branch(\u0026original_branch, false) {\n            // If we can't checkout the original branch, stay on main\n            // This can happen if the original branch was deleted elsewhere\n            eprintln!(\n                \"Warning: Could not return to original branch '{}': {}. Staying on {}.\",\n                original_branch, e, main_branch\n            );\n        }\n    }\n\n    Ok(MergeResult {\n        spec_id: spec_id.to_string(),\n        success: merge_success,\n        original_branch,\n        merged_to: main_branch.to_string(),\n        branch_deleted: should_delete_branch \u0026\u0026 merge_success,\n        branch_delete_warning,\n        dry_run,\n    })\n}\n\n/// Result of a merge operation.\n#[derive(Debug, Clone)]\npub struct MergeResult {\n    pub spec_id: String,\n    pub success: bool,\n    pub original_branch: String,\n    pub merged_to: String,\n    pub branch_deleted: bool,\n    pub branch_delete_warning: Option\u003cString\u003e,\n    pub dry_run: bool,\n}\n\n/// Format the merge result as a human-readable summary.\npub fn format_merge_summary(result: \u0026MergeResult) -\u003e String {\n    let mut output = String::new();\n\n    if result.dry_run {\n        output.push_str(\"[DRY RUN] \");\n    }\n\n    if result.success {\n        output.push_str(\u0026format!(\n            \"â Successfully merged {} to {}\",\n            result.spec_id, result.merged_to\n        ));\n        if result.branch_deleted {\n            output.push_str(\u0026format!(\" and deleted branch {}\", result.spec_id));\n        }\n    } else {\n        output.push_str(\u0026format!(\n            \"â Failed to merge {} to {}\",\n            result.spec_id, result.merged_to\n        ));\n    }\n\n    if let Some(warning) = \u0026result.branch_delete_warning {\n        output.push_str(\u0026format!(\"\\n  {}\", warning));\n    }\n\n    output.push_str(\u0026format!(\"\\nReturned to branch: {}\", result.original_branch));\n\n    output\n}\n\n/// Check if branch can be fast-forward merged into target branch.\n/// Returns true if the merge can be done as a fast-forward (no divergence).\npub fn can_fast_forward_merge(branch: \u0026str, target: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Get merge base between branch and target\n    let output = Command::new(\"git\")\n        .args([\"merge-base\", target, branch])\n        .output()\n        .context(\"Failed to find merge base\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let merge_base = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n\n    // Get the commit hash of target\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", target])\n        .output()\n        .context(\"Failed to get target commit\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let target_commit = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n\n    // If merge base equals target, then branch is ahead and can ff-merge\n    Ok(merge_base == target_commit)\n}\n\n/// Check if branch is behind target branch.\n/// Returns true if target has commits that branch doesn't have.\npub fn is_branch_behind(branch: \u0026str, target: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Get merge base\n    let output = Command::new(\"git\")\n        .args([\"merge-base\", branch, target])\n        .output()\n        .context(\"Failed to find merge base\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let merge_base = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n\n    // Get branch commit\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", branch])\n        .output()\n        .context(\"Failed to get branch commit\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let branch_commit = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n\n    // If merge base equals branch commit, then branch is behind target\n    Ok(merge_base == branch_commit)\n}\n\n/// Count number of commits in branch.\npub fn count_commits(branch: \u0026str) -\u003e Result\u003cusize\u003e {\n    let output = Command::new(\"git\")\n        .args([\"rev-list\", \"--count\", branch])\n        .output()\n        .context(\"Failed to count commits\")?;\n\n    if !output.status.success() {\n        return Ok(0);\n    }\n\n    let count_str = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    Ok(count_str.parse().unwrap_or(0))\n}\n\n/// Information about a single git commit.\n#[derive(Debug, Clone)]\npub struct CommitInfo {\n    pub hash: String,\n    pub message: String,\n    pub author: String,\n    pub timestamp: i64,\n}\n\n/// Get commits in a range between two refs.\n///\n/// Returns commits between `from_ref` and `to_ref` (inclusive of `to_ref`, exclusive of `from_ref`).\n/// Uses `git log from_ref..to_ref` format.\n///\n/// # Errors\n/// Returns error if refs are invalid or git command fails.\npub fn get_commits_in_range(from_ref: \u0026str, to_ref: \u0026str) -\u003e Result\u003cVec\u003cCommitInfo\u003e\u003e {\n    let range = format!(\"{}..{}\", from_ref, to_ref);\n\n    let output = Command::new(\"git\")\n        .args([\"log\", \u0026range, \"--format=%H|%an|%at|%s\", \"--reverse\"])\n        .output()\n        .context(\"Failed to execute git log\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Invalid git refs {}: {}\", range, stderr);\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut commits = Vec::new();\n\n    for line in stdout.lines() {\n        if line.is_empty() {\n            continue;\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = line.splitn(4, '|').collect();\n        if parts.len() != 4 {\n            continue;\n        }\n\n        commits.push(CommitInfo {\n            hash: parts[0].to_string(),\n            author: parts[1].to_string(),\n            timestamp: parts[2].parse().unwrap_or(0),\n            message: parts[3].to_string(),\n        });\n    }\n\n    Ok(commits)\n}\n\n/// Get files changed in a specific commit.\n///\n/// Returns a list of file paths that were modified in the commit.\n///\n/// # Errors\n/// Returns error if commit hash is invalid or git command fails.\npub fn get_commit_changed_files(hash: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"diff-tree\", \"--no-commit-id\", \"--name-only\", \"-r\", hash])\n        .output()\n        .context(\"Failed to execute git diff-tree\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Invalid commit hash {}: {}\", hash, stderr);\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let files: Vec\u003cString\u003e = stdout\n        .lines()\n        .filter(|line| !line.is_empty())\n        .map(|line| line.to_string())\n        .collect();\n\n    Ok(files)\n}\n\n/// Get files changed in a commit with their status (A/M/D).\n///\n/// Returns a list of strings in the format \"STATUS:filename\" (e.g., \"A:file.txt\", \"M:file.txt\").\n///\n/// # Errors\n/// Returns error if commit hash is invalid or git command fails.\npub fn get_commit_files_with_status(hash: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"diff-tree\", \"--no-commit-id\", \"--name-status\", \"-r\", hash])\n        .output()\n        .context(\"Failed to execute git diff-tree\")?;\n\n    if !output.status.success() {\n        return Ok(Vec::new());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut files = Vec::new();\n\n    for line in stdout.lines() {\n        let parts: Vec\u003c\u0026str\u003e = line.split('\\t').collect();\n        if parts.len() \u003e= 2 {\n            // parts[0] is status (A, M, D), parts[1] is filename\n            files.push(format!(\"{}:{}\", parts[0], parts[1]));\n        }\n    }\n\n    Ok(files)\n}\n\n/// Get file content at a specific commit.\n///\n/// Returns the file content as a string, or an empty string if the file doesn't exist at that commit.\n///\n/// # Errors\n/// Returns error if git command fails.\npub fn get_file_at_commit(commit: \u0026str, file: \u0026str) -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args([\"show\", \u0026format!(\"{}:{}\", commit, file)])\n        .output()\n        .context(\"Failed to get file at commit\")?;\n\n    if !output.status.success() {\n        return Ok(String::new());\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Get file content at parent commit.\n///\n/// Returns the file content as a string, or an empty string if the file doesn't exist at parent commit.\n///\n/// # Errors\n/// Returns error if git command fails.\npub fn get_file_at_parent(commit: \u0026str, file: \u0026str) -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args([\"show\", \u0026format!(\"{}^:{}\", commit, file)])\n        .output()\n        .context(\"Failed to get file at parent\")?;\n\n    if !output.status.success() {\n        return Ok(String::new());\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Get the N most recent commits.\n///\n/// # Errors\n/// Returns error if git command fails.\npub fn get_recent_commits(count: usize) -\u003e Result\u003cVec\u003cCommitInfo\u003e\u003e {\n    let count_str = count.to_string();\n\n    let output = Command::new(\"git\")\n        .args([\"log\", \"-n\", \u0026count_str, \"--format=%H|%an|%at|%s\"])\n        .output()\n        .context(\"Failed to execute git log\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to get recent commits: {}\", stderr);\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut commits = Vec::new();\n\n    for line in stdout.lines() {\n        if line.is_empty() {\n            continue;\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = line.splitn(4, '|').collect();\n        if parts.len() != 4 {\n            continue;\n        }\n\n        commits.push(CommitInfo {\n            hash: parts[0].to_string(),\n            author: parts[1].to_string(),\n            timestamp: parts[2].parse().unwrap_or(0),\n            message: parts[3].to_string(),\n        });\n    }\n\n    Ok(commits)\n}\n\n/// Get commits that modified a specific path.\n///\n/// # Arguments\n/// * `path` - File or directory path to filter by\n///\n/// # Errors\n/// Returns error if git command fails.\npub fn get_commits_for_path(path: \u0026str) -\u003e Result\u003cVec\u003cCommitInfo\u003e\u003e {\n    let output = Command::new(\"git\")\n        .args([\"log\", \"--all\", \"--format=%H|%an|%at|%s\", \"--\", path])\n        .output()\n        .context(\"Failed to execute git log\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git log failed: {}\", stderr);\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut commits = Vec::new();\n\n    for line in stdout.lines() {\n        if line.is_empty() {\n            continue;\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = line.splitn(4, '|').collect();\n        if parts.len() != 4 {\n            continue;\n        }\n\n        commits.push(CommitInfo {\n            hash: parts[0].to_string(),\n            author: parts[1].to_string(),\n            timestamp: parts[2].parse().unwrap_or(0),\n            message: parts[3].to_string(),\n        });\n    }\n\n    Ok(commits)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_get_current_branch_returns_string() {\n        // This should work in any git repo - gets the current branch\n        let result = get_current_branch();\n        // In a properly initialized git repo, this should succeed\n        if let Ok(branch) = result {\n            // Should have a branch name (not empty)\n            assert!(!branch.is_empty());\n        }\n    }\n\n    // Helper function to initialize a mock git repo for testing\n    fn setup_test_repo() -\u003e Result\u003cTempDir\u003e {\n        let temp_dir = TempDir::new()?;\n        let repo_path = temp_dir.path();\n\n        // Initialize git repo\n        Command::new(\"git\")\n            .arg(\"init\")\n            .current_dir(repo_path)\n            .output()?;\n\n        // Configure git\n        Command::new(\"git\")\n            .args([\"config\", \"user.email\", \"test@example.com\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        Command::new(\"git\")\n            .args([\"config\", \"user.name\", \"Test User\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        // Create initial commit\n        let file_path = repo_path.join(\"test.txt\");\n        fs::write(\u0026file_path, \"test content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"test.txt\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Initial commit\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        // Create and checkout main branch\n        Command::new(\"git\")\n            .args([\"branch\", \"main\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        Command::new(\"git\")\n            .args([\"checkout\", \"main\"])\n            .current_dir(repo_path)\n            .output()?;\n\n        Ok(temp_dir)\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_single_spec_successful_dry_run() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-001\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"spec-file.txt\");\n        fs::write(\u0026file_path, \"spec content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"spec-file.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add spec-file\"])\n            .output()?;\n\n        // Go back to main\n        Command::new(\"git\").args([\"checkout\", \"main\"]).output()?;\n\n        // Test merge with dry-run\n        let result = merge_single_spec(\"spec-001\", \"spec-001\", \"main\", false, true)?;\n\n        assert!(result.success);\n        assert!(result.dry_run);\n        assert_eq!(result.spec_id, \"spec-001\");\n        assert_eq!(result.merged_to, \"main\");\n        assert_eq!(result.original_branch, \"main\");\n\n        // Verify we're still on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        // Verify spec branch still exists (because of dry-run)\n        assert!(branch_exists(\"spec-001\")?);\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_single_spec_successful_with_delete() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-002\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"spec-file2.txt\");\n        fs::write(\u0026file_path, \"spec content 2\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"spec-file2.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add spec-file2\"])\n            .output()?;\n\n        // Go back to main\n        Command::new(\"git\").args([\"checkout\", \"main\"]).output()?;\n\n        // Test merge with delete\n        let result = merge_single_spec(\"spec-002\", \"spec-002\", \"main\", true, false)?;\n\n        assert!(result.success);\n        assert!(!result.dry_run);\n        assert!(result.branch_deleted);\n\n        // Verify branch was deleted\n        assert!(!branch_exists(\"spec-002\")?);\n\n        // Verify we're back on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_single_spec_nonexistent_main_branch() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-003\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"spec-file3.txt\");\n        fs::write(\u0026file_path, \"spec content 3\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"spec-file3.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add spec-file3\"])\n            .output()?;\n\n        // Test merge with nonexistent main branch\n        let result = merge_single_spec(\"spec-003\", \"spec-003\", \"nonexistent\", false, false);\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"does not exist\"));\n\n        // Verify we're still on spec-003\n        let current = get_current_branch()?;\n        assert_eq!(current, \"spec-003\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_single_spec_nonexistent_spec_branch() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Test merge with nonexistent spec branch\n        let result = merge_single_spec(\"nonexistent\", \"nonexistent\", \"main\", false, false);\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"not found\"));\n\n        // Verify we're still on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    fn test_format_merge_summary_success() {\n        let result = MergeResult {\n            spec_id: \"spec-001\".to_string(),\n            success: true,\n            original_branch: \"main\".to_string(),\n            merged_to: \"main\".to_string(),\n            branch_deleted: false,\n            branch_delete_warning: None,\n            dry_run: false,\n        };\n\n        let summary = format_merge_summary(\u0026result);\n        assert!(summary.contains(\"â\"));\n        assert!(summary.contains(\"spec-001\"));\n        assert!(summary.contains(\"Returned to branch: main\"));\n    }\n\n    #[test]\n    fn test_format_merge_summary_with_delete() {\n        let result = MergeResult {\n            spec_id: \"spec-002\".to_string(),\n            success: true,\n            original_branch: \"main\".to_string(),\n            merged_to: \"main\".to_string(),\n            branch_deleted: true,\n            branch_delete_warning: None,\n            dry_run: false,\n        };\n\n        let summary = format_merge_summary(\u0026result);\n        assert!(summary.contains(\"â\"));\n        assert!(summary.contains(\"deleted branch spec-002\"));\n    }\n\n    #[test]\n    fn test_format_merge_summary_dry_run() {\n        let result = MergeResult {\n            spec_id: \"spec-003\".to_string(),\n            success: true,\n            original_branch: \"main\".to_string(),\n            merged_to: \"main\".to_string(),\n            branch_deleted: false,\n            branch_delete_warning: None,\n            dry_run: true,\n        };\n\n        let summary = format_merge_summary(\u0026result);\n        assert!(summary.contains(\"[DRY RUN]\"));\n    }\n\n    #[test]\n    fn test_format_merge_summary_with_warning() {\n        let result = MergeResult {\n            spec_id: \"spec-004\".to_string(),\n            success: true,\n            original_branch: \"main\".to_string(),\n            merged_to: \"main\".to_string(),\n            branch_deleted: false,\n            branch_delete_warning: Some(\"Warning: Could not delete branch\".to_string()),\n            dry_run: false,\n        };\n\n        let summary = format_merge_summary(\u0026result);\n        assert!(summary.contains(\"Warning\"));\n    }\n\n    #[test]\n    fn test_format_merge_summary_failure() {\n        let result = MergeResult {\n            spec_id: \"spec-005\".to_string(),\n            success: false,\n            original_branch: \"main\".to_string(),\n            merged_to: \"main\".to_string(),\n            branch_deleted: false,\n            branch_delete_warning: None,\n            dry_run: false,\n        };\n\n        let summary = format_merge_summary(\u0026result);\n        assert!(summary.contains(\"â\"));\n        assert!(summary.contains(\"Failed to merge\"));\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_branches_have_diverged_no_divergence() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch that's ahead of main\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-no-diverge\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"diverge-test.txt\");\n        fs::write(\u0026file_path, \"spec content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"diverge-test.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add diverge-test\"])\n            .output()?;\n\n        // Go back to main\n        Command::new(\"git\").args([\"checkout\", \"main\"]).output()?;\n\n        // Test divergence check - spec branch is ancestor of main, so no divergence\n        let diverged = branches_have_diverged(\"spec-no-diverge\")?;\n        assert!(!diverged, \"Fast-forward merge should be possible\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_branches_have_diverged_with_divergence() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch from main\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-diverge\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"spec-file.txt\");\n        fs::write(\u0026file_path, \"spec content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"spec-file.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add spec-file\"])\n            .output()?;\n\n        // Go back to main and make a different change\n        Command::new(\"git\").args([\"checkout\", \"main\"]).output()?;\n        let main_file = repo_path.join(\"main-file.txt\");\n        fs::write(\u0026main_file, \"main content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"main-file.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add main-file\"])\n            .output()?;\n\n        // Test divergence check - branches have diverged\n        let diverged = branches_have_diverged(\"spec-diverge\")?;\n        assert!(diverged, \"Branches should have diverged\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_single_spec_with_diverged_branches() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch from main\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-diverged\"])\n            .output()?;\n\n        // Make a change on spec branch\n        let file_path = repo_path.join(\"spec-change.txt\");\n        fs::write(\u0026file_path, \"spec content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"spec-change.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add spec-change\"])\n            .output()?;\n\n        // Go back to main and make a different change\n        Command::new(\"git\").args([\"checkout\", \"main\"]).output()?;\n        let main_file = repo_path.join(\"main-change.txt\");\n        fs::write(\u0026main_file, \"main content\")?;\n        Command::new(\"git\")\n            .args([\"add\", \"main-change.txt\"])\n            .output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add main-change\"])\n            .output()?;\n\n        // Merge with diverged branches - should use --no-ff automatically\n        let result = merge_single_spec(\"spec-diverged\", \"spec-diverged\", \"main\", false, false)?;\n\n        assert!(result.success, \"Merge should succeed with --no-ff\");\n        assert_eq!(result.spec_id, \"spec-diverged\");\n        assert_eq!(result.merged_to, \"main\");\n\n        // Verify we're back on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_ensure_on_main_branch() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a spec branch\n        Command::new(\"git\")\n            .args([\"checkout\", \"-b\", \"spec-test\"])\n            .output()?;\n\n        // Verify we're on spec-test\n        let current = get_current_branch()?;\n        assert_eq!(current, \"spec-test\");\n\n        // Call ensure_on_main_branch - should switch back to main\n        ensure_on_main_branch(\"main\")?;\n\n        // Verify we're back on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_ensure_on_main_branch_already_on_main() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Verify we're on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        // Call ensure_on_main_branch - should be a no-op\n        ensure_on_main_branch(\"main\")?;\n\n        // Verify we're still on main\n        let current = get_current_branch()?;\n        assert_eq!(current, \"main\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commits_in_range() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create additional commits\n        for i in 1..=5 {\n            let file_path = repo_path.join(format!(\"test{}.txt\", i));\n            fs::write(\u0026file_path, format!(\"content {}\", i))?;\n            Command::new(\"git\").args([\"add\", \".\"]).output()?;\n            Command::new(\"git\")\n                .args([\"commit\", \"-m\", \u0026format!(\"Commit {}\", i)])\n                .output()?;\n        }\n\n        // Get commits in range\n        let commits = get_commits_in_range(\"HEAD~5\", \"HEAD\")?;\n\n        assert_eq!(commits.len(), 5);\n        assert_eq!(commits[0].message, \"Commit 1\");\n        assert_eq!(commits[4].message, \"Commit 5\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commits_in_range_invalid_refs() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        let result = get_commits_in_range(\"invalid\", \"HEAD\");\n        assert!(result.is_err());\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commits_in_range_empty() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Same ref should return empty\n        let commits = get_commits_in_range(\"HEAD\", \"HEAD\")?;\n        assert_eq!(commits.len(), 0);\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commit_changed_files() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create a commit with multiple files\n        let file1 = repo_path.join(\"file1.txt\");\n        let file2 = repo_path.join(\"file2.txt\");\n        fs::write(\u0026file1, \"content1\")?;\n        fs::write(\u0026file2, \"content2\")?;\n        Command::new(\"git\").args([\"add\", \".\"]).output()?;\n        Command::new(\"git\")\n            .args([\"commit\", \"-m\", \"Add files\"])\n            .output()?;\n\n        let hash_output = Command::new(\"git\").args([\"rev-parse\", \"HEAD\"]).output()?;\n        let hash = String::from_utf8_lossy(\u0026hash_output.stdout)\n            .trim()\n            .to_string();\n\n        let files = get_commit_changed_files(\u0026hash)?;\n        assert_eq!(files.len(), 2);\n        assert!(files.contains(\u0026\"file1.txt\".to_string()));\n        assert!(files.contains(\u0026\"file2.txt\".to_string()));\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commit_changed_files_invalid_hash() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        let result = get_commit_changed_files(\"invalid_hash\");\n        assert!(result.is_err());\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_commit_changed_files_empty() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create an empty commit\n        Command::new(\"git\")\n            .args([\"commit\", \"--allow-empty\", \"-m\", \"Empty commit\"])\n            .output()?;\n\n        let hash_output = Command::new(\"git\").args([\"rev-parse\", \"HEAD\"]).output()?;\n        let hash = String::from_utf8_lossy(\u0026hash_output.stdout)\n            .trim()\n            .to_string();\n\n        let files = get_commit_changed_files(\u0026hash)?;\n        assert_eq!(files.len(), 0);\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_get_recent_commits() -\u003e Result\u003c()\u003e {\n        let temp_dir = setup_test_repo()?;\n        let repo_path = temp_dir.path();\n        let original_dir = std::env::current_dir()?;\n\n        std::env::set_current_dir(repo_path)?;\n\n        // Create additional commits\n        for i in 1..=5 {\n            let file_path = repo_path.join(format!(\"test{}.txt\", i));\n            fs::write(\u0026file_path, format!(\"content {}\", i))?;\n            Command::new(\"git\").args([\"add\", \".\"]).output()?;\n            Command::new(\"git\")\n                .args([\"commit\", \"-m\", \u0026format!(\"Recent {}\", i)])\n                .output()?;\n        }\n\n        // Get 3 recent commits\n        let commits = get_recent_commits(3)?;\n        assert_eq!(commits.len(), 3);\n        assert_eq!(commits[0].message, \"Recent 5\");\n        assert_eq!(commits[1].message, \"Recent 4\");\n        assert_eq!(commits[2].message, \"Recent 3\");\n\n        std::env::set_current_dir(original_dir)?;\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":14}},{"line":16,"address":[],"length":0,"stats":{"Line":70}},{"line":18,"address":[],"length":0,"stats":{"Line":14}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":42}},{"line":23,"address":[],"length":0,"stats":{"Line":28}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":7}},{"line":34,"address":[],"length":0,"stats":{"Line":21}},{"line":39,"address":[],"length":0,"stats":{"Line":49}},{"line":40,"address":[],"length":0,"stats":{"Line":147}},{"line":41,"address":[],"length":0,"stats":{"Line":98}},{"line":45,"address":[],"length":0,"stats":{"Line":49}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":141}},{"line":50,"address":[],"length":0,"stats":{"Line":47}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":24}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":22}},{"line":80,"address":[],"length":0,"stats":{"Line":66}},{"line":81,"address":[],"length":0,"stats":{"Line":44}},{"line":85,"address":[],"length":0,"stats":{"Line":22}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":66}},{"line":90,"address":[],"length":0,"stats":{"Line":22}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":18}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":24}},{"line":147,"address":[],"length":0,"stats":{"Line":24}},{"line":153,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":18}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":193,"address":[],"length":0,"stats":{"Line":12}},{"line":194,"address":[],"length":0,"stats":{"Line":8}},{"line":196,"address":[],"length":0,"stats":{"Line":10}},{"line":199,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":24}},{"line":204,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":12}},{"line":236,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":5}},{"line":244,"address":[],"length":0,"stats":{"Line":5}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":15}},{"line":249,"address":[],"length":0,"stats":{"Line":10}},{"line":253,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":5}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":20}},{"line":384,"address":[],"length":0,"stats":{"Line":20}},{"line":385,"address":[],"length":0,"stats":{"Line":36}},{"line":386,"address":[],"length":0,"stats":{"Line":12}},{"line":387,"address":[],"length":0,"stats":{"Line":36}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":389,"address":[],"length":0,"stats":{"Line":24}},{"line":390,"address":[],"length":0,"stats":{"Line":36}},{"line":391,"address":[],"length":0,"stats":{"Line":12}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":393,"address":[],"length":0,"stats":{"Line":12}},{"line":398,"address":[],"length":0,"stats":{"Line":16}},{"line":401,"address":[],"length":0,"stats":{"Line":24}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":21}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":3}},{"line":417,"address":[],"length":0,"stats":{"Line":12}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":18}},{"line":425,"address":[],"length":0,"stats":{"Line":12}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":12}},{"line":457,"address":[],"length":0,"stats":{"Line":18}},{"line":458,"address":[],"length":0,"stats":{"Line":12}},{"line":459,"address":[],"length":0,"stats":{"Line":11}},{"line":460,"address":[],"length":0,"stats":{"Line":10}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":5}},{"line":471,"address":[],"length":0,"stats":{"Line":12}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":6}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":12}},{"line":487,"address":[],"length":0,"stats":{"Line":6}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":12}},{"line":490,"address":[],"length":0,"stats":{"Line":11}},{"line":491,"address":[],"length":0,"stats":{"Line":6}},{"line":492,"address":[],"length":0,"stats":{"Line":6}},{"line":509,"address":[],"length":0,"stats":{"Line":9}},{"line":510,"address":[],"length":0,"stats":{"Line":18}},{"line":512,"address":[],"length":0,"stats":{"Line":10}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":9}},{"line":517,"address":[],"length":0,"stats":{"Line":24}},{"line":518,"address":[],"length":0,"stats":{"Line":8}},{"line":519,"address":[],"length":0,"stats":{"Line":8}},{"line":521,"address":[],"length":0,"stats":{"Line":13}},{"line":522,"address":[],"length":0,"stats":{"Line":10}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":527,"address":[],"length":0,"stats":{"Line":1}},{"line":531,"address":[],"length":0,"stats":{"Line":11}},{"line":532,"address":[],"length":0,"stats":{"Line":2}},{"line":535,"address":[],"length":0,"stats":{"Line":27}},{"line":537,"address":[],"length":0,"stats":{"Line":9}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":3}},{"line":634,"address":[],"length":0,"stats":{"Line":6}},{"line":636,"address":[],"length":0,"stats":{"Line":9}},{"line":637,"address":[],"length":0,"stats":{"Line":9}},{"line":641,"address":[],"length":0,"stats":{"Line":3}},{"line":642,"address":[],"length":0,"stats":{"Line":3}},{"line":643,"address":[],"length":0,"stats":{"Line":1}},{"line":646,"address":[],"length":0,"stats":{"Line":6}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":649,"address":[],"length":0,"stats":{"Line":7}},{"line":650,"address":[],"length":0,"stats":{"Line":10}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":25}},{"line":655,"address":[],"length":0,"stats":{"Line":5}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":15}},{"line":660,"address":[],"length":0,"stats":{"Line":15}},{"line":661,"address":[],"length":0,"stats":{"Line":15}},{"line":662,"address":[],"length":0,"stats":{"Line":20}},{"line":663,"address":[],"length":0,"stats":{"Line":5}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":676,"address":[],"length":0,"stats":{"Line":3}},{"line":677,"address":[],"length":0,"stats":{"Line":9}},{"line":678,"address":[],"length":0,"stats":{"Line":12}},{"line":682,"address":[],"length":0,"stats":{"Line":3}},{"line":683,"address":[],"length":0,"stats":{"Line":3}},{"line":684,"address":[],"length":0,"stats":{"Line":1}},{"line":687,"address":[],"length":0,"stats":{"Line":6}},{"line":688,"address":[],"length":0,"stats":{"Line":6}},{"line":690,"address":[],"length":0,"stats":{"Line":6}},{"line":691,"address":[],"length":0,"stats":{"Line":6}},{"line":694,"address":[],"length":0,"stats":{"Line":2}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":1}},{"line":770,"address":[],"length":0,"stats":{"Line":3}},{"line":772,"address":[],"length":0,"stats":{"Line":3}},{"line":773,"address":[],"length":0,"stats":{"Line":3}},{"line":777,"address":[],"length":0,"stats":{"Line":1}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":3}},{"line":783,"address":[],"length":0,"stats":{"Line":2}},{"line":785,"address":[],"length":0,"stats":{"Line":4}},{"line":786,"address":[],"length":0,"stats":{"Line":6}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":15}},{"line":791,"address":[],"length":0,"stats":{"Line":3}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":9}},{"line":796,"address":[],"length":0,"stats":{"Line":9}},{"line":797,"address":[],"length":0,"stats":{"Line":9}},{"line":798,"address":[],"length":0,"stats":{"Line":12}},{"line":799,"address":[],"length":0,"stats":{"Line":3}},{"line":803,"address":[],"length":0,"stats":{"Line":1}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}}],"covered":160,"coverable":343},{"path":["/","Users","alex","Documents","checkouts","chant","src","id.rs"],"content":"//! Spec ID generation with date-based sequencing.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: concepts/ids.md, reference/schema.md\n//! - ignore: false\n\nuse anyhow::{anyhow, Result};\nuse chrono::Local;\nuse rand::Rng;\nuse std::fmt::{self, Display, Formatter};\nuse std::path::Path;\n\nconst BASE36_CHARS: \u0026[u8] = b\"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n/// Generate a new spec ID in the format: YYYY-MM-DD-SSS-XXX\n/// where SSS is a base36 sequence and XXX is a random base36 suffix.\npub fn generate_id(specs_dir: \u0026Path) -\u003e Result\u003cString\u003e {\n    let date = Local::now().format(\"%Y-%m-%d\").to_string();\n    let seq = next_sequence_for_date(specs_dir, \u0026date)?;\n    let rand = random_base36(3);\n\n    Ok(format!(\"{}-{}-{}\", date, format_base36(seq, 3), rand))\n}\n\n/// Get the next sequence number for a given date.\nfn next_sequence_for_date(specs_dir: \u0026Path, date: \u0026str) -\u003e Result\u003cu32\u003e {\n    let mut max_seq = 0u32;\n\n    if specs_dir.exists() {\n        for entry in std::fs::read_dir(specs_dir)? {\n            let entry = entry?;\n            let filename = entry.file_name();\n            let name = filename.to_string_lossy();\n\n            // Match pattern: YYYY-MM-DD-SSS-XXX.md or YYYY-MM-DD-SSS-XXX.N.md (group member)\n            if name.starts_with(date) \u0026\u0026 name.ends_with(\".md\") {\n                // Extract the sequence part (after the date, before the random suffix)\n                let parts: Vec\u003c\u0026str\u003e = name.trim_end_matches(\".md\").split('-').collect();\n                if parts.len() \u003e= 5 {\n                    // parts: [YYYY, MM, DD, SSS, XXX] or [YYYY, MM, DD, SSS, XXX.N]\n                    if let Some(seq) = parse_base36(parts[3]) {\n                        max_seq = max_seq.max(seq);\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(max_seq + 1)\n}\n\n/// Format a number as base36 with zero-padding.\npub fn format_base36(n: u32, width: usize) -\u003e String {\n    if n == 0 {\n        return \"0\".repeat(width);\n    }\n\n    let mut result = Vec::new();\n    let mut num = n;\n\n    while num \u003e 0 {\n        let digit = (num % 36) as usize;\n        result.push(BASE36_CHARS[digit] as char);\n        num /= 36;\n    }\n\n    result.reverse();\n    let s: String = result.into_iter().collect();\n\n    if s.len() \u003c width {\n        format!(\"{:0\u003ewidth$}\", s, width = width)\n    } else {\n        s\n    }\n}\n\n/// Parse a base36 string to a number.\npub fn parse_base36(s: \u0026str) -\u003e Option\u003cu32\u003e {\n    let mut result = 0u32;\n\n    for c in s.chars() {\n        result *= 36;\n        if let Some(pos) = BASE36_CHARS.iter().position(|\u0026b| b as char == c) {\n            result += pos as u32;\n        } else {\n            return None;\n        }\n    }\n\n    Some(result)\n}\n\n/// Generate a random base36 string of the given length.\nfn random_base36(len: usize) -\u003e String {\n    let mut rng = rand::thread_rng();\n    (0..len)\n        .map(|_| BASE36_CHARS[rng.gen_range(0..36)] as char)\n        .collect()\n}\n\n/// Represents a parsed spec ID with optional repo prefix.\n///\n/// Spec IDs can have three formats:\n/// - `2026-01-27-001-abc` (local spec, no repo prefix)\n/// - `project-2026-01-27-001-abc` (local spec with project prefix)\n/// - `backend:2026-01-27-001-abc` (cross-repo spec without project)\n/// - `backend:auth-2026-01-27-001-abc` (cross-repo spec with project)\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SpecId {\n    pub repo: Option\u003cString\u003e,\n    pub project: Option\u003cString\u003e,\n    pub base_id: String,\n    pub member: Option\u003cu32\u003e,\n}\n\nimpl SpecId {\n    /// Parse a spec ID string into a SpecId struct.\n    ///\n    /// Supports formats:\n    /// - `2026-01-27-001-abc` - local spec\n    /// - `project-2026-01-27-001-abc` - local spec with project\n    /// - `backend:2026-01-27-001-abc` - cross-repo spec\n    /// - `backend:project-2026-01-27-001-abc` - cross-repo with project\n    /// - Any of above with `.N` suffix for group members\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - Repo name contains invalid characters (not alphanumeric, hyphen, or underscore)\n    /// - Repo name is empty\n    /// - Base ID format is invalid\n    pub fn parse(input: \u0026str) -\u003e Result\u003cSelf\u003e {\n        if input.is_empty() {\n            return Err(anyhow!(\"Spec ID cannot be empty\"));\n        }\n\n        // Check for repo prefix (first `:`)\n        let (repo, remainder) = if let Some(colon_pos) = input.find(':') {\n            let repo_name = \u0026input[..colon_pos];\n            if repo_name.is_empty() {\n                return Err(anyhow!(\"Repo name cannot be empty before ':'\"));\n            }\n            if !is_valid_repo_name(repo_name) {\n                return Err(anyhow!(\"Invalid repo name '{}': must contain only alphanumeric characters, hyphens, and underscores\", repo_name));\n            }\n            (Some(repo_name.to_string()), \u0026input[colon_pos + 1..])\n        } else {\n            (None, input)\n        };\n\n        // Parse the remainder as: [project-]base_id[.member]\n        let (base_id, member) = Self::parse_base_id(remainder)?;\n\n        // Check if base_id has a project prefix\n        let (project, base_id) = Self::extract_project(\u0026base_id)?;\n\n        Ok(SpecId {\n            repo,\n            project,\n            base_id,\n            member,\n        })\n    }\n\n    /// Parse the base ID part, handling member suffixes.\n    fn parse_base_id(input: \u0026str) -\u003e Result\u003c(String, Option\u003cu32\u003e)\u003e {\n        if input.is_empty() {\n            return Err(anyhow!(\"Base ID cannot be empty\"));\n        }\n\n        // Check for member suffix (.N)\n        if let Some(dot_pos) = input.rfind('.') {\n            let (base, suffix) = input.split_at(dot_pos);\n            // Check if suffix is numeric\n            if suffix.len() \u003e 1 {\n                let num_str = \u0026suffix[1..];\n                // Check if the first part after dot is numeric\n                if let Some(first_char) = num_str.chars().next() {\n                    if first_char.is_ascii_digit() {\n                        // Try to parse as member number\n                        let member_part: String =\n                            num_str.chars().take_while(|c| c.is_ascii_digit()).collect();\n                        if let Ok(member_num) = member_part.parse::\u003cu32\u003e() {\n                            return Ok((base.to_string(), Some(member_num)));\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok((input.to_string(), None))\n    }\n\n    /// Extract project prefix from base_id if present.\n    /// Project prefix format: `project-rest` where project is alphanumeric with hyphens/underscores.\n    /// Looks for a 4-digit year (YYYY) in the string to detect the start of the date part.\n    fn extract_project(base_id: \u0026str) -\u003e Result\u003c(Option\u003cString\u003e, String)\u003e {\n        let parts: Vec\u003c\u0026str\u003e = base_id.split('-').collect();\n\n        // Need at least 5 parts for any valid spec ID: [YYYY, MM, DD, SSS, XXX]\n        // If less than 5 parts, no project prefix possible\n        if parts.len() \u003c 5 {\n            return Ok((None, base_id.to_string()));\n        }\n\n        // Check if parts[0] looks like a year (YYYY)\n        if parts[0].len() == 4 \u0026\u0026 parts[0].chars().all(|c| c.is_ascii_digit()) {\n            // No project prefix, starts with year directly\n            return Ok((None, base_id.to_string()));\n        }\n\n        // Look for a 4-digit year anywhere in the parts after position 0\n        for i in 1..parts.len() {\n            if parts[i].len() == 4 \u0026\u0026 parts[i].chars().all(|c| c.is_ascii_digit()) {\n                // Found a year at position i, everything before is the project\n                let project = parts[0..i].join(\"-\");\n                let rest = parts[i..].join(\"-\");\n                return Ok((Some(project), rest));\n            }\n        }\n\n        // No year found, treat as no project\n        Ok((None, base_id.to_string()))\n    }\n}\n\nimpl Display for SpecId {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\n        if let Some(repo) = \u0026self.repo {\n            write!(f, \"{}:\", repo)?;\n        }\n        if let Some(project) = \u0026self.project {\n            write!(f, \"{}-\", project)?;\n        }\n        write!(f, \"{}\", self.base_id)?;\n        if let Some(member) = self.member {\n            write!(f, \".{}\", member)?;\n        }\n        Ok(())\n    }\n}\n\n/// Check if a string is a valid repo name.\n/// Valid names contain only alphanumeric characters, hyphens, and underscores.\nfn is_valid_repo_name(name: \u0026str) -\u003e bool {\n    !name.is_empty()\n        \u0026\u0026 name\n            .chars()\n            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_format_base36() {\n        assert_eq!(format_base36(0, 3), \"000\");\n        assert_eq!(format_base36(1, 3), \"001\");\n        assert_eq!(format_base36(10, 3), \"00a\");\n        assert_eq!(format_base36(35, 3), \"00z\");\n        assert_eq!(format_base36(36, 3), \"010\");\n        assert_eq!(format_base36(999, 3), \"0rr\");\n        assert_eq!(format_base36(1000, 3), \"0rs\");\n    }\n\n    #[test]\n    fn test_parse_base36() {\n        assert_eq!(parse_base36(\"000\"), Some(0));\n        assert_eq!(parse_base36(\"001\"), Some(1));\n        assert_eq!(parse_base36(\"00a\"), Some(10));\n        assert_eq!(parse_base36(\"00z\"), Some(35));\n        assert_eq!(parse_base36(\"010\"), Some(36));\n    }\n\n    #[test]\n    fn test_random_base36_length() {\n        let r = random_base36(3);\n        assert_eq!(r.len(), 3);\n        assert!(r.chars().all(|c| BASE36_CHARS.contains(\u0026(c as u8))));\n    }\n\n    // SpecId tests\n\n    #[test]\n    fn test_parse_local_id_without_project() {\n        let spec = SpecId::parse(\"2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, None);\n        assert_eq!(spec.project, None);\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, None);\n    }\n\n    #[test]\n    fn test_parse_local_id_with_project() {\n        let spec = SpecId::parse(\"auth-2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, None);\n        assert_eq!(spec.project, Some(\"auth\".to_string()));\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, None);\n    }\n\n    #[test]\n    fn test_parse_repo_id_without_project() {\n        let spec = SpecId::parse(\"backend:2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, Some(\"backend\".to_string()));\n        assert_eq!(spec.project, None);\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, None);\n    }\n\n    #[test]\n    fn test_parse_repo_id_with_project() {\n        let spec = SpecId::parse(\"backend:auth-2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, Some(\"backend\".to_string()));\n        assert_eq!(spec.project, Some(\"auth\".to_string()));\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, None);\n    }\n\n    #[test]\n    fn test_parse_local_id_with_member() {\n        let spec = SpecId::parse(\"2026-01-27-001-abc.1\").unwrap();\n        assert_eq!(spec.repo, None);\n        assert_eq!(spec.project, None);\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, Some(1));\n    }\n\n    #[test]\n    fn test_parse_local_id_with_project_and_member() {\n        let spec = SpecId::parse(\"auth-2026-01-27-001-abc.3\").unwrap();\n        assert_eq!(spec.repo, None);\n        assert_eq!(spec.project, Some(\"auth\".to_string()));\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, Some(3));\n    }\n\n    #[test]\n    fn test_parse_repo_id_with_member() {\n        let spec = SpecId::parse(\"backend:2026-01-27-001-abc.2\").unwrap();\n        assert_eq!(spec.repo, Some(\"backend\".to_string()));\n        assert_eq!(spec.project, None);\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, Some(2));\n    }\n\n    #[test]\n    fn test_parse_repo_id_with_project_and_member() {\n        let spec = SpecId::parse(\"backend:auth-2026-01-27-001-abc.5\").unwrap();\n        assert_eq!(spec.repo, Some(\"backend\".to_string()));\n        assert_eq!(spec.project, Some(\"auth\".to_string()));\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n        assert_eq!(spec.member, Some(5));\n    }\n\n    #[test]\n    fn test_parse_repo_with_hyphen() {\n        let spec = SpecId::parse(\"my-repo:2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, Some(\"my-repo\".to_string()));\n        assert_eq!(spec.project, None);\n        assert_eq!(spec.base_id, \"2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_parse_repo_with_underscore() {\n        let spec = SpecId::parse(\"my_repo:2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.repo, Some(\"my_repo\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_project_with_hyphen() {\n        let spec = SpecId::parse(\"auth-service-2026-01-27-001-abc\").unwrap();\n        assert_eq!(spec.project, Some(\"auth-service\".to_string()));\n    }\n\n    #[test]\n    fn test_invalid_repo_name_empty_before_colon() {\n        let result = SpecId::parse(\":2026-01-27-001-abc\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"empty\"));\n    }\n\n    #[test]\n    fn test_invalid_repo_name_with_special_chars() {\n        let result = SpecId::parse(\"back@end:2026-01-27-001-abc\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_repo_name_with_dot() {\n        let result = SpecId::parse(\"backend.com:2026-01-27-001-abc\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_empty_spec_id() {\n        let result = SpecId::parse(\"\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_display_local_id() {\n        let spec = SpecId {\n            repo: None,\n            project: None,\n            base_id: \"2026-01-27-001-abc\".to_string(),\n            member: None,\n        };\n        assert_eq!(spec.to_string(), \"2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_display_local_id_with_project() {\n        let spec = SpecId {\n            repo: None,\n            project: Some(\"auth\".to_string()),\n            base_id: \"2026-01-27-001-abc\".to_string(),\n            member: None,\n        };\n        assert_eq!(spec.to_string(), \"auth-2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_display_repo_id() {\n        let spec = SpecId {\n            repo: Some(\"backend\".to_string()),\n            project: None,\n            base_id: \"2026-01-27-001-abc\".to_string(),\n            member: None,\n        };\n        assert_eq!(spec.to_string(), \"backend:2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_display_repo_id_with_project() {\n        let spec = SpecId {\n            repo: Some(\"backend\".to_string()),\n            project: Some(\"auth\".to_string()),\n            base_id: \"2026-01-27-001-abc\".to_string(),\n            member: None,\n        };\n        assert_eq!(spec.to_string(), \"backend:auth-2026-01-27-001-abc\");\n    }\n\n    #[test]\n    fn test_display_with_member() {\n        let spec = SpecId {\n            repo: Some(\"backend\".to_string()),\n            project: Some(\"auth\".to_string()),\n            base_id: \"2026-01-27-001-abc\".to_string(),\n            member: Some(3),\n        };\n        assert_eq!(spec.to_string(), \"backend:auth-2026-01-27-001-abc.3\");\n    }\n\n    #[test]\n    fn test_parse_and_display_roundtrip() {\n        let inputs = vec![\n            \"2026-01-27-001-abc\",\n            \"auth-2026-01-27-001-abc\",\n            \"backend:2026-01-27-001-abc\",\n            \"backend:auth-2026-01-27-001-abc\",\n            \"2026-01-27-001-abc.1\",\n            \"auth-2026-01-27-001-abc.2\",\n            \"backend:2026-01-27-001-abc.3\",\n            \"backend:auth-2026-01-27-001-abc.4\",\n            \"my-repo:my-proj-2026-01-27-001-abc.5\",\n        ];\n\n        for input in inputs {\n            let spec = SpecId::parse(input).unwrap();\n            assert_eq!(spec.to_string(), input);\n        }\n    }\n\n    #[test]\n    fn test_parse_member_with_large_number() {\n        let spec = SpecId::parse(\"2026-01-27-001-abc.999\").unwrap();\n        assert_eq!(spec.member, Some(999));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":14}},{"line":19,"address":[],"length":0,"stats":{"Line":56}},{"line":20,"address":[],"length":0,"stats":{"Line":56}},{"line":21,"address":[],"length":0,"stats":{"Line":28}},{"line":23,"address":[],"length":0,"stats":{"Line":28}},{"line":27,"address":[],"length":0,"stats":{"Line":14}},{"line":28,"address":[],"length":0,"stats":{"Line":28}},{"line":30,"address":[],"length":0,"stats":{"Line":28}},{"line":31,"address":[],"length":0,"stats":{"Line":28}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":21}},{"line":55,"address":[],"length":0,"stats":{"Line":21}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":40}},{"line":60,"address":[],"length":0,"stats":{"Line":40}},{"line":62,"address":[],"length":0,"stats":{"Line":66}},{"line":63,"address":[],"length":0,"stats":{"Line":69}},{"line":64,"address":[],"length":0,"stats":{"Line":69}},{"line":65,"address":[],"length":0,"stats":{"Line":23}},{"line":68,"address":[],"length":0,"stats":{"Line":20}},{"line":69,"address":[],"length":0,"stats":{"Line":100}},{"line":71,"address":[],"length":0,"stats":{"Line":40}},{"line":72,"address":[],"length":0,"stats":{"Line":20}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":255}},{"line":80,"address":[],"length":0,"stats":{"Line":510}},{"line":82,"address":[],"length":0,"stats":{"Line":1443}},{"line":83,"address":[],"length":0,"stats":{"Line":933}},{"line":84,"address":[],"length":0,"stats":{"Line":34888}},{"line":85,"address":[],"length":0,"stats":{"Line":933}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":255}},{"line":95,"address":[],"length":0,"stats":{"Line":15}},{"line":96,"address":[],"length":0,"stats":{"Line":30}},{"line":97,"address":[],"length":0,"stats":{"Line":15}},{"line":98,"address":[],"length":0,"stats":{"Line":150}},{"line":133,"address":[],"length":0,"stats":{"Line":26}},{"line":134,"address":[],"length":0,"stats":{"Line":52}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":83}},{"line":140,"address":[],"length":0,"stats":{"Line":28}},{"line":141,"address":[],"length":0,"stats":{"Line":28}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":22}},{"line":149,"address":[],"length":0,"stats":{"Line":11}},{"line":153,"address":[],"length":0,"stats":{"Line":88}},{"line":156,"address":[],"length":0,"stats":{"Line":88}},{"line":158,"address":[],"length":0,"stats":{"Line":22}},{"line":159,"address":[],"length":0,"stats":{"Line":44}},{"line":160,"address":[],"length":0,"stats":{"Line":44}},{"line":161,"address":[],"length":0,"stats":{"Line":22}},{"line":162,"address":[],"length":0,"stats":{"Line":22}},{"line":167,"address":[],"length":0,"stats":{"Line":22}},{"line":168,"address":[],"length":0,"stats":{"Line":44}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":32}},{"line":174,"address":[],"length":0,"stats":{"Line":40}},{"line":176,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":180,"address":[],"length":0,"stats":{"Line":20}},{"line":182,"address":[],"length":0,"stats":{"Line":20}},{"line":183,"address":[],"length":0,"stats":{"Line":64}},{"line":184,"address":[],"length":0,"stats":{"Line":20}},{"line":185,"address":[],"length":0,"stats":{"Line":20}},{"line":192,"address":[],"length":0,"stats":{"Line":24}},{"line":198,"address":[],"length":0,"stats":{"Line":22}},{"line":199,"address":[],"length":0,"stats":{"Line":110}},{"line":203,"address":[],"length":0,"stats":{"Line":22}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":178}},{"line":210,"address":[],"length":0,"stats":{"Line":24}},{"line":214,"address":[],"length":0,"stats":{"Line":22}},{"line":215,"address":[],"length":0,"stats":{"Line":116}},{"line":217,"address":[],"length":0,"stats":{"Line":40}},{"line":218,"address":[],"length":0,"stats":{"Line":40}},{"line":219,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":14}},{"line":230,"address":[],"length":0,"stats":{"Line":22}},{"line":231,"address":[],"length":0,"stats":{"Line":16}},{"line":233,"address":[],"length":0,"stats":{"Line":22}},{"line":234,"address":[],"length":0,"stats":{"Line":16}},{"line":236,"address":[],"length":0,"stats":{"Line":28}},{"line":237,"address":[],"length":0,"stats":{"Line":20}},{"line":238,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":14}},{"line":246,"address":[],"length":0,"stats":{"Line":13}},{"line":247,"address":[],"length":0,"stats":{"Line":13}},{"line":248,"address":[],"length":0,"stats":{"Line":13}},{"line":249,"address":[],"length":0,"stats":{"Line":13}},{"line":250,"address":[],"length":0,"stats":{"Line":201}}],"covered":89,"coverable":102},{"path":["/","Users","alex","Documents","checkouts","chant","src","lib.rs"],"content":"//! # Chant - Intent Driven Development\n//!\n//! Chant is a specification-driven development tool that enables reproducible,\n//! auditable AI-assisted development workflows.\n//!\n//! ## Overview\n//!\n//! Specs define work intentions as markdown files with YAML frontmatter. The chant\n//! CLI executes them in isolated git worktrees, ensuring reproducibility and\n//! auditability of all changes.\n//!\n//! ## Core Concepts\n//!\n//! - **Specs**: Markdown files describing work to be done, with acceptance criteria\n//! - **Worktrees**: Isolated git worktrees for spec execution\n//! - **Providers**: Pluggable AI model backends (Claude, Ollama, OpenAI)\n//!\n//! ## Modules\n//!\n//! - [`spec`] - Spec parsing, frontmatter handling, and lifecycle management\n//! - [`spec_group`] - Spec group/driver orchestration logic\n//! - [`config`] - Configuration management for chant projects\n//! - [`git`] - Git provider abstraction for PR creation\n//! - [`provider`] - AI model provider abstraction\n//! - [`worktree`] - Isolated git worktree operations\n//! - [`id`] - Spec ID generation with date-based sequencing\n//! - [`prompt`] - Prompt template management\n//! - [`merge`] - Spec merge logic and utilities\n//!\n//! ## Example\n//!\n//! ```no_run\n//! use std::path::Path;\n//! use chant::spec::{Spec, SpecStatus};\n//! use chant::config::Config;\n//!\n//! // Load project configuration\n//! let config = Config::load().expect(\"Failed to load config\");\n//!\n//! // Load a spec from a file\n//! let spec = Spec::load(Path::new(\".chant/specs/2026-01-24-01m-q7e.md\"))\n//!     .expect(\"Failed to load spec\");\n//!\n//! // Check spec status\n//! match spec.frontmatter.status {\n//!     SpecStatus::Pending =\u003e println!(\"Spec is pending\"),\n//!     SpecStatus::Completed =\u003e println!(\"Spec is complete\"),\n//!     _ =\u003e {}\n//! }\n//! ```\n\n// Re-export all public modules\npub mod agent;\npub mod config;\npub mod conflict;\npub mod deps;\npub mod derivation;\npub mod diagnose;\npub mod formatters;\npub mod git;\npub mod id;\npub mod merge;\npub mod merge_driver;\npub mod merge_errors;\npub mod pid;\npub mod prompt;\npub mod prompts;\npub mod provider;\npub mod retry;\npub mod score;\npub mod scoring;\npub mod site;\npub mod spec;\npub mod spec_group;\npub mod spec_template;\npub mod status;\npub mod takeover;\npub mod tools;\npub mod ui;\npub mod validation;\npub mod worktree;\n\n/// Default path constants for chant directory structure.\npub mod paths {\n    /// Directory containing spec files: `.chant/specs`\n    pub const SPECS_DIR: \u0026str = \".chant/specs\";\n    /// Directory containing prompt templates: `.chant/prompts`\n    pub const PROMPTS_DIR: \u0026str = \".chant/prompts\";\n    /// Directory containing execution logs: `.chant/logs`\n    pub const LOGS_DIR: \u0026str = \".chant/logs\";\n    /// Directory containing archived specs: `.chant/archive`\n    pub const ARCHIVE_DIR: \u0026str = \".chant/archive\";\n    /// Directory containing lock files: `.chant/.locks`\n    pub const LOCKS_DIR: \u0026str = \".chant/.locks\";\n    /// Directory containing internal store: `.chant/.store`\n    pub const STORE_DIR: \u0026str = \".chant/.store\";\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","main.rs"],"content":"//! CLI entry point and command handlers for chant.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: reference/cli.md\n//! - ignore: false\n\n// Internal modules not exposed via library\nmod mcp;\nmod render;\nmod templates;\n\nmod cmd;\n\nuse anyhow::Result;\nuse clap::{CommandFactory, Parser, Subcommand};\nuse clap_complete::{generate, Shell};\nuse colored::Colorize;\nuse std::io;\nuse std::path::{Path, PathBuf};\n\nuse cmd::dispatch::Execute;\n\n#[derive(Parser)]\n#[command(name = \"chant\")]\n#[command(version)]\n#[command(about = \"Intent Driven Development\", long_about = None)]\n#[command(\n    after_help = \"GETTING STARTED:\\n    chant init                 Interactive setup wizard (recommended)\\n    chant init --help           Show all initialization options\\n\\n    The wizard guides you through project setup, model selection, and agent configuration.\"\n)]\nstruct Cli {\n    /// Suppress all non-essential output\n    #[arg(short, long, global = true)]\n    quiet: bool,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Initialize chant in the current directory\n    ///\n    /// TIP: Run 'chant init' with no arguments for an interactive setup wizard.\n    /// The wizard guides you through all configuration options including:\n    ///   - Project name and settings\n    ///   - Model provider selection (Claude CLI, Ollama, OpenAI)\n    ///   - Default model selection\n    ///   - Agent configuration (creates CLAUDE.md, .mcp.json automatically)\n    Init {\n        /// Optional subcommand: 'prompts' to install/update prompts on existing projects\n        #[arg(value_name = \"SUBCOMMAND\")]\n        subcommand: Option\u003cString\u003e,\n        /// Override detected project name\n        #[arg(long)]\n        name: Option\u003cString\u003e,\n        /// Keep .chant/ local only (not tracked in git)\n        #[arg(long)]\n        silent: bool,\n        /// Overwrite existing .chant/ directory\n        #[arg(long)]\n        force_overwrite: bool,\n        /// Only create config.md, no prompt templates\n        #[arg(long)]\n        minimal: bool,\n        /// Initialize agent configuration files (claude, cursor, amazonq, generic, or all)\n        /// Can be specified multiple times\n        #[arg(long, value_name = \"PROVIDER\")]\n        agent: Vec\u003cString\u003e,\n        /// Set default model provider (claude, ollama, openai)\n        #[arg(long, value_name = \"PROVIDER\")]\n        provider: Option\u003cString\u003e,\n        /// Set default model (opus, sonnet, haiku, or custom model name)\n        #[arg(long, value_name = \"MODEL\")]\n        model: Option\u003cString\u003e,\n        /// Set up git merge driver for spec files\n        #[arg(long)]\n        merge_driver: bool,\n    },\n    /// Add a new spec\n    Add {\n        /// Description of what to implement (ignored when using --template)\n        #[arg(default_value = \"\")]\n        description: String,\n        /// Prompt to use for execution\n        #[arg(long)]\n        prompt: Option\u003cString\u003e,\n        /// Require approval before this spec can be worked\n        #[arg(long)]\n        needs_approval: bool,\n        /// Create spec from a template\n        #[arg(long, value_name = \"NAME\")]\n        template: Option\u003cString\u003e,\n        /// Set template variable (can be specified multiple times, format: key=value)\n        #[arg(long = \"var\", value_name = \"KEY=VALUE\")]\n        vars: Vec\u003cString\u003e,\n    },\n    /// Manage spec templates\n    Template {\n        #[command(subcommand)]\n        command: TemplateCommands,\n    },\n    /// Approve a spec for work\n    Approve {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Name of the person approving (validated against git committers)\n        #[arg(long)]\n        by: String,\n    },\n    /// Reject a spec with a reason\n    Reject {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Name of the person rejecting (validated against git committers)\n        #[arg(long)]\n        by: String,\n        /// Reason for rejection\n        #[arg(long)]\n        reason: String,\n    },\n    /// List specs\n    List {\n        /// Show only ready specs\n        #[arg(long)]\n        ready: bool,\n        /// Filter by label (can be specified multiple times, shows specs with any matching label)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Filter by type (code, task, driver, documentation, research)\n        #[arg(long)]\n        r#type: Option\u003cString\u003e,\n        /// Filter by status (pending, in_progress, completed, failed, blocked, cancelled)\n        #[arg(long)]\n        status: Option\u003cString\u003e,\n        /// List specs from all configured repos in global config\n        #[arg(long)]\n        global: bool,\n        /// Filter to specific repository (implies --global)\n        #[arg(long)]\n        repo: Option\u003cString\u003e,\n        /// Filter to specific project within repository\n        #[arg(long)]\n        project: Option\u003cString\u003e,\n        /// Filter by approval status (pending, approved, rejected)\n        #[arg(long)]\n        approval: Option\u003cString\u003e,\n        /// Filter by spec creator name (from git log)\n        #[arg(long)]\n        created_by: Option\u003cString\u003e,\n        /// Filter by recent activity (e.g., \"2h\", \"1d\", \"1w\")\n        #[arg(long)]\n        activity_since: Option\u003cString\u003e,\n        /// Filter specs mentioning a person in approval discussion\n        #[arg(long)]\n        mentions: Option\u003cString\u003e,\n        /// Show only count of matching specs\n        #[arg(long)]\n        count: bool,\n        /// Skip branch resolution for in_progress specs (debug option)\n        #[arg(long)]\n        main_only: bool,\n        /// Show project status summary\n        #[arg(long)]\n        summary: bool,\n        /// Watch mode - refresh every 5 seconds (requires --summary)\n        #[arg(long)]\n        watch: bool,\n        /// Brief single-line output (requires --summary)\n        #[arg(long)]\n        brief: bool,\n        /// JSON output (requires --summary)\n        #[arg(long)]\n        json: bool,\n    },\n    /// Show spec details\n    Show {\n        /// Spec ID (full or partial) or repo:spec-id for cross-repo specs\n        id: String,\n        /// Show full spec body (default: summary only)\n        #[arg(long)]\n        body: bool,\n        /// Disable markdown rendering\n        #[arg(long)]\n        no_render: bool,\n        /// Output raw spec body without frontmatter or formatting (for agents)\n        #[arg(long)]\n        raw: bool,\n        /// Strip agent conversation sections (used with --raw)\n        #[arg(long)]\n        clean: bool,\n    },\n    /// Edit a spec in $EDITOR\n    Edit {\n        /// Spec ID (full or partial)\n        id: String,\n    },\n    /// Search specs by title and body content\n    Search {\n        /// Search query (omit to launch interactive wizard)\n        query: Option\u003cString\u003e,\n        /// Search title only\n        #[arg(long)]\n        title_only: bool,\n        /// Search body only\n        #[arg(long)]\n        body_only: bool,\n        /// Case-sensitive matching\n        #[arg(long)]\n        case_sensitive: bool,\n        /// Filter by status\n        #[arg(long)]\n        status: Option\u003cString\u003e,\n        /// Filter by type\n        #[arg(long)]\n        type_: Option\u003cString\u003e,\n        /// Filter by label (can be specified multiple times)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Filter by date (relative: 7d, 2w, 1m; or absolute: YYYY-MM-DD)\n        #[arg(long)]\n        since: Option\u003cString\u003e,\n        /// Filter until date (relative: 7d, 2w, 1m; or absolute: YYYY-MM-DD)\n        #[arg(long)]\n        until: Option\u003cString\u003e,\n        /// Search active specs only\n        #[arg(long)]\n        active_only: bool,\n        /// Search archived specs only\n        #[arg(long)]\n        archived_only: bool,\n        /// Search across all configured repos\n        #[arg(long)]\n        global: bool,\n        /// Filter to specific repository (implies --global)\n        #[arg(long)]\n        repo: Option\u003cString\u003e,\n    },\n    /// Execute a spec\n    Work {\n        /// Spec ID(s) (full or partial). If omitted with --parallel, executes all ready specs.\n        #[arg(value_name = \"ID\")]\n        ids: Vec\u003cString\u003e,\n        /// Prompt to use\n        #[arg(long)]\n        prompt: Option\u003cString\u003e,\n        /// Disable worktree mode (deprecated - worktrees are now default)\n        #[arg(long)]\n        no_branch: bool,\n        /// Override dependency checks (work on a blocked spec)\n        #[arg(long)]\n        skip_deps: bool,\n        /// Skip validation of unchecked acceptance criteria\n        #[arg(long)]\n        skip_criteria: bool,\n        /// Execute all ready specs in parallel (when no spec ID provided). Optionally specify number of parallel workers.\n        #[arg(long, value_name = \"N\", num_args = 0..=1, default_missing_value = \"0\", require_equals = true)]\n        parallel: Option\u003cusize\u003e,\n        /// Filter by label (can be specified multiple times, used with --parallel)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Re-finalize an existing spec (update commits and timestamp)\n        #[arg(long)]\n        finalize: bool,\n        /// Allow spec to complete without matching commits (uses HEAD as fallback). Use only in special cases.\n        #[arg(long)]\n        allow_no_commits: bool,\n        /// Override maximum parallel agents (deprecated: use --parallel=N instead)\n        #[arg(long = \"max\")]\n        max_parallel: Option\u003cusize\u003e,\n        /// Skip cleanup prompt after parallel execution\n        #[arg(long)]\n        no_cleanup: bool,\n        /// Force cleanup prompt even on success\n        #[arg(long)]\n        cleanup: bool,\n        /// Skip approval check (for emergencies)\n        #[arg(long)]\n        skip_approval: bool,\n        /// Chain through specs. If spec IDs provided, chains through only those IDs in order. If no IDs, chains through all ready specs.\n        #[arg(long)]\n        chain: bool,\n        /// Maximum number of specs to chain (0 = unlimited, only with --chain)\n        #[arg(long, default_value = \"0\")]\n        chain_max: usize,\n        /// Disable auto-merge after parallel execution (branches are kept for manual merge)\n        #[arg(long)]\n        no_merge: bool,\n        /// Disable auto-rebase when merging branches in parallel execution\n        #[arg(long)]\n        no_rebase: bool,\n    },\n    /// Start MCP server (Model Context Protocol)\n    Mcp,\n    /// Show project status summary\n    Status {\n        /// Show status across all configured repos\n        #[arg(long)]\n        global: bool,\n        /// Filter to specific repository (implies --global)\n        #[arg(long)]\n        repo: Option\u003cString\u003e,\n        /// Watch mode - refresh every 5 seconds\n        #[arg(long)]\n        watch: bool,\n        /// Brief single-line output\n        #[arg(long)]\n        brief: bool,\n        /// JSON output\n        #[arg(long)]\n        json: bool,\n        /// Show disk usage of chant artifacts\n        #[arg(long)]\n        disk: bool,\n        /// Show status of all chant worktrees\n        #[arg(long)]\n        worktrees: bool,\n    },\n    /// Refresh dependency status for all specs\n    Refresh {\n        /// Show detailed list of ready and blocked specs\n        #[arg(short, long)]\n        verbose: bool,\n    },\n    /// Validate all specs for common issues\n    Lint {\n        /// Output format (text or json)\n        #[arg(short, long, default_value = \"text\")]\n        format: String,\n        /// Show all dimension details including isolation and AC quality\n        #[arg(short, long)]\n        verbose: bool,\n    },\n    /// Show log for a spec\n    Log {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Number of lines to show (default: 50)\n        #[arg(long, short = 'n', default_value = \"50\")]\n        lines: usize,\n        /// Do not follow the log in real-time (show static output)\n        #[arg(long)]\n        no_follow: bool,\n    },\n    /// Split a spec into member specs\n    Split {\n        /// Spec ID to split (full or partial)\n        id: String,\n        /// Model to use for split analysis (overrides config)\n        #[arg(long)]\n        model: Option\u003cString\u003e,\n        /// Force split even if spec status is not pending\n        #[arg(long)]\n        force_status: bool,\n        /// Recursively split over-complex members (experimental)\n        #[arg(long)]\n        recursive: bool,\n        /// Maximum recursion depth for recursive split (default: 2)\n        #[arg(long, default_value = \"2\")]\n        max_depth: usize,\n    },\n    /// Archive completed specs\n    Archive {\n        /// Spec ID (full or partial). If omitted, archives all completed specs.\n        id: Option\u003cString\u003e,\n        /// Dry run - show what would be archived without moving\n        #[arg(long)]\n        dry_run: bool,\n        /// Archive specs older than N days\n        #[arg(long)]\n        older_than: Option\u003cu64\u003e,\n        /// Allow archiving of non-completed specs\n        #[arg(long)]\n        allow_non_completed: bool,\n        /// Create a commit after archiving (only in git repos)\n        #[arg(long, default_value = \"true\", action = clap::ArgAction::SetTrue)]\n        commit: bool,\n        /// Skip creating a commit after archiving\n        #[arg(long, conflicts_with = \"commit\")]\n        no_commit: bool,\n        /// Use fs::rename instead of git mv (for special cases)\n        #[arg(long)]\n        no_stage: bool,\n    },\n    /// Merge completed spec branches back to main\n    Merge {\n        /// Spec ID(s) to merge (one or more)\n        #[arg(value_name = \"ID\")]\n        ids: Vec\u003cString\u003e,\n        /// Merge all completed spec branches\n        #[arg(long)]\n        all: bool,\n        /// Merge all completed specs that have branches (convenience flag for post-parallel execution)\n        #[arg(long)]\n        all_completed: bool,\n        /// List branch status without merging\n        #[arg(long)]\n        list: bool,\n        /// Merge all ready branches (can fast-forward, all criteria met)\n        #[arg(long)]\n        ready: bool,\n        /// Interactive mode to select which branches to merge\n        #[arg(short, long)]\n        interactive: bool,\n        /// Preview merges without executing\n        #[arg(long)]\n        dry_run: bool,\n        /// Delete branch after successful merge\n        #[arg(long)]\n        delete_branch: bool,\n        /// Continue even if a single spec merge fails\n        #[arg(long)]\n        continue_on_error: bool,\n        /// Skip confirmation prompt and proceed with merges\n        #[arg(long)]\n        yes: bool,\n        /// Rebase branches onto main before merging (enables sequential merge of parallel branches)\n        #[arg(long)]\n        rebase: bool,\n        /// Auto-resolve conflicts using agent (requires --rebase)\n        #[arg(long)]\n        auto: bool,\n        /// Mark specs as completed after successful merge\n        #[arg(long)]\n        finalize: bool,\n    },\n    /// Diagnose spec execution issues\n    Diagnose {\n        /// Spec ID (full or partial)\n        id: String,\n    },\n    /// Check for drift in documentation and research specs\n    Drift {\n        /// Spec ID (full or partial). If omitted, check all completed specs.\n        id: Option\u003cString\u003e,\n    },\n    /// Resume a failed spec - resets it to pending and optionally re-runs it\n    Resume {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Automatically re-execute the spec after resuming\n        #[arg(long)]\n        work: bool,\n        /// Prompt to use if --work is specified\n        #[arg(long)]\n        prompt: Option\u003cString\u003e,\n        /// Create a feature branch before re-executing (only with --work)\n        #[arg(long, num_args = 0..=1, require_equals = true, value_name = \"PREFIX\")]\n        branch: Option\u003cString\u003e,\n    },\n    /// Pause a running work process for a spec\n    Pause {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Force pause without confirmation\n        #[arg(long)]\n        force: bool,\n    },\n    /// Take over a running spec, stopping the agent and analyzing progress\n    Takeover {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Force takeover even if spec is not running\n        #[arg(long)]\n        force: bool,\n    },\n    /// Cancel a spec (soft-delete with status change, or hard-delete with --delete)\n    Cancel {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Skip safety checks (status and dependency validation)\n        #[arg(long)]\n        skip_checks: bool,\n        /// Hard delete: permanently remove spec file and artifacts (default: soft cancel to 'cancelled' status)\n        #[arg(long)]\n        delete: bool,\n        /// Delete driver and all members (only with --delete)\n        #[arg(long)]\n        cascade: bool,\n        /// Delete associated git branch (only with --delete)\n        #[arg(long)]\n        delete_branch: bool,\n        /// Dry run - show what would be cancelled or deleted\n        #[arg(long)]\n        dry_run: bool,\n        /// Skip confirmation prompt\n        #[arg(long)]\n        yes: bool,\n    },\n    /// Validate configuration\n    Config {\n        /// Validate config semantically (check paths, prompts, limits)\n        #[arg(long)]\n        validate: bool,\n    },\n    /// Manage silent mode for suppressing git tracking and output\n    Silent {\n        /// Apply to global config instead of project config\n        #[arg(long)]\n        global: bool,\n        /// Disable silent mode\n        #[arg(long)]\n        off: bool,\n        /// Show current silent mode status\n        #[arg(long)]\n        status: bool,\n    },\n    /// Show version information\n    Version {\n        /// Show additional build information\n        #[arg(long, short)]\n        verbose: bool,\n    },\n    /// Export specs to JSON, CSV, or Markdown format\n    Export {\n        /// Output format (json, csv, markdown, or omit for interactive wizard)\n        #[arg(long)]\n        format: Option\u003cString\u003e,\n        /// Filter by status (can be specified multiple times)\n        #[arg(long)]\n        status: Vec\u003cString\u003e,\n        /// Filter by type (code, task, driver, etc.)\n        #[arg(long)]\n        type_: Option\u003cString\u003e,\n        /// Filter by labels (can be specified multiple times, OR logic)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Only export ready specs\n        #[arg(long)]\n        ready: bool,\n        /// Filter by date range (from date in YYYY-MM-DD format)\n        #[arg(long)]\n        from: Option\u003cString\u003e,\n        /// Filter by date range (to date in YYYY-MM-DD format)\n        #[arg(long)]\n        to: Option\u003cString\u003e,\n        /// Comma-separated fields to include (or 'all' for all fields)\n        #[arg(long)]\n        fields: Option\u003cString\u003e,\n        /// Output file (if not specified, prints to stdout)\n        #[arg(long, short)]\n        output: Option\u003cString\u003e,\n    },\n    /// Show git-based activity feed for spec operations\n    Activity {\n        /// Filter by author name (case-insensitive substring match)\n        #[arg(long)]\n        by: Option\u003cString\u003e,\n        /// Show activity since duration (e.g., \"2h\", \"1d\", \"1w\", \"1m\")\n        #[arg(long)]\n        since: Option\u003cString\u003e,\n        /// Filter by spec ID (substring match)\n        #[arg(long)]\n        spec: Option\u003cString\u003e,\n    },\n    /// Remove orphan worktrees and stale artifacts\n    Cleanup {\n        /// Show what would be cleaned without removing\n        #[arg(long)]\n        dry_run: bool,\n        /// Skip confirmation prompt and proceed with cleanup\n        #[arg(long)]\n        yes: bool,\n        /// Only cleanup worktrees (skip other cleanup operations)\n        #[arg(long)]\n        worktrees: bool,\n    },\n    /// Worktree management commands\n    Worktree {\n        #[command(subcommand)]\n        command: WorktreeCommands,\n    },\n    /// Verify specs meet their acceptance criteria\n    Verify {\n        /// Spec ID to verify (full or partial). If omitted, verifies all specs.\n        #[arg(value_name = \"ID\")]\n        id: Option\u003cString\u003e,\n        /// Verify all specs\n        #[arg(long)]\n        all: bool,\n        /// Filter by label (can be specified multiple times)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Exit with code 1 if any spec fails verification\n        #[arg(long)]\n        exit_code: bool,\n        /// Show what would be verified without making changes\n        #[arg(long)]\n        dry_run: bool,\n        /// Prompt to use for verification\n        #[arg(long)]\n        prompt: Option\u003cString\u003e,\n    },\n    /// Output cleaned spec content for agent preparation\n    Prep {\n        /// Spec ID (full or partial)\n        id: String,\n        /// Strip agent conversation sections from spec body\n        #[arg(long)]\n        clean: bool,\n    },\n    /// Derive fields for specs based on enterprise config\n    Derive {\n        /// Spec ID (full or partial). If omitted with --all, derives for all specs.\n        id: Option\u003cString\u003e,\n        /// Derive for all specs\n        #[arg(long)]\n        all: bool,\n        /// Show what would be derived without modifying specs\n        #[arg(long)]\n        dry_run: bool,\n    },\n    /// Finalize a completed spec - validate criteria, update status and model\n    Finalize {\n        /// Spec ID (full or partial)\n        id: String,\n    },\n    /// Git merge driver for spec files (called by git, not directly by users)\n    #[command(name = \"merge-driver\", hide = true)]\n    MergeDriver {\n        /// Path to base (common ancestor) version\n        base: PathBuf,\n        /// Path to current version (ours) - result is written here\n        current: PathBuf,\n        /// Path to other version (theirs)\n        other: PathBuf,\n    },\n    /// Generate shell completion script\n    Completion {\n        /// Shell to generate completions for (bash, zsh, fish, powershell)\n        #[arg(value_enum)]\n        shell: Shell,\n    },\n    /// Static site generation for spec documentation\n    Site {\n        #[command(subcommand)]\n        command: SiteCommands,\n    },\n    /// Watch for spec completion and automatically finalize/merge\n    Watch {\n        /// Run only one iteration then exit (for testing)\n        #[arg(long)]\n        once: bool,\n        /// Dry run - show what would be done without executing\n        #[arg(long)]\n        dry_run: bool,\n        /// Poll interval in milliseconds (overrides config)\n        #[arg(long)]\n        poll_interval: Option\u003cu64\u003e,\n    },\n    /// Show dependency graph for specs\n    Dag {\n        /// Level of detail (minimal, titles, full)\n        #[arg(long, default_value = \"full\")]\n        detail: String,\n        /// Filter by status (pending, in_progress, completed, failed, blocked, cancelled)\n        #[arg(long)]\n        status: Option\u003cString\u003e,\n        /// Filter by label (can be specified multiple times)\n        #[arg(long)]\n        label: Vec\u003cString\u003e,\n        /// Filter by type (code, task, driver, documentation, research)\n        #[arg(long)]\n        type_: Option\u003cString\u003e,\n    },\n    /// Generate man page\n    #[command(hide = true)]\n    Man {\n        /// Output directory for the man page (defaults to current directory)\n        #[arg(long)]\n        out_dir: Option\u003cPathBuf\u003e,\n    },\n}\n\n/// Subcommands for worktree management\n#[derive(Subcommand)]\nenum WorktreeCommands {\n    /// Show status of all chant worktrees\n    Status,\n}\n\n/// Subcommands for template management\n#[derive(Subcommand)]\nenum TemplateCommands {\n    /// List available templates\n    List,\n    /// Show template details\n    Show {\n        /// Template name\n        name: String,\n    },\n}\n\n/// Subcommands for site generation\n#[derive(Subcommand)]\nenum SiteCommands {\n    /// Initialize theme directory with default templates for customization\n    Init {\n        /// Overwrite existing theme files\n        #[arg(long)]\n        force_overwrite: bool,\n    },\n    /// Build the static site\n    Build {\n        /// Output directory (overrides config)\n        #[arg(long, short)]\n        output: Option\u003cString\u003e,\n    },\n    /// Start a local HTTP server to preview the site\n    Serve {\n        /// Port to serve on (default: 3000)\n        #[arg(long, short, default_value = \"3000\")]\n        port: u16,\n        /// Output directory to serve (default: from config)\n        #[arg(long, short)]\n        output: Option\u003cString\u003e,\n    },\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    // Spawn the real work on a thread with a larger stack size.\n    // Windows defaults to a 1MB stack which is insufficient for this binary\n    // in debug builds (Linux/macOS default to 8MB). Using 8MB here matches\n    // the Linux default and prevents stack overflows on Windows CI.\n    const STACK_SIZE: usize = 8 * 1024 * 1024; // 8 MB\n\n    let thread = std::thread::Builder::new()\n        .stack_size(STACK_SIZE)\n        .spawn(run)\n        .expect(\"failed to spawn main thread\");\n\n    match thread.join() {\n        Ok(result) =\u003e result,\n        Err(payload) =\u003e std::panic::resume_unwind(payload),\n    }\n}\n\nfn run() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    // Set quiet mode globally if --quiet flag is present\n    if cli.quiet {\n        std::env::set_var(\"CHANT_QUIET\", \"1\");\n    }\n\n    cli.command.execute()\n}\n\nimpl cmd::dispatch::Execute for Commands {\n    fn execute(self) -\u003e Result\u003c()\u003e {\n        match self {\n            Commands::Init {\n                subcommand,\n                name,\n                silent,\n                force_overwrite,\n                minimal,\n                agent,\n                provider,\n                model,\n                merge_driver,\n            } =\u003e cmd_init(\n                subcommand.as_deref(),\n                name,\n                silent,\n                force_overwrite,\n                minimal,\n                agent,\n                provider,\n                model,\n                merge_driver,\n            ),\n            Commands::Add {\n                description,\n                prompt,\n                needs_approval,\n                template,\n                vars,\n            } =\u003e {\n                if let Some(template_name) = template {\n                    cmd::template::cmd_add_from_template(\n                        \u0026template_name,\n                        \u0026vars,\n                        prompt.as_deref(),\n                        needs_approval,\n                    )\n                } else {\n                    if description.is_empty() {\n                        anyhow::bail!(\n                            \"Description is required when not using --template.\\n\\n\\\n                         Usage:\\n  \\\n                         chant add \\\"description of work\\\"\\n  \\\n                         chant add --template \u003cname\u003e [--var key=value...]\"\n                        );\n                    }\n                    cmd::spec::cmd_add(\u0026description, prompt.as_deref(), needs_approval)\n                }\n            }\n            Commands::Template { command } =\u003e match command {\n                TemplateCommands::List =\u003e cmd::template::cmd_template_list(),\n                TemplateCommands::Show { name } =\u003e cmd::template::cmd_template_show(\u0026name),\n            },\n            Commands::Approve { id, by } =\u003e cmd::spec::cmd_approve(\u0026id, \u0026by),\n            Commands::Reject { id, by, reason } =\u003e cmd::spec::cmd_reject(\u0026id, \u0026by, \u0026reason),\n            Commands::List {\n                ready,\n                label,\n                r#type,\n                status,\n                global,\n                repo,\n                project,\n                approval,\n                created_by,\n                activity_since,\n                mentions,\n                count,\n                main_only,\n                summary,\n                watch,\n                brief,\n                json,\n            } =\u003e {\n                if summary {\n                    cmd::spec::cmd_status(global, repo.as_deref(), watch, brief, json)\n                } else {\n                    // Check that watch, brief, json are not used without --summary\n                    if watch || brief || json {\n                        anyhow::bail!(\"Error: --watch, --brief, and --json require --summary flag.\\n\\nUsage: chant list --summary [--watch] [--brief | --json]\");\n                    }\n                    cmd::spec::cmd_list(\n                        ready,\n                        \u0026label,\n                        r#type.as_deref(),\n                        status.as_deref(),\n                        global,\n                        repo.as_deref(),\n                        project.as_deref(),\n                        approval.as_deref(),\n                        created_by.as_deref(),\n                        activity_since.as_deref(),\n                        mentions.as_deref(),\n                        count,\n                        main_only,\n                    )\n                }\n            }\n            Commands::Show {\n                id,\n                body,\n                no_render,\n                raw,\n                clean,\n            } =\u003e cmd::spec::cmd_show(\u0026id, body, no_render, raw, clean),\n            Commands::Edit { id } =\u003e cmd::spec::cmd_edit(\u0026id),\n            Commands::Search {\n                query,\n                title_only,\n                body_only,\n                case_sensitive,\n                status,\n                type_,\n                label,\n                since,\n                until,\n                active_only,\n                archived_only,\n                global,\n                repo,\n            } =\u003e {\n                let opts = cmd::search::build_search_options(\n                    query,\n                    title_only,\n                    body_only,\n                    case_sensitive,\n                    status,\n                    type_,\n                    label,\n                    since,\n                    until,\n                    active_only,\n                    archived_only,\n                    global,\n                    repo.as_deref(),\n                )?;\n                cmd::search::cmd_search(opts)\n            }\n            Commands::Work {\n                ids,\n                prompt,\n                no_branch,\n                skip_deps,\n                skip_criteria,\n                parallel,\n                label,\n                finalize,\n                allow_no_commits,\n                max_parallel,\n                no_cleanup,\n                cleanup,\n                skip_approval,\n                chain,\n                chain_max,\n                no_merge,\n                no_rebase,\n            } =\u003e {\n                if no_branch {\n                    eprintln!(\n                        \"{} Warning: --no-branch is deprecated. Worktree mode is now the default.\",\n                        \"â \".yellow()\n                    );\n                }\n                // Handle --parallel flag: if provided, convert to (true, max_workers)\n                // If --max is also provided, it takes precedence (for backwards compat)\n                let (parallel_flag, effective_max) = if let Some(n) = parallel {\n                    // --parallel was provided\n                    if n == 0 {\n                        // --parallel with no value, use max_parallel or default\n                        (true, max_parallel)\n                    } else {\n                        // --parallel=N was provided\n                        (true, Some(n))\n                    }\n                } else {\n                    // --parallel not provided\n                    (false, max_parallel)\n                };\n                cmd::work::cmd_work(\n                    \u0026ids,\n                    prompt.as_deref(),\n                    no_branch,\n                    skip_deps,\n                    skip_criteria,\n                    parallel_flag,\n                    \u0026label,\n                    finalize,\n                    allow_no_commits,\n                    effective_max,\n                    no_cleanup,\n                    cleanup,\n                    skip_approval,\n                    chain,\n                    chain_max,\n                    no_merge,\n                    no_rebase,\n                )\n            }\n            Commands::Mcp =\u003e mcp::run_server(),\n            Commands::Status {\n                global,\n                repo,\n                watch,\n                brief,\n                json,\n                disk,\n                worktrees,\n            } =\u003e {\n                if worktrees {\n                    cmd::worktree::cmd_worktree_status()\n                } else if disk {\n                    cmd::disk::cmd_disk()\n                } else {\n                    cmd::spec::cmd_status(global, repo.as_deref(), watch, brief, json)\n                }\n            }\n            Commands::Refresh { verbose } =\u003e cmd::refresh::cmd_refresh(verbose),\n            Commands::Lint { format, verbose } =\u003e {\n                let lint_format = match format.to_lowercase().as_str() {\n                    \"json\" =\u003e cmd::spec::LintFormat::Json,\n                    \"text\" =\u003e cmd::spec::LintFormat::Text,\n                    _ =\u003e {\n                        eprintln!(\"Error: Invalid format '{}'. Use 'text' or 'json'.\", format);\n                        std::process::exit(1);\n                    }\n                };\n                cmd::spec::cmd_lint(lint_format, verbose)\n            }\n            Commands::Log {\n                id,\n                lines,\n                no_follow,\n            } =\u003e cmd::lifecycle::cmd_log(\u0026id, lines, !no_follow),\n            Commands::Split {\n                id,\n                model,\n                force_status,\n                recursive,\n                max_depth,\n            } =\u003e {\n                cmd::lifecycle::cmd_split(\u0026id, model.as_deref(), force_status, recursive, max_depth)\n            }\n            Commands::Archive {\n                id,\n                dry_run,\n                older_than,\n                allow_non_completed,\n                commit,\n                no_commit,\n                no_stage,\n            } =\u003e {\n                let should_commit = commit \u0026\u0026 !no_commit;\n                cmd::lifecycle::cmd_archive(\n                    id.as_deref(),\n                    dry_run,\n                    older_than,\n                    allow_non_completed,\n                    should_commit,\n                    no_stage,\n                )\n            }\n            Commands::Merge {\n                ids,\n                all,\n                all_completed,\n                list,\n                ready,\n                interactive,\n                dry_run,\n                delete_branch,\n                continue_on_error,\n                yes,\n                rebase,\n                auto,\n                finalize,\n            } =\u003e cmd::lifecycle::cmd_merge(\n                \u0026ids,\n                all,\n                all_completed,\n                list,\n                ready,\n                interactive,\n                dry_run,\n                delete_branch,\n                continue_on_error,\n                yes,\n                rebase,\n                auto,\n                finalize,\n            ),\n            Commands::Diagnose { id } =\u003e cmd::lifecycle::cmd_diagnose(\u0026id),\n            Commands::Drift { id } =\u003e cmd::lifecycle::cmd_drift(id.as_deref()),\n            Commands::Resume {\n                id,\n                work,\n                prompt,\n                branch,\n            } =\u003e cmd::lifecycle::cmd_resume(\u0026id, work, prompt.as_deref(), branch),\n            Commands::Pause { id, force } =\u003e cmd::pause::cmd_pause(\u0026id, force),\n            Commands::Takeover { id, force } =\u003e {\n                let result = cmd::takeover::cmd_takeover(\u0026id, force)?;\n                println!(\"\\n{}\", \"Analysis:\".bold());\n                println!(\"{}\", result.analysis);\n                println!(\"\\n{}\", \"Suggestion:\".bold());\n                println!(\"{}\", result.suggestion);\n                Ok(())\n            }\n            Commands::Cancel {\n                id,\n                skip_checks,\n                delete,\n                cascade,\n                delete_branch,\n                dry_run,\n                yes,\n            } =\u003e {\n                if delete {\n                    cmd::spec::cmd_delete(\u0026id, skip_checks, cascade, delete_branch, dry_run, yes)\n                } else {\n                    if cascade {\n                        anyhow::bail!(\"--cascade can only be used with --delete\");\n                    }\n                    if delete_branch {\n                        anyhow::bail!(\"--delete-branch can only be used with --delete\");\n                    }\n                    cmd::spec::cmd_cancel(\u0026id, skip_checks, dry_run, yes)\n                }\n            }\n            Commands::Config { validate } =\u003e {\n                if validate {\n                    cmd::config::cmd_config_validate()\n                } else {\n                    println!(\"Usage: chant config --validate\");\n                    Ok(())\n                }\n            }\n            Commands::Silent {\n                global,\n                off,\n                status,\n            } =\u003e cmd::silent::cmd_silent(global, off, status),\n            Commands::Version { verbose } =\u003e cmd_version(verbose),\n            Commands::Export {\n                format,\n                status,\n                type_,\n                label,\n                ready,\n                from,\n                to,\n                fields,\n                output,\n            } =\u003e cmd::spec::cmd_export(\n                format.as_deref(),\n                \u0026status,\n                type_.as_deref(),\n                \u0026label,\n                ready,\n                from.as_deref(),\n                to.as_deref(),\n                fields.as_deref(),\n                output.as_deref(),\n            ),\n            Commands::Activity { by, since, spec } =\u003e {\n                cmd::activity::cmd_activity(by.as_deref(), since.as_deref(), spec.as_deref())\n            }\n            Commands::Cleanup {\n                dry_run,\n                yes,\n                worktrees,\n            } =\u003e cmd::cleanup::cmd_cleanup(dry_run, yes, worktrees),\n            Commands::Worktree { command } =\u003e match command {\n                WorktreeCommands::Status =\u003e cmd::worktree::cmd_worktree_status(),\n            },\n            Commands::Verify {\n                id,\n                all,\n                label,\n                exit_code,\n                dry_run,\n                prompt,\n            } =\u003e cmd::verify::cmd_verify(\n                id.as_deref(),\n                all,\n                \u0026label,\n                exit_code,\n                dry_run,\n                prompt.as_deref(),\n            ),\n            Commands::Prep { id, clean } =\u003e {\n                let specs_dir = cmd::ensure_initialized()?;\n                cmd::prep::cmd_prep(\u0026id, clean, \u0026specs_dir)\n            }\n            Commands::Derive { id, all, dry_run } =\u003e cmd::derive::cmd_derive(id, all, dry_run),\n            Commands::Finalize { id } =\u003e {\n                let specs_dir = cmd::ensure_initialized()?;\n                cmd::lifecycle::cmd_finalize(\u0026id, \u0026specs_dir)\n            }\n            Commands::MergeDriver {\n                base,\n                current,\n                other,\n            } =\u003e cmd_merge_driver(\u0026base, \u0026current, \u0026other),\n            Commands::Completion { shell } =\u003e cmd_completion(shell),\n            Commands::Site { command } =\u003e match command {\n                SiteCommands::Init { force_overwrite } =\u003e cmd::site::cmd_site_init(force_overwrite),\n                SiteCommands::Build { output } =\u003e cmd::site::cmd_site_build(output.as_deref()),\n                SiteCommands::Serve { port, output } =\u003e {\n                    cmd::site::cmd_site_serve(port, output.as_deref())\n                }\n            },\n            Commands::Watch {\n                once,\n                dry_run,\n                poll_interval,\n            } =\u003e cmd::watch::run_watch(once, dry_run, poll_interval),\n            Commands::Dag {\n                detail,\n                status,\n                label,\n                type_,\n            } =\u003e cmd::spec::cmd_dag(\u0026detail, status.as_deref(), \u0026label, type_.as_deref()),\n            Commands::Man { out_dir } =\u003e cmd_man(out_dir.as_ref()),\n        }\n    }\n}\n\n/// Run the git merge driver for spec files\nfn cmd_merge_driver(base: \u0026Path, current: \u0026Path, other: \u0026Path) -\u003e Result\u003c()\u003e {\n    match chant::merge_driver::run_merge_driver(base, current, other) {\n        Ok(true) =\u003e {\n            // Clean merge\n            std::process::exit(0);\n        }\n        Ok(false) =\u003e {\n            // Merge with conflicts\n            eprintln!(\"Spec merge completed with conflicts - manual resolution needed for body\");\n            std::process::exit(1);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Merge driver error: {}\", e);\n            std::process::exit(2);\n        }\n    }\n}\n\n/// Generate shell completion script\nfn cmd_completion(shell: Shell) -\u003e Result\u003c()\u003e {\n    let mut cmd = Cli::command();\n    generate(shell, \u0026mut cmd, \"chant\", \u0026mut io::stdout());\n    Ok(())\n}\n\n/// Parse a provider string into a normalized form\nfn parse_provider_string(s: \u0026str) -\u003e Option\u003c\u0026'static str\u003e {\n    match s.to_lowercase().as_str() {\n        \"claude\" | \"claude-cli\" =\u003e Some(\"claude\"),\n        \"ollama\" | \"local\" =\u003e Some(\"ollama\"),\n        \"openai\" | \"gpt\" =\u003e Some(\"openai\"),\n        _ =\u003e None,\n    }\n}\n\n/// Result of writing an agent config file\n#[derive(Debug)]\nenum AgentFileResult {\n    /// File was created new\n    Created,\n    /// Existing file was updated (section injected/replaced)\n    Updated,\n    /// File was skipped (user declined or non-TTY)\n    Skipped,\n    /// File was unchanged (already up-to-date)\n    Unchanged,\n}\n\n/// Write agent configuration file, using section injection for Claude's CLAUDE.md\n///\n/// For Claude provider: Uses section injection to preserve existing CLAUDE.md content\n/// For other providers: Uses full template replacement\nfn write_agent_config_file(\n    provider: \u0026templates::AgentProvider,\n    template: \u0026templates::AgentTemplate,\n    target_path: \u0026Path,\n    force_overwrite: bool,\n    has_mcp: bool,\n) -\u003e Result\u003cAgentFileResult\u003e {\n    // For Claude provider, use section injection to preserve user content\n    if *provider == templates::AgentProvider::Claude {\n        let existing_content = if target_path.exists() {\n            Some(std::fs::read_to_string(target_path)?)\n        } else {\n            None\n        };\n\n        let result = templates::inject_chant_section(existing_content.as_deref(), has_mcp);\n\n        match result {\n            templates::InjectionResult::Created(content) =\u003e {\n                std::fs::write(target_path, content)?;\n                return Ok(AgentFileResult::Created);\n            }\n            templates::InjectionResult::Appended(content) =\u003e {\n                std::fs::write(target_path, content)?;\n                return Ok(AgentFileResult::Updated);\n            }\n            templates::InjectionResult::Replaced(content) =\u003e {\n                std::fs::write(target_path, content)?;\n                return Ok(AgentFileResult::Updated);\n            }\n            templates::InjectionResult::Unchanged =\u003e {\n                return Ok(AgentFileResult::Unchanged);\n            }\n        }\n    }\n\n    // For non-Claude providers, use full template replacement\n    if target_path.exists() \u0026\u0026 !force_overwrite {\n        if atty::is(atty::Stream::Stdin) {\n            let should_overwrite = dialoguer::Confirm::new()\n                .with_prompt(format!(\n                    \"{} already exists. Overwrite?\",\n                    target_path.display()\n                ))\n                .default(false)\n                .interact()?;\n\n            if !should_overwrite {\n                return Ok(AgentFileResult::Skipped);\n            }\n        } else {\n            eprintln!(\n                \"{} {} already exists. Use {} to overwrite.\",\n                \"â¢\".yellow(),\n                target_path.display(),\n                \"--force-overwrite\".cyan()\n            );\n            return Ok(AgentFileResult::Skipped);\n        }\n    }\n\n    // Write the full template for non-Claude providers\n    if let Some(parent) = target_path.parent() {\n        if !parent.as_os_str().is_empty() {\n            std::fs::create_dir_all(parent)?;\n        }\n    }\n    std::fs::write(target_path, template.content)?;\n\n    if target_path.exists() \u0026\u0026 force_overwrite {\n        Ok(AgentFileResult::Updated)\n    } else {\n        Ok(AgentFileResult::Created)\n    }\n}\n\n/// Handle updating only agent configuration files (used for re-running init with --agent)\nfn handle_agent_update(chant_dir: \u0026Path, agents: \u0026[String], force_overwrite: bool) -\u003e Result\u003c()\u003e {\n    let parsed_agents = templates::parse_agent_providers(agents)?;\n\n    if parsed_agents.is_empty() {\n        println!(\"{}\", \"No agents specified.\".yellow());\n        return Ok(());\n    }\n\n    // Create agents directory\n    std::fs::create_dir_all(chant_dir.join(\"agents\"))?;\n\n    // Check if MCP is configured (affects which chant section template to use)\n    let has_mcp = PathBuf::from(\".mcp.json\").exists();\n\n    let mut created_agents = Vec::new();\n    let mut updated_agents = Vec::new();\n    let mut unchanged_agents = Vec::new();\n\n    for provider in \u0026parsed_agents {\n        let template = templates::get_template(provider.as_str())?;\n\n        // Determine the target path based on provider\n        let target_path = match provider.config_filename() {\n            \".amazonq/rules.md\" =\u003e {\n                std::fs::create_dir_all(\".amazonq\")?;\n                PathBuf::from(\".amazonq/rules.md\")\n            }\n            filename =\u003e PathBuf::from(filename),\n        };\n\n        // Write the agent config file using the helper\n        let result =\n            write_agent_config_file(provider, \u0026template, \u0026target_path, force_overwrite, has_mcp)?;\n\n        match result {\n            AgentFileResult::Created =\u003e {\n                created_agents.push((target_path, provider.as_str()));\n            }\n            AgentFileResult::Updated =\u003e {\n                updated_agents.push((target_path, provider.as_str()));\n            }\n            AgentFileResult::Unchanged =\u003e {\n                unchanged_agents.push((target_path, provider.as_str()));\n            }\n            AgentFileResult::Skipped =\u003e {\n                // Already logged in write_agent_config_file\n            }\n        }\n    }\n\n    // Report results\n    for (target_path, _) in \u0026created_agents {\n        println!(\"{} {}\", \"Created\".green(), target_path.display());\n    }\n    for (target_path, _) in \u0026updated_agents {\n        println!(\"{} {}\", \"Updated\".green(), target_path.display());\n    }\n    for (target_path, _) in \u0026unchanged_agents {\n        println!(\n            \"{} {} (already up-to-date)\",\n            \"â¢\".cyan(),\n            target_path.display()\n        );\n    }\n\n    let all_modified: Vec\u003c_\u003e = created_agents\n        .iter()\n        .chain(updated_agents.iter())\n        .map(|(_, name)| *name)\n        .collect();\n\n    if all_modified.is_empty() \u0026\u0026 unchanged_agents.is_empty() {\n        println!(\"{}\", \"No agent files were updated.\".yellow());\n    } else if !all_modified.is_empty() {\n        let agent_names = all_modified.join(\", \");\n        println!(\n            \"{} Agent configuration updated for: {}\",\n            \"â\".green(),\n            agent_names.cyan()\n        );\n    }\n\n    // Create MCP config if any provider supports it\n    let mut mcp_created = false;\n    for provider in \u0026parsed_agents {\n        if provider.mcp_config_filename().is_some() {\n            // Update global ~/.claude/mcp.json (actually used by Claude Code)\n            match update_claude_mcp_config() {\n                Ok(result) =\u003e {\n                    if result.created {\n                        println!(\n                            \"{} Created {} with chant MCP server\",\n                            \"â\".green(),\n                            result.path.display()\n                        );\n                    } else if result.updated {\n                        println!(\n                            \"{} Added chant MCP server to {}\",\n                            \"â\".green(),\n                            result.path.display()\n                        );\n                    } else {\n                        println!(\n                            \"{} Updated chant MCP server in {}\",\n                            \"â\".green(),\n                            result.path.display()\n                        );\n                    }\n                    if let Some(warning) = result.warning {\n                        eprintln!(\"{} {}\", \"Warning:\".yellow(), warning);\n                    }\n                    mcp_created = true;\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"{} Failed to update global MCP config: {}\", \"â\".red(), e);\n                }\n            }\n\n            // Also create project-local .mcp.json as reference\n            let mcp_path = PathBuf::from(\".mcp.json\");\n            if !mcp_path.exists() || force_overwrite {\n                let mcp_config = r#\"{\n  \"mcpServers\": {\n    \"chant\": {\n      \"type\": \"stdio\",\n      \"command\": \"chant\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\"#;\n                if let Err(e) = std::fs::write(\u0026mcp_path, mcp_config) {\n                    // Project-local write failure is non-critical\n                    eprintln!(\n                        \"{} Could not create {} (reference copy): {}\",\n                        \"â¢\".yellow(),\n                        mcp_path.display(),\n                        e\n                    );\n                } else {\n                    println!(\n                        \"{} {} (reference copy)\",\n                        \"Created\".green(),\n                        mcp_path.display()\n                    );\n                }\n            }\n\n            if mcp_created {\n                println!(\n                    \"{} Restart Claude Code to activate MCP integration\",\n                    \"â¹\".cyan()\n                );\n            }\n            break; // Only create one MCP config file\n        }\n    }\n\n    Ok(())\n}\n\n/// Update config.md with surgical changes to specific fields\nfn update_config_field(config_path: \u0026Path, field: \u0026str, value: \u0026str) -\u003e Result\u003c()\u003e {\n    let content = std::fs::read_to_string(config_path)?;\n\n    // Split into frontmatter and body\n    let (frontmatter_opt, body) = chant::spec::split_frontmatter(\u0026content);\n    let frontmatter = frontmatter_opt.ok_or_else(|| anyhow::anyhow!(\"No frontmatter found\"))?;\n\n    // Parse YAML into a Value for manipulation\n    let mut yaml: serde_yaml::Value = serde_yaml::from_str(\u0026frontmatter)?;\n\n    // Navigate to the appropriate field and update it\n    match field {\n        \"provider\" =\u003e {\n            // Ensure defaults section exists\n            if yaml.get(\"defaults\").is_none() {\n                yaml[\"defaults\"] = serde_yaml::Value::Mapping(serde_yaml::Mapping::new());\n            }\n            yaml[\"defaults\"][\"provider\"] = serde_yaml::Value::String(value.to_string());\n        }\n        \"model\" =\u003e {\n            // Ensure defaults section exists\n            if yaml.get(\"defaults\").is_none() {\n                yaml[\"defaults\"] = serde_yaml::Value::Mapping(serde_yaml::Mapping::new());\n            }\n            yaml[\"defaults\"][\"model\"] = serde_yaml::Value::String(value.to_string());\n        }\n        _ =\u003e anyhow::bail!(\"Unknown field: {}\", field),\n    }\n\n    // Serialize back to YAML\n    let new_frontmatter = serde_yaml::to_string(\u0026yaml)?;\n\n    // Reconstruct the file content\n    let new_content = format!(\"---\\n{}---\\n{}\", new_frontmatter, body);\n    std::fs::write(config_path, new_content)?;\n\n    Ok(())\n}\n\n/// Create a global CLAUDE.md next to the chant binary\n///\n/// This allows Claude Code to discover chant instructions system-wide,\n/// even in projects without their own CLAUDE.md.\n///\n/// The file is written to the directory containing the chant binary\n/// (typically ~/.cargo/bin/ for cargo installs).\nfn create_global_claude_md(has_mcp: bool) -\u003e Result\u003c()\u003e {\n    // Get the path to the current executable\n    let exe_path = std::env::current_exe()\n        .map_err(|e| anyhow::anyhow!(\"Could not determine executable path: {}\", e))?;\n\n    let exe_dir = exe_path\n        .parent()\n        .ok_or_else(|| anyhow::anyhow!(\"Could not determine executable directory\"))?;\n\n    let global_claude_path = exe_dir.join(\"CLAUDE.md\");\n\n    // Use the same injection logic to preserve any existing content\n    let existing_content = if global_claude_path.exists() {\n        Some(std::fs::read_to_string(\u0026global_claude_path)?)\n    } else {\n        None\n    };\n\n    let result = templates::inject_chant_section(existing_content.as_deref(), has_mcp);\n\n    match result {\n        templates::InjectionResult::Created(content) =\u003e {\n            std::fs::write(\u0026global_claude_path, content)?;\n            println!(\n                \"{} {} (global)\",\n                \"Created\".green(),\n                global_claude_path.display()\n            );\n        }\n        templates::InjectionResult::Appended(content)\n        | templates::InjectionResult::Replaced(content) =\u003e {\n            std::fs::write(\u0026global_claude_path, content)?;\n            println!(\n                \"{} {} (global)\",\n                \"Updated\".green(),\n                global_claude_path.display()\n            );\n        }\n        templates::InjectionResult::Unchanged =\u003e {\n            // Already up-to-date, no action needed\n        }\n    }\n\n    Ok(())\n}\n\n/// Result of updating the global Claude MCP config\n#[derive(Debug)]\nstruct McpConfigResult {\n    /// Whether the global config was created (new file)\n    created: bool,\n    /// Whether the global config was updated (existing file merged)\n    updated: bool,\n    /// Path to the global config file\n    path: PathBuf,\n    /// Warning message if something went wrong but we recovered\n    warning: Option\u003cString\u003e,\n}\n\n/// Update the global Claude MCP config at ~/.claude/mcp.json\n///\n/// This function:\n/// - Creates ~/.claude/ directory if it doesn't exist\n/// - Creates a new mcp.json if it doesn't exist\n/// - Merges with existing mcp.json without overwriting other servers\n/// - Creates a backup if the existing file has invalid JSON\nfn update_claude_mcp_config() -\u003e Result\u003cMcpConfigResult\u003e {\n    let home_dir =\n        dirs::home_dir().ok_or_else(|| anyhow::anyhow!(\"Could not determine home directory\"))?;\n\n    let global_mcp_path = home_dir.join(\".claude\").join(\"mcp.json\");\n\n    // Ensure ~/.claude/ directory exists\n    if let Some(parent) = global_mcp_path.parent() {\n        std::fs::create_dir_all(parent).map_err(|e| {\n            anyhow::anyhow!(\"Failed to create directory {}: {}\", parent.display(), e)\n        })?;\n    }\n\n    // Define the chant MCP server config\n    let chant_server = serde_json::json!({\n        \"type\": \"stdio\",\n        \"command\": \"chant\",\n        \"args\": [\"mcp\"]\n    });\n\n    // Read existing config if it exists\n    let (mut config, is_new, warning) = if global_mcp_path.exists() {\n        let content = std::fs::read_to_string(\u0026global_mcp_path)\n            .map_err(|e| anyhow::anyhow!(\"Failed to read {}: {}\", global_mcp_path.display(), e))?;\n\n        match serde_json::from_str::\u003cserde_json::Value\u003e(\u0026content) {\n            Ok(parsed) =\u003e (parsed, false, None),\n            Err(_) =\u003e {\n                // Invalid JSON - create backup and show manual instructions\n                let backup_path = home_dir.join(\".claude\").join(\"mcp.json.backup\");\n                std::fs::copy(\u0026global_mcp_path, \u0026backup_path)?;\n\n                // Print the manual instructions\n                eprintln!(\n                    \"{} Could not parse existing {}\",\n                    \"â\".red(),\n                    global_mcp_path.display()\n                );\n                eprintln!(\"{} Please manually add the chant MCP server:\", \"â\".cyan());\n                eprintln!();\n                eprintln!(\n                    r#\"{{\n  \"mcpServers\": {{\n    \"chant\": {{\n      \"type\": \"stdio\",\n      \"command\": \"chant\",\n      \"args\": [\"mcp\"]\n    }}\n  }}\n}}\"#\n                );\n                eprintln!();\n                eprintln!(\"{} Backup saved to: {}\", \"â¹\".cyan(), backup_path.display());\n\n                // Start fresh with a new config\n                let warning_msg = format!(\n                    \"Existing {} had invalid JSON. Backup saved to {}\",\n                    global_mcp_path.display(),\n                    backup_path.display()\n                );\n                (\n                    serde_json::json!({\n                        \"mcpServers\": {}\n                    }),\n                    true,\n                    Some(warning_msg),\n                )\n            }\n        }\n    } else {\n        // Create new config structure\n        (\n            serde_json::json!({\n                \"mcpServers\": {}\n            }),\n            true,\n            None,\n        )\n    };\n\n    // Ensure mcpServers object exists\n    if config.get(\"mcpServers\").is_none() {\n        config[\"mcpServers\"] = serde_json::json!({});\n    }\n\n    // Check if chant server already exists (for reporting purposes)\n    let already_had_chant = config\n        .get(\"mcpServers\")\n        .and_then(|s| s.get(\"chant\"))\n        .is_some();\n\n    // Add or update chant MCP server\n    if let Some(servers) = config.get_mut(\"mcpServers\") {\n        servers[\"chant\"] = chant_server;\n    }\n\n    // Write updated config\n    let formatted = serde_json::to_string_pretty(\u0026config)\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize MCP config: {}\", e))?;\n    std::fs::write(\u0026global_mcp_path, formatted).map_err(|e| {\n        anyhow::anyhow!(\n            \"Failed to write {}: {} (permission denied?)\",\n            global_mcp_path.display(),\n            e\n        )\n    })?;\n\n    Ok(McpConfigResult {\n        created: is_new,\n        updated: !is_new \u0026\u0026 !already_had_chant,\n        path: global_mcp_path,\n        warning,\n    })\n}\n\n#[allow(clippy::too_many_arguments)]\nfn cmd_init(\n    subcommand: Option\u003c\u0026str\u003e,\n    name: Option\u003cString\u003e,\n    silent: bool,\n    force_overwrite: bool,\n    minimal: bool,\n    agents: Vec\u003cString\u003e,\n    provider: Option\u003cString\u003e,\n    model: Option\u003cString\u003e,\n    merge_driver: bool,\n) -\u003e Result\u003c()\u003e {\n    // Handle 'prompts' subcommand for upgrading prompts on existing projects\n    if let Some(\"prompts\") = subcommand {\n        let chant_dir = PathBuf::from(\".chant\");\n        if !chant_dir.exists() {\n            anyhow::bail!(\"Chant not initialized. Run 'chant init' first.\");\n        }\n        write_bundled_prompts(\u0026chant_dir)?;\n        println!(\"{} Prompts updated.\", \"Done!\".green());\n        return Ok(());\n    }\n\n    let chant_dir = PathBuf::from(\".chant\");\n    let config_path = chant_dir.join(\"config.md\");\n\n    // Check if this is an existing project\n    let already_initialized = chant_dir.exists() \u0026\u0026 config_path.exists();\n\n    // For existing projects with --silent flag: validate git tracking status first\n    // This is checked here because we may return early below for surgical updates\n    if already_initialized \u0026\u0026 silent {\n        let ls_output = std::process::Command::new(\"git\")\n            .args([\"ls-files\", \"--error-unmatch\", \".chant/config.md\"])\n            .output();\n\n        if let Ok(output) = ls_output {\n            if output.status.success() {\n                anyhow::bail!(\n                    \"Cannot enable silent mode: .chant/ is already tracked in git. \\\n                     Silent mode requires .chant/ to be local-only. \\\n                     Either remove .chant/ from git tracking or initialize without --silent.\"\n                );\n            }\n        }\n    }\n\n    // Handle surgical updates for existing projects (--provider or --model flags only)\n    if already_initialized \u0026\u0026 !force_overwrite {\n        // Check if this is a surgical update (only --provider or --model specified)\n        let is_surgical_provider =\n            provider.is_some() \u0026\u0026 name.is_none() \u0026\u0026 agents.is_empty() \u0026\u0026 model.is_none();\n        let is_surgical_model =\n            model.is_some() \u0026\u0026 name.is_none() \u0026\u0026 agents.is_empty() \u0026\u0026 provider.is_none();\n        let is_surgical_both =\n            provider.is_some() \u0026\u0026 model.is_some() \u0026\u0026 name.is_none() \u0026\u0026 agents.is_empty();\n        let is_agent_only =\n            !agents.is_empty() \u0026\u0026 name.is_none() \u0026\u0026 provider.is_none() \u0026\u0026 model.is_none();\n\n        if is_surgical_provider || is_surgical_model || is_surgical_both {\n            // Surgical config update\n            if let Some(ref prov) = provider {\n                let normalized = parse_provider_string(prov).ok_or_else(|| {\n                    anyhow::anyhow!(\"Invalid provider: {}. Use claude, ollama, or openai.\", prov)\n                })?;\n                update_config_field(\u0026config_path, \"provider\", normalized)?;\n                println!(\"{} Updated provider to: {}\", \"â\".green(), normalized.cyan());\n            }\n            if let Some(ref m) = model {\n                update_config_field(\u0026config_path, \"model\", m)?;\n                println!(\"{} Updated model to: {}\", \"â\".green(), m.cyan());\n            }\n            return Ok(());\n        }\n\n        if is_agent_only {\n            // Only update agent files, don't touch config\n            return handle_agent_update(\u0026chant_dir, \u0026agents, force_overwrite);\n        }\n\n        // No specific flags - show configuration menu in TTY mode\n        if atty::is(atty::Stream::Stdin)\n            \u0026\u0026 name.is_none()\n            \u0026\u0026 !silent\n            \u0026\u0026 !minimal\n            \u0026\u0026 agents.is_empty()\n            \u0026\u0026 provider.is_none()\n            \u0026\u0026 model.is_none()\n        {\n            // Read current project name from config\n            let current_name = if let Ok(config) = chant::config::Config::load() {\n                config.project.name\n            } else {\n                \"unknown\".to_string()\n            };\n\n            println!(\n                \"\\n{} {}\",\n                \"Chant already initialized for:\".cyan(),\n                current_name.bold()\n            );\n\n            let config_options = vec![\n                \"Add/update agent configuration\",\n                \"Change default model provider\",\n                \"Change default model\",\n                \"Exit (no changes)\",\n            ];\n\n            let selection = dialoguer::Select::new()\n                .with_prompt(\"What would you like to configure?\")\n                .items(\u0026config_options)\n                .default(3)\n                .interact()?;\n\n            match selection {\n                0 =\u003e {\n                    // Add/update agent configuration\n                    let agent_options = vec![\n                        \"Claude Code (CLAUDE.md)\",\n                        \"Cursor (.cursorrules)\",\n                        \"Amazon Q (.amazonq/rules.md)\",\n                        \"Generic (.ai-instructions)\",\n                        \"All of the above\",\n                    ];\n\n                    let agent_selection = dialoguer::Select::new()\n                        .with_prompt(\"Which agent configuration?\")\n                        .items(\u0026agent_options)\n                        .default(0)\n                        .interact()?;\n\n                    let selected_agents = match agent_selection {\n                        0 =\u003e vec![\"claude\".to_string()],\n                        1 =\u003e vec![\"cursor\".to_string()],\n                        2 =\u003e vec![\"amazonq\".to_string()],\n                        3 =\u003e vec![\"generic\".to_string()],\n                        4 =\u003e vec![\"all\".to_string()],\n                        _ =\u003e vec![],\n                    };\n\n                    return handle_agent_update(\u0026chant_dir, \u0026selected_agents, force_overwrite);\n                }\n                1 =\u003e {\n                    // Change default model provider\n                    let provider_options =\n                        vec![\"Claude CLI (recommended)\", \"Ollama (local)\", \"OpenAI API\"];\n\n                    let provider_selection = dialoguer::Select::new()\n                        .with_prompt(\"Default model provider?\")\n                        .items(\u0026provider_options)\n                        .default(0)\n                        .interact()?;\n\n                    let selected_provider = match provider_selection {\n                        0 =\u003e \"claude\",\n                        1 =\u003e \"ollama\",\n                        2 =\u003e \"openai\",\n                        _ =\u003e \"claude\",\n                    };\n\n                    update_config_field(\u0026config_path, \"provider\", selected_provider)?;\n                    println!(\n                        \"{} Updated provider to: {}\",\n                        \"â\".green(),\n                        selected_provider.cyan()\n                    );\n                    return Ok(());\n                }\n                2 =\u003e {\n                    // Change default model\n                    let model_options = vec![\n                        \"opus (most capable)\",\n                        \"sonnet (balanced)\",\n                        \"haiku (fastest)\",\n                        \"Custom model name\",\n                    ];\n\n                    let model_selection = dialoguer::Select::new()\n                        .with_prompt(\"Default model?\")\n                        .items(\u0026model_options)\n                        .default(1)\n                        .interact()?;\n\n                    let selected_model = match model_selection {\n                        0 =\u003e \"claude-opus-4\".to_string(),\n                        1 =\u003e \"claude-sonnet-4\".to_string(),\n                        2 =\u003e \"claude-haiku-4\".to_string(),\n                        3 =\u003e dialoguer::Input::new()\n                            .with_prompt(\"Custom model name\")\n                            .interact_text()?,\n                        _ =\u003e \"claude-sonnet-4\".to_string(),\n                    };\n\n                    update_config_field(\u0026config_path, \"model\", \u0026selected_model)?;\n                    println!(\n                        \"{} Updated model to: {}\",\n                        \"â\".green(),\n                        selected_model.cyan()\n                    );\n                    return Ok(());\n                }\n                _ =\u003e {\n                    println!(\"{}\", \"No changes made.\".yellow());\n                    return Ok(());\n                }\n            }\n        }\n\n        // Non-TTY mode without specific flags\n        println!(\"{}\", \"Chant already initialized.\".yellow());\n        return Ok(());\n    }\n\n    // Detect if we're in wizard mode (no flags provided for fresh init)\n    let is_wizard_mode = name.is_none()\n        \u0026\u0026 !silent\n        \u0026\u0026 !force_overwrite\n        \u0026\u0026 !minimal\n        \u0026\u0026 agents.is_empty()\n        \u0026\u0026 provider.is_none()\n        \u0026\u0026 model.is_none();\n\n    // Gather parameters - either from wizard or from flags\n    let (final_name, final_silent, final_minimal, final_agents, final_provider, final_model) =\n        if is_wizard_mode \u0026\u0026 atty::is(atty::Stream::Stdin) {\n            // Detect default project name for wizard\n            let detected_name = detect_project_name().unwrap_or_else(|| \"my-project\".to_string());\n\n            // Prompt for project name\n            let project_name = dialoguer::Input::new()\n                .with_prompt(\"Project name\")\n                .default(detected_name.clone())\n                .interact_text()?;\n\n            // Prompt for prompt templates\n            let include_templates = dialoguer::Confirm::new()\n                .with_prompt(\"Include prompt templates?\")\n                .default(true)\n                .interact()?;\n\n            // Prompt for silent mode\n            let enable_silent = dialoguer::Confirm::new()\n                .with_prompt(\"Keep .chant/ local only (gitignored)?\")\n                .default(false)\n                .interact()?;\n\n            // Prompt for model provider\n            let provider_options = vec![\"Claude CLI (recommended)\", \"Ollama (local)\", \"OpenAI API\"];\n\n            let provider_selection = dialoguer::Select::new()\n                .with_prompt(\"Default model provider?\")\n                .items(\u0026provider_options)\n                .default(0)\n                .interact()?;\n\n            let selected_provider = match provider_selection {\n                0 =\u003e Some(\"claude\".to_string()),\n                1 =\u003e Some(\"ollama\".to_string()),\n                2 =\u003e Some(\"openai\".to_string()),\n                _ =\u003e None,\n            };\n\n            // Prompt for default model\n            let model_options = vec![\n                \"opus (most capable)\",\n                \"sonnet (balanced)\",\n                \"haiku (fastest)\",\n                \"Custom model name\",\n                \"None (use provider default)\",\n            ];\n\n            let model_selection = dialoguer::Select::new()\n                .with_prompt(\"Default model?\")\n                .items(\u0026model_options)\n                .default(1)\n                .interact()?;\n\n            let selected_model = match model_selection {\n                0 =\u003e Some(\"claude-opus-4\".to_string()),\n                1 =\u003e Some(\"claude-sonnet-4\".to_string()),\n                2 =\u003e Some(\"claude-haiku-4\".to_string()),\n                3 =\u003e {\n                    let custom: String = dialoguer::Input::new()\n                        .with_prompt(\"Custom model name\")\n                        .interact_text()?;\n                    Some(custom)\n                }\n                _ =\u003e None,\n            };\n\n            // Prompt for agent configuration\n            let agent_options = vec![\n                \"None\",\n                \"Claude Code (CLAUDE.md)\",\n                \"Cursor (.cursorrules)\",\n                \"Amazon Q (.amazonq/rules.md)\",\n                \"Generic (.ai-instructions)\",\n                \"All of the above\",\n            ];\n\n            let agent_selection = dialoguer::Select::new()\n                .with_prompt(\"Initialize agent configuration?\")\n                .items(\u0026agent_options)\n                .default(0)\n                .interact()?;\n\n            let selected_agents = match agent_selection {\n                0 =\u003e vec![], // None\n                1 =\u003e vec![\"claude\".to_string()],\n                2 =\u003e vec![\"cursor\".to_string()],\n                3 =\u003e vec![\"amazonq\".to_string()],\n                4 =\u003e vec![\"generic\".to_string()],\n                5 =\u003e vec![\"all\".to_string()],\n                _ =\u003e vec![],\n            };\n\n            (\n                project_name,\n                enable_silent,\n                !include_templates, // invert: minimal is \"no templates\"\n                selected_agents,\n                selected_provider,\n                selected_model,\n            )\n        } else {\n            // Direct mode: use provided values\n            let project_name = name.unwrap_or_else(|| {\n                detect_project_name().unwrap_or_else(|| \"my-project\".to_string())\n            });\n\n            // Validate provider if specified\n            let validated_provider = if let Some(ref p) = provider {\n                let normalized = parse_provider_string(p).ok_or_else(|| {\n                    anyhow::anyhow!(\"Invalid provider: {}. Use claude, ollama, or openai.\", p)\n                })?;\n                Some(normalized.to_string())\n            } else {\n                None\n            };\n\n            (\n                project_name,\n                silent,\n                minimal,\n                agents,\n                validated_provider,\n                model,\n            )\n        };\n\n    // For silent mode: validate that .chant/ is not already tracked in git\n    // Do this check BEFORE the exists check so we catch tracking issues even if dir exists\n    if final_silent {\n        let ls_output = std::process::Command::new(\"git\")\n            .args([\"ls-files\", \"--error-unmatch\", \".chant/config.md\"])\n            .output();\n\n        if let Ok(output) = ls_output {\n            if output.status.success() {\n                anyhow::bail!(\n                    \"Cannot enable silent mode: .chant/ is already tracked in git. \\\n                     Silent mode requires .chant/ to be local-only. \\\n                     Either remove .chant/ from git tracking or initialize without --silent.\"\n                );\n            }\n        }\n    }\n\n    if chant_dir.exists() \u0026\u0026 force_overwrite {\n        // force_overwrite flag: do full reinitialization (preserve specs/config)\n        let specs_backup = chant_dir.join(\"specs\");\n        let config_backup = chant_dir.join(\"config.md\");\n        let prompts_backup = chant_dir.join(\"prompts\");\n        let gitignore_backup = chant_dir.join(\".gitignore\");\n        let locks_backup = chant_dir.join(\".locks\");\n        let store_backup = chant_dir.join(\".store\");\n\n        // Check which directories exist before deletion\n        let has_specs = specs_backup.exists();\n        let has_config = config_backup.exists();\n        let has_prompts = prompts_backup.exists();\n        let has_gitignore = gitignore_backup.exists();\n        let has_locks = locks_backup.exists();\n        let has_store = store_backup.exists();\n\n        // Temporarily move important files\n        let temp_dir = PathBuf::from(\".chant_temp_backup\");\n        std::fs::create_dir_all(\u0026temp_dir)?;\n\n        if has_specs {\n            std::fs::rename(\u0026specs_backup, temp_dir.join(\"specs\"))?;\n        }\n        if has_config {\n            std::fs::rename(\u0026config_backup, temp_dir.join(\"config.md\"))?;\n        }\n        if has_prompts {\n            std::fs::rename(\u0026prompts_backup, temp_dir.join(\"prompts\"))?;\n        }\n        if has_gitignore {\n            std::fs::rename(\u0026gitignore_backup, temp_dir.join(\".gitignore\"))?;\n        }\n        if has_locks {\n            std::fs::rename(\u0026locks_backup, temp_dir.join(\".locks\"))?;\n        }\n        if has_store {\n            std::fs::rename(\u0026store_backup, temp_dir.join(\".store\"))?;\n        }\n\n        // Remove the old .chant directory\n        std::fs::remove_dir_all(\u0026chant_dir)?;\n\n        // Create fresh directory structure\n        std::fs::create_dir_all(chant_dir.join(\"specs\"))?;\n        std::fs::create_dir_all(chant_dir.join(\"prompts\"))?;\n        std::fs::create_dir_all(chant_dir.join(\".locks\"))?;\n        std::fs::create_dir_all(chant_dir.join(\".store\"))?;\n\n        // Restore backed-up files\n        if has_specs {\n            std::fs::rename(temp_dir.join(\"specs\"), chant_dir.join(\"specs\"))?;\n        }\n        if has_config {\n            std::fs::rename(temp_dir.join(\"config.md\"), chant_dir.join(\"config.md\"))?;\n        }\n        if has_prompts {\n            std::fs::rename(temp_dir.join(\"prompts\"), chant_dir.join(\"prompts\"))?;\n        }\n        if has_gitignore {\n            std::fs::rename(temp_dir.join(\".gitignore\"), chant_dir.join(\".gitignore\"))?;\n        }\n        if has_locks {\n            std::fs::rename(temp_dir.join(\".locks\"), chant_dir.join(\".locks\"))?;\n        }\n        if has_store {\n            std::fs::rename(temp_dir.join(\".store\"), chant_dir.join(\".store\"))?;\n        }\n\n        // Clean up temp directory\n        let _ = std::fs::remove_dir(\u0026temp_dir);\n    }\n\n    // Detect project name\n    let project_name = final_name;\n\n    // Create directory structure (only if not already created during force_overwrite/restore)\n    std::fs::create_dir_all(chant_dir.join(\"specs\"))?;\n    std::fs::create_dir_all(chant_dir.join(\"prompts\"))?;\n    std::fs::create_dir_all(chant_dir.join(\".locks\"))?;\n    std::fs::create_dir_all(chant_dir.join(\".store\"))?;\n\n    // Create config.md only if it doesn't exist (preserve during --force-overwrite)\n    let config_path = chant_dir.join(\"config.md\");\n    if !config_path.exists() {\n        // Build defaults section with optional provider and model\n        let mut defaults_lines = vec![\n            \"  prompt: standard\".to_string(),\n            \"  branch: false\".to_string(),\n        ];\n        if let Some(ref prov) = final_provider {\n            defaults_lines.push(format!(\"  provider: {}\", prov));\n        }\n        if let Some(ref m) = final_model {\n            defaults_lines.push(format!(\"  model: {}\", m));\n        }\n\n        let config_content = format!(\n            r#\"---\nproject:\n  name: {}\n\ndefaults:\n{}\n---\n\n# Chant Configuration\n\nProject initialized on {}.\n\"#,\n            project_name,\n            defaults_lines.join(\"\\n\"),\n            chrono::Local::now().format(\"%Y-%m-%d\")\n        );\n        std::fs::write(\u0026config_path, config_content)?;\n    }\n\n    if !final_minimal {\n        // Write bundled prompts to .chant/prompts/ (only if they don't exist)\n        // This ensures existing customizations are preserved\n        write_bundled_prompts(\u0026chant_dir)?;\n    }\n\n    // Create .gitignore (only if it doesn't exist)\n    let gitignore_path = chant_dir.join(\".gitignore\");\n    if !gitignore_path.exists() {\n        let gitignore_content = \"# Local state (not shared)\\n.locks/\\n.store/\\nstore/\\nlogs/\\n\\n# Agent configuration (contains API keys, not shared)\\nagents.md\\n\";\n        std::fs::write(\u0026gitignore_path, gitignore_content)?;\n    }\n\n    // Set up the merge driver for spec files (handles .gitattributes and git config)\n    // This ensures branch mode works correctly by auto-resolving frontmatter conflicts\n    // Only run if --merge-driver flag is set\n    let (merge_driver_warning, merge_driver_result_opt) = if merge_driver {\n        let merge_driver_result = chant::merge_driver::setup_merge_driver();\n        let warning = match \u0026merge_driver_result {\n            Ok(result) =\u003e result.warning.clone(),\n            Err(e) =\u003e Some(format!(\"Failed to set up merge driver: {}\", e)),\n        };\n        (warning, Some(merge_driver_result))\n    } else {\n        (None, None)\n    };\n\n    // Handle silent mode: add .chant/ to .git/info/exclude\n    if final_silent {\n        // Get git common dir (supports worktrees)\n        let output = std::process::Command::new(\"git\")\n            .args([\"rev-parse\", \"--git-common-dir\"])\n            .output()?;\n\n        if output.status.success() {\n            let git_dir = String::from_utf8(output.stdout)?.trim().to_string();\n            let exclude_path = PathBuf::from(\u0026git_dir).join(\"info/exclude\");\n\n            // Create info directory if it doesn't exist\n            std::fs::create_dir_all(exclude_path.parent().unwrap())?;\n\n            // Read existing exclude file\n            let mut exclude_content = std::fs::read_to_string(\u0026exclude_path).unwrap_or_default();\n\n            // Add .chant/ if not already present\n            if !exclude_content.contains(\".chant/\") \u0026\u0026 !exclude_content.contains(\".chant\") {\n                if !exclude_content.ends_with('\\n') \u0026\u0026 !exclude_content.is_empty() {\n                    exclude_content.push('\\n');\n                }\n                exclude_content.push_str(\".chant/\\n\");\n                std::fs::write(\u0026exclude_path, exclude_content)?;\n            }\n        }\n    }\n\n    // Handle agent configuration if specified\n    let parsed_agents = templates::parse_agent_providers(\u0026final_agents)?;\n    let mut created_agents = Vec::new();\n    let mut updated_agents = Vec::new();\n    let mut unchanged_agents = Vec::new();\n    if !parsed_agents.is_empty() {\n        // Create agents directory\n        std::fs::create_dir_all(chant_dir.join(\"agents\"))?;\n\n        // Check if MCP will be created (affects which chant section template to use)\n        // MCP is created for Claude provider, so if Claude is in the list, we'll have MCP\n        let will_have_mcp = parsed_agents\n            .iter()\n            .any(|p| p.mcp_config_filename().is_some())\n            || PathBuf::from(\".mcp.json\").exists();\n\n        // Create agent configuration files for each provider\n        for provider in \u0026parsed_agents {\n            let template = templates::get_template(provider.as_str())?;\n\n            // Determine the target path based on provider\n            let target_path = match provider.config_filename() {\n                \".amazonq/rules.md\" =\u003e {\n                    // Create .amazonq directory in root\n                    std::fs::create_dir_all(\".amazonq\")?;\n                    PathBuf::from(\".amazonq/rules.md\")\n                }\n                filename =\u003e {\n                    // Other providers: write to root\n                    PathBuf::from(filename)\n                }\n            };\n\n            // Write the agent config file using the helper\n            let result = write_agent_config_file(\n                provider,\n                \u0026template,\n                \u0026target_path,\n                force_overwrite,\n                will_have_mcp,\n            )?;\n\n            match result {\n                AgentFileResult::Created =\u003e {\n                    created_agents.push((target_path, provider.as_str()));\n                }\n                AgentFileResult::Updated =\u003e {\n                    updated_agents.push((target_path, provider.as_str()));\n                }\n                AgentFileResult::Unchanged =\u003e {\n                    unchanged_agents.push((target_path, provider.as_str()));\n                }\n                AgentFileResult::Skipped =\u003e {\n                    // Already logged in write_agent_config_file\n                }\n            }\n        }\n\n        // Create MCP config if any provider supports it\n        let mut mcp_created = false;\n        for provider in \u0026parsed_agents {\n            if provider.mcp_config_filename().is_some() {\n                // Update global ~/.claude/mcp.json (actually used by Claude Code)\n                match update_claude_mcp_config() {\n                    Ok(result) =\u003e {\n                        if result.created {\n                            println!(\n                                \"{} Created {} with chant MCP server\",\n                                \"â\".green(),\n                                result.path.display()\n                            );\n                        } else if result.updated {\n                            println!(\n                                \"{} Added chant MCP server to {}\",\n                                \"â\".green(),\n                                result.path.display()\n                            );\n                        } else {\n                            println!(\n                                \"{} Updated chant MCP server in {}\",\n                                \"â\".green(),\n                                result.path.display()\n                            );\n                        }\n                        if let Some(warning) = result.warning {\n                            eprintln!(\"{} {}\", \"Warning:\".yellow(), warning);\n                        }\n                        mcp_created = true;\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"{} Failed to update global MCP config: {}\", \"â\".red(), e);\n                    }\n                }\n\n                // Also create project-local .mcp.json as reference\n                let mcp_path = PathBuf::from(\".mcp.json\");\n                if !mcp_path.exists() || force_overwrite {\n                    let mcp_config = r#\"{\n  \"mcpServers\": {\n    \"chant\": {\n      \"type\": \"stdio\",\n      \"command\": \"chant\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n\"#;\n                    if let Err(e) = std::fs::write(\u0026mcp_path, mcp_config) {\n                        // Project-local write failure is non-critical\n                        eprintln!(\n                            \"{} Could not create {} (reference copy): {}\",\n                            \"â¢\".yellow(),\n                            mcp_path.display(),\n                            e\n                        );\n                    } else {\n                        println!(\n                            \"{} {} (reference copy)\",\n                            \"Created\".green(),\n                            mcp_path.display()\n                        );\n                    }\n                }\n\n                if mcp_created {\n                    println!(\n                        \"{} Restart Claude Code to activate MCP integration\",\n                        \"â¹\".cyan()\n                    );\n                }\n\n                // Also create global CLAUDE.md next to binary for system-wide access\n                if *provider == templates::AgentProvider::Claude {\n                    if let Err(e) = create_global_claude_md(will_have_mcp) {\n                        // Non-critical error - log but don't fail\n                        eprintln!(\"{} Could not create global CLAUDE.md: {}\", \"â¢\".yellow(), e);\n                    }\n                }\n\n                break; // Only create one MCP config file\n            }\n        }\n    }\n\n    println!(\"{} .chant/config.md\", \"Created\".green());\n    if !final_minimal {\n        println!(\"{} .chant/prompts/standard.md\", \"Created\".green());\n        println!(\"{} .chant/prompts/split.md\", \"Created\".green());\n        println!(\"{} .chant/prompts/verify.md\", \"Created\".green());\n    }\n    println!(\"{} .chant/specs/\", \"Created\".green());\n\n    // Print agent files that were created/updated\n    for (target_path, _) in \u0026created_agents {\n        println!(\"{} {}\", \"Created\".green(), target_path.display());\n    }\n    for (target_path, _) in \u0026updated_agents {\n        println!(\"{} {}\", \"Updated\".green(), target_path.display());\n    }\n    for (target_path, _) in \u0026unchanged_agents {\n        println!(\n            \"{} {} (already up-to-date)\",\n            \"â¢\".cyan(),\n            target_path.display()\n        );\n    }\n\n    println!(\"\\nChant initialized for project: {}\", project_name.cyan());\n\n    // Show provider and model settings\n    if let Some(ref prov) = final_provider {\n        println!(\"{} Default provider: {}\", \"â¹\".cyan(), prov.cyan());\n    }\n    if let Some(ref m) = final_model {\n        println!(\"{} Default model: {}\", \"â¹\".cyan(), m.cyan());\n    }\n\n    if final_silent {\n        println!(\n            \"{} Silent mode enabled - .chant/ is local-only (not tracked in git)\",\n            \"â¹\".cyan()\n        );\n        println!(\n            \"  {} Specs won't be committed to the repository\",\n            \"â¢\".cyan()\n        );\n        println!(\n            \"  {} Use {} to convert to shared mode\",\n            \"â¢\".cyan(),\n            \"--force-overwrite\".cyan()\n        );\n    }\n    if final_minimal {\n        println!(\n            \"{} Minimal mode enabled - only config.md created\",\n            \"â¹\".cyan()\n        );\n    }\n\n    // Summarize agent configuration changes\n    let all_modified: Vec\u003c_\u003e = created_agents\n        .iter()\n        .chain(updated_agents.iter())\n        .map(|(_, name)| *name)\n        .collect();\n\n    if !all_modified.is_empty() {\n        let agent_names = all_modified.join(\", \");\n        println!(\n            \"{} Agent configuration created/updated for: {}\",\n            \"â¹\".cyan(),\n            agent_names.cyan()\n        );\n    }\n\n    // Show merge driver setup status\n    if let Some(warning) = merge_driver_warning {\n        eprintln!(\"{} Merge driver: {}\", \"Warning:\".yellow(), warning);\n    } else if let Some(Ok(result)) = merge_driver_result_opt {\n        if result.git_config_set {\n            println!(\n                \"{} Merge driver configured (auto-resolves spec file conflicts)\",\n                \"â¹\".cyan()\n            );\n        }\n    }\n\n    if is_wizard_mode {\n        println!(\n            \"\\n{} Run 'chant add \\\"description\\\"' to create your first spec.\",\n            \"Done!\".green()\n        );\n    }\n\n    Ok(())\n}\n\n/// Write bundled prompts to .chant/prompts/ directory\n///\n/// Only writes prompts that don't already exist, preserving any user customizations.\nfn write_bundled_prompts(chant_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    use chant::prompts;\n\n    for prompt in prompts::all_bundled_prompts() {\n        let prompt_path = chant_dir\n            .join(\"prompts\")\n            .join(format!(\"{}.md\", prompt.name));\n\n        // Only write if the file doesn't exist (preserve user customizations)\n        if !prompt_path.exists() {\n            std::fs::write(\u0026prompt_path, prompt.content)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn detect_project_name() -\u003e Option\u003cString\u003e {\n    // Try package.json\n    if let Ok(content) = std::fs::read_to_string(\"package.json\") {\n        if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026content) {\n            if let Some(name) = json.get(\"name\").and_then(|n| n.as_str()) {\n                return Some(name.to_string());\n            }\n        }\n    }\n\n    // Try Cargo.toml\n    if let Ok(content) = std::fs::read_to_string(\"Cargo.toml\") {\n        for line in content.lines() {\n            if line.starts_with(\"name\") {\n                if let Some(name) = line.split('=').nth(1) {\n                    return Some(name.trim().trim_matches('\"').to_string());\n                }\n            }\n        }\n    }\n\n    // Try go.mod\n    if let Ok(content) = std::fs::read_to_string(\"go.mod\") {\n        if let Some(line) = content.lines().next() {\n            if line.starts_with(\"module\") {\n                if let Some(module) = line.split_whitespace().nth(1) {\n                    // Get last segment of module path\n                    return Some(module.rsplit('/').next().unwrap_or(module).to_string());\n                }\n            }\n        }\n    }\n\n    // Fallback to directory name\n    std::env::current_dir()\n        .ok()\n        .and_then(|p| p.file_name().map(|n| n.to_string_lossy().to_string()))\n}\n\nfn cmd_version(verbose: bool) -\u003e Result\u003c()\u003e {\n    const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n    println!(\"chant {}\", VERSION);\n\n    if verbose {\n        const GIT_SHA: \u0026str = env!(\"GIT_SHA\");\n        const BUILD_DATE: \u0026str = env!(\"BUILD_DATE\");\n        println!(\"commit: {}\", GIT_SHA);\n        println!(\"built: {}\", BUILD_DATE);\n    }\n\n    Ok(())\n}\n\nfn cmd_man(out_dir: Option\u003c\u0026PathBuf\u003e) -\u003e Result\u003c()\u003e {\n    let cmd = Cli::command();\n    let man = clap_mangen::Man::new(cmd);\n    let mut buffer = Vec::new();\n    man.render(\u0026mut buffer)?;\n\n    let output_dir = out_dir\n        .map(|p| p.to_owned())\n        .unwrap_or_else(|| PathBuf::from(\".\"));\n\n    std::fs::create_dir_all(\u0026output_dir)?;\n    let man_path = output_dir.join(\"chant.1\");\n    std::fs::write(\u0026man_path, buffer)?;\n\n    println!(\"Man page written to: {}\", man_path.display());\n    Ok(())\n}\n\n/// Result of log file lookup (used in tests)\n#[cfg(test)]\n#[derive(Debug)]\nenum LogLookupResult {\n    /// Log file exists at the given path\n    Found(PathBuf),\n    /// Log file not found for the spec\n    NotFound { spec_id: String, log_path: PathBuf },\n}\n\n/// Look up the log file for a spec (used for testing)\n#[cfg(test)]\nfn lookup_log_file(base_path: \u0026std::path::Path, id: \u0026str) -\u003e anyhow::Result\u003cLogLookupResult\u003e {\n    let specs_dir = base_path.join(\"specs\");\n    let logs_dir = base_path.join(\"logs\");\n\n    if !specs_dir.exists() {\n        anyhow::bail!(\"Chant not initialized. Run `chant init` first.\");\n    }\n\n    let spec = chant::spec::resolve_spec(\u0026specs_dir, id)?;\n    let log_path = logs_dir.join(format!(\"{}.log\", spec.id));\n\n    if log_path.exists() {\n        Ok(LogLookupResult::Found(log_path))\n    } else {\n        Ok(LogLookupResult::NotFound {\n            spec_id: spec.id,\n            log_path,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_direct_mode_with_name() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Test direct mode with --name flag\n            let result = cmd_init(\n                None,\n                Some(\"test-project\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n\n            assert!(result.is_ok());\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n            assert!(temp_dir.path().join(\".chant/prompts/standard.md\").exists());\n            assert!(temp_dir.path().join(\".chant/specs\").exists());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_direct_mode_minimal() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Test direct mode with --minimal flag\n            let result = cmd_init(\n                None,\n                Some(\"minimal-project\".to_string()),\n                false,\n                false,\n                true,\n                vec![],\n                None,\n                None,\n                false,\n            );\n\n            assert!(result.is_ok());\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n            // Minimal mode should not create prompt templates\n            assert!(!temp_dir.path().join(\".chant/prompts/standard.md\").exists());\n            assert!(temp_dir.path().join(\".chant/specs\").exists());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_direct_mode_with_agent() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Test direct mode with --agent flag\n            let result = cmd_init(\n                None,\n                Some(\"agent-project\".to_string()),\n                false,\n                false,\n                false,\n                vec![\"claude\".to_string()],\n                None,\n                None,\n                false,\n            );\n\n            assert!(result.is_ok());\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n            assert!(temp_dir.path().join(\"CLAUDE.md\").exists());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_prevents_duplicate() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n\n            // Verify files were created\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n\n            // Second init without --force should gracefully exit (not fail)\n            let result2 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result2.is_ok()); // Should still be Ok, just skip re-initialization\n\n            // Third init with --force should succeed and reinitialize\n            let result3 = cmd_init(\n                None,\n                Some(\"test-force\".to_string()),\n                false,\n                true,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result3.is_ok());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_detect_project_name_from_cargo_toml() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            let _ = fs::write(\"Cargo.toml\", \"name = \\\"my-rust-project\\\"\\n\");\n\n            let detected = detect_project_name();\n            assert_eq!(detected, Some(\"my-rust-project\".to_string()));\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_force_preserves_specs_and_config() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n\n            // Create a dummy spec file\n            let specs_dir = temp_dir.path().join(\".chant/specs\");\n            let spec_file = specs_dir.join(\"2026-01-25-abc-def.md\");\n            let _ = fs::write(\n                \u0026spec_file,\n                \"---\\ntype: code\\nstatus: pending\\n---\\n# Test Spec\\n\",\n            );\n            assert!(spec_file.exists());\n\n            // Second init with --force should preserve specs\n            let result2 = cmd_init(\n                None,\n                Some(\"test-force\".to_string()),\n                false,\n                true,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result2.is_ok());\n\n            // Verify spec was preserved\n            assert!(spec_file.exists());\n            // Verify config was preserved\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n            // Verify directory structure exists\n            assert!(specs_dir.exists());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_force_reinstalls_agents() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init with Claude agent\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![\"claude\".to_string()],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n            assert!(temp_dir.path().join(\"CLAUDE.md\").exists());\n\n            // Get original file content\n            let original_content = fs::read_to_string(\"CLAUDE.md\").unwrap();\n\n            // Second init with --force should recreate agent files\n            let result2 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                true,\n                false,\n                vec![\"claude\".to_string()],\n                None,\n                None,\n                false,\n            );\n            assert!(result2.is_ok());\n            assert!(temp_dir.path().join(\"CLAUDE.md\").exists());\n\n            // Verify content is still the same (agent files are updated)\n            let new_content = fs::read_to_string(\"CLAUDE.md\").unwrap();\n            assert_eq!(original_content, new_content);\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_with_provider_and_model() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // Test init with --provider and --model flags\n            let result = cmd_init(\n                None,\n                Some(\"test-project\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                Some(\"ollama\".to_string()),\n                Some(\"llama3\".to_string()),\n                false,\n            );\n\n            assert!(result.is_ok());\n            assert!(temp_dir.path().join(\".chant/config.md\").exists());\n\n            // Verify config contains provider and model\n            let config_content = fs::read_to_string(\".chant/config.md\").unwrap();\n            assert!(config_content.contains(\"provider: ollama\"));\n            assert!(config_content.contains(\"model: llama3\"));\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_surgical_provider_update() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init without provider\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n\n            // Verify initial config doesn't have provider\n            let config_content = fs::read_to_string(\".chant/config.md\").unwrap();\n            assert!(!config_content.contains(\"provider:\"));\n\n            // Second init with only --provider should surgically update\n            let result2 = cmd_init(\n                None,\n                None, // no name\n                false,\n                false,\n                false,\n                vec![],\n                Some(\"ollama\".to_string()),\n                None,\n                false,\n            );\n            assert!(result2.is_ok());\n\n            // Verify config now contains provider\n            let config_content = fs::read_to_string(\".chant/config.md\").unwrap();\n            assert!(config_content.contains(\"provider: ollama\"));\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_surgical_model_update() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init without model\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n\n            // Second init with only --model should surgically update\n            let result2 = cmd_init(\n                None,\n                None, // no name\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                Some(\"claude-opus-4\".to_string()),\n                false,\n            );\n            assert!(result2.is_ok());\n\n            // Verify config now contains model\n            let config_content = fs::read_to_string(\".chant/config.md\").unwrap();\n            assert!(config_content.contains(\"model: claude-opus-4\"));\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_init_agent_only_update() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let orig_dir = std::env::current_dir().unwrap();\n\n        if std::env::set_current_dir(\u0026temp_dir).is_ok() {\n            // First init without agent\n            let result1 = cmd_init(\n                None,\n                Some(\"test\".to_string()),\n                false,\n                false,\n                false,\n                vec![],\n                None,\n                None,\n                false,\n            );\n            assert!(result1.is_ok());\n            assert!(!temp_dir.path().join(\"CLAUDE.md\").exists());\n\n            // Second init with only --agent should only add agent file\n            let result2 = cmd_init(\n                None,\n                None,\n                false,\n                false,\n                false,\n                vec![\"claude\".to_string()],\n                None,\n                None,\n                false,\n            );\n            assert!(result2.is_ok());\n            assert!(temp_dir.path().join(\"CLAUDE.md\").exists());\n\n            let _ = std::env::set_current_dir(orig_dir);\n        }\n    }\n}\n","traces":[{"line":720,"address":[],"length":0,"stats":{"Line":85}},{"line":727,"address":[],"length":0,"stats":{"Line":170}},{"line":728,"address":[],"length":0,"stats":{"Line":85}},{"line":729,"address":[],"length":0,"stats":{"Line":85}},{"line":732,"address":[],"length":0,"stats":{"Line":85}},{"line":733,"address":[],"length":0,"stats":{"Line":170}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":85}},{"line":739,"address":[],"length":0,"stats":{"Line":170}},{"line":742,"address":[],"length":0,"stats":{"Line":85}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":170}},{"line":750,"address":[],"length":0,"stats":{"Line":85}},{"line":751,"address":[],"length":0,"stats":{"Line":85}},{"line":753,"address":[],"length":0,"stats":{"Line":29}},{"line":754,"address":[],"length":0,"stats":{"Line":29}},{"line":755,"address":[],"length":0,"stats":{"Line":29}},{"line":756,"address":[],"length":0,"stats":{"Line":29}},{"line":757,"address":[],"length":0,"stats":{"Line":29}},{"line":758,"address":[],"length":0,"stats":{"Line":29}},{"line":759,"address":[],"length":0,"stats":{"Line":29}},{"line":760,"address":[],"length":0,"stats":{"Line":29}},{"line":761,"address":[],"length":0,"stats":{"Line":29}},{"line":763,"address":[],"length":0,"stats":{"Line":58}},{"line":764,"address":[],"length":0,"stats":{"Line":29}},{"line":765,"address":[],"length":0,"stats":{"Line":29}},{"line":766,"address":[],"length":0,"stats":{"Line":29}},{"line":767,"address":[],"length":0,"stats":{"Line":29}},{"line":768,"address":[],"length":0,"stats":{"Line":29}},{"line":769,"address":[],"length":0,"stats":{"Line":29}},{"line":770,"address":[],"length":0,"stats":{"Line":29}},{"line":771,"address":[],"length":0,"stats":{"Line":29}},{"line":774,"address":[],"length":0,"stats":{"Line":7}},{"line":775,"address":[],"length":0,"stats":{"Line":7}},{"line":776,"address":[],"length":0,"stats":{"Line":7}},{"line":777,"address":[],"length":0,"stats":{"Line":7}},{"line":778,"address":[],"length":0,"stats":{"Line":7}},{"line":780,"address":[],"length":0,"stats":{"Line":7}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":14}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":35}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":20}},{"line":807,"address":[],"length":0,"stats":{"Line":20}},{"line":808,"address":[],"length":0,"stats":{"Line":20}},{"line":809,"address":[],"length":0,"stats":{"Line":20}},{"line":810,"address":[],"length":0,"stats":{"Line":20}},{"line":811,"address":[],"length":0,"stats":{"Line":20}},{"line":812,"address":[],"length":0,"stats":{"Line":20}},{"line":813,"address":[],"length":0,"stats":{"Line":20}},{"line":814,"address":[],"length":0,"stats":{"Line":20}},{"line":815,"address":[],"length":0,"stats":{"Line":20}},{"line":816,"address":[],"length":0,"stats":{"Line":20}},{"line":817,"address":[],"length":0,"stats":{"Line":20}},{"line":818,"address":[],"length":0,"stats":{"Line":20}},{"line":819,"address":[],"length":0,"stats":{"Line":20}},{"line":820,"address":[],"length":0,"stats":{"Line":20}},{"line":821,"address":[],"length":0,"stats":{"Line":20}},{"line":822,"address":[],"length":0,"stats":{"Line":20}},{"line":824,"address":[],"length":0,"stats":{"Line":20}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":60}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":20}},{"line":833,"address":[],"length":0,"stats":{"Line":20}},{"line":834,"address":[],"length":0,"stats":{"Line":40}},{"line":835,"address":[],"length":0,"stats":{"Line":40}},{"line":836,"address":[],"length":0,"stats":{"Line":20}},{"line":837,"address":[],"length":0,"stats":{"Line":40}},{"line":838,"address":[],"length":0,"stats":{"Line":40}},{"line":839,"address":[],"length":0,"stats":{"Line":40}},{"line":840,"address":[],"length":0,"stats":{"Line":40}},{"line":841,"address":[],"length":0,"stats":{"Line":40}},{"line":842,"address":[],"length":0,"stats":{"Line":40}},{"line":843,"address":[],"length":0,"stats":{"Line":20}},{"line":844,"address":[],"length":0,"stats":{"Line":20}},{"line":849,"address":[],"length":0,"stats":{"Line":1}},{"line":850,"address":[],"length":0,"stats":{"Line":1}},{"line":851,"address":[],"length":0,"stats":{"Line":1}},{"line":852,"address":[],"length":0,"stats":{"Line":1}},{"line":853,"address":[],"length":0,"stats":{"Line":1}},{"line":854,"address":[],"length":0,"stats":{"Line":6}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":11}},{"line":890,"address":[],"length":0,"stats":{"Line":11}},{"line":891,"address":[],"length":0,"stats":{"Line":11}},{"line":892,"address":[],"length":0,"stats":{"Line":11}},{"line":893,"address":[],"length":0,"stats":{"Line":11}},{"line":894,"address":[],"length":0,"stats":{"Line":11}},{"line":895,"address":[],"length":0,"stats":{"Line":11}},{"line":896,"address":[],"length":0,"stats":{"Line":11}},{"line":897,"address":[],"length":0,"stats":{"Line":11}},{"line":898,"address":[],"length":0,"stats":{"Line":11}},{"line":899,"address":[],"length":0,"stats":{"Line":11}},{"line":900,"address":[],"length":0,"stats":{"Line":11}},{"line":901,"address":[],"length":0,"stats":{"Line":11}},{"line":902,"address":[],"length":0,"stats":{"Line":11}},{"line":903,"address":[],"length":0,"stats":{"Line":11}},{"line":904,"address":[],"length":0,"stats":{"Line":11}},{"line":905,"address":[],"length":0,"stats":{"Line":11}},{"line":907,"address":[],"length":0,"stats":{"Line":12}},{"line":908,"address":[],"length":0,"stats":{"Line":2}},{"line":909,"address":[],"length":0,"stats":{"Line":1}},{"line":910,"address":[],"length":0,"stats":{"Line":1}},{"line":915,"address":[],"length":0,"stats":{"Line":33}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":11}},{"line":929,"address":[],"length":0,"stats":{"Line":11}},{"line":930,"address":[],"length":0,"stats":{"Line":22}},{"line":931,"address":[],"length":0,"stats":{"Line":11}},{"line":932,"address":[],"length":0,"stats":{"Line":11}},{"line":933,"address":[],"length":0,"stats":{"Line":11}},{"line":934,"address":[],"length":0,"stats":{"Line":11}},{"line":935,"address":[],"length":0,"stats":{"Line":11}},{"line":936,"address":[],"length":0,"stats":{"Line":11}},{"line":937,"address":[],"length":0,"stats":{"Line":11}},{"line":938,"address":[],"length":0,"stats":{"Line":11}},{"line":939,"address":[],"length":0,"stats":{"Line":11}},{"line":940,"address":[],"length":0,"stats":{"Line":11}},{"line":941,"address":[],"length":0,"stats":{"Line":11}},{"line":942,"address":[],"length":0,"stats":{"Line":11}},{"line":943,"address":[],"length":0,"stats":{"Line":11}},{"line":944,"address":[],"length":0,"stats":{"Line":11}},{"line":945,"address":[],"length":0,"stats":{"Line":11}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":6}},{"line":968,"address":[],"length":0,"stats":{"Line":6}},{"line":969,"address":[],"length":0,"stats":{"Line":3}},{"line":970,"address":[],"length":0,"stats":{"Line":6}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":9}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":5}},{"line":1013,"address":[],"length":0,"stats":{"Line":5}},{"line":1014,"address":[],"length":0,"stats":{"Line":5}},{"line":1015,"address":[],"length":0,"stats":{"Line":5}},{"line":1016,"address":[],"length":0,"stats":{"Line":5}},{"line":1017,"address":[],"length":0,"stats":{"Line":5}},{"line":1018,"address":[],"length":0,"stats":{"Line":5}},{"line":1019,"address":[],"length":0,"stats":{"Line":5}},{"line":1020,"address":[],"length":0,"stats":{"Line":5}},{"line":1021,"address":[],"length":0,"stats":{"Line":5}},{"line":1022,"address":[],"length":0,"stats":{"Line":5}},{"line":1023,"address":[],"length":0,"stats":{"Line":5}},{"line":1024,"address":[],"length":0,"stats":{"Line":5}},{"line":1026,"address":[],"length":0,"stats":{"Line":5}},{"line":1027,"address":[],"length":0,"stats":{"Line":5}},{"line":1028,"address":[],"length":0,"stats":{"Line":5}},{"line":1029,"address":[],"length":0,"stats":{"Line":5}},{"line":1030,"address":[],"length":0,"stats":{"Line":5}},{"line":1031,"address":[],"length":0,"stats":{"Line":5}},{"line":1032,"address":[],"length":0,"stats":{"Line":5}},{"line":1033,"address":[],"length":0,"stats":{"Line":5}},{"line":1034,"address":[],"length":0,"stats":{"Line":5}},{"line":1035,"address":[],"length":0,"stats":{"Line":5}},{"line":1036,"address":[],"length":0,"stats":{"Line":5}},{"line":1037,"address":[],"length":0,"stats":{"Line":5}},{"line":1038,"address":[],"length":0,"stats":{"Line":5}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":1}},{"line":1094,"address":[],"length":0,"stats":{"Line":1}},{"line":1095,"address":[],"length":0,"stats":{"Line":1}},{"line":1096,"address":[],"length":0,"stats":{"Line":1}},{"line":1097,"address":[],"length":0,"stats":{"Line":1}},{"line":1098,"address":[],"length":0,"stats":{"Line":1}},{"line":1099,"address":[],"length":0,"stats":{"Line":1}},{"line":1100,"address":[],"length":0,"stats":{"Line":1}},{"line":1101,"address":[],"length":0,"stats":{"Line":1}},{"line":1103,"address":[],"length":0,"stats":{"Line":2}},{"line":1104,"address":[],"length":0,"stats":{"Line":1}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":1}},{"line":1107,"address":[],"length":0,"stats":{"Line":1}},{"line":1108,"address":[],"length":0,"stats":{"Line":2}},{"line":1109,"address":[],"length":0,"stats":{"Line":2}},{"line":1110,"address":[],"length":0,"stats":{"Line":2}},{"line":1111,"address":[],"length":0,"stats":{"Line":2}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":8}},{"line":1122,"address":[],"length":0,"stats":{"Line":4}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1128,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1136,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":7}},{"line":1144,"address":[],"length":0,"stats":{"Line":3}},{"line":1145,"address":[],"length":0,"stats":{"Line":6}},{"line":1146,"address":[],"length":0,"stats":{"Line":9}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1154,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":2}},{"line":1205,"address":[],"length":0,"stats":{"Line":2}},{"line":1206,"address":[],"length":0,"stats":{"Line":4}},{"line":1207,"address":[],"length":0,"stats":{"Line":4}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":4}},{"line":1238,"address":[],"length":0,"stats":{"Line":4}},{"line":1239,"address":[],"length":0,"stats":{"Line":12}},{"line":1240,"address":[],"length":0,"stats":{"Line":2}},{"line":1242,"address":[],"length":0,"stats":{"Line":3}},{"line":1245,"address":[],"length":0,"stats":{"Line":20}},{"line":1247,"address":[],"length":0,"stats":{"Line":4}},{"line":1248,"address":[],"length":0,"stats":{"Line":3}},{"line":1249,"address":[],"length":0,"stats":{"Line":9}},{"line":1250,"address":[],"length":0,"stats":{"Line":3}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":1}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":1}},{"line":1308,"address":[],"length":0,"stats":{"Line":3}},{"line":1310,"address":[],"length":0,"stats":{"Line":2}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":3}},{"line":1319,"address":[],"length":0,"stats":{"Line":2}},{"line":1321,"address":[],"length":0,"stats":{"Line":2}},{"line":1322,"address":[],"length":0,"stats":{"Line":2}},{"line":1323,"address":[],"length":0,"stats":{"Line":2}},{"line":1325,"address":[],"length":0,"stats":{"Line":2}},{"line":1326,"address":[],"length":0,"stats":{"Line":3}},{"line":1329,"address":[],"length":0,"stats":{"Line":2}},{"line":1330,"address":[],"length":0,"stats":{"Line":1}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":3}},{"line":1338,"address":[],"length":0,"stats":{"Line":1}},{"line":1339,"address":[],"length":0,"stats":{"Line":6}},{"line":1341,"address":[],"length":0,"stats":{"Line":1}},{"line":1342,"address":[],"length":0,"stats":{"Line":1}},{"line":1343,"address":[],"length":0,"stats":{"Line":4}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":3}},{"line":1359,"address":[],"length":0,"stats":{"Line":4}},{"line":1361,"address":[],"length":0,"stats":{"Line":1}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":1}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":3}},{"line":1374,"address":[],"length":0,"stats":{"Line":2}},{"line":1375,"address":[],"length":0,"stats":{"Line":1}},{"line":1378,"address":[],"length":0,"stats":{"Line":2}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":2}},{"line":1381,"address":[],"length":0,"stats":{"Line":4}},{"line":1382,"address":[],"length":0,"stats":{"Line":2}},{"line":1383,"address":[],"length":0,"stats":{"Line":1}},{"line":1384,"address":[],"length":0,"stats":{"Line":3}},{"line":1385,"address":[],"length":0,"stats":{"Line":1}},{"line":1390,"address":[],"length":0,"stats":{"Line":2}},{"line":1391,"address":[],"length":0,"stats":{"Line":2}},{"line":1392,"address":[],"length":0,"stats":{"Line":2}},{"line":1394,"address":[],"length":0,"stats":{"Line":1}},{"line":1395,"address":[],"length":0,"stats":{"Line":1}},{"line":1396,"address":[],"length":0,"stats":{"Line":1}},{"line":1397,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":1}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1404,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":2}},{"line":1410,"address":[],"length":0,"stats":{"Line":1}},{"line":1411,"address":[],"length":0,"stats":{"Line":3}},{"line":1412,"address":[],"length":0,"stats":{"Line":1}},{"line":1415,"address":[],"length":0,"stats":{"Line":1}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":1}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":2}},{"line":1427,"address":[],"length":0,"stats":{"Line":1}},{"line":1428,"address":[],"length":0,"stats":{"Line":2}},{"line":1429,"address":[],"length":0,"stats":{"Line":1}},{"line":1430,"address":[],"length":0,"stats":{"Line":1}},{"line":1431,"address":[],"length":0,"stats":{"Line":1}},{"line":1432,"address":[],"length":0,"stats":{"Line":1}},{"line":1433,"address":[],"length":0,"stats":{"Line":1}},{"line":1437,"address":[],"length":0,"stats":{"Line":1}},{"line":1438,"address":[],"length":0,"stats":{"Line":2}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":2}},{"line":1448,"address":[],"length":0,"stats":{"Line":1}},{"line":1449,"address":[],"length":0,"stats":{"Line":3}},{"line":1450,"address":[],"length":0,"stats":{"Line":1}},{"line":1455,"address":[],"length":0,"stats":{"Line":2}},{"line":1456,"address":[],"length":0,"stats":{"Line":2}},{"line":1457,"address":[],"length":0,"stats":{"Line":1}},{"line":1458,"address":[],"length":0,"stats":{"Line":1}},{"line":1461,"address":[],"length":0,"stats":{"Line":1}},{"line":1465,"address":[],"length":0,"stats":{"Line":1}},{"line":1469,"address":[],"length":0,"stats":{"Line":2}},{"line":1470,"address":[],"length":0,"stats":{"Line":6}},{"line":1473,"address":[],"length":0,"stats":{"Line":6}},{"line":1474,"address":[],"length":0,"stats":{"Line":6}},{"line":1477,"address":[],"length":0,"stats":{"Line":8}},{"line":1480,"address":[],"length":0,"stats":{"Line":2}},{"line":1481,"address":[],"length":0,"stats":{"Line":2}},{"line":1483,"address":[],"length":0,"stats":{"Line":2}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1486,"address":[],"length":0,"stats":{"Line":2}},{"line":1488,"address":[],"length":0,"stats":{"Line":1}},{"line":1490,"address":[],"length":0,"stats":{"Line":2}},{"line":1491,"address":[],"length":0,"stats":{"Line":0}},{"line":1493,"address":[],"length":0,"stats":{"Line":2}},{"line":1495,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":6}},{"line":1502,"address":[],"length":0,"stats":{"Line":4}},{"line":1503,"address":[],"length":0,"stats":{"Line":6}},{"line":1505,"address":[],"length":0,"stats":{"Line":2}},{"line":1515,"address":[],"length":0,"stats":{"Line":3}},{"line":1517,"address":[],"length":0,"stats":{"Line":6}},{"line":1518,"address":[],"length":0,"stats":{"Line":3}},{"line":1520,"address":[],"length":0,"stats":{"Line":6}},{"line":1522,"address":[],"length":0,"stats":{"Line":3}},{"line":1524,"address":[],"length":0,"stats":{"Line":9}},{"line":1527,"address":[],"length":0,"stats":{"Line":6}},{"line":1528,"address":[],"length":0,"stats":{"Line":4}},{"line":1530,"address":[],"length":0,"stats":{"Line":1}},{"line":1533,"address":[],"length":0,"stats":{"Line":15}},{"line":1535,"address":[],"length":0,"stats":{"Line":3}},{"line":1536,"address":[],"length":0,"stats":{"Line":1}},{"line":1537,"address":[],"length":0,"stats":{"Line":3}},{"line":1538,"address":[],"length":0,"stats":{"Line":1}},{"line":1540,"address":[],"length":0,"stats":{"Line":2}},{"line":1541,"address":[],"length":0,"stats":{"Line":1}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":2}},{"line":1558,"address":[],"length":0,"stats":{"Line":3}},{"line":1581,"address":[],"length":0,"stats":{"Line":4}},{"line":1582,"address":[],"length":0,"stats":{"Line":4}},{"line":1583,"address":[],"length":0,"stats":{"Line":8}},{"line":1585,"address":[],"length":0,"stats":{"Line":8}},{"line":1588,"address":[],"length":0,"stats":{"Line":8}},{"line":1589,"address":[],"length":0,"stats":{"Line":12}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":8}},{"line":1596,"address":[],"length":0,"stats":{"Line":4}},{"line":1597,"address":[],"length":0,"stats":{"Line":4}},{"line":1598,"address":[],"length":0,"stats":{"Line":4}},{"line":1602,"address":[],"length":0,"stats":{"Line":16}},{"line":1603,"address":[],"length":0,"stats":{"Line":12}},{"line":1604,"address":[],"length":0,"stats":{"Line":4}},{"line":1606,"address":[],"length":0,"stats":{"Line":4}},{"line":1607,"address":[],"length":0,"stats":{"Line":8}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1616,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":8}},{"line":1663,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":8}},{"line":1669,"address":[],"length":0,"stats":{"Line":12}},{"line":1673,"address":[],"length":0,"stats":{"Line":12}},{"line":1674,"address":[],"length":0,"stats":{"Line":4}},{"line":1678,"address":[],"length":0,"stats":{"Line":12}},{"line":1679,"address":[],"length":0,"stats":{"Line":4}},{"line":1680,"address":[],"length":0,"stats":{"Line":16}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":4}},{"line":1690,"address":[],"length":0,"stats":{"Line":8}},{"line":1691,"address":[],"length":0,"stats":{"Line":4}},{"line":1692,"address":[],"length":0,"stats":{"Line":4}},{"line":1697,"address":[],"length":0,"stats":{"Line":48}},{"line":1709,"address":[],"length":0,"stats":{"Line":48}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1712,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":96}},{"line":1720,"address":[],"length":0,"stats":{"Line":96}},{"line":1723,"address":[],"length":0,"stats":{"Line":104}},{"line":1727,"address":[],"length":0,"stats":{"Line":56}},{"line":1728,"address":[],"length":0,"stats":{"Line":3}},{"line":1729,"address":[],"length":0,"stats":{"Line":2}},{"line":1732,"address":[],"length":0,"stats":{"Line":2}},{"line":1733,"address":[],"length":0,"stats":{"Line":2}},{"line":1734,"address":[],"length":0,"stats":{"Line":1}},{"line":1744,"address":[],"length":0,"stats":{"Line":54}},{"line":1746,"address":[],"length":0,"stats":{"Line":4}},{"line":1747,"address":[],"length":0,"stats":{"Line":14}},{"line":1748,"address":[],"length":0,"stats":{"Line":4}},{"line":1749,"address":[],"length":0,"stats":{"Line":14}},{"line":1750,"address":[],"length":0,"stats":{"Line":4}},{"line":1751,"address":[],"length":0,"stats":{"Line":10}},{"line":1752,"address":[],"length":0,"stats":{"Line":4}},{"line":1753,"address":[],"length":0,"stats":{"Line":10}},{"line":1755,"address":[],"length":0,"stats":{"Line":9}},{"line":1757,"address":[],"length":0,"stats":{"Line":3}},{"line":1758,"address":[],"length":0,"stats":{"Line":4}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1761,"address":[],"length":0,"stats":{"Line":4}},{"line":1762,"address":[],"length":0,"stats":{"Line":5}},{"line":1764,"address":[],"length":0,"stats":{"Line":3}},{"line":1765,"address":[],"length":0,"stats":{"Line":4}},{"line":1766,"address":[],"length":0,"stats":{"Line":4}},{"line":1768,"address":[],"length":0,"stats":{"Line":2}},{"line":1771,"address":[],"length":0,"stats":{"Line":2}},{"line":1773,"address":[],"length":0,"stats":{"Line":4}},{"line":1777,"address":[],"length":0,"stats":{"Line":2}},{"line":1778,"address":[],"length":0,"stats":{"Line":0}},{"line":1779,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1782,"address":[],"length":0,"stats":{"Line":0}},{"line":1783,"address":[],"length":0,"stats":{"Line":0}},{"line":1786,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1792,"address":[],"length":0,"stats":{"Line":0}},{"line":1794,"address":[],"length":0,"stats":{"Line":0}},{"line":1795,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1807,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1822,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1828,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1830,"address":[],"length":0,"stats":{"Line":0}},{"line":1831,"address":[],"length":0,"stats":{"Line":0}},{"line":1832,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1834,"address":[],"length":0,"stats":{"Line":0}},{"line":1837,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1842,"address":[],"length":0,"stats":{"Line":0}},{"line":1844,"address":[],"length":0,"stats":{"Line":0}},{"line":1846,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1852,"address":[],"length":0,"stats":{"Line":0}},{"line":1853,"address":[],"length":0,"stats":{"Line":0}},{"line":1854,"address":[],"length":0,"stats":{"Line":0}},{"line":1857,"address":[],"length":0,"stats":{"Line":0}},{"line":1858,"address":[],"length":0,"stats":{"Line":0}},{"line":1860,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1874,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1882,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1887,"address":[],"length":0,"stats":{"Line":0}},{"line":1890,"address":[],"length":0,"stats":{"Line":0}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1906,"address":[],"length":0,"stats":{"Line":3}},{"line":1907,"address":[],"length":0,"stats":{"Line":1}},{"line":1911,"address":[],"length":0,"stats":{"Line":129}},{"line":1912,"address":[],"length":0,"stats":{"Line":28}},{"line":1913,"address":[],"length":0,"stats":{"Line":26}},{"line":1914,"address":[],"length":0,"stats":{"Line":26}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":258}},{"line":1921,"address":[],"length":0,"stats":{"Line":43}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1938,"address":[],"length":0,"stats":{"Line":0}},{"line":1944,"address":[],"length":0,"stats":{"Line":0}},{"line":1946,"address":[],"length":0,"stats":{"Line":0}},{"line":1948,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1955,"address":[],"length":0,"stats":{"Line":0}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1974,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1976,"address":[],"length":0,"stats":{"Line":0}},{"line":1977,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2003,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2006,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2015,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2018,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2023,"address":[],"length":0,"stats":{"Line":157}},{"line":2024,"address":[],"length":0,"stats":{"Line":56}},{"line":2028,"address":[],"length":0,"stats":{"Line":87}},{"line":2029,"address":[],"length":0,"stats":{"Line":4}},{"line":2030,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":1}},{"line":2034,"address":[],"length":0,"stats":{"Line":42}},{"line":2038,"address":[],"length":0,"stats":{"Line":86}},{"line":2039,"address":[],"length":0,"stats":{"Line":86}},{"line":2040,"address":[],"length":0,"stats":{"Line":86}},{"line":2041,"address":[],"length":0,"stats":{"Line":86}},{"line":2042,"address":[],"length":0,"stats":{"Line":43}},{"line":2043,"address":[],"length":0,"stats":{"Line":43}},{"line":2049,"address":[],"length":0,"stats":{"Line":43}},{"line":2050,"address":[],"length":0,"stats":{"Line":6}},{"line":2051,"address":[],"length":0,"stats":{"Line":4}},{"line":2054,"address":[],"length":0,"stats":{"Line":4}},{"line":2055,"address":[],"length":0,"stats":{"Line":4}},{"line":2056,"address":[],"length":0,"stats":{"Line":0}},{"line":2065,"address":[],"length":0,"stats":{"Line":46}},{"line":2067,"address":[],"length":0,"stats":{"Line":6}},{"line":2068,"address":[],"length":0,"stats":{"Line":6}},{"line":2069,"address":[],"length":0,"stats":{"Line":6}},{"line":2070,"address":[],"length":0,"stats":{"Line":6}},{"line":2071,"address":[],"length":0,"stats":{"Line":6}},{"line":2072,"address":[],"length":0,"stats":{"Line":6}},{"line":2075,"address":[],"length":0,"stats":{"Line":6}},{"line":2076,"address":[],"length":0,"stats":{"Line":6}},{"line":2077,"address":[],"length":0,"stats":{"Line":6}},{"line":2078,"address":[],"length":0,"stats":{"Line":6}},{"line":2079,"address":[],"length":0,"stats":{"Line":6}},{"line":2080,"address":[],"length":0,"stats":{"Line":6}},{"line":2083,"address":[],"length":0,"stats":{"Line":6}},{"line":2084,"address":[],"length":0,"stats":{"Line":6}},{"line":2086,"address":[],"length":0,"stats":{"Line":3}},{"line":2087,"address":[],"length":0,"stats":{"Line":9}},{"line":2089,"address":[],"length":0,"stats":{"Line":3}},{"line":2090,"address":[],"length":0,"stats":{"Line":9}},{"line":2092,"address":[],"length":0,"stats":{"Line":3}},{"line":2093,"address":[],"length":0,"stats":{"Line":9}},{"line":2095,"address":[],"length":0,"stats":{"Line":3}},{"line":2096,"address":[],"length":0,"stats":{"Line":9}},{"line":2098,"address":[],"length":0,"stats":{"Line":3}},{"line":2099,"address":[],"length":0,"stats":{"Line":9}},{"line":2101,"address":[],"length":0,"stats":{"Line":3}},{"line":2102,"address":[],"length":0,"stats":{"Line":9}},{"line":2106,"address":[],"length":0,"stats":{"Line":6}},{"line":2109,"address":[],"length":0,"stats":{"Line":6}},{"line":2110,"address":[],"length":0,"stats":{"Line":6}},{"line":2111,"address":[],"length":0,"stats":{"Line":6}},{"line":2112,"address":[],"length":0,"stats":{"Line":6}},{"line":2115,"address":[],"length":0,"stats":{"Line":3}},{"line":2116,"address":[],"length":0,"stats":{"Line":9}},{"line":2118,"address":[],"length":0,"stats":{"Line":3}},{"line":2119,"address":[],"length":0,"stats":{"Line":9}},{"line":2121,"address":[],"length":0,"stats":{"Line":3}},{"line":2122,"address":[],"length":0,"stats":{"Line":9}},{"line":2124,"address":[],"length":0,"stats":{"Line":3}},{"line":2125,"address":[],"length":0,"stats":{"Line":9}},{"line":2127,"address":[],"length":0,"stats":{"Line":3}},{"line":2128,"address":[],"length":0,"stats":{"Line":9}},{"line":2130,"address":[],"length":0,"stats":{"Line":3}},{"line":2131,"address":[],"length":0,"stats":{"Line":9}},{"line":2135,"address":[],"length":0,"stats":{"Line":3}},{"line":2139,"address":[],"length":0,"stats":{"Line":86}},{"line":2142,"address":[],"length":0,"stats":{"Line":86}},{"line":2143,"address":[],"length":0,"stats":{"Line":86}},{"line":2144,"address":[],"length":0,"stats":{"Line":86}},{"line":2145,"address":[],"length":0,"stats":{"Line":86}},{"line":2148,"address":[],"length":0,"stats":{"Line":86}},{"line":2149,"address":[],"length":0,"stats":{"Line":43}},{"line":2151,"address":[],"length":0,"stats":{"Line":80}},{"line":2152,"address":[],"length":0,"stats":{"Line":80}},{"line":2153,"address":[],"length":0,"stats":{"Line":80}},{"line":2155,"address":[],"length":0,"stats":{"Line":42}},{"line":2156,"address":[],"length":0,"stats":{"Line":2}},{"line":2158,"address":[],"length":0,"stats":{"Line":42}},{"line":2159,"address":[],"length":0,"stats":{"Line":2}},{"line":2162,"address":[],"length":0,"stats":{"Line":80}},{"line":2176,"address":[],"length":0,"stats":{"Line":80}},{"line":2177,"address":[],"length":0,"stats":{"Line":120}},{"line":2179,"address":[],"length":0,"stats":{"Line":120}},{"line":2182,"address":[],"length":0,"stats":{"Line":43}},{"line":2185,"address":[],"length":0,"stats":{"Line":32}},{"line":2189,"address":[],"length":0,"stats":{"Line":86}},{"line":2190,"address":[],"length":0,"stats":{"Line":43}},{"line":2191,"address":[],"length":0,"stats":{"Line":80}},{"line":2192,"address":[],"length":0,"stats":{"Line":120}},{"line":2198,"address":[],"length":0,"stats":{"Line":129}},{"line":2199,"address":[],"length":0,"stats":{"Line":0}},{"line":2200,"address":[],"length":0,"stats":{"Line":0}},{"line":2201,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":0}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2206,"address":[],"length":0,"stats":{"Line":43}},{"line":2210,"address":[],"length":0,"stats":{"Line":43}},{"line":2212,"address":[],"length":0,"stats":{"Line":6}},{"line":2213,"address":[],"length":0,"stats":{"Line":2}},{"line":2216,"address":[],"length":0,"stats":{"Line":4}},{"line":2217,"address":[],"length":0,"stats":{"Line":10}},{"line":2218,"address":[],"length":0,"stats":{"Line":4}},{"line":2221,"address":[],"length":0,"stats":{"Line":6}},{"line":2224,"address":[],"length":0,"stats":{"Line":8}},{"line":2227,"address":[],"length":0,"stats":{"Line":4}},{"line":2228,"address":[],"length":0,"stats":{"Line":2}},{"line":2229,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":6}},{"line":2232,"address":[],"length":0,"stats":{"Line":6}},{"line":2238,"address":[],"length":0,"stats":{"Line":129}},{"line":2239,"address":[],"length":0,"stats":{"Line":86}},{"line":2240,"address":[],"length":0,"stats":{"Line":86}},{"line":2241,"address":[],"length":0,"stats":{"Line":86}},{"line":2242,"address":[],"length":0,"stats":{"Line":43}},{"line":2244,"address":[],"length":0,"stats":{"Line":6}},{"line":2248,"address":[],"length":0,"stats":{"Line":6}},{"line":2249,"address":[],"length":0,"stats":{"Line":3}},{"line":2250,"address":[],"length":0,"stats":{"Line":9}},{"line":2251,"address":[],"length":0,"stats":{"Line":0}},{"line":2254,"address":[],"length":0,"stats":{"Line":6}},{"line":2255,"address":[],"length":0,"stats":{"Line":9}},{"line":2258,"address":[],"length":0,"stats":{"Line":6}},{"line":2259,"address":[],"length":0,"stats":{"Line":3}},{"line":2261,"address":[],"length":0,"stats":{"Line":0}},{"line":2262,"address":[],"length":0,"stats":{"Line":0}},{"line":2264,"address":[],"length":0,"stats":{"Line":3}},{"line":2266,"address":[],"length":0,"stats":{"Line":6}},{"line":2272,"address":[],"length":0,"stats":{"Line":3}},{"line":2273,"address":[],"length":0,"stats":{"Line":3}},{"line":2274,"address":[],"length":0,"stats":{"Line":3}},{"line":2275,"address":[],"length":0,"stats":{"Line":3}},{"line":2276,"address":[],"length":0,"stats":{"Line":3}},{"line":2279,"address":[],"length":0,"stats":{"Line":3}},{"line":2280,"address":[],"length":0,"stats":{"Line":2}},{"line":2281,"address":[],"length":0,"stats":{"Line":8}},{"line":2283,"address":[],"length":0,"stats":{"Line":0}},{"line":2284,"address":[],"length":0,"stats":{"Line":0}},{"line":2286,"address":[],"length":0,"stats":{"Line":1}},{"line":2287,"address":[],"length":0,"stats":{"Line":4}},{"line":2289,"address":[],"length":0,"stats":{"Line":0}},{"line":2296,"address":[],"length":0,"stats":{"Line":6}},{"line":2297,"address":[],"length":0,"stats":{"Line":6}},{"line":2298,"address":[],"length":0,"stats":{"Line":6}},{"line":2300,"address":[],"length":0,"stats":{"Line":3}},{"line":2301,"address":[],"length":0,"stats":{"Line":3}},{"line":2302,"address":[],"length":0,"stats":{"Line":3}},{"line":2303,"address":[],"length":0,"stats":{"Line":0}},{"line":2304,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2308,"address":[],"length":0,"stats":{"Line":3}},{"line":2309,"address":[],"length":0,"stats":{"Line":0}},{"line":2310,"address":[],"length":0,"stats":{"Line":0}},{"line":2311,"address":[],"length":0,"stats":{"Line":0}},{"line":2312,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":6}},{"line":2316,"address":[],"length":0,"stats":{"Line":3}},{"line":2317,"address":[],"length":0,"stats":{"Line":9}},{"line":2318,"address":[],"length":0,"stats":{"Line":3}},{"line":2321,"address":[],"length":0,"stats":{"Line":3}},{"line":2322,"address":[],"length":0,"stats":{"Line":0}},{"line":2324,"address":[],"length":0,"stats":{"Line":3}},{"line":2326,"address":[],"length":0,"stats":{"Line":0}},{"line":2327,"address":[],"length":0,"stats":{"Line":0}},{"line":2332,"address":[],"length":0,"stats":{"Line":6}},{"line":2333,"address":[],"length":0,"stats":{"Line":4}},{"line":2334,"address":[],"length":0,"stats":{"Line":6}},{"line":2335,"address":[],"length":0,"stats":{"Line":3}},{"line":2336,"address":[],"length":0,"stats":{"Line":3}},{"line":2337,"address":[],"length":0,"stats":{"Line":3}},{"line":2338,"address":[],"length":0,"stats":{"Line":3}},{"line":2339,"address":[],"length":0,"stats":{"Line":3}},{"line":2343,"address":[],"length":0,"stats":{"Line":3}},{"line":2344,"address":[],"length":0,"stats":{"Line":6}},{"line":2346,"address":[],"length":0,"stats":{"Line":0}},{"line":2347,"address":[],"length":0,"stats":{"Line":0}},{"line":2348,"address":[],"length":0,"stats":{"Line":0}},{"line":2349,"address":[],"length":0,"stats":{"Line":0}},{"line":2350,"address":[],"length":0,"stats":{"Line":0}},{"line":2353,"address":[],"length":0,"stats":{"Line":6}},{"line":2354,"address":[],"length":0,"stats":{"Line":3}},{"line":2355,"address":[],"length":0,"stats":{"Line":9}},{"line":2356,"address":[],"length":0,"stats":{"Line":3}},{"line":2361,"address":[],"length":0,"stats":{"Line":6}},{"line":2362,"address":[],"length":0,"stats":{"Line":6}},{"line":2363,"address":[],"length":0,"stats":{"Line":3}},{"line":2364,"address":[],"length":0,"stats":{"Line":3}},{"line":2369,"address":[],"length":0,"stats":{"Line":3}},{"line":2370,"address":[],"length":0,"stats":{"Line":3}},{"line":2372,"address":[],"length":0,"stats":{"Line":0}},{"line":2376,"address":[],"length":0,"stats":{"Line":3}},{"line":2381,"address":[],"length":0,"stats":{"Line":129}},{"line":2382,"address":[],"length":0,"stats":{"Line":59}},{"line":2383,"address":[],"length":0,"stats":{"Line":64}},{"line":2384,"address":[],"length":0,"stats":{"Line":64}},{"line":2385,"address":[],"length":0,"stats":{"Line":32}},{"line":2387,"address":[],"length":0,"stats":{"Line":129}},{"line":2390,"address":[],"length":0,"stats":{"Line":47}},{"line":2391,"address":[],"length":0,"stats":{"Line":8}},{"line":2393,"address":[],"length":0,"stats":{"Line":43}},{"line":2394,"address":[],"length":0,"stats":{"Line":0}},{"line":2396,"address":[],"length":0,"stats":{"Line":45}},{"line":2397,"address":[],"length":0,"stats":{"Line":2}},{"line":2398,"address":[],"length":0,"stats":{"Line":1}},{"line":2399,"address":[],"length":0,"stats":{"Line":3}},{"line":2400,"address":[],"length":0,"stats":{"Line":1}},{"line":2404,"address":[],"length":0,"stats":{"Line":86}},{"line":2407,"address":[],"length":0,"stats":{"Line":45}},{"line":2408,"address":[],"length":0,"stats":{"Line":4}},{"line":2410,"address":[],"length":0,"stats":{"Line":45}},{"line":2411,"address":[],"length":0,"stats":{"Line":4}},{"line":2414,"address":[],"length":0,"stats":{"Line":45}},{"line":2415,"address":[],"length":0,"stats":{"Line":4}},{"line":2416,"address":[],"length":0,"stats":{"Line":2}},{"line":2417,"address":[],"length":0,"stats":{"Line":6}},{"line":2419,"address":[],"length":0,"stats":{"Line":4}},{"line":2420,"address":[],"length":0,"stats":{"Line":2}},{"line":2421,"address":[],"length":0,"stats":{"Line":6}},{"line":2423,"address":[],"length":0,"stats":{"Line":4}},{"line":2424,"address":[],"length":0,"stats":{"Line":2}},{"line":2425,"address":[],"length":0,"stats":{"Line":6}},{"line":2426,"address":[],"length":0,"stats":{"Line":2}},{"line":2429,"address":[],"length":0,"stats":{"Line":70}},{"line":2430,"address":[],"length":0,"stats":{"Line":54}},{"line":2431,"address":[],"length":0,"stats":{"Line":27}},{"line":2432,"address":[],"length":0,"stats":{"Line":27}},{"line":2437,"address":[],"length":0,"stats":{"Line":129}},{"line":2439,"address":[],"length":0,"stats":{"Line":86}},{"line":2440,"address":[],"length":0,"stats":{"Line":43}},{"line":2443,"address":[],"length":0,"stats":{"Line":45}},{"line":2444,"address":[],"length":0,"stats":{"Line":8}},{"line":2445,"address":[],"length":0,"stats":{"Line":4}},{"line":2446,"address":[],"length":0,"stats":{"Line":2}},{"line":2447,"address":[],"length":0,"stats":{"Line":6}},{"line":2448,"address":[],"length":0,"stats":{"Line":2}},{"line":2453,"address":[],"length":0,"stats":{"Line":43}},{"line":2454,"address":[],"length":0,"stats":{"Line":0}},{"line":2455,"address":[],"length":0,"stats":{"Line":0}},{"line":2456,"address":[],"length":0,"stats":{"Line":0}},{"line":2457,"address":[],"length":0,"stats":{"Line":0}},{"line":2458,"address":[],"length":0,"stats":{"Line":0}},{"line":2459,"address":[],"length":0,"stats":{"Line":0}},{"line":2464,"address":[],"length":0,"stats":{"Line":43}},{"line":2465,"address":[],"length":0,"stats":{"Line":0}},{"line":2466,"address":[],"length":0,"stats":{"Line":0}},{"line":2467,"address":[],"length":0,"stats":{"Line":0}},{"line":2471,"address":[],"length":0,"stats":{"Line":43}},{"line":2477,"address":[],"length":0,"stats":{"Line":16}},{"line":2480,"address":[],"length":0,"stats":{"Line":192}},{"line":2481,"address":[],"length":0,"stats":{"Line":528}},{"line":2483,"address":[],"length":0,"stats":{"Line":176}},{"line":2486,"address":[],"length":0,"stats":{"Line":176}},{"line":2487,"address":[],"length":0,"stats":{"Line":429}},{"line":2491,"address":[],"length":0,"stats":{"Line":16}},{"line":2494,"address":[],"length":0,"stats":{"Line":29}},{"line":2496,"address":[],"length":0,"stats":{"Line":29}},{"line":2497,"address":[],"length":0,"stats":{"Line":0}},{"line":2498,"address":[],"length":0,"stats":{"Line":0}},{"line":2499,"address":[],"length":0,"stats":{"Line":0}},{"line":2505,"address":[],"length":0,"stats":{"Line":30}},{"line":2506,"address":[],"length":0,"stats":{"Line":2}},{"line":2507,"address":[],"length":0,"stats":{"Line":2}},{"line":2508,"address":[],"length":0,"stats":{"Line":2}},{"line":2509,"address":[],"length":0,"stats":{"Line":1}},{"line":2516,"address":[],"length":0,"stats":{"Line":28}},{"line":2517,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[],"length":0,"stats":{"Line":0}},{"line":2519,"address":[],"length":0,"stats":{"Line":0}},{"line":2521,"address":[],"length":0,"stats":{"Line":0}},{"line":2528,"address":[],"length":0,"stats":{"Line":28}},{"line":2530,"address":[],"length":0,"stats":{"Line":140}},{"line":2533,"address":[],"length":0,"stats":{"Line":0}},{"line":2535,"address":[],"length":0,"stats":{"Line":0}},{"line":2537,"address":[],"length":0,"stats":{"Line":0}},{"line":2540,"address":[],"length":0,"stats":{"Line":0}},{"line":2541,"address":[],"length":0,"stats":{"Line":0}},{"line":2544,"address":[],"length":0,"stats":{"Line":0}},{"line":2547,"address":[],"length":0,"stats":{"Line":0}},{"line":2548,"address":[],"length":0,"stats":{"Line":0}},{"line":2549,"address":[],"length":0,"stats":{"Line":0}},{"line":2550,"address":[],"length":0,"stats":{"Line":0}},{"line":2551,"address":[],"length":0,"stats":{"Line":0}},{"line":2553,"address":[],"length":0,"stats":{"Line":0}},{"line":2554,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":0}},{"line":2557,"address":[],"length":0,"stats":{"Line":0}},{"line":2558,"address":[],"length":0,"stats":{"Line":0}},{"line":2559,"address":[],"length":0,"stats":{"Line":0}},{"line":2561,"address":[],"length":0,"stats":{"Line":0}},{"line":2562,"address":[],"length":0,"stats":{"Line":0}},{"line":2577,"address":[],"length":0,"stats":{"Line":5}},{"line":2578,"address":[],"length":0,"stats":{"Line":15}},{"line":2579,"address":[],"length":0,"stats":{"Line":15}},{"line":2581,"address":[],"length":0,"stats":{"Line":5}},{"line":2582,"address":[],"length":0,"stats":{"Line":1}},{"line":2585,"address":[],"length":0,"stats":{"Line":16}},{"line":2586,"address":[],"length":0,"stats":{"Line":12}},{"line":2588,"address":[],"length":0,"stats":{"Line":4}},{"line":2589,"address":[],"length":0,"stats":{"Line":2}},{"line":2591,"address":[],"length":0,"stats":{"Line":2}},{"line":2592,"address":[],"length":0,"stats":{"Line":2}},{"line":2593,"address":[],"length":0,"stats":{"Line":2}}],"covered":586,"coverable":1029},{"path":["/","Users","alex","Documents","checkouts","chant","src","mcp","handlers.rs"],"content":"//! MCP tool handlers and method implementations.\n\nuse anyhow::{Context, Result};\nuse serde_json::{json, Value};\nuse std::path::PathBuf;\nuse std::process::{Command, Stdio};\n\nuse chant::diagnose;\nuse chant::id;\nuse chant::paths::{ARCHIVE_DIR, LOGS_DIR, SPECS_DIR};\nuse chant::spec::{load_all_specs, resolve_spec, SpecStatus};\nuse chant::spec_group;\n\nuse super::protocol::{PROTOCOL_VERSION, SERVER_NAME, SERVER_VERSION};\n\npub fn handle_method(method: \u0026str, params: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    match method {\n        \"initialize\" =\u003e handle_initialize(params),\n        \"tools/list\" =\u003e handle_tools_list(),\n        \"tools/call\" =\u003e handle_tools_call(params),\n        _ =\u003e anyhow::bail!(\"Method not found: {}\", method),\n    }\n}\n\npub fn handle_notification(method: \u0026str, _params: Option\u003c\u0026Value\u003e) {\n    // Handle notifications that don't require a response\n    match method {\n        \"notifications/initialized\" =\u003e {\n            // Client is ready\n        }\n        _ =\u003e {\n            // Unknown notification, ignore\n        }\n    }\n}\n\nfn handle_initialize(_params: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    Ok(json!({\n        \"protocolVersion\": PROTOCOL_VERSION,\n        \"capabilities\": {\n            \"tools\": {}\n        },\n        \"serverInfo\": {\n            \"name\": SERVER_NAME,\n            \"version\": SERVER_VERSION\n        }\n    }))\n}\n\nfn handle_tools_list() -\u003e Result\u003cValue\u003e {\n    Ok(json!({\n        \"tools\": [\n            // Query tools (read-only)\n            {\n                \"name\": \"chant_spec_list\",\n                \"description\": \"List all chant specs in the current project\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"status\": {\n                            \"type\": \"string\",\n                            \"description\": \"Filter by status (pending, in_progress, completed, failed, ready, blocked)\"\n                        },\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of specs to return (default: 50)\"\n                        }\n                    }\n                }\n            },\n            {\n                \"name\": \"chant_spec_get\",\n                \"description\": \"Get details of a chant spec including full body content\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_ready\",\n                \"description\": \"List all specs that are ready to be worked (no unmet dependencies)\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"limit\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Maximum number of specs to return (default: 50)\"\n                        }\n                    }\n                }\n            },\n            {\n                \"name\": \"chant_status\",\n                \"description\": \"Get project status summary with spec counts by status\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"brief\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Return brief single-line output (e.g., '3 pending | 2 in_progress | 15 completed')\"\n                        },\n                        \"include_activity\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include activity info for in_progress specs (last modified time, log activity)\"\n                        }\n                    }\n                }\n            },\n            {\n                \"name\": \"chant_log\",\n                \"description\": \"Read execution log for a spec\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        },\n                        \"lines\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Number of lines to return (default: 100)\"\n                        },\n                        \"offset\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Start from byte offset (for incremental reads)\"\n                        },\n                        \"since\": {\n                            \"type\": \"string\",\n                            \"description\": \"ISO timestamp - only lines after this time\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_search\",\n                \"description\": \"Search specs by title and body content\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\n                            \"type\": \"string\",\n                            \"description\": \"Search query (case-insensitive substring match)\"\n                        },\n                        \"status\": {\n                            \"type\": \"string\",\n                            \"description\": \"Filter by status\"\n                        }\n                    },\n                    \"required\": [\"query\"]\n                }\n            },\n            {\n                \"name\": \"chant_diagnose\",\n                \"description\": \"Diagnose issues with a spec (check file, log, locks, commits, criteria)\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            // Mutating tools\n            {\n                \"name\": \"chant_spec_update\",\n                \"description\": \"Update a chant spec status or add output\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        },\n                        \"status\": {\n                            \"type\": \"string\",\n                            \"description\": \"New status (pending, in_progress, completed, failed)\"\n                        },\n                        \"output\": {\n                            \"type\": \"string\",\n                            \"description\": \"Output text to append to spec body\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_add\",\n                \"description\": \"Create a new spec with description\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"description\": {\n                            \"type\": \"string\",\n                            \"description\": \"Description of work to be done (becomes spec title)\"\n                        },\n                        \"prompt\": {\n                            \"type\": \"string\",\n                            \"description\": \"Optional prompt template name to use\"\n                        }\n                    },\n                    \"required\": [\"description\"]\n                }\n            },\n            {\n                \"name\": \"chant_finalize\",\n                \"description\": \"Mark a spec as completed (validates all criteria are checked)\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_resume\",\n                \"description\": \"Reset a failed spec to pending status so it can be reworked\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_cancel\",\n                \"description\": \"Cancel a spec (sets status to cancelled)\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_archive\",\n                \"description\": \"Move a completed spec to the archive directory\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_verify\",\n                \"description\": \"Verify a spec meets its acceptance criteria\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_work_start\",\n                \"description\": \"Start working on a spec asynchronously (returns immediately)\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        },\n                        \"chain\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Continue to next ready spec after completion\"\n                        },\n                        \"parallel\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Number of parallel workers (requires multiple ready specs)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_work_list\",\n                \"description\": \"List running work processes\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"process_id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Filter to specific process\"\n                        },\n                        \"include_completed\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Include recently completed processes\"\n                        }\n                    }\n                }\n            },\n            {\n                \"name\": \"chant_pause\",\n                \"description\": \"Pause a running work process for a spec\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            },\n            {\n                \"name\": \"chant_takeover\",\n                \"description\": \"Take over a running spec, stopping the agent and analyzing progress\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"string\",\n                            \"description\": \"Spec ID (full or partial)\"\n                        },\n                        \"force\": {\n                            \"type\": \"boolean\",\n                            \"description\": \"Force takeover even if spec is not running\"\n                        }\n                    },\n                    \"required\": [\"id\"]\n                }\n            }\n        ]\n    }))\n}\n\nfn handle_tools_call(params: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let params = params.ok_or_else(|| anyhow::anyhow!(\"Missing params\"))?;\n\n    let name = params\n        .get(\"name\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing tool name\"))?;\n\n    let arguments = params.get(\"arguments\");\n\n    match name {\n        // Query tools (read-only)\n        \"chant_spec_list\" =\u003e tool_chant_spec_list(arguments),\n        \"chant_spec_get\" =\u003e tool_chant_spec_get(arguments),\n        \"chant_ready\" =\u003e tool_chant_ready(arguments),\n        \"chant_status\" =\u003e tool_chant_status(arguments),\n        \"chant_log\" =\u003e tool_chant_log(arguments),\n        \"chant_search\" =\u003e tool_chant_search(arguments),\n        \"chant_diagnose\" =\u003e tool_chant_diagnose(arguments),\n        // Mutating tools\n        \"chant_spec_update\" =\u003e tool_chant_spec_update(arguments),\n        \"chant_add\" =\u003e tool_chant_add(arguments),\n        \"chant_finalize\" =\u003e tool_chant_finalize(arguments),\n        \"chant_resume\" =\u003e tool_chant_resume(arguments),\n        \"chant_cancel\" =\u003e tool_chant_cancel(arguments),\n        \"chant_archive\" =\u003e tool_chant_archive(arguments),\n        \"chant_verify\" =\u003e tool_chant_verify(arguments),\n        \"chant_work_start\" =\u003e tool_chant_work_start(arguments),\n        \"chant_work_list\" =\u003e tool_chant_work_list(arguments),\n        \"chant_pause\" =\u003e tool_chant_pause(arguments),\n        \"chant_takeover\" =\u003e tool_chant_takeover(arguments),\n        _ =\u003e anyhow::bail!(\"Unknown tool: {}\", name),\n    }\n}\n\n/// Find the project root by walking up from cwd looking for `.chant/` directory.\n///\n/// # Returns\n///\n/// - `Some(path)`: The directory containing `.chant/`\n/// - `None`: No `.chant/` directory found in any parent\nfn find_project_root() -\u003e Option\u003cPathBuf\u003e {\n    let mut current = std::env::current_dir().ok()?;\n    loop {\n        if current.join(\".chant\").is_dir() {\n            return Some(current);\n        }\n        if !current.pop() {\n            return None;\n        }\n    }\n}\n\n/// Check if chant is initialized and return specs_dir, or an MCP error response.\n///\n/// # Validation\n///\n/// Checks that the `.chant/specs` directory exists, indicating that `chant init` has been run.\n///\n/// # Returns\n///\n/// - `Ok(specs_dir)`: If the specs directory exists\n/// - `Err(response)`: MCP response object with `isError: true` if not initialized\n///\n/// # Tool-Level Error Format\n///\n/// When returning an error, the response format differs from JSON-RPC protocol errors:\n/// - Not a JSON-RPC error (no `error` field)\n/// - Instead uses `isError: true` flag in the result\n/// - Error message in `content[].text`\n/// - This allows tools to return meaningful errors while maintaining valid JSON-RPC responses\nfn mcp_ensure_initialized() -\u003e Result\u003cPathBuf, Value\u003e {\n    let project_root = find_project_root().ok_or_else(|| {\n        json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": \"Not in a chant project directory. Run `chant init` first or navigate to a directory containing `.chant/`.\"\n                }\n            ],\n            \"isError\": true\n        })\n    })?;\n\n    let specs_dir = project_root.join(SPECS_DIR);\n    if !specs_dir.exists() {\n        return Err(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": \"Chant not initialized. Run `chant init` first.\"\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n    Ok(specs_dir)\n}\n\nfn tool_chant_spec_list(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let mut specs = load_all_specs(\u0026specs_dir)?;\n    specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    // Filter by status if provided\n    if let Some(args) = arguments {\n        if let Some(status_str) = args.get(\"status\").and_then(|v| v.as_str()) {\n            let filter_status = match status_str {\n                \"pending\" =\u003e Some(SpecStatus::Pending),\n                \"in_progress\" =\u003e Some(SpecStatus::InProgress),\n                \"completed\" =\u003e Some(SpecStatus::Completed),\n                \"failed\" =\u003e Some(SpecStatus::Failed),\n                _ =\u003e None,\n            };\n\n            if let Some(status) = filter_status {\n                specs.retain(|s| s.frontmatter.status == status);\n            }\n        }\n    }\n\n    // Get limit (default 50)\n    let limit = arguments\n        .and_then(|a| a.get(\"limit\"))\n        .and_then(|v| v.as_u64())\n        .unwrap_or(50) as usize;\n\n    let total = specs.len();\n    let limited_specs: Vec\u003c_\u003e = specs.into_iter().take(limit).collect();\n\n    let specs_json: Vec\u003cValue\u003e = limited_specs\n        .iter()\n        .map(|s| {\n            json!({\n                \"id\": s.id,\n                \"title\": s.title,\n                \"status\": format!(\"{:?}\", s.frontmatter.status).to_lowercase(),\n                \"type\": s.frontmatter.r#type,\n                \"depends_on\": s.frontmatter.depends_on,\n                \"labels\": s.frontmatter.labels\n            })\n        })\n        .collect();\n\n    let response = json!({\n        \"specs\": specs_json,\n        \"total\": total,\n        \"limit\": limit,\n        \"returned\": limited_specs.len()\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026response)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_spec_get(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let id = arguments\n        .and_then(|a| a.get(\"id\"))\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_json = json!({\n        \"id\": spec.id,\n        \"title\": spec.title,\n        \"status\": format!(\"{:?}\", spec.frontmatter.status).to_lowercase(),\n        \"type\": spec.frontmatter.r#type,\n        \"depends_on\": spec.frontmatter.depends_on,\n        \"labels\": spec.frontmatter.labels,\n        \"target_files\": spec.frontmatter.target_files,\n        \"context\": spec.frontmatter.context,\n        \"prompt\": spec.frontmatter.prompt,\n        \"branch\": spec.frontmatter.branch,\n        \"commits\": spec.frontmatter.commits,\n        \"completed_at\": spec.frontmatter.completed_at,\n        \"model\": spec.frontmatter.model,\n        \"body\": spec.body\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026spec_json)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_ready(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let mut specs = load_all_specs(\u0026specs_dir)?;\n    specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    // Filter to ready specs only\n    let all_specs = specs.clone();\n    specs.retain(|s| s.is_ready(\u0026all_specs));\n    // Filter out group specs - they are containers, not actionable work\n    specs.retain(|s| s.frontmatter.r#type != \"group\");\n\n    // Get limit (default 50)\n    let limit = arguments\n        .and_then(|a| a.get(\"limit\"))\n        .and_then(|v| v.as_u64())\n        .unwrap_or(50) as usize;\n\n    let total = specs.len();\n    let limited_specs: Vec\u003c_\u003e = specs.into_iter().take(limit).collect();\n\n    let specs_json: Vec\u003cValue\u003e = limited_specs\n        .iter()\n        .map(|s| {\n            json!({\n                \"id\": s.id,\n                \"title\": s.title,\n                \"status\": format!(\"{:?}\", s.frontmatter.status).to_lowercase(),\n                \"type\": s.frontmatter.r#type,\n                \"depends_on\": s.frontmatter.depends_on,\n                \"labels\": s.frontmatter.labels\n            })\n        })\n        .collect();\n\n    let response = json!({\n        \"specs\": specs_json,\n        \"total\": total,\n        \"limit\": limit,\n        \"returned\": limited_specs.len()\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026response)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_spec_update(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let mut spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let mut updated = false;\n\n    // Update status if provided\n    if let Some(status_str) = args.get(\"status\").and_then(|v| v.as_str()) {\n        let new_status = match status_str {\n            \"pending\" =\u003e SpecStatus::Pending,\n            \"in_progress\" =\u003e SpecStatus::InProgress,\n            \"completed\" =\u003e SpecStatus::Completed,\n            \"failed\" =\u003e SpecStatus::Failed,\n            _ =\u003e {\n                return Ok(json!({\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": format!(\"Invalid status: {}. Must be one of: pending, in_progress, completed, failed\", status_str)\n                        }\n                    ],\n                    \"isError\": true\n                }));\n            }\n        };\n        spec.frontmatter.status = new_status;\n        updated = true;\n    }\n\n    // Append output if provided\n    if let Some(output) = args.get(\"output\").and_then(|v| v.as_str()) {\n        if !output.is_empty() {\n            if !spec.body.ends_with('\\n') \u0026\u0026 !spec.body.is_empty() {\n                spec.body.push('\\n');\n            }\n            spec.body.push_str(\"\\n## Output\\n\\n\");\n            spec.body.push_str(output);\n            spec.body.push('\\n');\n            updated = true;\n        }\n    }\n\n    if !updated {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": \"No updates specified. Provide 'status' or 'output' parameter.\"\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    // Save the spec\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n    spec.save(\u0026spec_path)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": format!(\"Updated spec: {}\", spec.id)\n            }\n        ]\n    }))\n}\n\nfn tool_chant_status(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let specs = load_all_specs(\u0026specs_dir)?;\n\n    // Parse options\n    let brief = arguments\n        .and_then(|a| a.get(\"brief\"))\n        .and_then(|v| v.as_bool())\n        .unwrap_or(false);\n    let include_activity = arguments\n        .and_then(|a| a.get(\"include_activity\"))\n        .and_then(|v| v.as_bool())\n        .unwrap_or(false);\n\n    // Count by status\n    let mut pending = 0;\n    let mut in_progress = 0;\n    let mut completed = 0;\n    let mut failed = 0;\n    let mut blocked = 0;\n    let mut cancelled = 0;\n    let mut needs_attention = 0;\n\n    for spec in \u0026specs {\n        match spec.frontmatter.status {\n            SpecStatus::Pending =\u003e pending += 1,\n            SpecStatus::InProgress =\u003e in_progress += 1,\n            SpecStatus::Paused =\u003e in_progress += 1, // Count paused as in_progress for summary\n            SpecStatus::Completed =\u003e completed += 1,\n            SpecStatus::Failed =\u003e failed += 1,\n            SpecStatus::Ready =\u003e pending += 1, // Ready is computed, treat as pending\n            SpecStatus::Blocked =\u003e blocked += 1,\n            SpecStatus::Cancelled =\u003e cancelled += 1,\n            SpecStatus::NeedsAttention =\u003e needs_attention += 1,\n        }\n    }\n\n    // Brief output mode\n    if brief {\n        let mut parts = vec![];\n        if pending \u003e 0 {\n            parts.push(format!(\"{} pending\", pending));\n        }\n        if in_progress \u003e 0 {\n            parts.push(format!(\"{} in_progress\", in_progress));\n        }\n        if completed \u003e 0 {\n            parts.push(format!(\"{} completed\", completed));\n        }\n        if failed \u003e 0 {\n            parts.push(format!(\"{} failed\", failed));\n        }\n        if blocked \u003e 0 {\n            parts.push(format!(\"{} blocked\", blocked));\n        }\n        if cancelled \u003e 0 {\n            parts.push(format!(\"{} cancelled\", cancelled));\n        }\n        if needs_attention \u003e 0 {\n            parts.push(format!(\"{} needs_attention\", needs_attention));\n        }\n        let brief_text = if parts.is_empty() {\n            \"No specs\".to_string()\n        } else {\n            parts.join(\" | \")\n        };\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": brief_text\n                }\n            ]\n        }));\n    }\n\n    // Build status response\n    let mut status_json = json!({\n        \"total\": specs.len(),\n        \"pending\": pending,\n        \"in_progress\": in_progress,\n        \"completed\": completed,\n        \"failed\": failed,\n        \"blocked\": blocked,\n        \"cancelled\": cancelled,\n        \"needs_attention\": needs_attention\n    });\n\n    // Include activity info for in_progress specs\n    if include_activity {\n        let logs_dir = PathBuf::from(LOGS_DIR);\n        let mut activity: Vec\u003cValue\u003e = vec![];\n\n        for spec in \u0026specs {\n            if spec.frontmatter.status != SpecStatus::InProgress {\n                continue;\n            }\n\n            let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n            let log_path = logs_dir.join(format!(\"{}.log\", spec.id));\n\n            // Get spec file modification time\n            let spec_mtime = std::fs::metadata(\u0026spec_path)\n                .and_then(|m| m.modified())\n                .ok()\n                .map(|t| {\n                    chrono::DateTime::\u003cchrono::Local\u003e::from(t)\n                        .format(\"%Y-%m-%d %H:%M:%S\")\n                        .to_string()\n                });\n\n            // Get log file modification time (indicates last agent activity)\n            let log_mtime = std::fs::metadata(\u0026log_path)\n                .and_then(|m| m.modified())\n                .ok()\n                .map(|t| {\n                    chrono::DateTime::\u003cchrono::Local\u003e::from(t)\n                        .format(\"%Y-%m-%d %H:%M:%S\")\n                        .to_string()\n                });\n\n            // Check if log file exists\n            let has_log = log_path.exists();\n\n            activity.push(json!({\n                \"id\": spec.id,\n                \"title\": spec.title,\n                \"spec_modified\": spec_mtime,\n                \"log_modified\": log_mtime,\n                \"has_log\": has_log\n            }));\n        }\n\n        status_json[\"in_progress_activity\"] = json!(activity);\n    }\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026status_json)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_log(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let lines = args\n        .get(\"lines\")\n        .and_then(|v| v.as_u64())\n        .map(|v| v as usize);\n    let byte_offset = args.get(\"offset\").and_then(|v| v.as_u64());\n    let since = args.get(\"since\").and_then(|v| v.as_str());\n\n    // Resolve spec to get full ID\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let logs_dir = PathBuf::from(LOGS_DIR);\n    let log_path = logs_dir.join(format!(\"{}.log\", spec.id));\n\n    if !log_path.exists() {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"No log file found for spec '{}'. Logs are created when a spec is executed with `chant work`.\", spec.id)\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    // Read log file\n    let content = std::fs::read_to_string(\u0026log_path)?;\n    let file_byte_len = content.len() as u64;\n\n    // Filter by offset if provided\n    let content_after_offset = if let Some(offset) = byte_offset {\n        if offset \u003e= file_byte_len {\n            // Offset is at or beyond end of file\n            String::new()\n        } else {\n            content[(offset as usize)..].to_string()\n        }\n    } else {\n        content.clone()\n    };\n\n    // Filter by timestamp if provided\n    let content_after_since = if let Some(since_ts) = since {\n        if let Ok(since_time) = chrono::DateTime::parse_from_rfc3339(since_ts) {\n            content_after_offset\n                .lines()\n                .filter(|line| {\n                    // Try to parse timestamp from line start\n                    // Assumes log format: YYYY-MM-DDTHH:MM:SS.sssZ ...\n                    if line.len() \u003e= 24 {\n                        if let Ok(line_time) = chrono::DateTime::parse_from_rfc3339(\u0026line[..24]) {\n                            return line_time \u003e since_time;\n                        }\n                    }\n                    true // Include lines without parseable timestamps\n                })\n                .collect::\u003cVec\u003c\u0026str\u003e\u003e()\n                .join(\"\\n\")\n        } else {\n            content_after_offset\n        }\n    } else {\n        content_after_offset\n    };\n\n    // Apply lines limit\n    let all_lines: Vec\u003c\u0026str\u003e = content_after_since.lines().collect();\n    let lines_limit = lines.unwrap_or(100);\n    let start = if all_lines.len() \u003e lines_limit {\n        all_lines.len() - lines_limit\n    } else {\n        0\n    };\n    let log_output = all_lines[start..].join(\"\\n\");\n\n    // Calculate new byte offset\n    let new_byte_offset = if byte_offset.is_some() {\n        file_byte_len\n    } else {\n        content.len() as u64\n    };\n\n    let has_more = all_lines.len() \u003e lines_limit;\n    let line_count = all_lines[start..].len();\n\n    let response = json!({\n        \"content\": log_output,\n        \"byte_offset\": new_byte_offset,\n        \"line_count\": line_count,\n        \"has_more\": has_more\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026response)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_search(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let query = args\n        .get(\"query\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: query\"))?\n        .to_lowercase();\n\n    let status_filter = args.get(\"status\").and_then(|v| v.as_str());\n\n    let mut specs = load_all_specs(\u0026specs_dir)?;\n\n    // Filter by query (case-insensitive search in title and body)\n    specs.retain(|s| {\n        let title_match = s\n            .title\n            .as_ref()\n            .map(|t| t.to_lowercase().contains(\u0026query))\n            .unwrap_or(false);\n        title_match || s.body.to_lowercase().contains(\u0026query)\n    });\n\n    // Filter by status if provided\n    if let Some(status_str) = status_filter {\n        let filter_status = match status_str {\n            \"pending\" =\u003e Some(SpecStatus::Pending),\n            \"in_progress\" =\u003e Some(SpecStatus::InProgress),\n            \"completed\" =\u003e Some(SpecStatus::Completed),\n            \"failed\" =\u003e Some(SpecStatus::Failed),\n            \"blocked\" =\u003e Some(SpecStatus::Blocked),\n            \"cancelled\" =\u003e Some(SpecStatus::Cancelled),\n            _ =\u003e None,\n        };\n\n        if let Some(status) = filter_status {\n            specs.retain(|s| s.frontmatter.status == status);\n        }\n    }\n\n    specs.sort_by(|a, b| spec_group::compare_spec_ids(\u0026a.id, \u0026b.id));\n\n    let specs_json: Vec\u003cValue\u003e = specs\n        .iter()\n        .map(|s| {\n            json!({\n                \"id\": s.id,\n                \"title\": s.title,\n                \"status\": format!(\"{:?}\", s.frontmatter.status).to_lowercase(),\n                \"type\": s.frontmatter.r#type\n            })\n        })\n        .collect();\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026specs_json)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_diagnose(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    // Resolve spec to get full ID\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    // Run diagnostics\n    let report = match diagnose::diagnose_spec(\u0026spec.id) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": format!(\"Failed to diagnose spec: {}\", e)\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    // Format report as JSON\n    let checks_json: Vec\u003cValue\u003e = report\n        .checks\n        .iter()\n        .map(|c| {\n            json!({\n                \"name\": c.name,\n                \"passed\": c.passed,\n                \"details\": c.details\n            })\n        })\n        .collect();\n\n    let report_json = json!({\n        \"spec_id\": report.spec_id,\n        \"status\": format!(\"{:?}\", report.status).to_lowercase(),\n        \"location\": report.location,\n        \"checks\": checks_json,\n        \"diagnosis\": report.diagnosis,\n        \"suggestion\": report.suggestion\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026report_json)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_add(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let description = args\n        .get(\"description\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: description\"))?;\n\n    let prompt = args.get(\"prompt\").and_then(|v| v.as_str());\n\n    // Generate ID\n    let new_id = id::generate_id(\u0026specs_dir)?;\n    let filename = format!(\"{}.md\", new_id);\n    let filepath = specs_dir.join(\u0026filename);\n\n    // Create spec content\n    let prompt_line = match prompt {\n        Some(p) =\u003e format!(\"prompt: {}\\n\", p),\n        None =\u003e String::new(),\n    };\n\n    let content = format!(\n        r#\"---\ntype: code\nstatus: pending\n{}---\n\n# {}\n\"#,\n        prompt_line, description\n    );\n\n    std::fs::write(\u0026filepath, content)?;\n\n    // Lint the newly created spec\n    let lint_diagnostics = match chant::spec::Spec::load(\u0026filepath) {\n        Ok(spec) =\u003e {\n            use crate::cmd::spec::lint::{\n                validate_approval_schema, validate_model_waste, validate_output_schema,\n                validate_spec_complexity, validate_spec_coupling, validate_spec_type,\n            };\n\n            let mut diagnostics = Vec::new();\n\n            // Load config for thresholds\n            let config = chant::config::Config::load().ok();\n            let default_thresholds = chant::config::LintThresholds::default();\n            let thresholds = config\n                .as_ref()\n                .map(|c| \u0026c.lint.thresholds)\n                .unwrap_or(\u0026default_thresholds);\n\n            // Run validation checks\n            diagnostics.extend(validate_spec_type(\u0026spec));\n            diagnostics.extend(validate_spec_complexity(\u0026spec, thresholds));\n            diagnostics.extend(validate_spec_coupling(\u0026spec));\n            diagnostics.extend(validate_model_waste(\u0026spec, thresholds));\n            diagnostics.extend(validate_approval_schema(\u0026spec));\n            diagnostics.extend(validate_output_schema(\u0026spec));\n\n            diagnostics\n        }\n        Err(_) =\u003e Vec::new(),\n    };\n\n    // Build response with diagnostics if any\n    let mut response_text = format!(\"Created spec: {}\", new_id);\n\n    if !lint_diagnostics.is_empty() {\n        response_text.push_str(\"\\n\\nLint diagnostics:\");\n        for diagnostic in \u0026lint_diagnostics {\n            use crate::cmd::spec::lint::Severity;\n            let severity_str = match diagnostic.severity {\n                Severity::Error =\u003e \"ERROR\",\n                Severity::Warning =\u003e \"WARNING\",\n            };\n            response_text.push_str(\u0026format!(\n                \"\\n  [{}] {}: {}\",\n                severity_str,\n                diagnostic.rule.as_str(),\n                diagnostic.message\n            ));\n            if let Some(ref suggestion) = diagnostic.suggestion {\n                response_text.push_str(\u0026format!(\"\\n    â {}\", suggestion));\n            }\n        }\n    }\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": response_text\n            }\n        ]\n    }))\n}\n\nfn tool_chant_finalize(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let mut spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Check if spec is in valid state for finalization\n    match spec.frontmatter.status {\n        SpecStatus::Completed | SpecStatus::InProgress | SpecStatus::Failed =\u003e {\n            // Valid for finalization\n        }\n        _ =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": format!(\"Spec '{}' must be in_progress, completed, or failed to finalize. Current status: {:?}\", spec_id, spec.frontmatter.status)\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    }\n\n    // Check for unchecked acceptance criteria\n    let unchecked = spec.count_unchecked_checkboxes();\n    if unchecked \u003e 0 {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Spec '{}' has {} unchecked acceptance criteria. All criteria must be checked before finalization.\", spec_id, unchecked)\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    // Update status to completed\n    spec.frontmatter.status = SpecStatus::Completed;\n    spec.frontmatter.completed_at = Some(chrono::Local::now().to_rfc3339());\n\n    // Save the spec\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n    spec.save(\u0026spec_path)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": format!(\"Finalized spec: {}\", spec_id)\n            }\n        ]\n    }))\n}\n\nfn tool_chant_resume(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let mut spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Check if spec is in failed or in_progress state\n    if spec.frontmatter.status != SpecStatus::Failed\n        \u0026\u0026 spec.frontmatter.status != SpecStatus::InProgress\n    {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Spec '{}' is not in failed or in_progress state (current: {:?}). Only failed or in_progress specs can be resumed.\", spec_id, spec.frontmatter.status)\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    // Reset to pending\n    spec.frontmatter.status = SpecStatus::Pending;\n\n    // Save the spec\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n    spec.save(\u0026spec_path)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": format!(\"Resumed spec '{}' - reset to pending\", spec_id)\n            }\n        ]\n    }))\n}\n\nfn tool_chant_cancel(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let mut spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Check if already cancelled\n    if spec.frontmatter.status == SpecStatus::Cancelled {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Spec '{}' is already cancelled\", spec_id)\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    // Set status to cancelled\n    spec.frontmatter.status = SpecStatus::Cancelled;\n\n    // Save the spec\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n    spec.save(\u0026spec_path)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": format!(\"Cancelled spec: {}\", spec_id)\n            }\n        ]\n    }))\n}\n\nfn tool_chant_archive(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Check if completed\n    if spec.frontmatter.status != SpecStatus::Completed {\n        return Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Spec '{}' must be completed to archive (current: {:?})\", spec_id, spec.frontmatter.status)\n                }\n            ],\n            \"isError\": true\n        }));\n    }\n\n    let archive_dir = PathBuf::from(ARCHIVE_DIR);\n\n    // Create archive directory if it doesn't exist\n    std::fs::create_dir_all(\u0026archive_dir)?;\n\n    let source_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    let dest_path = archive_dir.join(format!(\"{}.md\", spec_id));\n\n    // Move the spec file\n    std::fs::rename(\u0026source_path, \u0026dest_path)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": format!(\"Archived spec: {} -\u003e {}\", spec_id, dest_path.display())\n            }\n        ]\n    }))\n}\n\nfn tool_chant_verify(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Count checked and unchecked criteria\n    let unchecked_count = spec.count_unchecked_checkboxes();\n\n    // Find total checkboxes in Acceptance Criteria section\n    let total_count: usize = {\n        let acceptance_criteria_marker = \"## Acceptance Criteria\";\n        let mut in_ac_section = false;\n        let mut in_code_fence = false;\n        let mut count = 0;\n\n        for line in spec.body.lines() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n                in_ac_section = true;\n                continue;\n            }\n\n            if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") \u0026\u0026 !in_code_fence {\n                break;\n            }\n\n            if in_ac_section\n                \u0026\u0026 !in_code_fence\n                \u0026\u0026 (trimmed.starts_with(\"- [x]\") || trimmed.starts_with(\"- [ ]\"))\n            {\n                count += 1;\n            }\n        }\n\n        count\n    };\n\n    let checked_count = total_count.saturating_sub(unchecked_count);\n    let verified = unchecked_count == 0 \u0026\u0026 total_count \u003e 0;\n\n    // Extract unchecked items\n    let unchecked_items = if unchecked_count \u003e 0 {\n        let acceptance_criteria_marker = \"## Acceptance Criteria\";\n        let mut in_ac_section = false;\n        let mut in_code_fence = false;\n        let mut items = Vec::new();\n\n        for line in spec.body.lines() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n                in_ac_section = true;\n                continue;\n            }\n\n            if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") \u0026\u0026 !in_code_fence {\n                break;\n            }\n\n            if in_ac_section \u0026\u0026 !in_code_fence \u0026\u0026 trimmed.starts_with(\"- [ ]\") {\n                items.push(trimmed.to_string());\n            }\n        }\n\n        items\n    } else {\n        Vec::new()\n    };\n\n    let verification_notes = if total_count == 0 {\n        \"No acceptance criteria found\".to_string()\n    } else if verified {\n        \"All acceptance criteria met\".to_string()\n    } else {\n        format!(\"{} criteria not yet checked\", unchecked_count)\n    };\n\n    let result = json!({\n        \"spec_id\": spec_id,\n        \"verified\": verified,\n        \"criteria\": {\n            \"total\": total_count,\n            \"checked\": checked_count,\n            \"unchecked\": unchecked_count\n        },\n        \"unchecked_items\": unchecked_items,\n        \"verification_notes\": verification_notes\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026result)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_work_start(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let chain = args.get(\"chain\").and_then(|v| v.as_bool()).unwrap_or(false);\n    let parallel = args.get(\"parallel\").and_then(|v| v.as_u64());\n\n    // Resolve spec to get full ID\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    let spec_id = spec.id.clone();\n\n    // Update status to in_progress before spawning agent (matches CLI behavior)\n    let mut spec = spec;\n    spec.frontmatter.status = SpecStatus::InProgress;\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n    spec.save(\u0026spec_path)?;\n\n    // Build command based on mode\n    let mut cmd = Command::new(\"chant\");\n    cmd.arg(\"work\").arg(\u0026spec_id);\n\n    let mode = if let Some(p) = parallel {\n        cmd.arg(\"--parallel\").arg(p.to_string());\n        format!(\"parallel({})\", p)\n    } else if chain {\n        cmd.arg(\"--chain\");\n        \"chain\".to_string()\n    } else {\n        \"single\".to_string()\n    };\n\n    // Spawn as background process\n    cmd.stdin(Stdio::null())\n        .stdout(Stdio::null())\n        .stderr(Stdio::null());\n\n    let child = cmd.spawn().context(\"Failed to spawn chant work process\")?;\n\n    let pid = child.id();\n    let started_at = chrono::Local::now().to_rfc3339();\n    let process_id = format!(\"{}-{}\", spec_id, pid);\n\n    // Store process info\n    let project_root =\n        find_project_root().ok_or_else(|| anyhow::anyhow!(\"Project root not found\"))?;\n    let processes_dir = project_root.join(\".chant/processes\");\n    std::fs::create_dir_all(\u0026processes_dir)?;\n\n    let process_info = json!({\n        \"process_id\": process_id,\n        \"spec_id\": spec_id,\n        \"pid\": pid,\n        \"started_at\": started_at,\n        \"mode\": mode\n    });\n\n    let process_file = processes_dir.join(format!(\"{}.json\", process_id));\n    std::fs::write(\u0026process_file, serde_json::to_string_pretty(\u0026process_info)?)?;\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026process_info)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_work_list(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let project_root =\n        find_project_root().ok_or_else(|| anyhow::anyhow!(\"Project root not found\"))?;\n\n    let processes_dir = project_root.join(\".chant/processes\");\n\n    // Create directory if it doesn't exist\n    if !processes_dir.exists() {\n        std::fs::create_dir_all(\u0026processes_dir)?;\n    }\n\n    // Parse optional filters\n    let filter_process_id = arguments\n        .and_then(|a| a.get(\"process_id\"))\n        .and_then(|v| v.as_str());\n    let include_completed = arguments\n        .and_then(|a| a.get(\"include_completed\"))\n        .and_then(|v| v.as_bool())\n        .unwrap_or(false);\n\n    // Read all process files\n    let entries = std::fs::read_dir(\u0026processes_dir)?;\n    let mut processes: Vec\u003cValue\u003e = Vec::new();\n    let mut running = 0;\n    let mut completed_count = 0;\n    let mut failed_count = 0;\n\n    for entry in entries {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().and_then(|s| s.to_str()) != Some(\"json\") {\n            continue;\n        }\n\n        // Read process info\n        let content = std::fs::read_to_string(\u0026path)?;\n        let mut process_info: Value = serde_json::from_str(\u0026content)?;\n\n        let process_id = process_info[\"process_id\"]\n            .as_str()\n            .unwrap_or(\"\")\n            .to_string();\n        let spec_id = process_info[\"spec_id\"].as_str().unwrap_or(\"\").to_string();\n        let pid = process_info[\"pid\"].as_u64().unwrap_or(0) as u32;\n        let started_at = process_info[\"started_at\"]\n            .as_str()\n            .unwrap_or(\"\")\n            .to_string();\n        let mode = process_info[\"mode\"]\n            .as_str()\n            .unwrap_or(\"single\")\n            .to_string();\n\n        // Apply process_id filter\n        if let Some(filter_id) = filter_process_id {\n            if !process_id.contains(filter_id) {\n                continue;\n            }\n        }\n\n        // Check if process is still running\n        let is_running = if cfg!(unix) {\n            // Use kill -0 to check if process exists\n            Command::new(\"kill\")\n                .args([\"-0\", \u0026pid.to_string()])\n                .output()\n                .map(|output| output.status.success())\n                .unwrap_or(false)\n        } else {\n            // On non-Unix, we can't reliably check, so assume running\n            true\n        };\n\n        let status = if is_running {\n            running += 1;\n            \"running\"\n        } else {\n            // Check if spec is completed or failed\n            let specs_dir = match mcp_ensure_initialized() {\n                Ok(dir) =\u003e dir,\n                Err(_) =\u003e {\n                    completed_count += 1;\n                    process_info[\"status\"] = json!(\"completed\");\n                    process_info[\"completed_at\"] = json!(chrono::Local::now().to_rfc3339());\n                    processes.push(process_info);\n                    continue;\n                }\n            };\n\n            if let Ok(spec) = resolve_spec(\u0026specs_dir, \u0026spec_id) {\n                match spec.frontmatter.status {\n                    SpecStatus::Completed =\u003e {\n                        completed_count += 1;\n                        \"completed\"\n                    }\n                    SpecStatus::Failed =\u003e {\n                        failed_count += 1;\n                        \"failed\"\n                    }\n                    _ =\u003e {\n                        completed_count += 1;\n                        \"completed\"\n                    }\n                }\n            } else {\n                completed_count += 1;\n                \"completed\"\n            }\n        };\n\n        // Skip completed processes if not requested\n        if !include_completed \u0026\u0026 status != \"running\" {\n            continue;\n        }\n\n        // Add status and completed_at to process_info\n        process_info[\"status\"] = json!(status);\n        if status != \"running\" {\n            process_info[\"completed_at\"] = json!(chrono::Local::now().to_rfc3339());\n        }\n\n        processes.push(json!({\n            \"process_id\": process_id,\n            \"spec_id\": spec_id,\n            \"pid\": pid,\n            \"status\": status,\n            \"started_at\": started_at,\n            \"completed_at\": process_info.get(\"completed_at\"),\n            \"mode\": mode\n        }));\n    }\n\n    let summary = json!({\n        \"running\": running,\n        \"completed\": completed_count,\n        \"failed\": failed_count\n    });\n\n    let response = json!({\n        \"processes\": processes,\n        \"summary\": summary\n    });\n\n    Ok(json!({\n        \"content\": [\n            {\n                \"type\": \"text\",\n                \"text\": serde_json::to_string_pretty(\u0026response)?\n            }\n        ]\n    }))\n}\n\nfn tool_chant_pause(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    // Resolve spec to get full ID\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    // Pause the work (stops process and updates status)\n    match crate::cmd::pause::cmd_pause(\u0026spec.id, true) {\n        Ok(()) =\u003e Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Successfully paused work for spec '{}'\", spec.id)\n                }\n            ]\n        })),\n        Err(e) =\u003e Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Failed to pause work for spec '{}': {}\", spec.id, e)\n                }\n            ],\n            \"isError\": true\n        })),\n    }\n}\n\nfn tool_chant_takeover(arguments: Option\u003c\u0026Value\u003e) -\u003e Result\u003cValue\u003e {\n    let specs_dir = match mcp_ensure_initialized() {\n        Ok(dir) =\u003e dir,\n        Err(err_response) =\u003e return Ok(err_response),\n    };\n\n    let args = arguments.ok_or_else(|| anyhow::anyhow!(\"Missing arguments\"))?;\n\n    let id = args\n        .get(\"id\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| anyhow::anyhow!(\"Missing required parameter: id\"))?;\n\n    let force = args.get(\"force\").and_then(|v| v.as_bool()).unwrap_or(false);\n\n    // Resolve spec to get full ID\n    let spec = match resolve_spec(\u0026specs_dir, id) {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e {\n            return Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": e.to_string()\n                    }\n                ],\n                \"isError\": true\n            }));\n        }\n    };\n\n    // Execute takeover\n    match crate::cmd::takeover::cmd_takeover(\u0026spec.id, force) {\n        Ok(result) =\u003e {\n            let response = json!({\n                \"spec_id\": result.spec_id,\n                \"analysis\": result.analysis,\n                \"log_tail\": result.log_tail,\n                \"suggestion\": result.suggestion\n            });\n\n            Ok(json!({\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": serde_json::to_string_pretty(\u0026response)?\n                    }\n                ]\n            }))\n        }\n        Err(e) =\u003e Ok(json!({\n            \"content\": [\n                {\n                    \"type\": \"text\",\n                    \"text\": format!(\"Failed to take over spec '{}': {}\", spec.id, e)\n                }\n            ],\n            \"isError\": true\n        })),\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":5}},{"line":18,"address":[],"length":0,"stats":{"Line":7}},{"line":19,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":8}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":8}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":109,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":8}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":118,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":8}},{"line":123,"address":[],"length":0,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":8}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":142,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":8}},{"line":148,"address":[],"length":0,"stats":{"Line":8}},{"line":149,"address":[],"length":0,"stats":{"Line":8}},{"line":151,"address":[],"length":0,"stats":{"Line":8}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":8}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":8}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":8}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":180,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":182,"address":[],"length":0,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":8}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":8}},{"line":197,"address":[],"length":0,"stats":{"Line":8}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":8}},{"line":200,"address":[],"length":0,"stats":{"Line":8}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":8}},{"line":203,"address":[],"length":0,"stats":{"Line":8}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":206,"address":[],"length":0,"stats":{"Line":8}},{"line":207,"address":[],"length":0,"stats":{"Line":8}},{"line":208,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":8}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":219,"address":[],"length":0,"stats":{"Line":8}},{"line":220,"address":[],"length":0,"stats":{"Line":8}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":225,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":8}},{"line":233,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[],"length":0,"stats":{"Line":8}},{"line":235,"address":[],"length":0,"stats":{"Line":8}},{"line":236,"address":[],"length":0,"stats":{"Line":8}},{"line":239,"address":[],"length":0,"stats":{"Line":8}},{"line":243,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":8}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":8}},{"line":248,"address":[],"length":0,"stats":{"Line":8}},{"line":249,"address":[],"length":0,"stats":{"Line":8}},{"line":250,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":8}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":8}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":261,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":8}},{"line":263,"address":[],"length":0,"stats":{"Line":8}},{"line":264,"address":[],"length":0,"stats":{"Line":8}},{"line":267,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":8}},{"line":272,"address":[],"length":0,"stats":{"Line":8}},{"line":273,"address":[],"length":0,"stats":{"Line":8}},{"line":274,"address":[],"length":0,"stats":{"Line":8}},{"line":275,"address":[],"length":0,"stats":{"Line":8}},{"line":276,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":8}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":281,"address":[],"length":0,"stats":{"Line":8}},{"line":285,"address":[],"length":0,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":8}},{"line":287,"address":[],"length":0,"stats":{"Line":8}},{"line":288,"address":[],"length":0,"stats":{"Line":8}},{"line":289,"address":[],"length":0,"stats":{"Line":8}},{"line":290,"address":[],"length":0,"stats":{"Line":8}},{"line":291,"address":[],"length":0,"stats":{"Line":8}},{"line":292,"address":[],"length":0,"stats":{"Line":8}},{"line":294,"address":[],"length":0,"stats":{"Line":8}},{"line":295,"address":[],"length":0,"stats":{"Line":8}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":298,"address":[],"length":0,"stats":{"Line":8}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[],"length":0,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":310,"address":[],"length":0,"stats":{"Line":8}},{"line":311,"address":[],"length":0,"stats":{"Line":8}},{"line":312,"address":[],"length":0,"stats":{"Line":8}},{"line":313,"address":[],"length":0,"stats":{"Line":8}},{"line":314,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":8}},{"line":317,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":8}},{"line":324,"address":[],"length":0,"stats":{"Line":8}},{"line":325,"address":[],"length":0,"stats":{"Line":8}},{"line":326,"address":[],"length":0,"stats":{"Line":8}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":8}},{"line":329,"address":[],"length":0,"stats":{"Line":8}},{"line":330,"address":[],"length":0,"stats":{"Line":8}},{"line":331,"address":[],"length":0,"stats":{"Line":8}},{"line":334,"address":[],"length":0,"stats":{"Line":8}},{"line":338,"address":[],"length":0,"stats":{"Line":8}},{"line":339,"address":[],"length":0,"stats":{"Line":8}},{"line":340,"address":[],"length":0,"stats":{"Line":8}},{"line":341,"address":[],"length":0,"stats":{"Line":8}},{"line":342,"address":[],"length":0,"stats":{"Line":8}},{"line":343,"address":[],"length":0,"stats":{"Line":8}},{"line":344,"address":[],"length":0,"stats":{"Line":8}},{"line":345,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":8}},{"line":348,"address":[],"length":0,"stats":{"Line":8}},{"line":349,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1129,"address":[],"length":0,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":0}},{"line":1139,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1148,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":0}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1154,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1161,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1185,"address":[],"length":0,"stats":{"Line":0}},{"line":1188,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1206,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1232,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1270,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1305,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1341,"address":[],"length":0,"stats":{"Line":0}},{"line":1342,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1384,"address":[],"length":0,"stats":{"Line":0}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1404,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1446,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[],"length":0,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1486,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1496,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1511,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1519,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1533,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1548,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1574,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1586,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1592,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1596,"address":[],"length":0,"stats":{"Line":0}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1603,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1608,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1613,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1624,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":0}},{"line":1627,"address":[],"length":0,"stats":{"Line":0}},{"line":1630,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[],"length":0,"stats":{"Line":0}},{"line":1652,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1658,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1707,"address":[],"length":0,"stats":{"Line":0}},{"line":1708,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1720,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1723,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1725,"address":[],"length":0,"stats":{"Line":0}},{"line":1726,"address":[],"length":0,"stats":{"Line":0}},{"line":1727,"address":[],"length":0,"stats":{"Line":0}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1731,"address":[],"length":0,"stats":{"Line":0}},{"line":1732,"address":[],"length":0,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1737,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1744,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1746,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":0}},{"line":1752,"address":[],"length":0,"stats":{"Line":0}},{"line":1756,"address":[],"length":0,"stats":{"Line":0}},{"line":1757,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1760,"address":[],"length":0,"stats":{"Line":0}},{"line":1761,"address":[],"length":0,"stats":{"Line":0}},{"line":1765,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1767,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1771,"address":[],"length":0,"stats":{"Line":0}},{"line":1772,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1783,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1799,"address":[],"length":0,"stats":{"Line":0}},{"line":1800,"address":[],"length":0,"stats":{"Line":0}},{"line":1801,"address":[],"length":0,"stats":{"Line":0}},{"line":1808,"address":[],"length":0,"stats":{"Line":0}},{"line":1809,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1815,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1823,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1826,"address":[],"length":0,"stats":{"Line":0}},{"line":1827,"address":[],"length":0,"stats":{"Line":0}},{"line":1828,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1830,"address":[],"length":0,"stats":{"Line":0}},{"line":1834,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1837,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1842,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1846,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1857,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1877,"address":[],"length":0,"stats":{"Line":0}},{"line":1878,"address":[],"length":0,"stats":{"Line":0}},{"line":1879,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1885,"address":[],"length":0,"stats":{"Line":0}},{"line":1888,"address":[],"length":0,"stats":{"Line":0}},{"line":1889,"address":[],"length":0,"stats":{"Line":0}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1892,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1901,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1906,"address":[],"length":0,"stats":{"Line":0}},{"line":1908,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1913,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1929,"address":[],"length":0,"stats":{"Line":0}},{"line":1930,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1937,"address":[],"length":0,"stats":{"Line":0}},{"line":1938,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1944,"address":[],"length":0,"stats":{"Line":0}},{"line":1949,"address":[],"length":0,"stats":{"Line":0}},{"line":1950,"address":[],"length":0,"stats":{"Line":0}},{"line":1951,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1955,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1962,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1966,"address":[],"length":0,"stats":{"Line":0}},{"line":1967,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1971,"address":[],"length":0,"stats":{"Line":0}},{"line":1972,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1983,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1986,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1991,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2002,"address":[],"length":0,"stats":{"Line":0}},{"line":2003,"address":[],"length":0,"stats":{"Line":0}},{"line":2006,"address":[],"length":0,"stats":{"Line":0}}],"covered":216,"coverable":1118},{"path":["/","Users","alex","Documents","checkouts","chant","src","mcp","mod.rs"],"content":"//! Model Context Protocol (MCP) server implementation.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: reference/mcp.md\n//! - ignore: false\n\nmod handlers;\nmod protocol;\nmod server;\n\npub use server::run_server;\n\n#[cfg(test)]\nmod tests {\n    use super::handlers::{handle_method, handle_notification};\n    use super::protocol::{JsonRpcResponse, PROTOCOL_VERSION, SERVER_NAME};\n    use serde_json::json;\n\n    #[test]\n    fn test_handle_initialize() {\n        let result = handle_method(\"initialize\", None).unwrap();\n        assert_eq!(result[\"protocolVersion\"], PROTOCOL_VERSION);\n        assert_eq!(result[\"serverInfo\"][\"name\"], SERVER_NAME);\n    }\n\n    #[test]\n    fn test_handle_tools_list() {\n        let result = handle_method(\"tools/list\", None).unwrap();\n        let tools = result[\"tools\"].as_array().unwrap();\n        assert_eq!(tools.len(), 18);\n        // Query tools (7)\n        assert_eq!(tools[0][\"name\"], \"chant_spec_list\");\n        assert_eq!(tools[1][\"name\"], \"chant_spec_get\");\n        assert_eq!(tools[2][\"name\"], \"chant_ready\");\n        assert_eq!(tools[3][\"name\"], \"chant_status\");\n        assert_eq!(tools[4][\"name\"], \"chant_log\");\n        assert_eq!(tools[5][\"name\"], \"chant_search\");\n        assert_eq!(tools[6][\"name\"], \"chant_diagnose\");\n        // Mutating tools (11)\n        assert_eq!(tools[7][\"name\"], \"chant_spec_update\");\n        assert_eq!(tools[8][\"name\"], \"chant_add\");\n        assert_eq!(tools[9][\"name\"], \"chant_finalize\");\n        assert_eq!(tools[10][\"name\"], \"chant_resume\");\n        assert_eq!(tools[11][\"name\"], \"chant_cancel\");\n        assert_eq!(tools[12][\"name\"], \"chant_archive\");\n        assert_eq!(tools[13][\"name\"], \"chant_verify\");\n        assert_eq!(tools[14][\"name\"], \"chant_work_start\");\n        assert_eq!(tools[15][\"name\"], \"chant_work_list\");\n        assert_eq!(tools[16][\"name\"], \"chant_pause\");\n        assert_eq!(tools[17][\"name\"], \"chant_takeover\");\n    }\n\n    #[test]\n    fn test_json_rpc_response_success() {\n        let resp = JsonRpcResponse::success(json!(1), json!({\"test\": true}));\n        assert_eq!(resp.jsonrpc, \"2.0\");\n        assert!(resp.result.is_some());\n        assert!(resp.error.is_none());\n    }\n\n    #[test]\n    fn test_json_rpc_response_error() {\n        let resp = JsonRpcResponse::error(json!(1), -32600, \"Invalid request\");\n        assert_eq!(resp.jsonrpc, \"2.0\");\n        assert!(resp.result.is_none());\n        assert!(resp.error.is_some());\n        assert_eq!(resp.error.as_ref().unwrap().code, -32600);\n    }\n\n    #[test]\n    fn test_chant_status_schema_has_brief_and_activity() {\n        let result = handle_method(\"tools/list\", None).unwrap();\n        let tools = result[\"tools\"].as_array().unwrap();\n        let status_tool = tools.iter().find(|t| t[\"name\"] == \"chant_status\").unwrap();\n\n        let props = \u0026status_tool[\"inputSchema\"][\"properties\"];\n        assert!(\n            props.get(\"brief\").is_some(),\n            \"chant_status should have 'brief' property\"\n        );\n        assert!(\n            props.get(\"include_activity\").is_some(),\n            \"chant_status should have 'include_activity' property\"\n        );\n\n        // Check descriptions\n        assert!(props[\"brief\"][\"description\"]\n            .as_str()\n            .unwrap()\n            .contains(\"single-line\"));\n        assert!(props[\"include_activity\"][\"description\"]\n            .as_str()\n            .unwrap()\n            .contains(\"activity\"));\n    }\n\n    #[test]\n    fn test_chant_ready_has_limit_param() {\n        let result = handle_method(\"tools/list\", None).unwrap();\n        let tools = result[\"tools\"].as_array().unwrap();\n        let ready_tool = tools.iter().find(|t| t[\"name\"] == \"chant_ready\").unwrap();\n\n        let props = \u0026ready_tool[\"inputSchema\"][\"properties\"];\n        assert!(\n            props.get(\"limit\").is_some(),\n            \"chant_ready should have 'limit' property\"\n        );\n        assert_eq!(props[\"limit\"][\"type\"], \"integer\");\n        assert!(props[\"limit\"][\"description\"]\n            .as_str()\n            .unwrap()\n            .contains(\"50\"));\n    }\n\n    #[test]\n    fn test_chant_spec_list_has_limit_param() {\n        let result = handle_method(\"tools/list\", None).unwrap();\n        let tools = result[\"tools\"].as_array().unwrap();\n        let list_tool = tools\n            .iter()\n            .find(|t| t[\"name\"] == \"chant_spec_list\")\n            .unwrap();\n\n        let props = \u0026list_tool[\"inputSchema\"][\"properties\"];\n        assert!(\n            props.get(\"limit\").is_some(),\n            \"chant_spec_list should have 'limit' property\"\n        );\n        assert_eq!(props[\"limit\"][\"type\"], \"integer\");\n        assert!(props[\"limit\"][\"description\"]\n            .as_str()\n            .unwrap()\n            .contains(\"50\"));\n    }\n\n    #[test]\n    fn test_handle_notification() {\n        // Should not panic\n        handle_notification(\"notifications/initialized\", None);\n        handle_notification(\"unknown_notification\", None);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","mcp","protocol.rs"],"content":"//! JSON-RPC 2.0 protocol types and MCP constants.\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// MCP Server info\npub const SERVER_NAME: \u0026str = \"chant\";\npub const SERVER_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\npub const PROTOCOL_VERSION: \u0026str = \"2024-11-05\";\n\n/// JSON-RPC 2.0 Request\n#[derive(Debug, Deserialize)]\npub struct JsonRpcRequest {\n    pub jsonrpc: String,\n    pub method: String,\n    #[serde(default)]\n    pub params: Option\u003cValue\u003e,\n    pub id: Option\u003cValue\u003e,\n}\n\n/// JSON-RPC 2.0 Response\n///\n/// Represents a JSON-RPC 2.0 response message. Either `result` or `error` will be present,\n/// but not both.\n///\n/// # Success Response\n///\n/// When the request succeeds, `result` contains the response data and `error` is `None`.\n///\n/// # Error Response\n///\n/// When the request fails, `error` contains error details and `result` is `None`.\n///\n/// # Fields\n///\n/// - `jsonrpc`: Version string, always `\"2.0\"`\n/// - `result`: Success data (tool result or handler response)\n/// - `error`: Error details if request failed\n/// - `id`: Request ID from the original request (for correlation)\n#[derive(Debug, Serialize)]\npub struct JsonRpcResponse {\n    pub jsonrpc: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub result: Option\u003cValue\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error: Option\u003cJsonRpcError\u003e,\n    pub id: Value,\n}\n\n/// JSON-RPC 2.0 Error\n///\n/// Represents an error in a JSON-RPC response.\n///\n/// # Error Codes\n///\n/// - `-32700`: Parse error (invalid JSON)\n/// - `-32600`: Invalid JSON-RPC version (jsonrpc != \"2.0\")\n/// - `-32603`: Server error (internal handler error)\n///\n/// # Fields\n///\n/// - `code`: JSON-RPC error code (negative integer)\n/// - `message`: Human-readable error description\n/// - `data`: Optional additional error context\n#[derive(Debug, Serialize)]\npub struct JsonRpcError {\n    pub code: i32,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cValue\u003e,\n}\n\nimpl JsonRpcResponse {\n    /// Create a successful response.\n    ///\n    /// # Arguments\n    ///\n    /// - `id`: Request ID to echo back\n    /// - `result`: Response data (typically a JSON object)\n    ///\n    /// # Returns\n    ///\n    /// A response with `result` set and `error` as `None`.\n    pub fn success(id: Value, result: Value) -\u003e Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            result: Some(result),\n            error: None,\n            id,\n        }\n    }\n\n    /// Create an error response.\n    ///\n    /// # Arguments\n    ///\n    /// - `id`: Request ID to echo back\n    /// - `code`: JSON-RPC error code (negative integer)\n    ///   - `-32700`: Parse error\n    ///   - `-32600`: Invalid JSON-RPC version\n    ///   - `-32603`: Server error\n    /// - `message`: Human-readable error description\n    ///\n    /// # Returns\n    ///\n    /// A response with `error` set and `result` as `None`.\n    pub fn error(id: Value, code: i32, message: \u0026str) -\u003e Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            result: None,\n            error: Some(JsonRpcError {\n                code,\n                message: message.to_string(),\n                data: None,\n            }),\n            id,\n        }\n    }\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":9}},{"line":111,"address":[],"length":0,"stats":{"Line":3}}],"covered":6,"coverable":6},{"path":["/","Users","alex","Documents","checkouts","chant","src","mcp","server.rs"],"content":"//! MCP server main loop and request handling.\n\nuse anyhow::{Context, Result};\nuse serde_json::Value;\nuse std::io::{BufRead, BufReader, Write};\n\nuse super::handlers::{handle_method, handle_notification};\nuse super::protocol::{JsonRpcRequest, JsonRpcResponse};\n\n/// Run the MCP server, reading from stdin and writing to stdout.\npub fn run_server() -\u003e Result\u003c()\u003e {\n    let stdin = std::io::stdin();\n    let mut stdout = std::io::stdout();\n    let reader = BufReader::new(stdin.lock());\n\n    for line in reader.lines() {\n        let line = line.context(\"Failed to read from stdin\")?;\n\n        if line.trim().is_empty() {\n            continue;\n        }\n\n        let response = handle_request(\u0026line);\n\n        if let Some(resp) = response {\n            let output = serde_json::to_string(\u0026resp)?;\n            writeln!(stdout, \"{}\", output)?;\n            stdout.flush()?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Handle a single JSON-RPC request line.\n///\n/// # Request Processing\n///\n/// 1. Parse JSON-RPC 2.0 request from the line\n/// 2. Validate `jsonrpc` field is `\"2.0\"`\n/// 3. Dispatch to appropriate handler based on `method`\n/// 4. Return response or `None` for notifications\n///\n/// # Error Handling\n///\n/// - **Parse Error (-32700)**: JSON is invalid or malformed\n/// - **Invalid Version (-32600)**: `jsonrpc` field is not `\"2.0\"`\n/// - **Server Error (-32603)**: Handler function returns `Err`\n/// - **No Response**: Notifications (requests without `id`) are handled silently\n///\n/// # Returns\n///\n/// - `Some(response)`: For requests (with `id`)\n/// - `None`: For notifications (without `id`)\nfn handle_request(line: \u0026str) -\u003e Option\u003cJsonRpcResponse\u003e {\n    let request: JsonRpcRequest = match serde_json::from_str(line) {\n        Ok(req) =\u003e req,\n        Err(e) =\u003e {\n            return Some(JsonRpcResponse::error(\n                Value::Null,\n                -32700,\n                \u0026format!(\"Parse error: {}\", e),\n            ));\n        }\n    };\n\n    // Validate jsonrpc version\n    if request.jsonrpc != \"2.0\" {\n        return Some(JsonRpcResponse::error(\n            request.id.unwrap_or(Value::Null),\n            -32600,\n            \"Invalid JSON-RPC version\",\n        ));\n    }\n\n    // Notifications (no id) don't get responses\n    let id = match request.id {\n        Some(id) =\u003e id,\n        None =\u003e {\n            // Handle notification (no response needed)\n            handle_notification(\u0026request.method, request.params.as_ref());\n            return None;\n        }\n    };\n\n    let result = handle_method(\u0026request.method, request.params.as_ref());\n\n    match result {\n        Ok(value) =\u003e Some(JsonRpcResponse::success(id, value)),\n        Err(e) =\u003e Some(JsonRpcResponse::error(id, -32603, \u0026e.to_string())),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_handle_request_parse_error() {\n        let response = handle_request(\"{invalid json}\");\n        assert!(response.is_some());\n        let resp = response.unwrap();\n        assert!(resp.error.is_some());\n        assert_eq!(resp.error.as_ref().unwrap().code, -32700);\n    }\n\n    #[test]\n    fn test_handle_request_invalid_version() {\n        let response = handle_request(r#\"{\"jsonrpc\":\"1.0\",\"method\":\"test\",\"id\":1}\"#);\n        assert!(response.is_some());\n        let resp = response.unwrap();\n        assert!(resp.error.is_some());\n        assert_eq!(resp.error.as_ref().unwrap().code, -32600);\n    }\n\n    #[test]\n    fn test_handle_request_notification() {\n        let response = handle_request(r#\"{\"jsonrpc\":\"2.0\",\"method\":\"notifications/initialized\"}\"#);\n        assert!(response.is_none());\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":7}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":35},{"path":["/","Users","alex","Documents","checkouts","chant","src","merge.rs"],"content":"//! Spec merge logic and utilities.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: guides/recovery.md\n//! - ignore: false\n\nuse crate::config::Config;\nuse crate::git::MergeResult;\nuse crate::spec::{Spec, SpecStatus};\nuse crate::spec_group::{extract_member_number, is_member_of};\nuse anyhow::Result;\n\n/// Status of a branch for selective merge operations\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum BranchStatus {\n    /// All criteria checked, can fast-forward merge\n    Ready,\n    /// Behind main, needs rebase but no conflicts expected\n    NeedsRebase,\n    /// Rebase would likely have conflicts\n    HasConflicts,\n    /// Spec criteria not all checked\n    Incomplete,\n    /// Branch exists but no commits\n    NoCommits,\n    /// Branch doesn't exist\n    NoBranch,\n}\n\n/// Information about a branch for selective merge display\n#[derive(Debug, Clone)]\npub struct BranchInfo {\n    pub spec_id: String,\n    pub spec_title: Option\u003cString\u003e,\n    pub status: BranchStatus,\n    pub commit_count: usize,\n    pub criteria_checked: usize,\n    pub criteria_total: usize,\n}\n\n/// Load main_branch from config with fallback to \"main\"\npub fn load_main_branch(config: \u0026Config) -\u003e String {\n    config.defaults.main_branch.clone()\n}\n\n/// Count checked and total acceptance criteria in a spec\npub fn count_criteria(spec: \u0026Spec) -\u003e (usize, usize) {\n    let body = \u0026spec.body;\n    let mut in_criteria_section = false;\n    let mut in_code_fence = false;\n    let mut checked = 0;\n    let mut total = 0;\n\n    for line in body.lines() {\n        let trimmed = line.trim();\n\n        // Track code fences\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        // Skip lines in code fences\n        if in_code_fence {\n            continue;\n        }\n\n        // Check for acceptance criteria section\n        if trimmed.starts_with(\"## Acceptance Criteria\") {\n            in_criteria_section = true;\n            continue;\n        }\n\n        // Exit criteria section on next heading\n        if in_criteria_section \u0026\u0026 trimmed.starts_with(\"## \") {\n            break;\n        }\n\n        // Count criteria checkboxes\n        if in_criteria_section {\n            if trimmed.starts_with(\"- [x]\") || trimmed.starts_with(\"- [X]\") {\n                checked += 1;\n                total += 1;\n            } else if trimmed.starts_with(\"- [ ]\") {\n                total += 1;\n            }\n        }\n    }\n\n    (checked, total)\n}\n\n/// Detect the status of a branch for selective merge\npub fn detect_branch_status(\n    spec: \u0026Spec,\n    branch_name: \u0026str,\n    main_branch: \u0026str,\n) -\u003e Result\u003cBranchStatus\u003e {\n    use crate::git;\n\n    // Check if branch exists\n    let exists = git::branch_exists(branch_name)?;\n    if !exists {\n        return Ok(BranchStatus::NoBranch);\n    }\n\n    // Count commits\n    let commit_count = git::count_commits(branch_name).unwrap_or(0);\n    if commit_count == 0 {\n        return Ok(BranchStatus::NoCommits);\n    }\n\n    // Check criteria\n    let (checked, total) = count_criteria(spec);\n    if total \u003e 0 \u0026\u0026 checked \u003c total {\n        return Ok(BranchStatus::Incomplete);\n    }\n\n    // Check if can fast-forward merge\n    let can_ff = git::can_fast_forward_merge(branch_name, main_branch)?;\n    if can_ff {\n        return Ok(BranchStatus::Ready);\n    }\n\n    // Check if behind main\n    let is_behind = git::is_branch_behind(branch_name, main_branch)?;\n    if is_behind {\n        // Could check for conflicts here, but for now assume needs rebase\n        return Ok(BranchStatus::NeedsRebase);\n    }\n\n    // Branch has diverged - likely has conflicts\n    Ok(BranchStatus::HasConflicts)\n}\n\n/// Get branch information for all completed specs\npub fn get_branch_info_for_specs(\n    specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n) -\u003e Result\u003cVec\u003cBranchInfo\u003e\u003e {\n    let mut infos = Vec::new();\n\n    for spec in specs {\n        if spec.frontmatter.status != SpecStatus::Completed {\n            continue;\n        }\n\n        let branch_name = format!(\"{}{}\", branch_prefix, spec.id);\n        let status = detect_branch_status(spec, \u0026branch_name, main_branch)?;\n\n        // Only include specs with branches\n        if status == BranchStatus::NoBranch {\n            continue;\n        }\n\n        let (checked, total) = count_criteria(spec);\n        let commit_count = crate::git::count_commits(\u0026branch_name).unwrap_or(0);\n\n        infos.push(BranchInfo {\n            spec_id: spec.id.clone(),\n            spec_title: spec.title.clone(),\n            status,\n            commit_count,\n            criteria_checked: checked,\n            criteria_total: total,\n        });\n    }\n\n    Ok(infos)\n}\n\n/// Get the list of specs to merge based on arguments\n/// Returns vector of (spec_id, Spec) tuples\npub fn get_specs_to_merge(\n    args: \u0026[String],\n    all: bool,\n    all_specs: \u0026[Spec],\n) -\u003e Result\u003cVec\u003c(String, Spec)\u003e\u003e {\n    let mut result = Vec::new();\n\n    if all {\n        // Collect all specs with status == Completed that have branches\n        for spec in all_specs {\n            if spec.frontmatter.status == SpecStatus::Completed {\n                result.push((spec.id.clone(), spec.clone()));\n            }\n        }\n    } else {\n        // Resolve each ID using the same matching logic as resolve_spec:\n        // 1. Exact match\n        // 2. Suffix match (ends_with)\n        // 3. Contains match (partial_id anywhere in spec.id)\n        for partial_id in args {\n            // Try exact match first\n            if let Some(spec) = all_specs.iter().find(|s| s.id == *partial_id) {\n                result.push((spec.id.clone(), spec.clone()));\n                continue;\n            }\n\n            // Try suffix match\n            let suffix_matches: Vec\u003c_\u003e = all_specs\n                .iter()\n                .filter(|s| s.id.ends_with(partial_id))\n                .collect();\n            if suffix_matches.len() == 1 {\n                result.push((suffix_matches[0].id.clone(), suffix_matches[0].clone()));\n                continue;\n            }\n\n            // Try contains match\n            let contains_matches: Vec\u003c_\u003e = all_specs\n                .iter()\n                .filter(|s| s.id.contains(partial_id))\n                .collect();\n            if contains_matches.len() == 1 {\n                result.push((contains_matches[0].id.clone(), contains_matches[0].clone()));\n                continue;\n            }\n\n            if contains_matches.len() \u003e 1 {\n                anyhow::bail!(\n                    \"Ambiguous spec ID '{}'. Matches: {}\",\n                    partial_id,\n                    contains_matches\n                        .iter()\n                        .map(|s| s.id.as_str())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\", \")\n                );\n            }\n\n            anyhow::bail!(\"Spec not found: {}\", partial_id);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Validate that a spec can be merged. Public API used in tests.\npub fn validate_spec_can_merge(spec: \u0026Spec, branch_exists: bool) -\u003e Result\u003c()\u003e {\n    // Check status is Completed\n    match \u0026spec.frontmatter.status {\n        SpecStatus::Completed =\u003e {}\n        other =\u003e {\n            let status_str = format!(\"{:?}\", other);\n            anyhow::bail!(\n                \"{}\",\n                crate::merge_errors::spec_status_not_mergeable(\u0026spec.id, \u0026status_str)\n            );\n        }\n    }\n\n    // Check branch exists\n    if !branch_exists {\n        anyhow::bail!(\"{}\", crate::merge_errors::no_branch_for_spec(\u0026spec.id));\n    }\n\n    Ok(())\n}\n\n/// Check if a spec is a driver spec (has member specs)\npub fn is_driver_spec(spec: \u0026Spec, all_specs: \u0026[Spec]) -\u003e bool {\n    let members = collect_member_specs(spec, all_specs);\n    !members.is_empty()\n}\n\n/// Collect member specs of a driver spec in order (by sequence number)\nfn collect_member_specs(driver_spec: \u0026Spec, all_specs: \u0026[Spec]) -\u003e Vec\u003cSpec\u003e {\n    let driver_id = \u0026driver_spec.id;\n    let mut members: Vec\u003c(u32, Spec)\u003e = Vec::new();\n\n    for spec in all_specs {\n        if is_member_of(\u0026spec.id, driver_id) {\n            // Extract sequence number from member ID\n            if let Some(seq_num) = extract_member_number(\u0026spec.id) {\n                members.push((seq_num, spec.clone()));\n            }\n        }\n    }\n\n    // Sort by sequence number\n    members.sort_by_key(|m| m.0);\n\n    // Return just the specs\n    members.into_iter().map(|(_, spec)| spec).collect()\n}\n\n/// Merge a driver spec and all its members in order.\n///\n/// This function:\n/// 1. Collects all member specs in order\n/// 2. Validates all members are completed and branches exist\n/// 3. Merges each member spec in sequence\n/// 4. If any member merge fails, stops and reports which member failed\n/// 5. After all members succeed, merges the driver spec itself\n/// 6. Returns a list of all merge results (members + driver)\n///\n/// If any validation fails, returns an error with a clear listing of incomplete members.\npub fn merge_driver_spec(\n    driver_spec: \u0026Spec,\n    all_specs: \u0026[Spec],\n    branch_prefix: \u0026str,\n    main_branch: \u0026str,\n    should_delete_branch: bool,\n    dry_run: bool,\n) -\u003e Result\u003cVec\u003cMergeResult\u003e\u003e {\n    use crate::git;\n\n    // Collect member specs in order\n    let members = collect_member_specs(driver_spec, all_specs);\n\n    // Check preconditions for all members\n    let mut incomplete_members = Vec::new();\n    for member in \u0026members {\n        // Check status is Completed\n        if member.frontmatter.status != SpecStatus::Completed {\n            incomplete_members.push(format!(\n                \"{} (status: {:?})\",\n                member.id, member.frontmatter.status\n            ));\n        }\n    }\n\n    // Check all member branches exist (unless dry_run)\n    if !dry_run {\n        for member in \u0026members {\n            let branch_name = format!(\"{}{}\", branch_prefix, member.id);\n            match git::branch_exists(\u0026branch_name) {\n                Ok(exists) =\u003e {\n                    if !exists {\n                        incomplete_members.push(format!(\"{} (branch not found)\", member.id));\n                    }\n                }\n                Err(e) =\u003e {\n                    anyhow::bail!(\"Failed to check branch for {}: {}\", member.id, e);\n                }\n            }\n        }\n    }\n\n    // If any preconditions failed, report them all\n    if !incomplete_members.is_empty() {\n        anyhow::bail!(\n            \"{}\",\n            crate::merge_errors::driver_members_incomplete(\u0026driver_spec.id, \u0026incomplete_members)\n        );\n    }\n\n    // Merge each member spec in order\n    let mut all_results = Vec::new();\n    for member in \u0026members {\n        let branch_name = format!(\"{}{}\", branch_prefix, member.id);\n        match git::merge_single_spec(\n            \u0026member.id,\n            \u0026branch_name,\n            main_branch,\n            should_delete_branch,\n            dry_run,\n        ) {\n            Ok(result) =\u003e {\n                if !result.success {\n                    anyhow::bail!(\n                        \"{}\",\n                        crate::merge_errors::member_merge_failed(\n                            \u0026driver_spec.id,\n                            \u0026member.id,\n                            \u0026format!(\"Merge returned unsuccessful for {}\", result.spec_id)\n                        )\n                    );\n                }\n                all_results.push(result);\n            }\n            Err(e) =\u003e {\n                anyhow::bail!(\n                    \"{}\",\n                    crate::merge_errors::member_merge_failed(\n                        \u0026driver_spec.id,\n                        \u0026member.id,\n                        \u0026e.to_string()\n                    )\n                );\n            }\n        }\n    }\n\n    // After all members succeed, merge the driver spec itself\n    let driver_branch = format!(\"{}{}\", branch_prefix, driver_spec.id);\n    match git::merge_single_spec(\n        \u0026driver_spec.id,\n        \u0026driver_branch,\n        main_branch,\n        should_delete_branch,\n        dry_run,\n    ) {\n        Ok(result) =\u003e {\n            all_results.push(result);\n            Ok(all_results)\n        }\n        Err(e) =\u003e {\n            anyhow::bail!(\n                \"{}\",\n                crate::merge_errors::member_merge_failed(\n                    \u0026driver_spec.id,\n                    \u0026driver_spec.id,\n                    \u0026e.to_string()\n                )\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::config::DefaultsConfig;\n\n    fn make_config(defaults: DefaultsConfig) -\u003e Config {\n        Config {\n            project: crate::config::ProjectConfig {\n                name: \"test\".to_string(),\n                prefix: None,\n                silent: false,\n            },\n            defaults,\n            providers: crate::provider::ProviderConfig::default(),\n            parallel: crate::config::ParallelConfig::default(),\n            repos: vec![],\n            enterprise: crate::config::EnterpriseConfig::default(),\n            approval: crate::config::ApprovalConfig::default(),\n            validation: crate::config::OutputValidationConfig::default(),\n            site: crate::config::SiteConfig::default(),\n            lint: crate::config::LintConfig::default(),\n            watch: crate::config::WatchConfig::default(),\n        }\n    }\n\n    fn make_spec(id: \u0026str, status: SpecStatus) -\u003e Spec {\n        Spec {\n            id: id.to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status,\n                ..Default::default()\n            },\n            title: Some(format!(\"Spec {}\", id)),\n            body: format!(\"Body {}\", id),\n        }\n    }\n\n    #[test]\n    fn test_load_main_branch_default() {\n        let config = make_config(DefaultsConfig::default());\n        let branch = load_main_branch(\u0026config);\n        assert_eq!(branch, \"main\");\n    }\n\n    #[test]\n    fn test_load_main_branch_custom() {\n        let config = make_config(DefaultsConfig {\n            main_branch: \"master\".to_string(),\n            ..Default::default()\n        });\n        let branch = load_main_branch(\u0026config);\n        assert_eq!(branch, \"master\");\n    }\n\n    #[test]\n    fn test_get_specs_to_merge_all() {\n        let specs = vec![\n            make_spec(\"spec1\", SpecStatus::Completed),\n            make_spec(\"spec2\", SpecStatus::Pending),\n            make_spec(\"spec3\", SpecStatus::Completed),\n        ];\n\n        let result = get_specs_to_merge(\u0026[], true, \u0026specs).unwrap();\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].0, \"spec1\");\n        assert_eq!(result[1].0, \"spec3\");\n    }\n\n    #[test]\n    fn test_get_specs_to_merge_specific() {\n        let specs = vec![\n            make_spec(\"spec1\", SpecStatus::Completed),\n            make_spec(\"spec2\", SpecStatus::Completed),\n        ];\n\n        let result = get_specs_to_merge(\u0026[\"spec1\".to_string()], false, \u0026specs).unwrap();\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0].0, \"spec1\");\n    }\n\n    #[test]\n    fn test_get_specs_to_merge_not_found() {\n        let specs = vec![make_spec(\"spec1\", SpecStatus::Pending)];\n\n        let result = get_specs_to_merge(\u0026[\"nonexistent\".to_string()], false, \u0026specs);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Spec not found\"));\n    }\n\n    #[test]\n    fn test_validate_spec_can_merge_completed() {\n        let spec = make_spec(\"spec1\", SpecStatus::Completed);\n        let result = validate_spec_can_merge(\u0026spec, true);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_validate_spec_can_merge_pending_fails() {\n        let spec = make_spec(\"spec1\", SpecStatus::Pending);\n        let result = validate_spec_can_merge(\u0026spec, true);\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(err_msg.contains(\"Cannot merge spec spec1\"));\n        assert!(err_msg.contains(\"Pending\"));\n        assert!(err_msg.contains(\"Next Steps\"));\n    }\n\n    #[test]\n    fn test_validate_spec_can_merge_in_progress_fails() {\n        let spec = make_spec(\"spec1\", SpecStatus::InProgress);\n        let result = validate_spec_can_merge(\u0026spec, true);\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(err_msg.contains(\"Cannot merge spec spec1\"));\n        assert!(err_msg.contains(\"InProgress\"));\n        assert!(err_msg.contains(\"Next Steps\"));\n    }\n\n    #[test]\n    fn test_validate_spec_can_merge_failed_fails() {\n        let spec = make_spec(\"spec1\", SpecStatus::Failed);\n        let result = validate_spec_can_merge(\u0026spec, true);\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(err_msg.contains(\"Cannot merge spec spec1\"));\n        assert!(err_msg.contains(\"Failed\"));\n        assert!(err_msg.contains(\"Next Steps\"));\n    }\n\n    #[test]\n    fn test_validate_spec_can_merge_no_branch() {\n        let spec = make_spec(\"spec1\", SpecStatus::Completed);\n        let result = validate_spec_can_merge(\u0026spec, false);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"No branch found\"));\n    }\n\n    #[test]\n    fn test_collect_member_specs() {\n        let driver = Spec {\n            id: \"driver\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"driver.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"driver.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let member3 = Spec {\n            id: \"driver.3\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Member 3\".to_string()),\n            body: \"Member 3\".to_string(),\n        };\n\n        let all_specs = vec![\n            driver.clone(),\n            member3.clone(),\n            member1.clone(),\n            member2.clone(),\n        ];\n\n        let result = collect_member_specs(\u0026driver, \u0026all_specs);\n        assert_eq!(result.len(), 3);\n        assert_eq!(result[0].id, \"driver.1\");\n        assert_eq!(result[1].id, \"driver.2\");\n        assert_eq!(result[2].id, \"driver.3\");\n    }\n\n    #[test]\n    fn test_collect_member_specs_with_nested() {\n        let driver = Spec {\n            id: \"driver\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"driver.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"driver.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter::default(),\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let all_specs = vec![driver.clone(), member1.clone(), member2.clone()];\n\n        let result = collect_member_specs(\u0026driver, \u0026all_specs);\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].id, \"driver.1\");\n        assert_eq!(result[1].id, \"driver.2\");\n    }\n\n    #[test]\n    fn test_collect_member_specs_empty() {\n        let driver = make_spec(\"driver\", SpecStatus::Pending);\n        let other = make_spec(\"other\", SpecStatus::Pending);\n        let all_specs = vec![driver.clone(), other];\n        let result = collect_member_specs(\u0026driver, \u0026all_specs);\n        assert_eq!(result.len(), 0);\n    }\n\n    #[test]\n    fn test_is_driver_spec_with_members() {\n        let driver = make_spec(\"driver\", SpecStatus::Pending);\n        let member1 = make_spec(\"driver.1\", SpecStatus::Pending);\n        let all_specs = vec![driver.clone(), member1];\n        let result = is_driver_spec(\u0026driver, \u0026all_specs);\n        assert!(result);\n    }\n\n    #[test]\n    fn test_is_driver_spec_without_members() {\n        let driver = make_spec(\"driver\", SpecStatus::Pending);\n        let other = make_spec(\"other\", SpecStatus::Pending);\n        let all_specs = vec![driver.clone(), other];\n        let result = is_driver_spec(\u0026driver, \u0026all_specs);\n        assert!(!result);\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_driver_spec_all_members_completed() {\n        let driver = Spec {\n            id: \"driver\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"driver.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"driver.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let member3 = Spec {\n            id: \"driver.3\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 3\".to_string()),\n            body: \"Member 3\".to_string(),\n        };\n\n        let all_specs = vec![driver.clone(), member1, member2, member3];\n\n        // In dry-run mode, this should succeed (no branch validation)\n        let result = merge_driver_spec(\u0026driver, \u0026all_specs, \"spec-\", \"main\", false, true);\n        assert!(result.is_ok());\n        let results = result.unwrap();\n        // Should have 4 results: 3 members + 1 driver\n        assert_eq!(results.len(), 4);\n        // All should be in dry-run mode\n        assert!(results.iter().all(|r| r.dry_run));\n    }\n\n    #[test]\n    fn test_merge_driver_spec_member_pending() {\n        let driver = Spec {\n            id: \"driver\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"driver.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"driver.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let all_specs = vec![driver.clone(), member1, member2];\n\n        let result = merge_driver_spec(\u0026driver, \u0026all_specs, \"spec-\", \"main\", false, true);\n        assert!(result.is_err());\n        let error = result.unwrap_err().to_string();\n        assert!(error.contains(\"Cannot merge driver spec\"));\n        assert!(error.contains(\"driver.2\"));\n        assert!(error.contains(\"incomplete\"));\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_driver_spec_multiple_members_in_order() {\n        let driver = Spec {\n            id: \"2026-01-24-01y-73b\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"2026-01-24-01y-73b.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"2026-01-24-01y-73b.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let member3 = Spec {\n            id: \"2026-01-24-01y-73b.3\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 3\".to_string()),\n            body: \"Member 3\".to_string(),\n        };\n\n        let all_specs = vec![driver.clone(), member3, member1, member2];\n\n        let result = merge_driver_spec(\u0026driver, \u0026all_specs, \"spec-\", \"main\", false, true);\n        assert!(result.is_ok());\n        let results = result.unwrap();\n        // Should have 4 results in correct order: .1, .2, .3, driver\n        assert_eq!(results.len(), 4);\n        assert_eq!(results[0].spec_id, \"2026-01-24-01y-73b.1\");\n        assert_eq!(results[1].spec_id, \"2026-01-24-01y-73b.2\");\n        assert_eq!(results[2].spec_id, \"2026-01-24-01y-73b.3\");\n        assert_eq!(results[3].spec_id, \"2026-01-24-01y-73b\");\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_driver_spec_dry_run_shows_all_merges() {\n        let driver = Spec {\n            id: \"driver\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"Driver\".to_string(),\n        };\n\n        let member1 = Spec {\n            id: \"driver.1\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 1\".to_string()),\n            body: \"Member 1\".to_string(),\n        };\n\n        let member2 = Spec {\n            id: \"driver.2\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Completed,\n                ..Default::default()\n            },\n            title: Some(\"Member 2\".to_string()),\n            body: \"Member 2\".to_string(),\n        };\n\n        let all_specs = vec![driver.clone(), member1, member2];\n\n        let result = merge_driver_spec(\u0026driver, \u0026all_specs, \"spec-\", \"main\", false, true);\n        assert!(result.is_ok());\n        let results = result.unwrap();\n        // 3 merges: member1, member2, driver\n        assert_eq!(results.len(), 3);\n        // All should be in dry-run mode\n        assert!(results.iter().all(|r| r.dry_run));\n        // All should be marked as success in dry-run\n        assert!(results.iter().all(|r| r.success));\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":16}},{"line":183,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":197,"address":[],"length":0,"stats":{"Line":48}},{"line":198,"address":[],"length":0,"stats":{"Line":30}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":7}},{"line":242,"address":[],"length":0,"stats":{"Line":5}},{"line":244,"address":[],"length":0,"stats":{"Line":5}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":6}},{"line":265,"address":[],"length":0,"stats":{"Line":24}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":13}},{"line":271,"address":[],"length":0,"stats":{"Line":26}},{"line":272,"address":[],"length":0,"stats":{"Line":39}},{"line":274,"address":[],"length":0,"stats":{"Line":46}},{"line":275,"address":[],"length":0,"stats":{"Line":99}},{"line":277,"address":[],"length":0,"stats":{"Line":48}},{"line":278,"address":[],"length":0,"stats":{"Line":64}},{"line":284,"address":[],"length":0,"stats":{"Line":26}},{"line":287,"address":[],"length":0,"stats":{"Line":52}},{"line":301,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":16}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":14}},{"line":318,"address":[],"length":0,"stats":{"Line":11}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":4}},{"line":345,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":352,"address":[],"length":0,"stats":{"Line":6}},{"line":353,"address":[],"length":0,"stats":{"Line":11}},{"line":354,"address":[],"length":0,"stats":{"Line":16}},{"line":355,"address":[],"length":0,"stats":{"Line":16}},{"line":356,"address":[],"length":0,"stats":{"Line":16}},{"line":357,"address":[],"length":0,"stats":{"Line":16}},{"line":358,"address":[],"length":0,"stats":{"Line":16}},{"line":359,"address":[],"length":0,"stats":{"Line":8}},{"line":360,"address":[],"length":0,"stats":{"Line":8}},{"line":362,"address":[],"length":0,"stats":{"Line":8}},{"line":363,"address":[],"length":0,"stats":{"Line":8}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":24}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":6}},{"line":392,"address":[],"length":0,"stats":{"Line":6}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":3}},{"line":397,"address":[],"length":0,"stats":{"Line":3}},{"line":398,"address":[],"length":0,"stats":{"Line":9}},{"line":399,"address":[],"length":0,"stats":{"Line":3}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}}],"covered":77,"coverable":173},{"path":["/","Users","alex","Documents","checkouts","chant","src","merge_driver.rs"],"content":"//! Git merge driver for spec files.\n//!\n//! This module implements a custom merge driver for `.chant/specs/*.md` files\n//! that intelligently resolves frontmatter conflicts while preserving body content.\n//!\n//! ## Problem\n//!\n//! When merging spec branches back to main, frontmatter conflicts occur because:\n//! - Main has `status: completed` (from finalize)\n//! - Feature branch has `status: in_progress`\n//! - Main may have `completed_at` and `model` fields\n//! - Feature branch may not have these fields yet\n//!\n//! ## Solution\n//!\n//! This merge driver:\n//! 1. Parses frontmatter from base, ours, and theirs versions\n//! 2. Intelligently merges frontmatter fields\n//! 3. Uses standard 3-way merge for body content\n//! 4. Produces a clean merge result or marks conflicts\n//!\n//! ## Git Configuration\n//!\n//! To use this merge driver, add to `.gitattributes`:\n//! ```text\n//! .chant/specs/*.md merge=chant-spec\n//! ```\n//!\n//! Then configure git:\n//! ```text\n//! git config merge.chant-spec.name \"Chant spec merge driver\"\n//! git config merge.chant-spec.driver \"chant merge-driver %O %A %B\"\n//! ```\n//!\n//! # Doc Audit\n//! - audited: 2026-01-27\n//! - docs: guides/recovery.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\nuse std::process::Command;\n\nuse crate::spec::{split_frontmatter, SpecFrontmatter, SpecStatus};\n\n/// Result of parsing a spec file into frontmatter and body\n#[derive(Debug, Clone)]\npub struct ParsedSpec {\n    /// Raw frontmatter YAML string (without ---\\n markers)\n    pub frontmatter_yaml: String,\n    /// Parsed frontmatter structure\n    pub frontmatter: SpecFrontmatter,\n    /// Body content after frontmatter\n    pub body: String,\n}\n\n/// Parse a spec file into frontmatter and body components\npub fn parse_spec_file(content: \u0026str) -\u003e Result\u003cParsedSpec\u003e {\n    let (frontmatter_opt, body) = split_frontmatter(content);\n\n    let frontmatter_yaml = frontmatter_opt.unwrap_or_default();\n    let frontmatter: SpecFrontmatter = if !frontmatter_yaml.is_empty() {\n        serde_yaml::from_str(\u0026frontmatter_yaml).context(\"Failed to parse frontmatter\")?\n    } else {\n        SpecFrontmatter::default()\n    };\n\n    Ok(ParsedSpec {\n        frontmatter_yaml,\n        frontmatter,\n        body: body.to_string(),\n    })\n}\n\n/// Merge frontmatter from base, ours, and theirs\n///\n/// Strategy:\n/// - `status`: Prefer the more \"advanced\" status (completed \u003e in_progress \u003e pending)\n/// - `completed_at`, `model`: Take from whichever side has them (prefer ours)\n/// - `commits`: Merge both lists, deduplicate\n/// - Other fields: Prefer ours (feature branch) as it's fresher for work-in-progress\npub fn merge_frontmatter(\n    base: \u0026SpecFrontmatter,\n    ours: \u0026SpecFrontmatter,\n    theirs: \u0026SpecFrontmatter,\n) -\u003e SpecFrontmatter {\n    let mut result = ours.clone();\n\n    // Status: prefer the more \"advanced\" status\n    result.status = merge_status(\u0026base.status, \u0026ours.status, \u0026theirs.status);\n\n    // completed_at: take from whichever side has it (prefer theirs as it's from finalize)\n    if result.completed_at.is_none() \u0026\u0026 theirs.completed_at.is_some() {\n        result.completed_at = theirs.completed_at.clone();\n    }\n\n    // model: take from whichever side has it (prefer theirs as it's from finalize)\n    if result.model.is_none() \u0026\u0026 theirs.model.is_some() {\n        result.model = theirs.model.clone();\n    }\n\n    // commits: merge both lists, deduplicate\n    result.commits = merge_commits(\u0026base.commits, \u0026ours.commits, \u0026theirs.commits);\n\n    // branch: prefer ours (feature branch has the actual branch info)\n    if result.branch.is_none() \u0026\u0026 theirs.branch.is_some() {\n        result.branch = theirs.branch.clone();\n    }\n\n    // labels: merge both lists, deduplicate\n    result.labels = merge_string_lists(\u0026base.labels, \u0026ours.labels, \u0026theirs.labels);\n\n    // target_files: merge both lists, deduplicate\n    result.target_files =\n        merge_string_lists(\u0026base.target_files, \u0026ours.target_files, \u0026theirs.target_files);\n\n    // context: merge both lists, deduplicate\n    result.context = merge_string_lists(\u0026base.context, \u0026ours.context, \u0026theirs.context);\n\n    // members: merge both lists, deduplicate\n    result.members = merge_string_lists(\u0026base.members, \u0026ours.members, \u0026theirs.members);\n\n    // Verification fields: prefer theirs (from finalize) if present\n    if result.last_verified.is_none() \u0026\u0026 theirs.last_verified.is_some() {\n        result.last_verified = theirs.last_verified.clone();\n    }\n    if result.verification_status.is_none() \u0026\u0026 theirs.verification_status.is_some() {\n        result.verification_status = theirs.verification_status.clone();\n    }\n    if result.verification_failures.is_none() \u0026\u0026 theirs.verification_failures.is_some() {\n        result.verification_failures = theirs.verification_failures.clone();\n    }\n\n    // Replay fields: prefer ours\n    if result.replayed_at.is_none() \u0026\u0026 theirs.replayed_at.is_some() {\n        result.replayed_at = theirs.replayed_at.clone();\n    }\n    if result.replay_count.is_none() \u0026\u0026 theirs.replay_count.is_some() {\n        result.replay_count = theirs.replay_count;\n    }\n    if result.original_completed_at.is_none() \u0026\u0026 theirs.original_completed_at.is_some() {\n        result.original_completed_at = theirs.original_completed_at.clone();\n    }\n\n    result\n}\n\n/// Merge status fields, preferring the more \"advanced\" status\nfn merge_status(_base: \u0026SpecStatus, ours: \u0026SpecStatus, theirs: \u0026SpecStatus) -\u003e SpecStatus {\n    // Status priority (higher is more \"advanced\"):\n    // Cancelled \u003c Failed \u003c NeedsAttention \u003c Blocked \u003c Pending \u003c Ready \u003c InProgress \u003c Completed\n    let priority = |s: \u0026SpecStatus| -\u003e u8 {\n        match s {\n            SpecStatus::Cancelled =\u003e 0,\n            SpecStatus::Failed =\u003e 1,\n            SpecStatus::NeedsAttention =\u003e 2,\n            SpecStatus::Blocked =\u003e 3,\n            SpecStatus::Pending =\u003e 4,\n            SpecStatus::Ready =\u003e 5,\n            SpecStatus::Paused =\u003e 6,\n            SpecStatus::InProgress =\u003e 7,\n            SpecStatus::Completed =\u003e 8,\n        }\n    };\n\n    let ours_priority = priority(ours);\n    let theirs_priority = priority(theirs);\n\n    // If both changed from base, prefer the higher priority\n    if ours_priority \u003e= theirs_priority {\n        ours.clone()\n    } else {\n        theirs.clone()\n    }\n}\n\n/// Merge commit lists, deduplicating entries\nfn merge_commits(\n    _base: \u0026Option\u003cVec\u003cString\u003e\u003e,\n    ours: \u0026Option\u003cVec\u003cString\u003e\u003e,\n    theirs: \u0026Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n    match (ours, theirs) {\n        (Some(o), Some(t)) =\u003e {\n            let mut result: Vec\u003cString\u003e = o.clone();\n            for commit in t {\n                if !result.contains(commit) {\n                    result.push(commit.clone());\n                }\n            }\n            if result.is_empty() {\n                None\n            } else {\n                Some(result)\n            }\n        }\n        (Some(o), None) =\u003e Some(o.clone()),\n        (None, Some(t)) =\u003e Some(t.clone()),\n        (None, None) =\u003e None,\n    }\n}\n\n/// Merge string lists, deduplicating entries\nfn merge_string_lists(\n    _base: \u0026Option\u003cVec\u003cString\u003e\u003e,\n    ours: \u0026Option\u003cVec\u003cString\u003e\u003e,\n    theirs: \u0026Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n    match (ours, theirs) {\n        (Some(o), Some(t)) =\u003e {\n            let mut result: Vec\u003cString\u003e = o.clone();\n            for item in t {\n                if !result.contains(item) {\n                    result.push(item.clone());\n                }\n            }\n            if result.is_empty() {\n                None\n            } else {\n                Some(result)\n            }\n        }\n        (Some(o), None) =\u003e Some(o.clone()),\n        (None, Some(t)) =\u003e Some(t.clone()),\n        (None, None) =\u003e None,\n    }\n}\n\n/// Merge body content using git's 3-way merge\n///\n/// Returns Ok(merged_body) if merge succeeded, or Err with conflict markers\npub fn merge_body(base: \u0026str, ours: \u0026str, theirs: \u0026str) -\u003e Result\u003cString\u003e {\n    // If base and ours are the same, take theirs\n    if base.trim() == ours.trim() {\n        return Ok(theirs.to_string());\n    }\n    // If base and theirs are the same, take ours\n    if base.trim() == theirs.trim() {\n        return Ok(ours.to_string());\n    }\n    // If ours and theirs are the same, take ours\n    if ours.trim() == theirs.trim() {\n        return Ok(ours.to_string());\n    }\n\n    // Write to temporary files and use git merge-file\n    let temp_dir = tempfile::tempdir().context(\"Failed to create temp directory\")?;\n    let base_path = temp_dir.path().join(\"base\");\n    let ours_path = temp_dir.path().join(\"ours\");\n    let theirs_path = temp_dir.path().join(\"theirs\");\n\n    fs::write(\u0026base_path, base).context(\"Failed to write base file\")?;\n    fs::write(\u0026ours_path, ours).context(\"Failed to write ours file\")?;\n    fs::write(\u0026theirs_path, theirs).context(\"Failed to write theirs file\")?;\n\n    // Run git merge-file\n    let output = Command::new(\"git\")\n        .args([\n            \"merge-file\",\n            \"-p\", // Write to stdout instead of overwriting\n            ours_path.to_str().unwrap(),\n            base_path.to_str().unwrap(),\n            theirs_path.to_str().unwrap(),\n        ])\n        .output()\n        .context(\"Failed to run git merge-file\")?;\n\n    let merged = String::from_utf8_lossy(\u0026output.stdout).to_string();\n\n    // Exit code 0 = clean merge, \u003e0 = conflicts (but content is still usable)\n    // We return the merged content either way, as it contains conflict markers if needed\n    Ok(merged)\n}\n\n/// Serialize frontmatter back to YAML string\npub fn serialize_frontmatter(frontmatter: \u0026SpecFrontmatter) -\u003e Result\u003cString\u003e {\n    serde_yaml::to_string(frontmatter).context(\"Failed to serialize frontmatter\")\n}\n\n/// Assemble a spec file from frontmatter and body\npub fn assemble_spec(frontmatter: \u0026SpecFrontmatter, body: \u0026str) -\u003e Result\u003cString\u003e {\n    let frontmatter_yaml = serialize_frontmatter(frontmatter)?;\n    Ok(format!(\"---\\n{}---\\n{}\", frontmatter_yaml, body))\n}\n\n/// Run the merge driver\n///\n/// This is the main entry point called by git.\n/// Arguments:\n/// - base_path: Path to the common ancestor version (%O)\n/// - ours_path: Path to our version (%A) - this is also where we write the result\n/// - theirs_path: Path to their version (%B)\n///\n/// Returns:\n/// - 0 (Ok) if merge succeeded\n/// - 1 (Err) if there are conflicts\npub fn run_merge_driver(base_path: \u0026Path, ours_path: \u0026Path, theirs_path: \u0026Path) -\u003e Result\u003cbool\u003e {\n    // Read all three versions\n    let base_content = fs::read_to_string(base_path)\n        .with_context(|| format!(\"Failed to read base file: {}\", base_path.display()))?;\n    let ours_content = fs::read_to_string(ours_path)\n        .with_context(|| format!(\"Failed to read ours file: {}\", ours_path.display()))?;\n    let theirs_content = fs::read_to_string(theirs_path)\n        .with_context(|| format!(\"Failed to read theirs file: {}\", theirs_path.display()))?;\n\n    // Parse all three\n    let base = parse_spec_file(\u0026base_content)?;\n    let ours = parse_spec_file(\u0026ours_content)?;\n    let theirs = parse_spec_file(\u0026theirs_content)?;\n\n    // Merge frontmatter\n    let merged_frontmatter =\n        merge_frontmatter(\u0026base.frontmatter, \u0026ours.frontmatter, \u0026theirs.frontmatter);\n\n    // Merge body\n    let merged_body = merge_body(\u0026base.body, \u0026ours.body, \u0026theirs.body)?;\n\n    // Check for conflict markers in body\n    let has_conflicts = merged_body.contains(\"\u003c\u003c\u003c\u003c\u003c\u003c\u003c\")\n        || merged_body.contains(\"=======\")\n        || merged_body.contains(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\");\n\n    // Assemble result\n    let result = assemble_spec(\u0026merged_frontmatter, \u0026merged_body)?;\n\n    // Write result to ours_path (git expects us to modify this file)\n    fs::write(ours_path, result)\n        .with_context(|| format!(\"Failed to write result to: {}\", ours_path.display()))?;\n\n    Ok(!has_conflicts)\n}\n\n/// Generate git configuration instructions for the merge driver\npub fn get_setup_instructions() -\u003e String {\n    r#\"# Chant Spec Merge Driver Setup\n\n## Step 1: Add .gitattributes entry\n\nAdd to your `.gitattributes` file (or create one):\n\n```\n.chant/specs/*.md merge=chant-spec\n```\n\n## Step 2: Configure git merge driver\n\nRun these commands in your repository:\n\n```bash\n# Configure the merge driver\ngit config merge.chant-spec.name \"Chant spec merge driver\"\ngit config merge.chant-spec.driver \"chant merge-driver %O %A %B\"\n```\n\nOr add to your `.git/config`:\n\n```ini\n[merge \"chant-spec\"]\n    name = Chant spec merge driver\n    driver = chant merge-driver %O %A %B\n```\n\n## How it works\n\nThe merge driver intelligently handles spec file merges by:\n\n1. **Frontmatter conflicts**: Automatically resolved\n   - `status`: Prefers more \"advanced\" status (completed \u003e in_progress \u003e pending)\n   - `completed_at`, `model`: Takes values from either side\n   - `commits`: Merges both lists, deduplicates\n\n2. **Body conflicts**: Uses standard 3-way merge\n   - Shows conflict markers if both sides changed same section\n\nThis prevents the common issue where `git checkout --theirs` discards\nimplementation code while keeping wrong metadata.\n\"#\n    .to_string()\n}\n\n/// Result of setting up the merge driver\n#[derive(Debug, Clone)]\npub struct MergeDriverSetupResult {\n    /// Whether the git config was set up (false if not in a git repo)\n    pub git_config_set: bool,\n    /// Whether .gitattributes was created/updated\n    pub gitattributes_updated: bool,\n    /// Any warning message (e.g., \"not in a git repository\")\n    pub warning: Option\u003cString\u003e,\n}\n\n/// Set up the merge driver for the current repository\n///\n/// This function:\n/// 1. Configures git with the merge driver settings (if in a git repo)\n/// 2. Creates/updates .gitattributes with the merge pattern\n///\n/// Returns a result indicating what was set up, or an error if something failed.\npub fn setup_merge_driver() -\u003e Result\u003cMergeDriverSetupResult\u003e {\n    let mut result = MergeDriverSetupResult {\n        git_config_set: false,\n        gitattributes_updated: false,\n        warning: None,\n    };\n\n    // Check if we're in a git repository\n    let in_git_repo = Command::new(\"git\")\n        .args([\"rev-parse\", \"--git-dir\"])\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false);\n\n    if in_git_repo {\n        // Configure the merge driver name\n        let name_result = Command::new(\"git\")\n            .args([\"config\", \"merge.chant-spec.name\", \"Chant spec merge driver\"])\n            .output();\n\n        // Configure the merge driver command\n        let driver_result = Command::new(\"git\")\n            .args([\n                \"config\",\n                \"merge.chant-spec.driver\",\n                \"chant merge-driver %O %A %B\",\n            ])\n            .output();\n\n        // Check if both commands succeeded\n        match (name_result, driver_result) {\n            (Ok(name_out), Ok(driver_out))\n                if name_out.status.success() \u0026\u0026 driver_out.status.success() =\u003e\n            {\n                result.git_config_set = true;\n            }\n            _ =\u003e {\n                result.warning = Some(\"Failed to configure git merge driver\".to_string());\n            }\n        }\n    } else {\n        result.warning = Some(\"Not in a git repository - merge driver config skipped\".to_string());\n    }\n\n    // Create/update .gitattributes (this works even without git)\n    let gitattributes_path = std::path::Path::new(\".gitattributes\");\n    let merge_pattern = \".chant/specs/*.md merge=chant-spec\";\n\n    if gitattributes_path.exists() {\n        // Check if the pattern already exists\n        let content =\n            fs::read_to_string(gitattributes_path).context(\"Failed to read .gitattributes\")?;\n\n        if !content.contains(merge_pattern) {\n            // Append the pattern\n            let mut new_content = content;\n            if !new_content.ends_with('\\n') \u0026\u0026 !new_content.is_empty() {\n                new_content.push('\\n');\n            }\n            new_content.push_str(\"\\n# Chant spec files use a custom merge driver for intelligent conflict resolution\\n\");\n            new_content.push_str(merge_pattern);\n            new_content.push('\\n');\n            fs::write(gitattributes_path, new_content)\n                .context(\"Failed to update .gitattributes\")?;\n            result.gitattributes_updated = true;\n        }\n        // If pattern already exists, gitattributes_updated stays false (already configured)\n    } else {\n        // Create new .gitattributes file\n        let content = format!(\n            \"# Chant spec files use a custom merge driver for intelligent conflict resolution\\n# This driver automatically resolves frontmatter conflicts while preserving implementation content\\n#\\n# The merge driver is configured automatically by `chant init`\\n{}\\n\",\n            merge_pattern\n        );\n        fs::write(gitattributes_path, content).context(\"Failed to create .gitattributes\")?;\n        result.gitattributes_updated = true;\n    }\n\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_spec_file_basic() {\n        let content = r#\"---\ntype: code\nstatus: pending\n---\n# Test Spec\n\nBody content here.\n\"#;\n        let result = parse_spec_file(content).unwrap();\n        assert_eq!(result.frontmatter.status, SpecStatus::Pending);\n        assert!(result.body.contains(\"# Test Spec\"));\n        assert!(result.body.contains(\"Body content here.\"));\n    }\n\n    #[test]\n    fn test_parse_spec_file_with_all_fields() {\n        let content = r#\"---\ntype: code\nstatus: completed\ncommits:\n  - abc123\n  - def456\ncompleted_at: 2026-01-27T10:00:00Z\nmodel: claude-opus-4-5\n---\n# Completed Spec\n\nImplementation details.\n\"#;\n        let result = parse_spec_file(content).unwrap();\n        assert_eq!(result.frontmatter.status, SpecStatus::Completed);\n        assert_eq!(\n            result.frontmatter.model,\n            Some(\"claude-opus-4-5\".to_string())\n        );\n        assert_eq!(\n            result.frontmatter.commits,\n            Some(vec![\"abc123\".to_string(), \"def456\".to_string()])\n        );\n    }\n\n    #[test]\n    fn test_merge_status_prefers_completed() {\n        let base = SpecStatus::Pending;\n        let ours = SpecStatus::InProgress;\n        let theirs = SpecStatus::Completed;\n\n        let result = merge_status(\u0026base, \u0026ours, \u0026theirs);\n        assert_eq!(result, SpecStatus::Completed);\n    }\n\n    #[test]\n    fn test_merge_status_prefers_in_progress_over_pending() {\n        let base = SpecStatus::Pending;\n        let ours = SpecStatus::InProgress;\n        let theirs = SpecStatus::Pending;\n\n        let result = merge_status(\u0026base, \u0026ours, \u0026theirs);\n        assert_eq!(result, SpecStatus::InProgress);\n    }\n\n    #[test]\n    fn test_merge_commits_deduplicates() {\n        let base = Some(vec![\"abc\".to_string()]);\n        let ours = Some(vec![\"abc\".to_string(), \"def\".to_string()]);\n        let theirs = Some(vec![\"abc\".to_string(), \"ghi\".to_string()]);\n\n        let result = merge_commits(\u0026base, \u0026ours, \u0026theirs);\n        let result = result.unwrap();\n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026\"abc\".to_string()));\n        assert!(result.contains(\u0026\"def\".to_string()));\n        assert!(result.contains(\u0026\"ghi\".to_string()));\n    }\n\n    #[test]\n    fn test_merge_frontmatter_takes_completed_at_from_theirs() {\n        let base = SpecFrontmatter::default();\n        let ours = SpecFrontmatter {\n            status: SpecStatus::InProgress,\n            ..Default::default()\n        };\n        let theirs = SpecFrontmatter {\n            status: SpecStatus::Completed,\n            completed_at: Some(\"2026-01-27T10:00:00Z\".to_string()),\n            model: Some(\"claude-opus-4-5\".to_string()),\n            ..Default::default()\n        };\n\n        let result = merge_frontmatter(\u0026base, \u0026ours, \u0026theirs);\n        assert_eq!(result.status, SpecStatus::Completed);\n        assert_eq!(\n            result.completed_at,\n            Some(\"2026-01-27T10:00:00Z\".to_string())\n        );\n        assert_eq!(result.model, Some(\"claude-opus-4-5\".to_string()));\n    }\n\n    #[test]\n    fn test_merge_body_takes_ours_when_theirs_unchanged() {\n        let base = \"Original content\";\n        let ours = \"Modified content\";\n        let theirs = \"Original content\";\n\n        let result = merge_body(base, ours, theirs).unwrap();\n        assert_eq!(result, \"Modified content\");\n    }\n\n    #[test]\n    fn test_merge_body_takes_theirs_when_ours_unchanged() {\n        let base = \"Original content\";\n        let ours = \"Original content\";\n        let theirs = \"Modified content\";\n\n        let result = merge_body(base, ours, theirs).unwrap();\n        assert_eq!(result, \"Modified content\");\n    }\n\n    #[test]\n    fn test_assemble_spec() {\n        let frontmatter = SpecFrontmatter {\n            status: SpecStatus::Completed,\n            ..Default::default()\n        };\n        let body = \"# Test\\n\\nContent here.\";\n\n        let result = assemble_spec(\u0026frontmatter, body).unwrap();\n        assert!(result.starts_with(\"---\\n\"));\n        assert!(result.contains(\"status: completed\"));\n        assert!(result.contains(\"---\\n# Test\"));\n        assert!(result.contains(\"Content here.\"));\n    }\n\n    #[test]\n    fn test_merge_string_lists_deduplicates() {\n        let base: Option\u003cVec\u003cString\u003e\u003e = None;\n        let ours = Some(vec![\"a\".to_string(), \"b\".to_string()]);\n        let theirs = Some(vec![\"b\".to_string(), \"c\".to_string()]);\n\n        let result = merge_string_lists(\u0026base, \u0026ours, \u0026theirs).unwrap();\n        assert_eq!(result.len(), 3);\n        assert!(result.contains(\u0026\"a\".to_string()));\n        assert!(result.contains(\u0026\"b\".to_string()));\n        assert!(result.contains(\u0026\"c\".to_string()));\n    }\n\n    #[test]\n    fn test_real_world_scenario() {\n        // Simulate the exact conflict scenario from the spec:\n        // - Main has status: completed (from finalize)\n        // - Feature branch has status: in_progress\n        // - Main has completed_at and model fields\n\n        let base_content = r#\"---\ntype: code\nstatus: pending\n---\n# Implement feature X\n\n## Problem\n\nDescription of the problem.\n\n## Acceptance Criteria\n\n- [ ] Feature X implemented\n- [ ] Tests passing\n\"#;\n\n        let ours_content = r#\"---\ntype: code\nstatus: in_progress\ncommits:\n  - abc123\n---\n# Implement feature X\n\n## Problem\n\nDescription of the problem.\n\n## Solution\n\nHere's how we solved it...\n\n## Acceptance Criteria\n\n- [x] Feature X implemented\n- [x] Tests passing\n\"#;\n\n        let theirs_content = r#\"---\ntype: code\nstatus: completed\ncompleted_at: 2026-01-27T15:00:00Z\nmodel: claude-opus-4-5\ncommits:\n  - def456\n---\n# Implement feature X\n\n## Problem\n\nDescription of the problem.\n\n## Acceptance Criteria\n\n- [ ] Feature X implemented\n- [ ] Tests passing\n\"#;\n\n        let base = parse_spec_file(base_content).unwrap();\n        let ours = parse_spec_file(ours_content).unwrap();\n        let theirs = parse_spec_file(theirs_content).unwrap();\n\n        // Merge frontmatter\n        let merged_fm =\n            merge_frontmatter(\u0026base.frontmatter, \u0026ours.frontmatter, \u0026theirs.frontmatter);\n\n        // Should get completed status (higher priority)\n        assert_eq!(merged_fm.status, SpecStatus::Completed);\n        // Should get completed_at from theirs\n        assert_eq!(\n            merged_fm.completed_at,\n            Some(\"2026-01-27T15:00:00Z\".to_string())\n        );\n        // Should get model from theirs\n        assert_eq!(merged_fm.model, Some(\"claude-opus-4-5\".to_string()));\n        // Should have both commits merged\n        let commits = merged_fm.commits.unwrap();\n        assert!(commits.contains(\u0026\"abc123\".to_string()));\n        assert!(commits.contains(\u0026\"def456\".to_string()));\n\n        // Merge body - ours has the implementation, so it should be preserved\n        let merged_body = merge_body(\u0026base.body, \u0026ours.body, \u0026theirs.body).unwrap();\n\n        // The merged body should have our solution section\n        assert!(\n            merged_body.contains(\"## Solution\") || merged_body.contains(\"Here's how we solved it\")\n        );\n        // And our checked checkboxes (or at least not revert to unchecked without conflict)\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":15}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":10}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":10}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":10}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":8}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":18}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":5}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":8}},{"line":233,"address":[],"length":0,"stats":{"Line":3}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":4}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}}],"covered":71,"coverable":197},{"path":["/","Users","alex","Documents","checkouts","chant","src","merge_errors.rs"],"content":"//! Actionable error messages for merge operations.\n//!\n//! Provides structured error messages with context, diagnosis,\n//! and concrete next steps to help users recover from merge failures.\n\n/// Format a fast-forward merge failure with actionable next steps.\n///\n/// Used when branches have diverged and a fast-forward-only merge cannot proceed.\npub fn fast_forward_conflict(\n    spec_id: \u0026str,\n    spec_branch: \u0026str,\n    main_branch: \u0026str,\n    stderr: \u0026str,\n) -\u003e String {\n    format!(\n        \"Error: Cannot fast-forward merge for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Target: {}\\n\\\n         \\x20 - Branches have diverged from common ancestor\\n\\\n         \\x20 - Git output: {}\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Use no-fast-forward merge:  chant merge {} --no-ff\\n\\\n         \\x20 2. Or rebase onto {}:  chant merge {} --rebase\\n\\\n         \\x20 3. Or merge manually:  git merge --no-ff {}\\n\\\n         \\x20 4. Debug divergence:  git log {} --oneline -5\\n\\n\\\n         Tip: Use 'chant merge --help' for all available options\",\n        spec_id,\n        spec_branch,\n        main_branch,\n        stderr.trim(),\n        spec_id,\n        main_branch,\n        spec_id,\n        spec_branch,\n        spec_branch\n    )\n}\n\n/// Format a merge conflict error with recovery steps.\n///\n/// Used when git detects actual content conflicts during merge.\npub fn merge_conflict(spec_id: \u0026str, spec_branch: \u0026str, main_branch: \u0026str) -\u003e String {\n    format!(\n        \"Error: Merge conflicts detected for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Target: {}\\n\\\n         \\x20 - Conflicting changes exist between branches\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - The spec branch and {} have conflicting changes\\n\\\n         \\x20 - Merge was aborted to preserve both branches\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Auto-resolve conflicts:  chant merge {} --rebase --auto\\n\\\n         \\x20 2. Rebase first, then merge:  chant merge {} --rebase\\n\\\n         \\x20 3. Manual merge:  git merge --no-ff {}\\n\\\n         \\x20 4. Inspect conflicts:  git diff {} {}\\n\\\n         \\x20 5. View branch history:  git log {} --oneline -5\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id,\n        spec_branch,\n        main_branch,\n        main_branch,\n        spec_id,\n        spec_id,\n        spec_branch,\n        main_branch,\n        spec_branch,\n        spec_branch\n    )\n}\n\n/// Format a spec branch not found error.\npub fn branch_not_found(spec_id: \u0026str, spec_branch: \u0026str) -\u003e String {\n    format!(\n        \"Error: Spec branch '{}' not found for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Expected branch: {}\\n\\\n         \\x20 - The branch may have been deleted or never created\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - Check if the spec was worked in branch mode\\n\\\n         \\x20 - The branch may have been cleaned up after a previous merge\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. List all chant branches:  git branch --list 'chant/*'\\n\\\n         \\x20 2. Check worktree status:  git worktree list\\n\\\n         \\x20 3. If branch existed, check reflog:  git reflog --all\\n\\\n         \\x20 4. If work was lost, re-execute:  chant work {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_branch, spec_id, spec_branch, spec_id\n    )\n}\n\n/// Format a main branch not found error.\npub fn main_branch_not_found(main_branch: \u0026str) -\u003e String {\n    format!(\n        \"Error: Main branch '{}' does not exist\\n\\n\\\n         Context:\\n\\\n         \\x20 - Expected main branch: {}\\n\\\n         \\x20 - This is typically 'main' or 'master'\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - The repository may use a different default branch name\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Check available branches:  git branch -a\\n\\\n         \\x20 2. Check remote default:  git remote show origin | grep 'HEAD branch'\\n\\\n         \\x20 3. If using a different name, configure it in .chant/config.md\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        main_branch, main_branch\n    )\n}\n\n/// Format a failed spec merge error with status context.\npub fn spec_status_not_mergeable(spec_id: \u0026str, status: \u0026str) -\u003e String {\n    format!(\n        \"Error: Cannot merge spec {} (status: {})\\n\\n\\\n         Context:\\n\\\n         \\x20 - Spec: {}\\n\\\n         \\x20 - Current status: {}\\n\\\n         \\x20 - Only completed specs can be merged\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Check spec details:  chant show {}\\n\\\n         \\x20 2. If work is done, finalize first:  chant finalize {}\\n\\\n         \\x20 3. If needs attention, resolve issues and retry\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id, status, spec_id, status, spec_id, spec_id\n    )\n}\n\n/// Format a no-branch-found error for a completed spec.\npub fn no_branch_for_spec(spec_id: \u0026str) -\u003e String {\n    format!(\n        \"Error: No branch found for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Spec: {}\\n\\\n         \\x20 - The spec is completed but has no associated branch\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - The spec may have been worked in direct mode (no separate branch)\\n\\\n         \\x20 - The branch may have been deleted after a previous merge\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Check for existing branches:  git branch --list 'chant/*{}*'\\n\\\n         \\x20 2. Check if already merged:  git log --oneline --grep='chant({})'\\n\\\n         \\x20 3. If not merged and branch lost, re-execute:  chant work {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id, spec_id, spec_id, spec_id, spec_id\n    )\n}\n\n/// Format a worktree conflict error when a worktree already exists.\npub fn worktree_already_exists(spec_id: \u0026str, worktree_path: \u0026str, branch: \u0026str) -\u003e String {\n    format!(\n        \"Error: Worktree already exists for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Worktree path: {}\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - A worktree at this path is already in use\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - A previous execution may not have cleaned up properly\\n\\\n         \\x20 - The worktree may still be in use by another process\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Clean up stale worktrees:  chant cleanup --worktrees\\n\\\n         \\x20 2. Or remove manually:  git worktree remove {} --force\\n\\\n         \\x20 3. List all worktrees:  git worktree list\\n\\\n         \\x20 4. Then retry:  chant work {}\\n\\n\\\n         Documentation: See 'chant cleanup --help' for more options\",\n        spec_id, worktree_path, branch, worktree_path, spec_id\n    )\n}\n\n/// Format a no-commits-found error with branch diagnostic info.\npub fn no_commits_found(spec_id: \u0026str, branch: \u0026str) -\u003e String {\n    format!(\n        \"Error: No commits found matching pattern 'chant({}):'\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Expected pattern: 'chant({}): \u003cdescription\u003e'\\n\\n\\\n         Diagnosis:\\n\\\n         \\x20 - The agent may have forgotten to commit with the correct pattern\\n\\\n         \\x20 - Commit messages must include 'chant({}):' prefix\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Check commits on branch:  git log {} --oneline\\n\\\n         \\x20 2. If commits exist but wrong pattern, amend or merge manually\\n\\\n         \\x20 3. If no work was done, the branch may be empty\\n\\\n         \\x20 4. Use --allow-no-commits as fallback (special cases only)\\n\\n\\\n         Debugging: Report this if commits look correct - may be a pattern matching bug\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id, branch, spec_id, spec_id, branch\n    )\n}\n\n/// Format a driver spec member incomplete error.\npub fn driver_members_incomplete(driver_id: \u0026str, incomplete: \u0026[String]) -\u003e String {\n    format!(\n        \"Error: Cannot merge driver spec {} - members are incomplete\\n\\n\\\n         Context:\\n\\\n         \\x20 - Driver spec: {}\\n\\\n         \\x20 - All member specs must be completed before merging the driver\\n\\n\\\n         Incomplete members:\\n\\\n         \\x20 - {}\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Check each incomplete member:  chant show \u003cmember-id\u003e\\n\\\n         \\x20 2. Complete or cancel pending members\\n\\\n         \\x20 3. Retry driver merge:  chant merge {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        driver_id,\n        driver_id,\n        incomplete.join(\"\\n  - \"),\n        driver_id\n    )\n}\n\n/// Format a member spec merge failure within a driver merge.\npub fn member_merge_failed(driver_id: \u0026str, member_id: \u0026str, error: \u0026str) -\u003e String {\n    format!(\n        \"Error: Member spec merge failed, driver merge not attempted\\n\\n\\\n         Context:\\n\\\n         \\x20 - Driver spec: {}\\n\\\n         \\x20 - Failed member: {}\\n\\\n         \\x20 - Error: {}\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Resolve the member merge issue first\\n\\\n         \\x20 2. Merge the member manually:  chant merge {}\\n\\\n         \\x20 3. Then retry the driver merge:  chant merge {}\\n\\\n         \\x20 4. Or use rebase:  chant merge {} --rebase\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        driver_id, member_id, error, member_id, driver_id, member_id\n    )\n}\n\n/// Format a generic merge failure in the merge summary with next steps.\npub fn generic_merge_failed(spec_id: \u0026str, branch: \u0026str, main_branch: \u0026str, error: \u0026str) -\u003e String {\n    format!(\n        \"Error: Merge failed for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Target: {}\\n\\\n         \\x20 - Error: {}\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Try with rebase:  chant merge {} --rebase\\n\\\n         \\x20 2. Or auto-resolve:  chant merge {} --rebase --auto\\n\\\n         \\x20 3. Manual merge:  git merge --no-ff {}\\n\\\n         \\x20 4. Debug:  git log {} --oneline -5\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id,\n        branch,\n        main_branch,\n        error.trim(),\n        spec_id,\n        spec_id,\n        branch,\n        branch\n    )\n}\n\n/// Format a rebase conflict error with recovery steps.\npub fn rebase_conflict(spec_id: \u0026str, branch: \u0026str, conflicting_files: \u0026[String]) -\u003e String {\n    format!(\n        \"Error: Rebase conflict for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Conflicting files:\\n\\\n         \\x20   - {}\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Auto-resolve:  chant merge {} --rebase --auto\\n\\\n         \\x20 2. Resolve manually, then:  git rebase --continue\\n\\\n         \\x20 3. Abort rebase:  git rebase --abort\\n\\\n         \\x20 4. Try direct merge instead:  git merge --no-ff {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id,\n        branch,\n        conflicting_files.join(\"\\n    - \"),\n        spec_id,\n        branch\n    )\n}\n\n/// Format a merge stopped error when --continue-on-error is not set.\npub fn merge_stopped(spec_id: \u0026str) -\u003e String {\n    format!(\n        \"Error: Merge stopped at spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Processing halted due to merge failure\\n\\\n         \\x20 - Remaining specs were not processed\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Resolve the issue with spec {}:  chant show {}\\n\\\n         \\x20 2. Retry with continue-on-error:  chant merge --all --continue-on-error\\n\\\n         \\x20 3. Or merge specs individually:  chant merge {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id, spec_id, spec_id, spec_id\n    )\n}\n\n/// Format a rebase stopped error with --auto suggestion.\npub fn rebase_stopped(spec_id: \u0026str) -\u003e String {\n    format!(\n        \"Error: Merge stopped at spec {} due to rebase conflict\\n\\n\\\n         Context:\\n\\\n         \\x20 - Rebase encountered conflicts\\n\\\n         \\x20 - Remaining specs were not processed\\n\\n\\\n         Next Steps:\\n\\\n         \\x20 1. Auto-resolve conflicts:  chant merge {} --rebase --auto\\n\\\n         \\x20 2. Use continue-on-error:  chant merge --all --rebase --continue-on-error\\n\\\n         \\x20 3. Resolve manually and retry\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        spec_id, spec_id\n    )\n}\n\n/// Conflict type classification for merge operations.\n#[derive(Debug, Clone, PartialEq)]\npub enum ConflictType {\n    /// Fast-forward is not possible - branches have diverged\n    FastForward,\n    /// Content conflicts - same lines modified in both branches\n    Content,\n    /// Tree conflicts - file renamed/deleted in one branch, modified in another\n    Tree,\n    /// Unknown conflict type\n    Unknown,\n}\n\nimpl std::fmt::Display for ConflictType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ConflictType::FastForward =\u003e write!(f, \"fast-forward\"),\n            ConflictType::Content =\u003e write!(f, \"content\"),\n            ConflictType::Tree =\u003e write!(f, \"tree\"),\n            ConflictType::Unknown =\u003e write!(f, \"unknown\"),\n        }\n    }\n}\n\n/// Detailed merge conflict error with file list and recovery steps.\n///\n/// Used when git detects content or tree conflicts during merge.\npub fn merge_conflict_detailed(\n    spec_id: \u0026str,\n    spec_branch: \u0026str,\n    main_branch: \u0026str,\n    conflict_type: ConflictType,\n    conflicting_files: \u0026[String],\n) -\u003e String {\n    let conflict_type_str = match conflict_type {\n        ConflictType::FastForward =\u003e \"Cannot fast-forward\",\n        ConflictType::Content =\u003e \"Content conflicts detected\",\n        ConflictType::Tree =\u003e \"Tree conflicts detected\",\n        ConflictType::Unknown =\u003e \"Merge conflicts detected\",\n    };\n\n    let files_section = if conflicting_files.is_empty() {\n        \"  (unable to determine conflicting files)\".to_string()\n    } else {\n        conflicting_files\n            .iter()\n            .map(|f| format!(\"  - {}\", f))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\")\n    };\n\n    let recovery_steps = match conflict_type {\n        ConflictType::FastForward =\u003e format!(\n            \"Next steps:\\n\\\n             \\x20 1. Use no-fast-forward merge:  chant merge {} --no-ff\\n\\\n             \\x20 2. Or rebase onto {}:  chant merge {} --rebase\\n\\\n             \\x20 3. Or merge manually:  git merge --no-ff {}\",\n            spec_id, main_branch, spec_id, spec_branch\n        ),\n        ConflictType::Content | ConflictType::Tree | ConflictType::Unknown =\u003e format!(\n            \"Next steps:\\n\\\n             \\x20 1. Resolve conflicts manually, then:  git merge --continue\\n\\\n             \\x20 2. Or try automatic rebase:  chant merge {} --rebase --auto\\n\\\n             \\x20 3. Or abort:  git merge --abort\\n\\n\\\n             Example (resolve manually):\\n\\\n             \\x20 $ git status                    # see conflicting files\\n\\\n             \\x20 $ vim src/main.rs               # edit to resolve\\n\\\n             \\x20 $ git add src/main.rs           # stage resolved file\\n\\\n             \\x20 $ git merge --continue          # complete merge\",\n            spec_id\n        ),\n    };\n\n    format!(\n        \"Error: {} for spec {}\\n\\n\\\n         Context:\\n\\\n         \\x20 - Branch: {}\\n\\\n         \\x20 - Target: {}\\n\\\n         \\x20 - Conflict type: {}\\n\\n\\\n         Files with conflicts:\\n\\\n         {}\\n\\n\\\n         {}\\n\\n\\\n         Documentation: See 'chant merge --help' for more options\",\n        conflict_type_str,\n        spec_id,\n        spec_branch,\n        main_branch,\n        conflict_type,\n        files_section,\n        recovery_steps\n    )\n}\n\n/// Classify merge conflict type from git output.\n///\n/// Analyzes git merge stderr and status output to determine the type of conflict.\npub fn classify_conflict_type(stderr: \u0026str, status_output: Option\u003c\u0026str\u003e) -\u003e ConflictType {\n    let stderr_lower = stderr.to_lowercase();\n\n    // Check for fast-forward conflicts\n    if stderr_lower.contains(\"not possible to fast-forward\")\n        || stderr_lower.contains(\"cannot fast-forward\")\n        || stderr_lower.contains(\"refusing to merge unrelated histories\")\n    {\n        return ConflictType::FastForward;\n    }\n\n    // Check for tree conflicts (rename/delete conflicts)\n    if stderr_lower.contains(\"conflict (rename/delete)\")\n        || stderr_lower.contains(\"conflict (modify/delete)\")\n        || stderr_lower.contains(\"deleted in\")\n        || stderr_lower.contains(\"renamed in\")\n        || stderr_lower.contains(\"conflict (add/add)\")\n    {\n        return ConflictType::Tree;\n    }\n\n    // Check git status for conflict markers if available\n    if let Some(status) = status_output {\n        // Tree conflicts show as DD, AU, UD, UA, DU in status\n        if status.lines().any(|line| {\n            let prefix = line.get(..2).unwrap_or(\"\");\n            matches!(prefix, \"DD\" | \"AU\" | \"UD\" | \"UA\" | \"DU\")\n        }) {\n            return ConflictType::Tree;\n        }\n\n        // Content conflicts show as UU or AA in status\n        if status.lines().any(|line| {\n            let prefix = line.get(..2).unwrap_or(\"\");\n            matches!(prefix, \"UU\" | \"AA\")\n        }) {\n            return ConflictType::Content;\n        }\n    }\n\n    // Check for general merge conflicts\n    if stderr_lower.contains(\"conflict\") || stderr_lower.contains(\"merge conflict\") {\n        return ConflictType::Content;\n    }\n\n    ConflictType::Unknown\n}\n\n/// Parse conflicting files from git status --porcelain output.\n///\n/// Returns a list of files that have conflict markers.\npub fn parse_conflicting_files(status_output: \u0026str) -\u003e Vec\u003cString\u003e {\n    let mut files = Vec::new();\n\n    for line in status_output.lines() {\n        if line.len() \u003e= 3 {\n            let status = \u0026line[0..2];\n            // Conflict markers: UU, AA, DD, AU, UD, UA, DU\n            if status.contains('U') || status == \"AA\" || status == \"DD\" {\n                let file = line[3..].trim();\n                files.push(file.to_string());\n            }\n        }\n    }\n\n    files\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fast_forward_conflict_contains_spec_id() {\n        let msg = fast_forward_conflict(\n            \"001-abc\",\n            \"chant/001-abc\",\n            \"main\",\n            \"fatal: cannot fast-forward\",\n        );\n        assert!(msg.contains(\"001-abc\"), \"should include spec ID\");\n        assert!(msg.contains(\"chant/001-abc\"), \"should include branch name\");\n        assert!(msg.contains(\"main\"), \"should include target branch\");\n        assert!(msg.contains(\"Next Steps\"), \"should provide next steps\");\n        assert!(\n            msg.contains(\"chant merge 001-abc --no-ff\"),\n            \"should suggest --no-ff option\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase\"),\n            \"should suggest --rebase option\"\n        );\n    }\n\n    #[test]\n    fn test_merge_conflict_contains_recovery_steps() {\n        let msg = merge_conflict(\"001-abc\", \"chant/001-abc\", \"main\");\n        assert!(\n            msg.contains(\"Merge conflicts detected\"),\n            \"should describe error type\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase --auto\"),\n            \"should suggest auto-resolve\"\n        );\n        assert!(\n            msg.contains(\"git merge --no-ff chant/001-abc\"),\n            \"should provide manual merge command\"\n        );\n        assert!(\n            msg.contains(\"Documentation\"),\n            \"should reference documentation\"\n        );\n    }\n\n    #[test]\n    fn test_branch_not_found_contains_search_steps() {\n        let msg = branch_not_found(\"001-abc\", \"chant/001-abc\");\n        assert!(msg.contains(\"not found\"), \"should state branch is missing\");\n        assert!(\n            msg.contains(\"git branch --list\"),\n            \"should suggest listing branches\"\n        );\n        assert!(\n            msg.contains(\"chant work 001-abc\"),\n            \"should suggest re-execution\"\n        );\n    }\n\n    #[test]\n    fn test_main_branch_not_found() {\n        let msg = main_branch_not_found(\"main\");\n        assert!(\n            msg.contains(\"'main' does not exist\"),\n            \"should state main branch is missing\"\n        );\n        assert!(\n            msg.contains(\"git branch -a\"),\n            \"should suggest listing all branches\"\n        );\n        assert!(\n            msg.contains(\".chant/config.md\"),\n            \"should reference config file\"\n        );\n    }\n\n    #[test]\n    fn test_spec_status_not_mergeable() {\n        let msg = spec_status_not_mergeable(\"001-abc\", \"Failed\");\n        assert!(\n            msg.contains(\"Cannot merge spec 001-abc\"),\n            \"should state spec cannot be merged\"\n        );\n        assert!(msg.contains(\"Failed\"), \"should include current status\");\n        assert!(\n            msg.contains(\"chant show 001-abc\"),\n            \"should suggest inspecting spec\"\n        );\n        assert!(\n            msg.contains(\"chant finalize 001-abc\"),\n            \"should suggest finalizing spec\"\n        );\n    }\n\n    #[test]\n    fn test_no_branch_for_spec() {\n        let msg = no_branch_for_spec(\"001-abc\");\n        assert!(\n            msg.contains(\"No branch found\"),\n            \"should state no branch exists\"\n        );\n        assert!(msg.contains(\"001-abc\"), \"should include spec ID\");\n        assert!(\n            msg.contains(\"git log --oneline --grep\"),\n            \"should suggest searching commit history\"\n        );\n    }\n\n    #[test]\n    fn test_worktree_already_exists() {\n        let msg = worktree_already_exists(\"001-abc\", \"/tmp/chant-001-abc\", \"chant/001-abc\");\n        assert!(\n            msg.contains(\"Worktree already exists\"),\n            \"should describe the conflict\"\n        );\n        assert!(\n            msg.contains(\"/tmp/chant-001-abc\"),\n            \"should include worktree path\"\n        );\n        assert!(\n            msg.contains(\"git worktree remove\"),\n            \"should suggest manual removal\"\n        );\n        assert!(\n            msg.contains(\"chant cleanup\"),\n            \"should suggest cleanup command\"\n        );\n    }\n\n    #[test]\n    fn test_no_commits_found() {\n        let msg = no_commits_found(\"001-abc\", \"chant/001-abc\");\n        assert!(\n            msg.contains(\"No commits found\"),\n            \"should state no matching commits\"\n        );\n        assert!(\n            msg.contains(\"chant(001-abc):\"),\n            \"should show expected pattern\"\n        );\n        assert!(\n            msg.contains(\"git log chant/001-abc\"),\n            \"should suggest inspecting branch\"\n        );\n        assert!(\n            msg.contains(\"--allow-no-commits\"),\n            \"should mention fallback option\"\n        );\n    }\n\n    #[test]\n    fn test_driver_members_incomplete() {\n        let incomplete = vec![\n            \"driver.1 (status: Pending)\".to_string(),\n            \"driver.2 (branch not found)\".to_string(),\n        ];\n        let msg = driver_members_incomplete(\"driver\", \u0026incomplete);\n        assert!(\n            msg.contains(\"Cannot merge driver spec\"),\n            \"should state driver cannot be merged\"\n        );\n        assert!(\n            msg.contains(\"driver.1\"),\n            \"should list first incomplete member\"\n        );\n        assert!(\n            msg.contains(\"driver.2\"),\n            \"should list second incomplete member\"\n        );\n        assert!(\n            msg.contains(\"chant merge driver\"),\n            \"should suggest merging driver after members complete\"\n        );\n    }\n\n    #[test]\n    fn test_member_merge_failed() {\n        let msg = member_merge_failed(\"driver\", \"driver.1\", \"Merge conflicts detected\");\n        assert!(\n            msg.contains(\"Member spec merge failed\"),\n            \"should describe member failure\"\n        );\n        assert!(msg.contains(\"driver\"), \"should include driver spec ID\");\n        assert!(msg.contains(\"driver.1\"), \"should include failed member ID\");\n        assert!(\n            msg.contains(\"chant merge driver.1\"),\n            \"should suggest merging member first\"\n        );\n        assert!(\n            msg.contains(\"chant merge driver\"),\n            \"should suggest retrying driver after\"\n        );\n    }\n\n    #[test]\n    fn test_generic_merge_failed() {\n        let msg = generic_merge_failed(\"001-abc\", \"chant/001-abc\", \"main\", \"some error\");\n        assert!(\n            msg.contains(\"Merge failed for spec 001-abc\"),\n            \"should state merge failed\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase\"),\n            \"should suggest rebase option\"\n        );\n        assert!(\n            msg.contains(\"git merge --no-ff chant/001-abc\"),\n            \"should provide manual merge command\"\n        );\n    }\n\n    #[test]\n    fn test_rebase_conflict() {\n        let files = vec![\"src/main.rs\".to_string(), \"src/lib.rs\".to_string()];\n        let msg = rebase_conflict(\"001-abc\", \"chant/001-abc\", \u0026files);\n        assert!(\n            msg.contains(\"Rebase conflict\"),\n            \"should describe rebase conflict\"\n        );\n        assert!(\n            msg.contains(\"src/main.rs\"),\n            \"should list first conflicting file\"\n        );\n        assert!(\n            msg.contains(\"src/lib.rs\"),\n            \"should list second conflicting file\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase --auto\"),\n            \"should suggest auto-resolve\"\n        );\n    }\n\n    #[test]\n    fn test_merge_stopped() {\n        let msg = merge_stopped(\"001-abc\");\n        assert!(\n            msg.contains(\"Merge stopped at spec 001-abc\"),\n            \"should identify where merge stopped\"\n        );\n        assert!(\n            msg.contains(\"--continue-on-error\"),\n            \"should suggest continue-on-error flag\"\n        );\n    }\n\n    #[test]\n    fn test_rebase_stopped() {\n        let msg = rebase_stopped(\"001-abc\");\n        assert!(\n            msg.contains(\"rebase conflict\"),\n            \"should describe rebase conflict\"\n        );\n        assert!(\n            msg.contains(\"--rebase --auto\"),\n            \"should suggest auto-resolve flags\"\n        );\n    }\n\n    #[test]\n    fn test_conflict_type_display() {\n        assert_eq!(format!(\"{}\", ConflictType::FastForward), \"fast-forward\");\n        assert_eq!(format!(\"{}\", ConflictType::Content), \"content\");\n        assert_eq!(format!(\"{}\", ConflictType::Tree), \"tree\");\n        assert_eq!(format!(\"{}\", ConflictType::Unknown), \"unknown\");\n    }\n\n    #[test]\n    fn test_classify_conflict_type_fast_forward() {\n        let stderr = \"fatal: Not possible to fast-forward, aborting.\";\n        assert_eq!(\n            classify_conflict_type(stderr, None),\n            ConflictType::FastForward\n        );\n\n        let stderr2 = \"error: cannot fast-forward\";\n        assert_eq!(\n            classify_conflict_type(stderr2, None),\n            ConflictType::FastForward\n        );\n    }\n\n    #[test]\n    fn test_classify_conflict_type_tree() {\n        let stderr = \"CONFLICT (rename/delete): file.rs renamed in HEAD\";\n        assert_eq!(classify_conflict_type(stderr, None), ConflictType::Tree);\n\n        let stderr2 = \"CONFLICT (modify/delete): file.rs deleted in branch\";\n        assert_eq!(classify_conflict_type(stderr2, None), ConflictType::Tree);\n\n        // Test via status output\n        let status = \"DU src/deleted.rs\\n\";\n        assert_eq!(classify_conflict_type(\"\", Some(status)), ConflictType::Tree);\n    }\n\n    #[test]\n    fn test_classify_conflict_type_content() {\n        let stderr = \"CONFLICT (content): Merge conflict in file.rs\";\n        assert_eq!(classify_conflict_type(stderr, None), ConflictType::Content);\n\n        // Test via status output\n        let status = \"UU src/main.rs\\nUU src/lib.rs\\n\";\n        assert_eq!(\n            classify_conflict_type(\"\", Some(status)),\n            ConflictType::Content\n        );\n    }\n\n    #[test]\n    fn test_classify_conflict_type_unknown() {\n        let stderr = \"some other error\";\n        assert_eq!(classify_conflict_type(stderr, None), ConflictType::Unknown);\n    }\n\n    #[test]\n    fn test_parse_conflicting_files() {\n        let status = \"UU src/main.rs\\nUU src/lib.rs\\nM  src/other.rs\\n\";\n        let files = parse_conflicting_files(status);\n        assert_eq!(files.len(), 2, \"should find exactly 2 conflicting files\");\n        assert!(\n            files.contains(\u0026\"src/main.rs\".to_string()),\n            \"should include src/main.rs\"\n        );\n        assert!(\n            files.contains(\u0026\"src/lib.rs\".to_string()),\n            \"should include src/lib.rs\"\n        );\n    }\n\n    #[test]\n    fn test_parse_conflicting_files_tree_conflicts() {\n        let status = \"DD deleted.rs\\nAU added_unmerged.rs\\nUD unmerged_deleted.rs\\n\";\n        let files = parse_conflicting_files(status);\n        assert_eq!(files.len(), 3, \"should find exactly 3 tree conflicts\");\n        assert!(\n            files.contains(\u0026\"deleted.rs\".to_string()),\n            \"should include deleted.rs\"\n        );\n        assert!(\n            files.contains(\u0026\"added_unmerged.rs\".to_string()),\n            \"should include added_unmerged.rs\"\n        );\n        assert!(\n            files.contains(\u0026\"unmerged_deleted.rs\".to_string()),\n            \"should include unmerged_deleted.rs\"\n        );\n    }\n\n    #[test]\n    fn test_merge_conflict_detailed_content() {\n        let files = vec![\"src/main.rs\".to_string(), \"src/lib.rs\".to_string()];\n        let msg = merge_conflict_detailed(\n            \"001-abc\",\n            \"chant/001-abc\",\n            \"main\",\n            ConflictType::Content,\n            \u0026files,\n        );\n\n        assert!(\n            msg.contains(\"Content conflicts detected\"),\n            \"should describe conflict type\"\n        );\n        assert!(msg.contains(\"001-abc\"), \"should include spec ID\");\n        assert!(msg.contains(\"chant/001-abc\"), \"should include branch name\");\n        assert!(msg.contains(\"main\"), \"should include target branch\");\n        assert!(\n            msg.contains(\"Conflict type: content\"),\n            \"should label conflict type\"\n        );\n        assert!(\n            msg.contains(\"src/main.rs\"),\n            \"should list first conflicting file\"\n        );\n        assert!(\n            msg.contains(\"src/lib.rs\"),\n            \"should list second conflicting file\"\n        );\n        assert!(\n            msg.contains(\"Next steps:\"),\n            \"should provide next steps section\"\n        );\n        assert!(msg.contains(\"1.\"), \"should have numbered step 1\");\n        assert!(msg.contains(\"2.\"), \"should have numbered step 2\");\n        assert!(msg.contains(\"3.\"), \"should have numbered step 3\");\n        assert!(\n            msg.contains(\"git merge --continue\"),\n            \"should suggest continuing merge\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase --auto\"),\n            \"should suggest auto-resolve\"\n        );\n        assert!(msg.contains(\"git merge --abort\"), \"should suggest aborting\");\n        assert!(msg.contains(\"Example\"), \"should provide example workflow\");\n    }\n\n    #[test]\n    fn test_merge_conflict_detailed_tree() {\n        let files = vec![\"src/renamed.rs\".to_string()];\n        let msg = merge_conflict_detailed(\n            \"001-abc\",\n            \"chant/001-abc\",\n            \"main\",\n            ConflictType::Tree,\n            \u0026files,\n        );\n\n        assert!(\n            msg.contains(\"Tree conflicts detected\"),\n            \"should describe tree conflict\"\n        );\n        assert!(\n            msg.contains(\"Conflict type: tree\"),\n            \"should label conflict as tree type\"\n        );\n        assert!(\n            msg.contains(\"src/renamed.rs\"),\n            \"should list conflicting file\"\n        );\n    }\n\n    #[test]\n    fn test_merge_conflict_detailed_fast_forward() {\n        let files: Vec\u003cString\u003e = vec![];\n        let msg = merge_conflict_detailed(\n            \"001-abc\",\n            \"chant/001-abc\",\n            \"main\",\n            ConflictType::FastForward,\n            \u0026files,\n        );\n\n        assert!(\n            msg.contains(\"Cannot fast-forward\"),\n            \"should describe fast-forward failure\"\n        );\n        assert!(\n            msg.contains(\"Conflict type: fast-forward\"),\n            \"should label conflict as fast-forward\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --no-ff\"),\n            \"should suggest --no-ff option\"\n        );\n        assert!(\n            msg.contains(\"chant merge 001-abc --rebase\"),\n            \"should suggest --rebase option\"\n        );\n    }\n\n    #[test]\n    fn test_merge_conflict_detailed_empty_files() {\n        let files: Vec\u003cString\u003e = vec![];\n        let msg = merge_conflict_detailed(\n            \"001-abc\",\n            \"chant/001-abc\",\n            \"main\",\n            ConflictType::Content,\n            \u0026files,\n        );\n\n        assert!(\n            msg.contains(\"unable to determine conflicting files\"),\n            \"should indicate when files cannot be determined\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":8}},{"line":322,"address":[],"length":0,"stats":{"Line":8}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":8}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":12}},{"line":349,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":5}},{"line":358,"address":[],"length":0,"stats":{"Line":8}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":3}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":403,"address":[],"length":0,"stats":{"Line":8}},{"line":404,"address":[],"length":0,"stats":{"Line":24}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":7}},{"line":409,"address":[],"length":0,"stats":{"Line":6}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":416,"address":[],"length":0,"stats":{"Line":5}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[],"length":0,"stats":{"Line":4}},{"line":419,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":425,"address":[],"length":0,"stats":{"Line":6}},{"line":427,"address":[],"length":0,"stats":{"Line":7}},{"line":428,"address":[],"length":0,"stats":{"Line":18}},{"line":429,"address":[],"length":0,"stats":{"Line":19}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":3}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":3}},{"line":445,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":10}},{"line":458,"address":[],"length":0,"stats":{"Line":6}},{"line":459,"address":[],"length":0,"stats":{"Line":12}},{"line":461,"address":[],"length":0,"stats":{"Line":21}},{"line":462,"address":[],"length":0,"stats":{"Line":20}},{"line":463,"address":[],"length":0,"stats":{"Line":15}},{"line":468,"address":[],"length":0,"stats":{"Line":2}}],"covered":84,"coverable":85},{"path":["/","Users","alex","Documents","checkouts","chant","src","pid.rs"],"content":"//! PID tracking for running work processes\n//!\n//! Provides functionality to track and manage running agent processes\n//! associated with specs being worked on.\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::PathBuf;\n\nconst PIDS_DIR: \u0026str = \".chant/pids\";\n\n/// Ensure the PIDs directory exists\npub fn ensure_pids_dir() -\u003e Result\u003cPathBuf\u003e {\n    let pids_dir = PathBuf::from(PIDS_DIR);\n    if !pids_dir.exists() {\n        fs::create_dir_all(\u0026pids_dir)?;\n    }\n    Ok(pids_dir)\n}\n\n/// Write a PID file for a spec\npub fn write_pid_file(spec_id: \u0026str, pid: u32) -\u003e Result\u003c()\u003e {\n    let pids_dir = ensure_pids_dir()?;\n    let pid_file = pids_dir.join(format!(\"{}.pid\", spec_id));\n    fs::write(\u0026pid_file, pid.to_string())?;\n    Ok(())\n}\n\n/// Read PID from a spec's PID file\npub fn read_pid_file(spec_id: \u0026str) -\u003e Result\u003cOption\u003cu32\u003e\u003e {\n    let pids_dir = PathBuf::from(PIDS_DIR);\n    let pid_file = pids_dir.join(format!(\"{}.pid\", spec_id));\n\n    if !pid_file.exists() {\n        return Ok(None);\n    }\n\n    let content = fs::read_to_string(\u0026pid_file)\n        .with_context(|| format!(\"Failed to read PID file: {}\", pid_file.display()))?;\n\n    let pid: u32 = content\n        .trim()\n        .parse()\n        .with_context(|| format!(\"Invalid PID in file: {}\", content))?;\n\n    Ok(Some(pid))\n}\n\n/// Remove PID file for a spec\npub fn remove_pid_file(spec_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let pids_dir = PathBuf::from(PIDS_DIR);\n    let pid_file = pids_dir.join(format!(\"{}.pid\", spec_id));\n\n    if pid_file.exists() {\n        fs::remove_file(\u0026pid_file)?;\n    }\n\n    Ok(())\n}\n\n/// Check if a process with the given PID is running\npub fn is_process_running(pid: u32) -\u003e bool {\n    #[cfg(unix)]\n    {\n        use std::process::Command;\n\n        // Use `kill -0` to check if process exists without actually killing it\n        Command::new(\"kill\")\n            .args([\"-0\", \u0026pid.to_string()])\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    #[cfg(not(unix))]\n    {\n        // On Windows, we could use tasklist or similar\n        // For now, assume it's not running if we can't check\n        // This is a limitation on non-Unix platforms\n        eprintln!(\"Warning: Process checking not implemented for this platform\");\n        false\n    }\n}\n\n/// Stop a process with the given PID\npub fn stop_process(pid: u32) -\u003e Result\u003c()\u003e {\n    #[cfg(unix)]\n    {\n        use std::process::Command;\n\n        // Try graceful termination first (SIGTERM)\n        let status = Command::new(\"kill\")\n            .args([\"-TERM\", \u0026pid.to_string()])\n            .status()\n            .with_context(|| format!(\"Failed to send SIGTERM to process {}\", pid))?;\n\n        if !status.success() {\n            anyhow::bail!(\"Failed to terminate process {}\", pid);\n        }\n\n        Ok(())\n    }\n\n    #[cfg(not(unix))]\n    {\n        anyhow::bail!(\"Process termination not implemented for this platform\");\n    }\n}\n\n/// Stop the work process for a spec\npub fn stop_spec_work(spec_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let pid = read_pid_file(spec_id)?;\n\n    if let Some(pid) = pid {\n        if is_process_running(pid) {\n            stop_process(pid)?;\n            remove_pid_file(spec_id)?;\n            Ok(())\n        } else {\n            // Process not running, clean up PID file\n            remove_pid_file(spec_id)?;\n            anyhow::bail!(\"Process {} is not running\", pid)\n        }\n    } else {\n        anyhow::bail!(\"No PID file found for spec {}\", spec_id)\n    }\n}\n\n/// List all specs with active PID files\npub fn list_active_pids() -\u003e Result\u003cVec\u003c(String, u32, bool)\u003e\u003e {\n    let pids_dir = PathBuf::from(PIDS_DIR);\n\n    if !pids_dir.exists() {\n        return Ok(Vec::new());\n    }\n\n    let mut results = Vec::new();\n\n    for entry in fs::read_dir(\u0026pids_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.extension().and_then(|s| s.to_str()) == Some(\"pid\") {\n            if let Some(spec_id) = path.file_stem().and_then(|s| s.to_str()) {\n                if let Ok(Some(pid)) = read_pid_file(spec_id) {\n                    let is_running = is_process_running(pid);\n                    results.push((spec_id.to_string(), pid, is_running));\n                }\n            }\n        }\n    }\n\n    Ok(results)\n}\n\n/// Clean up stale PID files (where process is no longer running)\npub fn cleanup_stale_pids() -\u003e Result\u003cusize\u003e {\n    let active_pids = list_active_pids()?;\n    let mut cleaned = 0;\n\n    for (spec_id, _pid, is_running) in active_pids {\n        if !is_running {\n            remove_pid_file(\u0026spec_id)?;\n            cleaned += 1;\n        }\n    }\n\n    Ok(cleaned)\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":10}},{"line":31,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":30}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":18}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":18}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":18}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":69},{"path":["/","Users","alex","Documents","checkouts","chant","src","prompt.rs"],"content":"//! Prompt template management and variable substitution.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: concepts/prompts.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse serde::Deserialize;\nuse std::collections::HashSet;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\n\nuse crate::config::Config;\nuse crate::paths::SPECS_DIR;\nuse crate::spec::{split_frontmatter, Spec};\nuse crate::validation;\n\n/// Frontmatter for prompt templates\n#[derive(Debug, Deserialize, Default)]\npub struct PromptFrontmatter {\n    /// Name of the prompt\n    pub name: Option\u003cString\u003e,\n    /// Purpose/description of the prompt\n    pub purpose: Option\u003cString\u003e,\n    /// Parent prompt name to extend from\n    pub extends: Option\u003cString\u003e,\n}\n\n/// Context about the execution environment (worktree, branch, isolation).\n///\n/// This information is passed to prompt assembly so agents can be aware\n/// of their execution context - whether they're running in an isolated\n/// worktree, what branch they're on, etc.\n#[derive(Debug, Clone, Default)]\npub struct WorktreeContext {\n    /// Path to the worktree directory (e.g., `/tmp/chant-{spec-id}`)\n    pub worktree_path: Option\u003cPathBuf\u003e,\n    /// Branch name the agent is working on\n    pub branch_name: Option\u003cString\u003e,\n    /// Whether execution is isolated (in a worktree vs main repo)\n    pub is_isolated: bool,\n}\n\n/// Ask user for confirmation with a yes/no prompt.\n/// Returns true if user confirms (y/yes), false if user declines (n/no).\n/// Repeats until user provides valid input.\n///\n/// In non-interactive (non-TTY) contexts, automatically proceeds without prompting\n/// and logs a message indicating confirmation was skipped.\npub fn confirm(message: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Detect non-TTY contexts (e.g., when running in worktrees or piped input)\n    if !atty::is(atty::Stream::Stdin) {\n        eprintln!(\"â¹ Non-interactive mode detected, proceeding without confirmation\");\n        return Ok(true);\n    }\n\n    loop {\n        print!(\"{} (y/n): \", message);\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n        let input = input.trim().to_lowercase();\n\n        match input.as_str() {\n            \"y\" | \"yes\" =\u003e return Ok(true),\n            \"n\" | \"no\" =\u003e return Ok(false),\n            _ =\u003e {\n                println!(\"Please enter 'y' or 'n'.\");\n            }\n        }\n    }\n}\n\n/// Assemble a prompt by substituting template variables.\n///\n/// This version uses default (empty) worktree context. For parallel execution\n/// in isolated worktrees, use `assemble_with_context` instead.\npub fn assemble(spec: \u0026Spec, prompt_path: \u0026Path, config: \u0026Config) -\u003e Result\u003cString\u003e {\n    assemble_with_context(spec, prompt_path, config, \u0026WorktreeContext::default())\n}\n\n/// Assemble a prompt with explicit worktree context.\n///\n/// Use this when the agent will run in an isolated worktree and should be\n/// aware of its execution environment (worktree path, branch, isolation status).\npub fn assemble_with_context(\n    spec: \u0026Spec,\n    prompt_path: \u0026Path,\n    config: \u0026Config,\n    worktree_ctx: \u0026WorktreeContext,\n) -\u003e Result\u003cString\u003e {\n    // Resolve prompt with inheritance\n    let mut visited = HashSet::new();\n    let resolved_body = resolve_prompt_inheritance(prompt_path, \u0026mut visited)?;\n\n    // Check if this is a split prompt (don't inject commit instruction for analysis prompts)\n    let is_split_prompt = prompt_path\n        .file_stem()\n        .map(|s| s.to_string_lossy() == \"split\")\n        .unwrap_or(false);\n\n    // Substitute template variables and inject commit instruction (except for split)\n    let mut message = substitute(\u0026resolved_body, spec, config, !is_split_prompt, worktree_ctx);\n\n    // Append prompt extensions from config\n    for extension_name in \u0026config.defaults.prompt_extensions {\n        let extension_content = load_extension(extension_name)?;\n        message.push_str(\"\\n\\n\");\n        message.push_str(\u0026extension_content);\n    }\n\n    Ok(message)\n}\n\n/// Resolve prompt inheritance by loading parent prompts recursively.\n/// Returns the fully resolved prompt body with {{\u003e parent}} markers replaced.\nfn resolve_prompt_inheritance(\n    prompt_path: \u0026Path,\n    visited: \u0026mut HashSet\u003cPathBuf\u003e,\n) -\u003e Result\u003cString\u003e {\n    // Check for circular dependencies\n    if visited.contains(prompt_path) {\n        anyhow::bail!(\n            \"Circular prompt inheritance detected: {}\",\n            prompt_path.display()\n        );\n    }\n    visited.insert(prompt_path.to_path_buf());\n\n    let prompt_content = fs::read_to_string(prompt_path)\n        .with_context(|| format!(\"Failed to read prompt from {}\", prompt_path.display()))?;\n\n    // Parse frontmatter\n    let (frontmatter_str, body) = split_frontmatter(\u0026prompt_content);\n\n    // Check if this prompt extends another\n    if let Some(frontmatter_str) = frontmatter_str {\n        let frontmatter: PromptFrontmatter =\n            serde_yaml::from_str(\u0026frontmatter_str).with_context(|| {\n                format!(\n                    \"Failed to parse prompt frontmatter from {}\",\n                    prompt_path.display()\n                )\n            })?;\n\n        if let Some(parent_name) = frontmatter.extends {\n            // Construct parent prompt path\n            let prompt_dir = prompt_path.parent().unwrap_or(Path::new(\".chant/prompts\"));\n            let parent_path = prompt_dir.join(format!(\"{}.md\", parent_name));\n\n            // Recursively resolve parent\n            let parent_body = resolve_prompt_inheritance(\u0026parent_path, visited)?;\n\n            // Replace {{\u003e parent}} marker with parent content\n            let resolved = body.replace(\"{{\u003e parent}}\", \u0026parent_body);\n            return Ok(resolved);\n        }\n    }\n\n    // No parent, return body as-is\n    Ok(body.to_string())\n}\n\n/// Load a prompt extension from .chant/prompts/extensions/\nfn load_extension(extension_name: \u0026str) -\u003e Result\u003cString\u003e {\n    let extension_path =\n        Path::new(\".chant/prompts/extensions\").join(format!(\"{}.md\", extension_name));\n\n    let content = fs::read_to_string(\u0026extension_path)\n        .with_context(|| format!(\"Failed to read extension from {}\", extension_path.display()))?;\n\n    // Extract body (skip frontmatter if present)\n    let (_frontmatter, body) = split_frontmatter(\u0026content);\n\n    Ok(body.to_string())\n}\n\nfn substitute(\n    template: \u0026str,\n    spec: \u0026Spec,\n    config: \u0026Config,\n    inject_commit: bool,\n    worktree_ctx: \u0026WorktreeContext,\n) -\u003e String {\n    let mut result = template.to_string();\n\n    // Project variables\n    result = result.replace(\"{{project.name}}\", \u0026config.project.name);\n\n    // Spec variables\n    result = result.replace(\"{{spec.id}}\", \u0026spec.id);\n    result = result.replace(\n        \"{{spec.title}}\",\n        spec.title.as_deref().unwrap_or(\"(untitled)\"),\n    );\n    result = result.replace(\"{{spec.description}}\", \u0026spec.body);\n\n    // Spec path (constructed from id)\n    let spec_path = format!(\"{}/{}.md\", SPECS_DIR, spec.id);\n    result = result.replace(\"{{spec.path}}\", \u0026spec_path);\n\n    // The full spec content\n    result = result.replace(\"{{spec}}\", \u0026format_spec_for_prompt(spec));\n\n    // Target files\n    if let Some(files) = \u0026spec.frontmatter.target_files {\n        result = result.replace(\"{{spec.target_files}}\", \u0026files.join(\"\\n\"));\n    } else {\n        result = result.replace(\"{{spec.target_files}}\", \"\");\n    }\n\n    // Context files - read and include content\n    if let Some(context_paths) = \u0026spec.frontmatter.context {\n        let mut context_content = String::new();\n        for path in context_paths {\n            if let Ok(content) = fs::read_to_string(path) {\n                context_content.push_str(\u0026format!(\"\\n--- {} ---\\n{}\\n\", path, content));\n            }\n        }\n        result = result.replace(\"{{spec.context}}\", \u0026context_content);\n    } else {\n        result = result.replace(\"{{spec.context}}\", \"\");\n    }\n\n    // Worktree context variables\n    result = result.replace(\n        \"{{worktree.path}}\",\n        worktree_ctx\n            .worktree_path\n            .as_ref()\n            .map(|p| p.display().to_string())\n            .as_deref()\n            .unwrap_or(\"\"),\n    );\n    result = result.replace(\n        \"{{worktree.branch}}\",\n        worktree_ctx.branch_name.as_deref().unwrap_or(\"\"),\n    );\n    result = result.replace(\n        \"{{worktree.isolated}}\",\n        if worktree_ctx.is_isolated {\n            \"true\"\n        } else {\n            \"false\"\n        },\n    );\n\n    // Inject execution environment section if running in a worktree\n    // This gives agents awareness of their isolated context\n    if worktree_ctx.is_isolated {\n        let env_section = format!(\n            \"\\n\\n## Execution Environment\\n\\n\\\n             You are running in an **isolated worktree**:\\n\\\n             - **Working directory:** `{}`\\n\\\n             - **Branch:** `{}`\\n\\\n             - **Isolation:** Changes are isolated from the main repository until merged\\n\\n\\\n             This means your changes will not affect the main branch until explicitly merged.\\n\",\n            worktree_ctx\n                .worktree_path\n                .as_ref()\n                .map(|p| p.display().to_string())\n                .unwrap_or_default(),\n            worktree_ctx.branch_name.as_deref().unwrap_or(\"unknown\"),\n        );\n        result.push_str(\u0026env_section);\n    }\n\n    // Inject output schema section if present\n    if let Some(ref schema_path) = spec.frontmatter.output_schema {\n        let schema_path = Path::new(schema_path);\n        if schema_path.exists() {\n            match validation::generate_schema_prompt_section(schema_path) {\n                Ok(schema_section) =\u003e {\n                    result.push_str(\u0026schema_section);\n                }\n                Err(e) =\u003e {\n                    // Log warning but don't fail prompt assembly\n                    eprintln!(\"Warning: Failed to generate schema prompt section: {}\", e);\n                }\n            }\n        } else {\n            eprintln!(\n                \"Warning: Output schema file not found: {}\",\n                schema_path.display()\n            );\n        }\n    }\n\n    // Inject commit instruction if not already present (and if enabled)\n    if inject_commit \u0026\u0026 !result.to_lowercase().contains(\"commit your work\") {\n        let commit_instruction = \"\\n\\n## Required: Commit Your Work\\n\\n\\\n             When you have completed the work, commit your changes with:\\n\\n\\\n             ```\\n\\\n             git commit -m \\\"chant(\";\n        result.push_str(commit_instruction);\n        result.push_str(\u0026spec.id);\n        result.push_str(\n            \"): \u003cbrief description of changes\u003e\\\"\\n\\\n             ```\\n\\n\\\n             This commit message pattern is required for chant to track your work.\",\n        );\n    }\n\n    result\n}\n\nfn format_spec_for_prompt(spec: \u0026Spec) -\u003e String {\n    let mut output = String::new();\n\n    // ID\n    output.push_str(\u0026format!(\"Spec ID: {}\\n\\n\", spec.id));\n\n    // Title and body\n    output.push_str(\u0026spec.body);\n\n    // Target files if any\n    if let Some(files) = \u0026spec.frontmatter.target_files {\n        output.push_str(\"\\n\\n## Target Files\\n\\n\");\n        for file in files {\n            output.push_str(\u0026format!(\"- {}\\n\", file));\n        }\n    }\n\n    output\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::SpecFrontmatter;\n\n    fn make_test_config() -\u003e Config {\n        Config {\n            project: crate::config::ProjectConfig {\n                name: \"test-project\".to_string(),\n                prefix: None,\n                silent: false,\n            },\n            defaults: crate::config::DefaultsConfig::default(),\n            providers: crate::provider::ProviderConfig::default(),\n            parallel: crate::config::ParallelConfig::default(),\n            repos: vec![],\n            enterprise: crate::config::EnterpriseConfig::default(),\n            approval: crate::config::ApprovalConfig::default(),\n            validation: crate::config::OutputValidationConfig::default(),\n            site: crate::config::SiteConfig::default(),\n            lint: crate::config::LintConfig::default(),\n            watch: crate::config::WatchConfig::default(),\n        }\n    }\n\n    fn make_test_spec() -\u003e Spec {\n        Spec {\n            id: \"2026-01-22-001-x7m\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Fix the bug\".to_string()),\n            body: \"# Fix the bug\\n\\nDescription here.\".to_string(),\n        }\n    }\n\n    #[test]\n    fn test_substitute() {\n        let template = \"Project: {{project.name}}\\nSpec: {{spec.id}}\\nTitle: {{spec.title}}\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, true, \u0026worktree_ctx);\n\n        assert!(result.contains(\"Project: test-project\"));\n        assert!(result.contains(\"Spec: 2026-01-22-001-x7m\"));\n        assert!(result.contains(\"Title: Fix the bug\"));\n    }\n\n    #[test]\n    fn test_spec_path_substitution() {\n        let template = \"Edit {{spec.path}} to check off criteria\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, true, \u0026worktree_ctx);\n\n        assert!(result.contains(\".chant/specs/2026-01-22-001-x7m.md\"));\n    }\n\n    #[test]\n    fn test_split_frontmatter_extracts_body() {\n        let content = r#\"---\nname: test\n---\n\nBody content here.\"#;\n\n        let (_frontmatter, body) = split_frontmatter(content);\n        assert_eq!(body, \"Body content here.\");\n    }\n\n    #[test]\n    fn test_commit_instruction_is_injected() {\n        let template = \"# Do some work\\n\\nThis is a test prompt.\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, true, \u0026worktree_ctx);\n\n        // Should contain commit instruction\n        assert!(result.contains(\"## Required: Commit Your Work\"));\n        assert!(result.contains(\"git commit -m \\\"chant(2026-01-22-001-x7m):\"));\n    }\n\n    #[test]\n    fn test_commit_instruction_not_duplicated() {\n        let template =\n            \"# Do some work\\n\\n## Required: Commit Your Work\\n\\nAlready has instruction.\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, true, \u0026worktree_ctx);\n\n        // Count occurrences of the section header\n        let count = result.matches(\"## Required: Commit Your Work\").count();\n        assert_eq!(count, 1, \"Commit instruction should not be duplicated\");\n    }\n\n    #[test]\n    fn test_commit_instruction_skipped_when_disabled() {\n        let template = \"# Analyze something\\n\\nJust output text.\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, false, \u0026worktree_ctx);\n\n        // Should NOT contain commit instruction\n        assert!(\n            !result.contains(\"## Required: Commit Your Work\"),\n            \"Commit instruction should not be injected when disabled\"\n        );\n    }\n\n    #[test]\n    fn test_worktree_context_substitution() {\n        let template =\n            \"Path: {{worktree.path}}\\nBranch: {{worktree.branch}}\\nIsolated: {{worktree.isolated}}\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext {\n            worktree_path: Some(PathBuf::from(\"/tmp/chant-test-spec\")),\n            branch_name: Some(\"chant/test-spec\".to_string()),\n            is_isolated: true,\n        };\n\n        let result = substitute(template, \u0026spec, \u0026config, false, \u0026worktree_ctx);\n\n        assert!(result.contains(\"Path: /tmp/chant-test-spec\"));\n        assert!(result.contains(\"Branch: chant/test-spec\"));\n        assert!(result.contains(\"Isolated: true\"));\n    }\n\n    #[test]\n    fn test_worktree_context_empty_when_not_isolated() {\n        let template = \"Path: '{{worktree.path}}'\\nBranch: '{{worktree.branch}}'\\nIsolated: {{worktree.isolated}}\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, false, \u0026worktree_ctx);\n\n        assert!(result.contains(\"Path: ''\"));\n        assert!(result.contains(\"Branch: ''\"));\n        assert!(result.contains(\"Isolated: false\"));\n    }\n\n    #[test]\n    fn test_execution_environment_section_injected_when_isolated() {\n        let template = \"# Do some work\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext {\n            worktree_path: Some(PathBuf::from(\"/tmp/chant-test-spec\")),\n            branch_name: Some(\"chant/test-spec\".to_string()),\n            is_isolated: true,\n        };\n\n        let result = substitute(template, \u0026spec, \u0026config, false, \u0026worktree_ctx);\n\n        assert!(result.contains(\"## Execution Environment\"));\n        assert!(result.contains(\"isolated worktree\"));\n        assert!(result.contains(\"/tmp/chant-test-spec\"));\n        assert!(result.contains(\"chant/test-spec\"));\n    }\n\n    #[test]\n    fn test_execution_environment_section_not_injected_when_not_isolated() {\n        let template = \"# Do some work\";\n        let spec = make_test_spec();\n        let config = make_test_config();\n        let worktree_ctx = WorktreeContext::default();\n\n        let result = substitute(template, \u0026spec, \u0026config, false, \u0026worktree_ctx);\n\n        assert!(!result.contains(\"## Execution Environment\"));\n    }\n\n    // =========================================================================\n    // PROMPT INHERITANCE TESTS\n    // =========================================================================\n\n    #[test]\n    fn test_resolve_prompt_no_inheritance() {\n        use tempfile::TempDir;\n\n        let tmp = TempDir::new().unwrap();\n        let prompt_path = tmp.path().join(\"simple.md\");\n\n        fs::write(\n            \u0026prompt_path,\n            r#\"---\nname: simple\n---\n\nSimple prompt body.\"#,\n        )\n        .unwrap();\n\n        let mut visited = HashSet::new();\n        let result = resolve_prompt_inheritance(\u0026prompt_path, \u0026mut visited).unwrap();\n\n        assert_eq!(result, \"Simple prompt body.\");\n    }\n\n    #[test]\n    fn test_resolve_prompt_with_parent() {\n        use tempfile::TempDir;\n\n        let tmp = TempDir::new().unwrap();\n        let parent_path = tmp.path().join(\"parent.md\");\n        let child_path = tmp.path().join(\"child.md\");\n\n        fs::write(\n            \u0026parent_path,\n            r#\"---\nname: parent\n---\n\nParent content here.\"#,\n        )\n        .unwrap();\n\n        fs::write(\n            \u0026child_path,\n            r#\"---\nname: child\nextends: parent\n---\n\n{{\u003e parent}}\n\nAdditional child content.\"#,\n        )\n        .unwrap();\n\n        let mut visited = HashSet::new();\n        let result = resolve_prompt_inheritance(\u0026child_path, \u0026mut visited).unwrap();\n\n        assert!(result.contains(\"Parent content here.\"));\n        assert!(result.contains(\"Additional child content.\"));\n        assert!(!result.contains(\"{{\u003e parent}}\"));\n    }\n\n    #[test]\n    fn test_circular_inheritance_detection() {\n        use tempfile::TempDir;\n\n        let tmp = TempDir::new().unwrap();\n        let prompt_a = tmp.path().join(\"a.md\");\n        let prompt_b = tmp.path().join(\"b.md\");\n\n        fs::write(\n            \u0026prompt_a,\n            r#\"---\nname: a\nextends: b\n---\n\n{{\u003e parent}}\"#,\n        )\n        .unwrap();\n\n        fs::write(\n            \u0026prompt_b,\n            r#\"---\nname: b\nextends: a\n---\n\n{{\u003e parent}}\"#,\n        )\n        .unwrap();\n\n        let mut visited = HashSet::new();\n        let result = resolve_prompt_inheritance(\u0026prompt_a, \u0026mut visited);\n\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Circular prompt inheritance\"));\n    }\n\n    #[test]\n    fn test_load_extension() {\n        use tempfile::TempDir;\n\n        let tmp = TempDir::new().unwrap();\n        let extensions_dir = tmp.path().join(\".chant/prompts/extensions\");\n        fs::create_dir_all(\u0026extensions_dir).unwrap();\n\n        let extension_path = extensions_dir.join(\"test-ext.md\");\n        fs::write(\n            \u0026extension_path,\n            r#\"---\nname: test-ext\n---\n\nExtension content here.\"#,\n        )\n        .unwrap();\n\n        // Change to temp directory for test\n        let original_dir = std::env::current_dir().unwrap();\n        std::env::set_current_dir(\u0026tmp).unwrap();\n\n        let result = load_extension(\"test-ext\").unwrap();\n        assert_eq!(result, \"Extension content here.\");\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n    }\n\n    #[test]\n    fn test_prompt_extensions_in_config() {\n        use tempfile::TempDir;\n\n        let tmp = TempDir::new().unwrap();\n        let extensions_dir = tmp.path().join(\".chant/prompts/extensions\");\n        fs::create_dir_all(\u0026extensions_dir).unwrap();\n\n        let extension_path = extensions_dir.join(\"concise.md\");\n        fs::write(\u0026extension_path, \"Keep output concise.\").unwrap();\n\n        let prompt_path = tmp.path().join(\"main.md\");\n        fs::write(\u0026prompt_path, \"Main prompt.\").unwrap();\n\n        let mut config = make_test_config();\n        config.defaults.prompt_extensions = vec![\"concise\".to_string()];\n\n        let spec = make_test_spec();\n        let worktree_ctx = WorktreeContext::default();\n\n        // Change to temp directory for test\n        let original_dir = std::env::current_dir().unwrap();\n        std::env::set_current_dir(\u0026tmp).unwrap();\n\n        let result = assemble_with_context(\u0026spec, \u0026prompt_path, \u0026config, \u0026worktree_ctx).unwrap();\n\n        assert!(result.contains(\"Main prompt.\"));\n        assert!(result.contains(\"Keep output concise.\"));\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":20}},{"line":89,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":10}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":100,"address":[],"length":0,"stats":{"Line":10}},{"line":102,"address":[],"length":0,"stats":{"Line":15}},{"line":106,"address":[],"length":0,"stats":{"Line":35}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":11}},{"line":125,"address":[],"length":0,"stats":{"Line":33}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":40}},{"line":133,"address":[],"length":0,"stats":{"Line":30}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":30}},{"line":140,"address":[],"length":0,"stats":{"Line":15}},{"line":141,"address":[],"length":0,"stats":{"Line":10}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":8}},{"line":151,"address":[],"length":0,"stats":{"Line":15}},{"line":152,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":7}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":42}},{"line":191,"address":[],"length":0,"stats":{"Line":42}},{"line":194,"address":[],"length":0,"stats":{"Line":42}},{"line":195,"address":[],"length":0,"stats":{"Line":56}},{"line":196,"address":[],"length":0,"stats":{"Line":14}},{"line":197,"address":[],"length":0,"stats":{"Line":42}},{"line":199,"address":[],"length":0,"stats":{"Line":42}},{"line":202,"address":[],"length":0,"stats":{"Line":28}},{"line":203,"address":[],"length":0,"stats":{"Line":42}},{"line":206,"address":[],"length":0,"stats":{"Line":56}},{"line":209,"address":[],"length":0,"stats":{"Line":14}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":42}},{"line":216,"address":[],"length":0,"stats":{"Line":14}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":42}},{"line":229,"address":[],"length":0,"stats":{"Line":42}},{"line":231,"address":[],"length":0,"stats":{"Line":14}},{"line":232,"address":[],"length":0,"stats":{"Line":14}},{"line":233,"address":[],"length":0,"stats":{"Line":14}},{"line":234,"address":[],"length":0,"stats":{"Line":18}},{"line":235,"address":[],"length":0,"stats":{"Line":14}},{"line":236,"address":[],"length":0,"stats":{"Line":28}},{"line":238,"address":[],"length":0,"stats":{"Line":56}},{"line":239,"address":[],"length":0,"stats":{"Line":14}},{"line":240,"address":[],"length":0,"stats":{"Line":42}},{"line":242,"address":[],"length":0,"stats":{"Line":42}},{"line":244,"address":[],"length":0,"stats":{"Line":14}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":253,"address":[],"length":0,"stats":{"Line":14}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":6}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":8}},{"line":268,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":14}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":31}},{"line":294,"address":[],"length":0,"stats":{"Line":24}},{"line":295,"address":[],"length":0,"stats":{"Line":16}},{"line":296,"address":[],"length":0,"stats":{"Line":16}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":298,"address":[],"length":0,"stats":{"Line":32}},{"line":299,"address":[],"length":0,"stats":{"Line":32}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":307,"address":[],"length":0,"stats":{"Line":14}},{"line":310,"address":[],"length":0,"stats":{"Line":14}},{"line":311,"address":[],"length":0,"stats":{"Line":28}},{"line":314,"address":[],"length":0,"stats":{"Line":42}},{"line":317,"address":[],"length":0,"stats":{"Line":42}},{"line":320,"address":[],"length":0,"stats":{"Line":14}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":14}}],"covered":96,"coverable":127},{"path":["/","Users","alex","Documents","checkouts","chant","src","prompts.rs"],"content":"//! # Bundled Prompt Management\n//!\n//! This module manages the standard prompts bundled into the Chant binary.\n//! All prompts are embedded at compile time using `include_str!` and can be\n//! written to the `.chant/prompts/` directory during project initialization.\n\n/// Standard execution prompt - default prompt for spec execution\npub const STANDARD: \u0026str = include_str!(\"../prompts/standard.md\");\n\n/// Split prompt - for splitting driver specs into member specs\npub const SPLIT: \u0026str = include_str!(\"../prompts/split.md\");\n\n/// Verify prompt - for verifying acceptance criteria are met\npub const VERIFY: \u0026str = include_str!(\"../prompts/verify.md\");\n\n/// Merge conflict prompt - for resolving git merge conflicts\npub const MERGE_CONFLICT: \u0026str = include_str!(\"../prompts/merge-conflict.md\");\n\n/// Parallel cleanup prompt - for analyzing parallel execution results\npub const PARALLEL_CLEANUP: \u0026str = include_str!(\"../prompts/parallel-cleanup.md\");\n\n/// Ollama prompt - optimized prompt for local LLM execution\npub const OLLAMA: \u0026str = include_str!(\"../prompts/ollama.md\");\n\n// Dev-only prompts (not included in distribution)\n#[cfg(debug_assertions)]\nmod dev {\n    /// Bootstrap prompt - minimal prompt that defers to prep command\n    pub const BOOTSTRAP: \u0026str = include_str!(\"../prompts-dev/bootstrap.md\");\n\n    /// Documentation prompt - for generating documentation from source code\n    pub const DOCUMENTATION: \u0026str = include_str!(\"../prompts-dev/documentation.md\");\n\n    /// Documentation audit prompt - for auditing Rust code against mdbook documentation\n    pub const DOC_AUDIT: \u0026str = include_str!(\"../prompts-dev/doc-audit.md\");\n\n    /// Research analysis prompt - for chant-specific research analysis\n    pub const RESEARCH_ANALYSIS: \u0026str = include_str!(\"../prompts-dev/research-analysis.md\");\n\n    /// Research synthesis prompt - for chant-specific research synthesis\n    pub const RESEARCH_SYNTHESIS: \u0026str = include_str!(\"../prompts-dev/research-synthesis.md\");\n}\n\n/// Metadata about a bundled prompt\n#[derive(Debug, Clone)]\npub struct PromptMetadata {\n    /// The name of the prompt (used as filename without .md extension)\n    pub name: \u0026'static str,\n    /// The purpose/description of the prompt\n    pub purpose: \u0026'static str,\n    /// The content of the prompt\n    pub content: \u0026'static str,\n}\n\n/// Returns all bundled prompts with their metadata\npub fn all_bundled_prompts() -\u003e Vec\u003cPromptMetadata\u003e {\n    let prompts = vec![\n        PromptMetadata {\n            name: \"standard\",\n            purpose: \"Default execution prompt\",\n            content: STANDARD,\n        },\n        PromptMetadata {\n            name: \"split\",\n            purpose: \"Split a driver spec into members with detailed acceptance criteria\",\n            content: SPLIT,\n        },\n        PromptMetadata {\n            name: \"verify\",\n            purpose: \"Verify that acceptance criteria are met\",\n            content: VERIFY,\n        },\n        PromptMetadata {\n            name: \"merge-conflict\",\n            purpose: \"Resolve git merge conflicts during rebase operations\",\n            content: MERGE_CONFLICT,\n        },\n        PromptMetadata {\n            name: \"parallel-cleanup\",\n            purpose: \"Analyze parallel execution results and help resolve issues\",\n            content: PARALLEL_CLEANUP,\n        },\n        PromptMetadata {\n            name: \"ollama\",\n            purpose: \"Optimized prompt for local LLM execution\",\n            content: OLLAMA,\n        },\n    ];\n\n    // Include dev-only prompts when running in debug mode\n    #[cfg(debug_assertions)]\n    let prompts = {\n        let mut prompts = prompts;\n        prompts.extend(vec![\n            PromptMetadata {\n                name: \"bootstrap\",\n                purpose: \"Minimal bootstrap prompt that defers to prep command\",\n                content: dev::BOOTSTRAP,\n            },\n            PromptMetadata {\n                name: \"documentation\",\n                purpose: \"Generate documentation from tracked source files\",\n                content: dev::DOCUMENTATION,\n            },\n            PromptMetadata {\n                name: \"doc-audit\",\n                purpose: \"Audit Rust code against mdbook documentation\",\n                content: dev::DOC_AUDIT,\n            },\n            PromptMetadata {\n                name: \"research-analysis\",\n                purpose: \"Chant-specific research analysis\",\n                content: dev::RESEARCH_ANALYSIS,\n            },\n            PromptMetadata {\n                name: \"research-synthesis\",\n                purpose: \"Chant-specific research synthesis\",\n                content: dev::RESEARCH_SYNTHESIS,\n            },\n        ]);\n        prompts\n    };\n\n    prompts\n}\n\n/// Get a prompt by name\npub fn get_prompt(name: \u0026str) -\u003e Option\u003cPromptMetadata\u003e {\n    all_bundled_prompts().into_iter().find(|p| p.name == name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_all_bundled_prompts_not_empty() {\n        let prompts = all_bundled_prompts();\n        assert!(!prompts.is_empty());\n    }\n\n    #[test]\n    fn test_all_prompts_have_content() {\n        let prompts = all_bundled_prompts();\n        for prompt in prompts {\n            assert!(\n                !prompt.content.is_empty(),\n                \"Prompt {} has no content\",\n                prompt.name\n            );\n        }\n    }\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn test_get_prompt_bootstrap() {\n        let prompt = get_prompt(\"bootstrap\");\n        assert!(prompt.is_some());\n        let p = prompt.unwrap();\n        assert_eq!(p.name, \"bootstrap\");\n        assert!(p.content.contains(\"chant prep\"));\n    }\n\n    #[test]\n    fn test_get_prompt_nonexistent() {\n        let prompt = get_prompt(\"nonexistent\");\n        assert!(prompt.is_none());\n    }\n}\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":34}},{"line":57,"address":[],"length":0,"stats":{"Line":68}},{"line":58,"address":[],"length":0,"stats":{"Line":34}},{"line":59,"address":[],"length":0,"stats":{"Line":34}},{"line":60,"address":[],"length":0,"stats":{"Line":34}},{"line":61,"address":[],"length":0,"stats":{"Line":34}},{"line":63,"address":[],"length":0,"stats":{"Line":34}},{"line":64,"address":[],"length":0,"stats":{"Line":34}},{"line":65,"address":[],"length":0,"stats":{"Line":34}},{"line":66,"address":[],"length":0,"stats":{"Line":34}},{"line":68,"address":[],"length":0,"stats":{"Line":34}},{"line":69,"address":[],"length":0,"stats":{"Line":34}},{"line":70,"address":[],"length":0,"stats":{"Line":34}},{"line":71,"address":[],"length":0,"stats":{"Line":34}},{"line":73,"address":[],"length":0,"stats":{"Line":34}},{"line":74,"address":[],"length":0,"stats":{"Line":34}},{"line":75,"address":[],"length":0,"stats":{"Line":34}},{"line":76,"address":[],"length":0,"stats":{"Line":34}},{"line":78,"address":[],"length":0,"stats":{"Line":34}},{"line":79,"address":[],"length":0,"stats":{"Line":34}},{"line":80,"address":[],"length":0,"stats":{"Line":34}},{"line":81,"address":[],"length":0,"stats":{"Line":34}},{"line":83,"address":[],"length":0,"stats":{"Line":34}},{"line":84,"address":[],"length":0,"stats":{"Line":34}},{"line":85,"address":[],"length":0,"stats":{"Line":34}},{"line":86,"address":[],"length":0,"stats":{"Line":34}},{"line":92,"address":[],"length":0,"stats":{"Line":34}},{"line":93,"address":[],"length":0,"stats":{"Line":68}},{"line":94,"address":[],"length":0,"stats":{"Line":102}},{"line":95,"address":[],"length":0,"stats":{"Line":34}},{"line":96,"address":[],"length":0,"stats":{"Line":34}},{"line":97,"address":[],"length":0,"stats":{"Line":34}},{"line":98,"address":[],"length":0,"stats":{"Line":34}},{"line":100,"address":[],"length":0,"stats":{"Line":34}},{"line":101,"address":[],"length":0,"stats":{"Line":34}},{"line":102,"address":[],"length":0,"stats":{"Line":34}},{"line":103,"address":[],"length":0,"stats":{"Line":34}},{"line":105,"address":[],"length":0,"stats":{"Line":34}},{"line":106,"address":[],"length":0,"stats":{"Line":34}},{"line":107,"address":[],"length":0,"stats":{"Line":34}},{"line":108,"address":[],"length":0,"stats":{"Line":34}},{"line":110,"address":[],"length":0,"stats":{"Line":34}},{"line":111,"address":[],"length":0,"stats":{"Line":34}},{"line":112,"address":[],"length":0,"stats":{"Line":34}},{"line":113,"address":[],"length":0,"stats":{"Line":34}},{"line":115,"address":[],"length":0,"stats":{"Line":34}},{"line":116,"address":[],"length":0,"stats":{"Line":34}},{"line":117,"address":[],"length":0,"stats":{"Line":34}},{"line":118,"address":[],"length":0,"stats":{"Line":34}},{"line":121,"address":[],"length":0,"stats":{"Line":34}},{"line":124,"address":[],"length":0,"stats":{"Line":34}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":40}}],"covered":53,"coverable":53},{"path":["/","Users","alex","Documents","checkouts","chant","src","provider.rs"],"content":"//! Model provider abstraction for invoking AI agents.\n//!\n//! Supports multiple providers (Claude, Ollama, OpenAI).\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: architecture/invoke.md\n//! - ignore: false\n\nuse anyhow::{anyhow, Context, Result};\nuse serde::Deserialize;\nuse std::io::BufRead;\nuse std::process::{Command, Stdio};\nuse ureq::Agent;\n\n/// Model provider type\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProviderType {\n    #[default]\n    Claude,\n    Ollama,\n    Openai,\n}\n\n/// Provider configuration\n#[derive(Debug, Clone, Default, Deserialize)]\npub struct ProviderConfig {\n    #[serde(default)]\n    pub ollama: Option\u003cOllamaConfig\u003e,\n    #[serde(default)]\n    pub openai: Option\u003cOpenaiConfig\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct OllamaConfig {\n    #[serde(default = \"default_ollama_endpoint\")]\n    pub endpoint: String,\n    /// Maximum number of retry attempts for throttled requests\n    #[serde(default = \"default_max_retries\")]\n    pub max_retries: u32,\n    /// Initial delay in milliseconds before first retry\n    #[serde(default = \"default_retry_delay_ms\")]\n    pub retry_delay_ms: u64,\n}\n\nfn default_ollama_endpoint() -\u003e String {\n    \"http://localhost:11434/v1\".to_string()\n}\n\nfn default_max_retries() -\u003e u32 {\n    3\n}\n\nfn default_retry_delay_ms() -\u003e u64 {\n    1000 // 1 second\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct OpenaiConfig {\n    #[serde(default = \"default_openai_endpoint\")]\n    pub endpoint: String,\n    /// Maximum number of retry attempts for throttled requests\n    #[serde(default = \"default_max_retries\")]\n    pub max_retries: u32,\n    /// Initial delay in milliseconds before first retry\n    #[serde(default = \"default_retry_delay_ms\")]\n    pub retry_delay_ms: u64,\n}\n\nfn default_openai_endpoint() -\u003e String {\n    \"https://api.openai.com/v1\".to_string()\n}\n\n/// Trait for model providers\npub trait ModelProvider {\n    fn invoke(\n        \u0026self,\n        message: \u0026str,\n        model: \u0026str,\n        callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    ) -\u003e Result\u003cString\u003e;\n\n    /// Returns the provider name. Part of the trait API, used in tests.\n    fn name(\u0026self) -\u003e \u0026'static str;\n}\n\n/// Claude CLI provider (existing behavior)\npub struct ClaudeCliProvider;\n\nimpl ModelProvider for ClaudeCliProvider {\n    fn invoke(\n        \u0026self,\n        message: \u0026str,\n        model: \u0026str,\n        callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    ) -\u003e Result\u003cString\u003e {\n        let mut cmd = Command::new(\"claude\");\n        cmd.arg(\"--print\")\n            .arg(\"--output-format\")\n            .arg(\"stream-json\")\n            .arg(\"--verbose\")\n            .arg(\"--model\")\n            .arg(model)\n            .arg(\"--dangerously-skip-permissions\")\n            .arg(message)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n\n        let mut child = cmd\n            .spawn()\n            .context(\"Failed to invoke claude CLI. Is it installed and in PATH?\")?;\n\n        let mut captured_output = String::new();\n        if let Some(stdout) = child.stdout.take() {\n            let reader = std::io::BufReader::new(stdout);\n            for line in reader.lines().map_while(Result::ok) {\n                for text in extract_text_from_stream_json(\u0026line) {\n                    for text_line in text.lines() {\n                        callback(text_line)?;\n                        captured_output.push_str(text_line);\n                        captured_output.push('\\n');\n                    }\n                }\n            }\n        }\n\n        let status = child.wait()?;\n        if !status.success() {\n            anyhow::bail!(\"Agent exited with status: {}\", status);\n        }\n\n        Ok(captured_output)\n    }\n\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"claude\"\n    }\n}\n\n/// Ollama provider (OpenAI-compatible API with agent runtime)\npub struct OllamaProvider {\n    pub endpoint: String,\n    pub max_retries: u32,\n    pub retry_delay_ms: u64,\n}\n\nimpl ModelProvider for OllamaProvider {\n    fn invoke(\n        \u0026self,\n        message: \u0026str,\n        model: \u0026str,\n        callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    ) -\u003e Result\u003cString\u003e {\n        // Validate endpoint URL\n        if !self.endpoint.starts_with(\"http://\") \u0026\u0026 !self.endpoint.starts_with(\"https://\") {\n            return Err(anyhow!(\"Invalid endpoint URL: {}\", self.endpoint));\n        }\n\n        crate::agent::run_agent_with_retries(\n            \u0026self.endpoint,\n            model,\n            \"\",\n            message,\n            callback,\n            self.max_retries,\n            self.retry_delay_ms,\n        )\n        .map_err(|e| {\n            let err_str = e.to_string();\n            if err_str.contains(\"Connection\") || err_str.contains(\"connect\") {\n                anyhow!(\"Failed to connect to Ollama at {}\\n\\nOllama does not appear to be running. To fix:\\n\\n  1. Install Ollama: https://ollama.ai/download\\n  2. Start Ollama: ollama serve\\n  3. Pull a model: ollama pull {}\\n\\nOr switch to Claude CLI by removing 'provider: ollama' from .chant/config.md\", self.endpoint, model)\n            } else {\n                e\n            }\n        })\n    }\n\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"ollama\"\n    }\n}\n\n/// OpenAI provider\npub struct OpenaiProvider {\n    pub endpoint: String,\n    pub api_key: Option\u003cString\u003e,\n    pub max_retries: u32,\n    pub retry_delay_ms: u64,\n}\n\nimpl ModelProvider for OpenaiProvider {\n    fn invoke(\n        \u0026self,\n        message: \u0026str,\n        model: \u0026str,\n        callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    ) -\u003e Result\u003cString\u003e {\n        let api_key = self\n            .api_key\n            .clone()\n            .or_else(|| std::env::var(\"OPENAI_API_KEY\").ok())\n            .ok_or_else(|| anyhow!(\"OPENAI_API_KEY environment variable not set\"))?;\n\n        let url = format!(\"{}/chat/completions\", self.endpoint);\n\n        // Validate endpoint URL\n        if !self.endpoint.starts_with(\"http://\") \u0026\u0026 !self.endpoint.starts_with(\"https://\") {\n            return Err(anyhow!(\"Invalid endpoint URL: {}\", self.endpoint));\n        }\n\n        let request_body = serde_json::json!({\n            \"model\": model,\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": message\n                }\n            ],\n            \"stream\": true,\n        });\n\n        // Retry loop with exponential backoff\n        let mut attempt = 0;\n        loop {\n            attempt += 1;\n\n            // Create HTTP agent and send request\n            let agent = Agent::new();\n            let response = agent\n                .post(\u0026url)\n                .set(\"Content-Type\", \"application/json\")\n                .set(\"Authorization\", \u0026format!(\"Bearer {}\", api_key))\n                .send_json(\u0026request_body)\n                .map_err(|e| anyhow!(\"HTTP request failed: {}\", e))?;\n\n            let status = response.status();\n\n            // Check response status\n            if status == 401 {\n                return Err(anyhow!(\n                    \"Authentication failed. Check OPENAI_API_KEY env var\"\n                ));\n            }\n\n            // Check for throttle/error conditions (429 or 400+ errors)\n            let is_retryable =\n                status == 429 || status == 500 || status == 502 || status == 503 || status == 504;\n\n            if status == 200 {\n                // Success - process response\n                return self.process_response(response, callback);\n            } else if is_retryable \u0026\u0026 attempt \u003c= self.max_retries {\n                // Retryable error - wait and retry\n                let delay_ms = self.calculate_backoff(attempt);\n                callback(\u0026format!(\n                    \"[Retry {}] HTTP {} - waiting {}ms before retry\",\n                    attempt, status, delay_ms\n                ))?;\n                std::thread::sleep(std::time::Duration::from_millis(delay_ms));\n                continue;\n            } else {\n                // Non-retryable error or max retries exceeded\n                return Err(anyhow!(\n                    \"HTTP {}: {} (after {} attempt{})\",\n                    status,\n                    response.status_text(),\n                    attempt,\n                    if attempt == 1 { \"\" } else { \"s\" }\n                ));\n            }\n        }\n    }\n\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"openai\"\n    }\n}\n\nimpl OpenaiProvider {\n    /// Calculate exponential backoff delay with jitter\n    fn calculate_backoff(\u0026self, attempt: u32) -\u003e u64 {\n        let base_delay = self.retry_delay_ms;\n        let exponential = 2u64.saturating_pow(attempt - 1);\n        let delay = base_delay.saturating_mul(exponential);\n        // Add jitter: Â±10% of delay to avoid thundering herd\n        let jitter = (delay / 10).saturating_mul(\n            ((attempt as u64).wrapping_mul(7)) % 21 / 10, // Deterministic pseudo-random jitter\n        );\n        if attempt.is_multiple_of(2) {\n            delay.saturating_add(jitter)\n        } else {\n            delay.saturating_sub(jitter)\n        }\n    }\n\n    /// Process successful API response\n    fn process_response(\n        \u0026self,\n        response: ureq::Response,\n        callback: \u0026mut dyn FnMut(\u0026str) -\u003e Result\u003c()\u003e,\n    ) -\u003e Result\u003cString\u003e {\n        let reader = std::io::BufReader::new(response.into_reader());\n        let mut captured_output = String::new();\n        let mut line_buffer = String::new();\n\n        for line in reader.lines().map_while(Result::ok) {\n            if let Some(json_str) = line.strip_prefix(\"data: \") {\n                if json_str == \"[DONE]\" {\n                    break;\n                }\n\n                if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(json_str) {\n                    if let Some(choices) = json.get(\"choices\").and_then(|c| c.as_array()) {\n                        for choice in choices {\n                            if let Some(delta) = choice.get(\"delta\") {\n                                if let Some(content) = delta.get(\"content\").and_then(|c| c.as_str())\n                                {\n                                    line_buffer.push_str(content);\n\n                                    // Only callback when we have complete lines\n                                    while let Some(newline_pos) = line_buffer.find('\\n') {\n                                        let complete_line = \u0026line_buffer[..newline_pos];\n                                        callback(complete_line)?;\n                                        captured_output.push_str(complete_line);\n                                        captured_output.push('\\n');\n                                        line_buffer = line_buffer[newline_pos + 1..].to_string();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Flush any remaining buffered content\n        if !line_buffer.is_empty() {\n            callback(\u0026line_buffer)?;\n            captured_output.push_str(\u0026line_buffer);\n            captured_output.push('\\n');\n        }\n\n        if captured_output.is_empty() {\n            return Err(anyhow!(\"Empty response from OpenAI API\"));\n        }\n\n        Ok(captured_output)\n    }\n}\n\n/// Helper function to extract text from Claude CLI stream-json format\nfn extract_text_from_stream_json(line: \u0026str) -\u003e Vec\u003cString\u003e {\n    let mut texts = Vec::new();\n\n    if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(line) {\n        if let Some(\"assistant\") = json.get(\"type\").and_then(|t| t.as_str()) {\n            if let Some(content) = json\n                .get(\"message\")\n                .and_then(|m| m.get(\"content\"))\n                .and_then(|c| c.as_array())\n            {\n                for item in content {\n                    if let Some(text) = item.get(\"text\").and_then(|t| t.as_str()) {\n                        texts.push(text.to_string());\n                    }\n                }\n            }\n        }\n    }\n\n    texts\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_ollama_endpoint() {\n        assert_eq!(\n            default_ollama_endpoint(),\n            \"http://localhost:11434/v1\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_default_openai_endpoint() {\n        assert_eq!(\n            default_openai_endpoint(),\n            \"https://api.openai.com/v1\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_claude_provider_name() {\n        let provider = ClaudeCliProvider;\n        assert_eq!(provider.name(), \"claude\");\n    }\n\n    #[test]\n    fn test_ollama_provider_name() {\n        let provider = OllamaProvider {\n            endpoint: \"http://localhost:11434/v1\".to_string(),\n            max_retries: 3,\n            retry_delay_ms: 1000,\n        };\n        assert_eq!(provider.name(), \"ollama\");\n    }\n\n    #[test]\n    fn test_openai_provider_name() {\n        let provider = OpenaiProvider {\n            endpoint: \"https://api.openai.com/v1\".to_string(),\n            api_key: None,\n            max_retries: 3,\n            retry_delay_ms: 1000,\n        };\n        assert_eq!(provider.name(), \"openai\");\n    }\n\n    #[test]\n    fn test_provider_type_default() {\n        let provider_type: ProviderType = Default::default();\n        assert_eq!(provider_type, ProviderType::Claude);\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":104,"address":[],"length":0,"stats":{"Line":12}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":114,"address":[],"length":0,"stats":{"Line":8}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":24}},{"line":118,"address":[],"length":0,"stats":{"Line":28}},{"line":119,"address":[],"length":0,"stats":{"Line":38}},{"line":120,"address":[],"length":0,"stats":{"Line":34}},{"line":121,"address":[],"length":0,"stats":{"Line":102}},{"line":122,"address":[],"length":0,"stats":{"Line":68}},{"line":128,"address":[],"length":0,"stats":{"Line":12}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":354,"address":[],"length":0,"stats":{"Line":24}},{"line":356,"address":[],"length":0,"stats":{"Line":24}},{"line":357,"address":[],"length":0,"stats":{"Line":72}},{"line":358,"address":[],"length":0,"stats":{"Line":8}},{"line":360,"address":[],"length":0,"stats":{"Line":12}},{"line":361,"address":[],"length":0,"stats":{"Line":12}},{"line":363,"address":[],"length":0,"stats":{"Line":8}},{"line":364,"address":[],"length":0,"stats":{"Line":28}},{"line":365,"address":[],"length":0,"stats":{"Line":12}},{"line":372,"address":[],"length":0,"stats":{"Line":12}}],"covered":41,"coverable":136},{"path":["/","Users","alex","Documents","checkouts","chant","src","render.rs"],"content":"//! Terminal markdown rendering utilities.\n//!\n//! # Doc Audit\n//! - ignore: internal implementation detail\n\nuse colored::Colorize;\nuse pulldown_cmark::{Event, Parser, Tag, TagEnd};\n\nuse chant::ui;\n\n/// Re-export status_icon from ui module for backward compatibility\npub use chant::ui::status_icon;\n\n/// Renders markdown text to the terminal with ANSI formatting\npub fn render_markdown(markdown: \u0026str) {\n    let parser = Parser::new(markdown);\n    let mut renderer = TerminalRenderer::new();\n\n    for event in parser {\n        renderer.handle_event(event);\n    }\n\n    renderer.flush();\n}\n\nstruct TerminalRenderer {\n    buffer: String,\n    in_code_block: bool,\n    in_italic: bool,\n    in_bold: bool,\n    heading_level: usize,\n    in_table_cell: bool,\n    table_cells: Vec\u003cString\u003e,\n    list_depth: usize,\n    ordered_list_depth: Vec\u003cusize\u003e,\n}\n\nimpl TerminalRenderer {\n    fn new() -\u003e Self {\n        Self {\n            buffer: String::new(),\n            in_code_block: false,\n            in_italic: false,\n            in_bold: false,\n            heading_level: 0,\n            in_table_cell: false,\n            table_cells: Vec::new(),\n            list_depth: 0,\n            ordered_list_depth: Vec::new(),\n        }\n    }\n\n    fn handle_event(\u0026mut self, event: Event) {\n        match event {\n            Event::Start(tag) =\u003e self.handle_start_tag(tag),\n            Event::End(tag_end) =\u003e self.handle_end_tag(tag_end),\n            Event::Text(text) =\u003e self.buffer.push_str(\u0026text),\n            Event::Code(text) =\u003e {\n                self.buffer.push('`');\n                self.buffer.push_str(\u0026text);\n                self.buffer.push('`');\n            }\n            Event::SoftBreak | Event::HardBreak =\u003e {\n                self.buffer.push('\\n');\n            }\n            Event::Rule =\u003e {\n                self.flush();\n                println!(\"{}\", \"â\".repeat(40).dimmed());\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn handle_start_tag(\u0026mut self, tag: Tag) {\n        match tag {\n            Tag::Heading { level, .. } =\u003e {\n                self.flush();\n                self.heading_level = match level {\n                    pulldown_cmark::HeadingLevel::H1 =\u003e 1,\n                    pulldown_cmark::HeadingLevel::H2 =\u003e 2,\n                    pulldown_cmark::HeadingLevel::H3 =\u003e 3,\n                    pulldown_cmark::HeadingLevel::H4 =\u003e 4,\n                    pulldown_cmark::HeadingLevel::H5 =\u003e 5,\n                    pulldown_cmark::HeadingLevel::H6 =\u003e 6,\n                };\n            }\n            Tag::Paragraph =\u003e {\n                // Paragraph start - no special handling needed\n            }\n            Tag::Emphasis =\u003e {\n                self.in_italic = true;\n            }\n            Tag::Strong =\u003e {\n                self.in_bold = true;\n            }\n            Tag::CodeBlock(_) =\u003e {\n                self.flush();\n                self.in_code_block = true;\n                self.buffer.clear();\n            }\n            Tag::Link { .. } =\u003e {\n                // Link text will be handled, URL will be appended on end\n            }\n            Tag::Image { .. } =\u003e {\n                // Image alt text will be handled\n            }\n            Tag::List(ordered) =\u003e {\n                self.flush();\n                self.list_depth += 1;\n                if let Some(start_num) = ordered {\n                    self.ordered_list_depth.push(start_num as usize);\n                } else {\n                    self.ordered_list_depth.push(0);\n                }\n            }\n            Tag::Item =\u003e {\n                self.flush();\n                let indent = \"  \".repeat(self.list_depth.saturating_sub(1));\n                if let Some(last) = self.ordered_list_depth.last_mut() {\n                    if *last \u003e 0 {\n                        print!(\"{}{}. \", indent, last);\n                        *last += 1;\n                    } else {\n                        print!(\"{}â¢ \", indent);\n                    }\n                }\n            }\n            Tag::Table(_) =\u003e {\n                self.flush();\n            }\n            Tag::TableHead =\u003e {\n                // Table head - cells will be collected\n            }\n            Tag::TableRow =\u003e {\n                // Row start\n            }\n            Tag::TableCell =\u003e {\n                self.in_table_cell = true;\n            }\n            Tag::BlockQuote =\u003e {\n                self.flush();\n                print!(\"{}\", \"\u003e \".dimmed());\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn handle_end_tag(\u0026mut self, tag_end: TagEnd) {\n        match tag_end {\n            TagEnd::Heading(_) =\u003e {\n                let formatted = ui::colors::markdown_heading(\u0026self.buffer, self.heading_level);\n                println!(\"{}\", formatted);\n                self.buffer.clear();\n                self.heading_level = 0;\n                println!();\n            }\n            TagEnd::Paragraph =\u003e {\n                if !self.buffer.is_empty() {\n                    let output = if self.in_bold \u0026\u0026 self.in_italic {\n                        self.buffer.bold().italic().to_string()\n                    } else if self.in_bold {\n                        self.buffer.bold().to_string()\n                    } else if self.in_italic {\n                        self.buffer.italic().to_string()\n                    } else {\n                        self.buffer.clone()\n                    };\n                    println!(\"{}\", output);\n                    self.buffer.clear();\n                }\n                println!();\n            }\n            TagEnd::Emphasis =\u003e {\n                self.in_italic = false;\n            }\n            TagEnd::Strong =\u003e {\n                self.in_bold = false;\n            }\n            TagEnd::CodeBlock =\u003e {\n                self.in_code_block = false;\n                if !self.buffer.is_empty() {\n                    for line in self.buffer.lines() {\n                        println!(\"{}\", line.dimmed());\n                    }\n                    self.buffer.clear();\n                }\n                println!();\n            }\n            TagEnd::Link =\u003e {\n                // Link end - text already in buffer\n            }\n            TagEnd::Image =\u003e {\n                // Image alt text already handled\n            }\n            TagEnd::List(_) =\u003e {\n                if self.list_depth \u003e 0 {\n                    self.list_depth -= 1;\n                    self.ordered_list_depth.pop();\n                }\n                println!();\n            }\n            TagEnd::Item =\u003e {\n                if !self.buffer.is_empty() {\n                    println!(\"{}\", self.buffer);\n                    self.buffer.clear();\n                }\n            }\n            TagEnd::Table =\u003e {\n                println!();\n            }\n            TagEnd::TableHead =\u003e {\n                // Separator after table head\n            }\n            TagEnd::TableRow =\u003e {\n                self.table_cells.clear();\n            }\n            TagEnd::TableCell =\u003e {\n                self.in_table_cell = false;\n                self.table_cells.push(self.buffer.clone());\n                self.buffer.clear();\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn flush(\u0026mut self) {\n        if !self.buffer.is_empty() {\n            let output = if self.in_bold \u0026\u0026 self.in_italic {\n                self.buffer.bold().italic().to_string()\n            } else if self.in_bold {\n                self.buffer.bold().to_string()\n            } else if self.in_italic {\n                self.buffer.italic().to_string()\n            } else {\n                self.buffer.clone()\n            };\n            print!(\"{}\", output);\n            self.buffer.clear();\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":129},{"path":["/","Users","alex","Documents","checkouts","chant","src","retry.rs"],"content":"//! Retry logic with exponential backoff for failed specs.\n//!\n//! Provides retry state tracking and decision logic for determining whether\n//! a failed spec should be retried or marked as permanently failed.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\nuse crate::config::FailureConfig;\n\n/// Maximum retry delay capped at 1 hour to prevent overflow\nconst MAX_RETRY_DELAY_MS: u64 = 3_600_000;\n\n/// Retry state for tracking retry attempts and timing\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RetryState {\n    /// Number of retry attempts made so far\n    pub attempts: usize,\n    /// Timestamp of last retry attempt (milliseconds since epoch)\n    pub last_retry_time: u64,\n    /// Timestamp when next retry should occur (milliseconds since epoch)\n    pub next_retry_time: u64,\n}\n\nimpl RetryState {\n    /// Create a new retry state with no attempts\n    pub fn new() -\u003e Self {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n\n        Self {\n            attempts: 0,\n            last_retry_time: now,\n            next_retry_time: now,\n        }\n    }\n\n    /// Update retry state after a failed attempt\n    pub fn record_attempt(\u0026mut self, next_delay_ms: u64) {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n\n        self.attempts += 1;\n        self.last_retry_time = now;\n        self.next_retry_time = now + next_delay_ms;\n    }\n}\n\nimpl Default for RetryState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Decision on whether to retry a failed spec\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum RetryDecision {\n    /// Retry after the specified delay\n    Retry(Duration),\n    /// Permanent failure with reason\n    PermanentFailure(String),\n}\n\n/// Determine whether a failed spec should be retried based on error log and config.\n///\n/// # Arguments\n/// * `spec_id` - The spec ID (for error messages)\n/// * `error_log` - The error log content to scan for retryable patterns\n/// * `config` - Failure configuration with retry settings and patterns\n///\n/// # Returns\n/// * `Ok(RetryDecision::Retry(delay))` - Should retry after the delay\n/// * `Ok(RetryDecision::PermanentFailure(reason))` - Permanent failure, don't retry\n/// * `Err(_)` - Configuration error\n///\n/// # Edge Cases\n/// * Empty or missing error log â PermanentFailure\n/// * max_retries = 0 â First failure is permanent\n/// * No pattern match â PermanentFailure\n/// * Backoff overflow â Capped at 1 hour\n/// * Multiple pattern matches â Still retryable (OR logic)\npub fn should_retry(\n    spec_id: \u0026str,\n    error_log: \u0026str,\n    config: \u0026FailureConfig,\n) -\u003e Result\u003cRetryDecision\u003e {\n    // Validate config\n    config.validate()?;\n\n    // Edge case: Empty or missing error log\n    if error_log.trim().is_empty() {\n        return Ok(RetryDecision::PermanentFailure(\n            \"Empty error log (no pattern match)\".to_string(),\n        ));\n    }\n\n    // Edge case: max_retries = 0 means first failure is permanent\n    if config.max_retries == 0 {\n        return Ok(RetryDecision::PermanentFailure(\n            \"max_retries is 0\".to_string(),\n        ));\n    }\n\n    // Check if error log contains any retryable pattern\n    let has_retryable_pattern = config\n        .retryable_patterns\n        .iter()\n        .any(|pattern| error_log.contains(pattern));\n\n    if !has_retryable_pattern {\n        return Ok(RetryDecision::PermanentFailure(format!(\n            \"No retryable pattern found in error log for spec {}\",\n            spec_id\n        )));\n    }\n\n    // At this point, we have a retryable error\n    // We need to get the current attempt count from somewhere\n    // For now, we'll calculate based on the assumption this is called after each failure\n    // The caller should maintain RetryState to track attempts\n\n    Ok(RetryDecision::PermanentFailure(\n        \"Retry state tracking not yet integrated\".to_string(),\n    ))\n}\n\n/// Calculate exponential backoff delay for a given attempt number.\n///\n/// Formula: delay = base_delay * (backoff_multiplier ^ attempt)\n/// Capped at MAX_RETRY_DELAY_MS (1 hour) to prevent overflow.\n///\n/// # Arguments\n/// * `attempt` - The current attempt number (0-indexed)\n/// * `base_delay_ms` - Base delay in milliseconds\n/// * `backoff_multiplier` - Multiplier for exponential backoff (must be \u003e= 1.0)\n///\n/// # Returns\n/// Delay in milliseconds, capped at 1 hour\npub fn calculate_backoff_delay(attempt: usize, base_delay_ms: u64, backoff_multiplier: f64) -\u003e u64 {\n    // Calculate delay with overflow protection\n    let delay = (base_delay_ms as f64) * backoff_multiplier.powi(attempt as i32);\n\n    // Cap at maximum delay\n    if delay \u003e MAX_RETRY_DELAY_MS as f64 {\n        MAX_RETRY_DELAY_MS\n    } else {\n        delay as u64\n    }\n}\n\n/// Determine retry decision based on retry state and config.\n///\n/// # Arguments\n/// * `state` - Current retry state with attempt count\n/// * `error_log` - Error log to check for retryable patterns\n/// * `config` - Failure configuration\n///\n/// # Returns\n/// * `RetryDecision::Retry(delay)` if should retry\n/// * `RetryDecision::PermanentFailure(reason)` if should not retry\npub fn decide_retry(state: \u0026RetryState, error_log: \u0026str, config: \u0026FailureConfig) -\u003e RetryDecision {\n    // Edge case: Empty or missing error log\n    if error_log.trim().is_empty() {\n        return RetryDecision::PermanentFailure(\"Empty error log (no pattern match)\".to_string());\n    }\n\n    // Edge case: max_retries = 0 means first failure is permanent\n    if config.max_retries == 0 {\n        return RetryDecision::PermanentFailure(\"max_retries is 0\".to_string());\n    }\n\n    // Check if we've exceeded max retries\n    if state.attempts \u003e= config.max_retries {\n        return RetryDecision::PermanentFailure(format!(\n            \"Exceeded max retries ({}/{})\",\n            state.attempts, config.max_retries\n        ));\n    }\n\n    // Check if error log contains any retryable pattern (OR logic)\n    let has_retryable_pattern = config\n        .retryable_patterns\n        .iter()\n        .any(|pattern| error_log.contains(pattern));\n\n    if !has_retryable_pattern {\n        return RetryDecision::PermanentFailure(\n            \"No retryable pattern found in error log\".to_string(),\n        );\n    }\n\n    // Calculate exponential backoff delay\n    let delay_ms = calculate_backoff_delay(\n        state.attempts,\n        config.retry_delay_ms,\n        config.backoff_multiplier,\n    );\n\n    RetryDecision::Retry(Duration::from_millis(delay_ms))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn test_config() -\u003e FailureConfig {\n        FailureConfig {\n            max_retries: 3,\n            retry_delay_ms: 60_000, // 60 seconds\n            backoff_multiplier: 2.0,\n            retryable_patterns: vec![\"rate_limit\".to_string()],\n            on_permanent_failure: crate::config::OnPermanentFailure::Skip,\n        }\n    }\n\n    #[test]\n    fn test_retry_state_new() {\n        let state = RetryState::new();\n        assert_eq!(state.attempts, 0);\n        assert!(state.last_retry_time \u003e 0);\n        assert_eq!(state.last_retry_time, state.next_retry_time);\n    }\n\n    #[test]\n    fn test_retry_state_record_attempt() {\n        let mut state = RetryState::new();\n        let initial_time = state.last_retry_time;\n\n        state.record_attempt(5000);\n\n        assert_eq!(state.attempts, 1);\n        assert!(state.last_retry_time \u003e= initial_time);\n        assert_eq!(state.next_retry_time, state.last_retry_time + 5000);\n    }\n\n    #[test]\n    fn test_calculate_backoff_delay() {\n        // Base case: attempt 0\n        assert_eq!(calculate_backoff_delay(0, 60_000, 2.0), 60_000);\n\n        // Attempt 1: 60s * 2^1 = 120s\n        assert_eq!(calculate_backoff_delay(1, 60_000, 2.0), 120_000);\n\n        // Attempt 2: 60s * 2^2 = 240s\n        assert_eq!(calculate_backoff_delay(2, 60_000, 2.0), 240_000);\n\n        // Attempt 3: 60s * 2^3 = 480s\n        assert_eq!(calculate_backoff_delay(3, 60_000, 2.0), 480_000);\n    }\n\n    #[test]\n    fn test_calculate_backoff_delay_with_different_multiplier() {\n        // Multiplier 1.5\n        assert_eq!(calculate_backoff_delay(0, 60_000, 1.5), 60_000);\n        assert_eq!(calculate_backoff_delay(1, 60_000, 1.5), 90_000);\n        assert_eq!(calculate_backoff_delay(2, 60_000, 1.5), 135_000);\n    }\n\n    #[test]\n    fn test_calculate_backoff_delay_overflow_cap() {\n        // Large attempt number should be capped at 1 hour\n        let delay = calculate_backoff_delay(100, 60_000, 2.0);\n        assert_eq!(delay, MAX_RETRY_DELAY_MS);\n    }\n\n    #[test]\n    fn test_decide_retry_with_retryable_error() {\n        let mut state = RetryState::new();\n        let config = test_config();\n        let error_log = \"Error: API rate_limit exceeded\";\n\n        // First attempt (state.attempts = 0)\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::Retry(_)));\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_millis(), 60_000); // 60s\n        }\n\n        // Second attempt\n        state.record_attempt(60_000);\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::Retry(_)));\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_millis(), 120_000); // 120s\n        }\n\n        // Third attempt\n        state.record_attempt(120_000);\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::Retry(_)));\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_millis(), 240_000); // 240s\n        }\n\n        // Fourth attempt - exceeds max_retries\n        state.record_attempt(240_000);\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::PermanentFailure(_)));\n    }\n\n    #[test]\n    fn test_decide_retry_with_non_retryable_error() {\n        let state = RetryState::new();\n        let config = test_config();\n        let error_log = \"Error: syntax error in code\";\n\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::PermanentFailure(_)));\n    }\n\n    #[test]\n    fn test_decide_retry_empty_error_log() {\n        let state = RetryState::new();\n        let config = test_config();\n\n        let decision = decide_retry(\u0026state, \"\", \u0026config);\n        assert!(matches!(decision, RetryDecision::PermanentFailure(_)));\n\n        let decision = decide_retry(\u0026state, \"   \", \u0026config);\n        assert!(matches!(decision, RetryDecision::PermanentFailure(_)));\n    }\n\n    #[test]\n    fn test_decide_retry_max_retries_zero() {\n        let state = RetryState::new();\n        let mut config = test_config();\n        config.max_retries = 0;\n\n        let error_log = \"Error: rate_limit exceeded\";\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        assert!(matches!(decision, RetryDecision::PermanentFailure(_)));\n    }\n\n    #[test]\n    fn test_decide_retry_multiple_patterns() {\n        let state = RetryState::new();\n        let mut config = test_config();\n        config.retryable_patterns = vec![\n            \"rate_limit\".to_string(),\n            \"timeout\".to_string(),\n            \"connection_refused\".to_string(),\n        ];\n\n        // Test each pattern matches (OR logic)\n        let error_log1 = \"Error: rate_limit exceeded\";\n        assert!(matches!(\n            decide_retry(\u0026state, error_log1, \u0026config),\n            RetryDecision::Retry(_)\n        ));\n\n        let error_log2 = \"Error: timeout occurred\";\n        assert!(matches!(\n            decide_retry(\u0026state, error_log2, \u0026config),\n            RetryDecision::Retry(_)\n        ));\n\n        let error_log3 = \"Error: connection_refused\";\n        assert!(matches!(\n            decide_retry(\u0026state, error_log3, \u0026config),\n            RetryDecision::Retry(_)\n        ));\n    }\n\n    #[test]\n    fn test_decide_retry_backoff_calculation() {\n        let mut state = RetryState::new();\n        let config = test_config();\n        let error_log = \"Error: rate_limit exceeded\";\n\n        // Attempt 0: 60s * 2^0 = 60s\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_secs(), 60);\n        }\n\n        // Attempt 1: 60s * 2^1 = 120s\n        state.record_attempt(60_000);\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_secs(), 120);\n        }\n\n        // Attempt 2: 60s * 2^2 = 240s\n        state.record_attempt(120_000);\n        let decision = decide_retry(\u0026state, error_log, \u0026config);\n        if let RetryDecision::Retry(delay) = decision {\n            assert_eq!(delay.as_secs(), 240);\n        }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":24}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":18}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":17}},{"line":146,"address":[],"length":0,"stats":{"Line":68}},{"line":149,"address":[],"length":0,"stats":{"Line":17}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":16}},{"line":166,"address":[],"length":0,"stats":{"Line":14}},{"line":168,"address":[],"length":0,"stats":{"Line":28}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":11}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":49}},{"line":191,"address":[],"length":0,"stats":{"Line":10}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":9}},{"line":200,"address":[],"length":0,"stats":{"Line":9}},{"line":201,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":9}}],"covered":37,"coverable":56},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","ac_quality.rs"],"content":"//! Acceptance criteria quality scoring.\n//!\n//! Analyzes individual acceptance criteria based on:\n//! - Phrasing: Uses imperative verbs (implement, add, create, etc.)\n//! - Value: Addresses real requirements (not meta/admin tasks)\n//! - Testability: Concrete and measurable (can verify completion)\n\nuse crate::scoring::ACQualityGrade;\n\n/// List of imperative verbs that indicate clear, actionable criteria\nconst IMPERATIVE_VERBS: \u0026[\u0026str] = \u0026[\n    \"implement\",\n    \"add\",\n    \"create\",\n    \"update\",\n    \"fix\",\n    \"remove\",\n    \"delete\",\n    \"refactor\",\n    \"test\",\n    \"verify\",\n    \"ensure\",\n    \"validate\",\n    \"configure\",\n    \"setup\",\n    \"install\",\n    \"deploy\",\n    \"build\",\n    \"run\",\n    \"execute\",\n    \"check\",\n    \"document\",\n    \"write\",\n    \"read\",\n    \"parse\",\n    \"handle\",\n    \"process\",\n    \"calculate\",\n    \"compute\",\n    \"convert\",\n    \"transform\",\n    \"migrate\",\n    \"upgrade\",\n    \"downgrade\",\n];\n\n/// List of meta/admin phrases that indicate low-value criteria\nconst META_PHRASES: \u0026[\u0026str] = \u0026[\n    \"update spec\",\n    \"add comment\",\n    \"update comment\",\n    \"add documentation\",\n    \"update documentation\",\n    \"add todo\",\n    \"update readme\",\n];\n\n/// List of vague verbs that indicate untestable criteria\nconst VAGUE_VERBS: \u0026[\u0026str] = \u0026[\n    \"understand\",\n    \"consider\",\n    \"improve\",\n    \"enhance\",\n    \"optimize\",\n    \"investigate\",\n    \"explore\",\n    \"research\",\n    \"think about\",\n    \"look into\",\n];\n\n/// Calculate acceptance criteria quality grade.\n///\n/// Scores each criterion on three dimensions:\n/// - Phrasing: Starts with an imperative verb\n/// - Value: Not a meta/admin task\n/// - Testability: Concrete and measurable (no vague verbs)\n///\n/// A criterion passes if it meets all three checks.\n///\n/// Grading rules:\n/// - Grade A: \u003e90% criteria pass all three checks\n/// - Grade B: \u003e70% criteria pass all three checks\n/// - Grade C: \u003e50% criteria pass all three checks\n/// - Grade D: â¤50% criteria pass\n///\n/// Edge cases:\n/// - Empty criteria list returns Grade D\n/// - Single criterion that passes returns Grade A\n///\n/// # Arguments\n///\n/// * `criteria` - Slice of acceptance criteria strings to analyze\n///\n/// # Returns\n///\n/// An `ACQualityGrade` based on the percentage of criteria that pass all checks\npub fn calculate_ac_quality(criteria: \u0026[String]) -\u003e ACQualityGrade {\n    // Edge case: empty criteria list\n    if criteria.is_empty() {\n        return ACQualityGrade::D;\n    }\n\n    // Count criteria that pass all three checks\n    let passing_count = criteria\n        .iter()\n        .filter(|criterion| {\n            let has_imperative = has_imperative_verb(criterion);\n            let has_value = !is_meta_task(criterion);\n            let is_testable = !has_vague_verb(criterion);\n\n            has_imperative \u0026\u0026 has_value \u0026\u0026 is_testable\n        })\n        .count();\n\n    // Calculate pass ratio\n    let pass_ratio = passing_count as f64 / criteria.len() as f64;\n\n    // Apply grading rules\n    if pass_ratio \u003e 0.90 {\n        ACQualityGrade::A\n    } else if pass_ratio \u003e 0.70 {\n        ACQualityGrade::B\n    } else if pass_ratio \u003e 0.50 {\n        ACQualityGrade::C\n    } else {\n        ACQualityGrade::D\n    }\n}\n\n/// Check if a criterion starts with an imperative verb.\n///\n/// Extracts the first word and checks if it matches a known imperative verb.\nfn has_imperative_verb(criterion: \u0026str) -\u003e bool {\n    let first_word = criterion.split_whitespace().next().unwrap_or(\"\");\n\n    IMPERATIVE_VERBS.contains(\u0026first_word.to_lowercase().as_str())\n}\n\n/// Check if a criterion is a meta/admin task (low value).\n///\n/// Looks for common meta phrases that indicate the criterion is about\n/// maintaining the spec itself rather than delivering actual functionality.\nfn is_meta_task(criterion: \u0026str) -\u003e bool {\n    let criterion_lower = criterion.to_lowercase();\n\n    META_PHRASES\n        .iter()\n        .any(|phrase| criterion_lower.contains(phrase))\n}\n\n/// Check if a criterion uses vague verbs (untestable).\n///\n/// Looks for verbs that indicate unclear or unmeasurable requirements.\nfn has_vague_verb(criterion: \u0026str) -\u003e bool {\n    let criterion_lower = criterion.to_lowercase();\n\n    VAGUE_VERBS.iter().any(|verb| {\n        // Check if the vague verb appears as the first word or within the criterion\n        let words: Vec\u003c\u0026str\u003e = criterion_lower.split_whitespace().collect();\n        (words.first() == Some(verb))\n            || criterion_lower.contains(\u0026format!(\" {} \", verb))\n            || criterion_lower.starts_with(\u0026format!(\"{} \", verb))\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_empty_criteria_returns_grade_d() {\n        let criteria: Vec\u003cString\u003e = vec![];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::D);\n    }\n\n    #[test]\n    fn test_single_passing_criterion_returns_grade_a() {\n        let criteria = vec![\"Implement function X\".to_string()];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::A);\n    }\n\n    #[test]\n    fn test_all_passing_criteria_grade_a() {\n        let criteria = vec![\n            \"Implement function X\".to_string(),\n            \"Add test for Y\".to_string(),\n            \"Verify Z works\".to_string(),\n        ];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::A);\n    }\n\n    #[test]\n    fn test_all_failing_criteria_grade_d() {\n        let criteria = vec![\n            \"Update spec\".to_string(),\n            \"Consider edge cases\".to_string(),\n            \"Improve code\".to_string(),\n        ];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::D);\n    }\n\n    #[test]\n    fn test_mixed_criteria_grade_b() {\n        // 1 passes, 1 is meta â 50% â Grade C\n        // Actually need \u003e70% for B, so let's have 2 pass out of 3\n        let criteria = vec![\n            \"Create endpoint /api/foo\".to_string(),\n            \"Add test coverage\".to_string(),\n            \"Update README\".to_string(), // meta task\n        ];\n        // 2/3 = 66.7% â Grade C (need \u003e70% for B)\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::C);\n    }\n\n    #[test]\n    fn test_grade_b_boundary() {\n        // Need \u003e70%, so 8 out of 10 = 80%\n        let criteria = vec![\n            \"Implement feature A\".to_string(),\n            \"Add feature B\".to_string(),\n            \"Create feature C\".to_string(),\n            \"Build feature D\".to_string(),\n            \"Deploy feature E\".to_string(),\n            \"Test feature F\".to_string(),\n            \"Verify feature G\".to_string(),\n            \"Handle feature H\".to_string(),\n            \"Update spec\".to_string(),       // meta\n            \"Improve something\".to_string(), // vague\n        ];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::B);\n    }\n\n    #[test]\n    fn test_has_imperative_verb() {\n        assert!(has_imperative_verb(\"Implement feature X\"));\n        assert!(has_imperative_verb(\"add functionality\"));\n        assert!(has_imperative_verb(\"CREATE component\"));\n        assert!(!has_imperative_verb(\"This does not start with verb\"));\n        assert!(!has_imperative_verb(\"Something else\"));\n    }\n\n    #[test]\n    fn test_is_meta_task() {\n        assert!(is_meta_task(\"Update spec with new info\"));\n        assert!(is_meta_task(\"Add comment to file\"));\n        assert!(is_meta_task(\"Update README\"));\n        assert!(!is_meta_task(\"Implement feature X\"));\n        assert!(!is_meta_task(\"Create new component\"));\n    }\n\n    #[test]\n    fn test_has_vague_verb() {\n        assert!(has_vague_verb(\"Understand the codebase\"));\n        assert!(has_vague_verb(\"Consider edge cases\"));\n        assert!(has_vague_verb(\"Improve performance\"));\n        assert!(has_vague_verb(\"We should consider this\"));\n        assert!(!has_vague_verb(\"Implement feature X\"));\n        assert!(!has_vague_verb(\"Add test for Y\"));\n    }\n\n    #[test]\n    fn test_vague_verbs_fail_phrasing() {\n        // \"Improve\" and \"enhance\" are vague but not imperative verbs\n        let criteria = vec![\n            \"Improve code quality\".to_string(),\n            \"Enhance performance\".to_string(),\n        ];\n        // These fail testability (vague verbs) even though \"improve\" isn't in imperative list\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::D);\n    }\n\n    #[test]\n    fn test_case_insensitive_matching() {\n        assert!(has_imperative_verb(\"IMPLEMENT feature\"));\n        assert!(has_imperative_verb(\"Add Feature\"));\n        assert!(has_imperative_verb(\"CrEaTe component\"));\n    }\n\n    #[test]\n    fn test_grade_c_boundary() {\n        // \u003e50% but â¤70% â Grade C\n        // 6 out of 10 = 60%\n        let criteria = vec![\n            \"Implement feature A\".to_string(),\n            \"Add feature B\".to_string(),\n            \"Create feature C\".to_string(),\n            \"Build feature D\".to_string(),\n            \"Deploy feature E\".to_string(),\n            \"Test feature F\".to_string(),\n            \"Update spec\".to_string(),          // meta\n            \"Consider this\".to_string(),        // vague\n            \"Improve that\".to_string(),         // vague\n            \"Update documentation\".to_string(), // meta\n        ];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::C);\n    }\n\n    #[test]\n    fn test_exactly_50_percent_is_grade_d() {\n        // Exactly 50% should be Grade D (need \u003e50% for C)\n        let criteria = vec![\n            \"Implement feature A\".to_string(),\n            \"Add feature B\".to_string(),\n            \"Update spec\".to_string(),  // meta\n            \"Improve code\".to_string(), // vague\n        ];\n        // 2/4 = 50% â Grade D\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::D);\n    }\n\n    #[test]\n    fn test_single_failing_criterion_returns_grade_d() {\n        let criteria = vec![\"Update spec\".to_string()];\n        assert_eq!(calculate_ac_quality(\u0026criteria), ACQualityGrade::D);\n    }\n}\n","traces":[{"line":98,"address":[],"length":0,"stats":{"Line":36}},{"line":100,"address":[],"length":0,"stats":{"Line":72}},{"line":101,"address":[],"length":0,"stats":{"Line":23}},{"line":105,"address":[],"length":0,"stats":{"Line":26}},{"line":107,"address":[],"length":0,"stats":{"Line":54}},{"line":108,"address":[],"length":0,"stats":{"Line":123}},{"line":109,"address":[],"length":0,"stats":{"Line":82}},{"line":110,"address":[],"length":0,"stats":{"Line":82}},{"line":112,"address":[],"length":0,"stats":{"Line":100}},{"line":117,"address":[],"length":0,"stats":{"Line":39}},{"line":120,"address":[],"length":0,"stats":{"Line":13}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":7}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":49}},{"line":135,"address":[],"length":0,"stats":{"Line":245}},{"line":137,"address":[],"length":0,"stats":{"Line":147}},{"line":144,"address":[],"length":0,"stats":{"Line":46}},{"line":145,"address":[],"length":0,"stats":{"Line":138}},{"line":147,"address":[],"length":0,"stats":{"Line":46}},{"line":149,"address":[],"length":0,"stats":{"Line":883}},{"line":155,"address":[],"length":0,"stats":{"Line":47}},{"line":156,"address":[],"length":0,"stats":{"Line":141}},{"line":158,"address":[],"length":0,"stats":{"Line":475}},{"line":160,"address":[],"length":0,"stats":{"Line":1524}},{"line":161,"address":[],"length":0,"stats":{"Line":381}},{"line":162,"address":[],"length":0,"stats":{"Line":740}},{"line":163,"address":[],"length":0,"stats":{"Line":738}}],"covered":31,"coverable":31},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","confidence.rs"],"content":"//! Confidence scoring based on spec structure, bullet quality, and vague language.\n//!\n//! Analyzes spec quality by examining:\n//! - Bullet-to-prose ratio (structured vs unstructured content)\n//! - Imperative verb usage in bullets (clear actionable items)\n//! - Vague language patterns (unclear requirements)\n\nuse crate::config::Config;\nuse crate::scoring::ConfidenceGrade;\nuse crate::spec::Spec;\n\n/// List of imperative verbs that indicate clear, actionable bullets\nconst IMPERATIVE_VERBS: \u0026[\u0026str] = \u0026[\n    \"implement\",\n    \"add\",\n    \"create\",\n    \"update\",\n    \"fix\",\n    \"remove\",\n    \"delete\",\n    \"refactor\",\n    \"test\",\n    \"verify\",\n    \"ensure\",\n    \"validate\",\n    \"configure\",\n    \"setup\",\n    \"install\",\n    \"deploy\",\n    \"build\",\n    \"run\",\n    \"execute\",\n    \"check\",\n    \"document\",\n    \"write\",\n    \"read\",\n    \"parse\",\n    \"handle\",\n    \"process\",\n    \"calculate\",\n    \"compute\",\n    \"convert\",\n    \"transform\",\n    \"migrate\",\n    \"upgrade\",\n    \"downgrade\",\n];\n\n/// Calculate confidence grade based on spec structure, bullet quality, and vague language.\n///\n/// Grading rules:\n/// - Grade A: High bullet ratio (\u003e80%), verbs in \u003e80% bullets, no vague patterns\n/// - Grade B: Medium bullet ratio (\u003e50%), verbs in \u003e50% bullets, \u003c3 vague patterns\n/// - Grade C: Low bullet ratio (\u003e20%), verbs in \u003e30% bullets, 3-5 vague patterns\n/// - Grade D: Very low bullet ratio (\u003c20%) OR \u003e5 vague patterns\n///\n/// Edge cases:\n/// - Specs with no body text default to Grade D\n/// - Empty bullets don't count toward bullet ratio\n///\n/// # Arguments\n///\n/// * `spec` - The spec to analyze\n/// * `config` - Configuration (for potential future customization of vague patterns)\n///\n/// # Returns\n///\n/// A `ConfidenceGrade` based on the spec's structure and clarity\npub fn calculate_confidence(spec: \u0026Spec, _config: \u0026Config) -\u003e ConfidenceGrade {\n    // Edge case: empty body defaults to Grade D\n    if spec.body.trim().is_empty() {\n        return ConfidenceGrade::D;\n    }\n\n    // Count bullet lines and paragraph lines\n    let (bullet_lines, paragraph_lines) = count_bullets_and_paragraphs(\u0026spec.body);\n\n    // Calculate bullet-to-prose ratio\n    let bullet_ratio = if bullet_lines + paragraph_lines == 0 {\n        0.0\n    } else {\n        bullet_lines as f64 / (bullet_lines + paragraph_lines) as f64\n    };\n\n    // Count bullets with imperative verbs\n    let bullets_with_verbs = count_bullets_with_imperative_verbs(\u0026spec.body);\n    let verb_ratio = if bullet_lines == 0 {\n        0.0\n    } else {\n        bullets_with_verbs as f64 / bullet_lines as f64\n    };\n\n    // Count all instances of vague patterns (not deduplicated)\n    let vague_count = count_all_vague_instances(\u0026spec.body);\n\n    // Apply grading logic (check from best to worst grade)\n    // Grade D: Very low bullet ratio (\u003c20%) OR \u003e5 vague patterns\n    if bullet_ratio \u003c 0.20 || vague_count \u003e 5 {\n        return ConfidenceGrade::D;\n    }\n\n    // Grade A: High bullet ratio (\u003e80%), verbs in \u003e80% bullets, no vague patterns\n    if bullet_ratio \u003e 0.80 \u0026\u0026 verb_ratio \u003e 0.80 \u0026\u0026 vague_count == 0 {\n        return ConfidenceGrade::A;\n    }\n\n    // Grade B: Medium bullet ratio (\u003e50%), verbs in \u003e50% bullets, \u003c3 vague patterns\n    if bullet_ratio \u003e 0.50 \u0026\u0026 verb_ratio \u003e 0.50 \u0026\u0026 vague_count \u003c 3 {\n        return ConfidenceGrade::B;\n    }\n\n    // Grade C: Low bullet ratio (\u003e20%), verbs in \u003e30% bullets, 3-5 vague patterns\n    if bullet_ratio \u003e 0.20 \u0026\u0026 verb_ratio \u003e 0.30 \u0026\u0026 (3..=5).contains(\u0026vague_count) {\n        return ConfidenceGrade::C;\n    }\n\n    // Default to C for specs that don't fit clear patterns\n    ConfidenceGrade::C\n}\n\n/// Count bullet lines and paragraph lines in the spec body.\n///\n/// Bullet lines start with `-` or `*` (after trimming).\n/// Paragraph lines are non-empty lines that aren't bullets, headings, or code fences.\n/// Empty bullets (just `-` or `*` with no content) don't count.\nfn count_bullets_and_paragraphs(body: \u0026str) -\u003e (usize, usize) {\n    let mut bullet_count = 0;\n    let mut paragraph_count = 0;\n    let mut in_code_fence = false;\n\n    for line in body.lines() {\n        let trimmed = line.trim();\n\n        // Track code fences\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        // Skip empty lines, code blocks, and headings\n        if trimmed.is_empty() || in_code_fence || trimmed.starts_with('#') {\n            continue;\n        }\n\n        // Skip lone bullet markers (just \"-\" or \"*\" without space/content)\n        if trimmed == \"-\" || trimmed == \"*\" {\n            continue;\n        }\n\n        // Check if it's a bullet\n        if let Some(content) = trimmed\n            .strip_prefix(\"- \")\n            .or_else(|| trimmed.strip_prefix(\"* \"))\n        {\n            // Only count non-empty bullets\n            if !content.trim().is_empty() {\n                bullet_count += 1;\n            }\n        } else {\n            // It's a paragraph line\n            paragraph_count += 1;\n        }\n    }\n\n    (bullet_count, paragraph_count)\n}\n\n/// Count all instances of vague patterns in the spec body.\n///\n/// Unlike `detect_vague_patterns` which deduplicates, this counts every\n/// occurrence of every vague pattern. Multiple patterns in one line count\n/// separately.\nfn count_all_vague_instances(body: \u0026str) -\u003e usize {\n    let body_lower = body.to_lowercase();\n    let mut count = 0;\n\n    for pattern in super::vague::DEFAULT_VAGUE_PATTERNS {\n        let pattern_lower = pattern.to_lowercase();\n\n        // Count all occurrences of this pattern\n        let mut start = 0;\n        while let Some(pos) = body_lower[start..].find(\u0026pattern_lower) {\n            count += 1;\n            start += pos + pattern_lower.len();\n        }\n    }\n\n    count\n}\n\n/// Count bullets that start with imperative verbs.\n///\n/// A bullet is considered to have an imperative verb if the first word\n/// (after the bullet marker and checkbox if present) matches one of the\n/// known imperative verbs.\nfn count_bullets_with_imperative_verbs(body: \u0026str) -\u003e usize {\n    let mut count = 0;\n    let mut in_code_fence = false;\n\n    for line in body.lines() {\n        let trimmed = line.trim();\n\n        // Track code fences\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        // Skip non-bullets\n        if in_code_fence {\n            continue;\n        }\n\n        // Extract content after bullet marker\n        let content = if let Some(c) = trimmed\n            .strip_prefix(\"- \")\n            .or_else(|| trimmed.strip_prefix(\"* \"))\n        {\n            c\n        } else {\n            continue;\n        };\n\n        // Skip checkbox if present ([ ] or [x])\n        let content = if content.trim_start().starts_with(\"[\") {\n            if let Some(pos) = content.find(']') {\n                \u0026content[pos + 1..]\n            } else {\n                content\n            }\n        } else {\n            content\n        };\n\n        // Get first word\n        let first_word = content.split_whitespace().next();\n\n        // Check if first word is an imperative verb\n        if let Some(word) = first_word {\n            let word_lower = word.to_lowercase();\n            if IMPERATIVE_VERBS.contains(\u0026word_lower.as_str()) {\n                count += 1;\n            }\n        }\n    }\n\n    count\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::{Spec, SpecFrontmatter};\n\n    fn make_config() -\u003e Config {\n        // Create a minimal config for testing\n        Config {\n            project: crate::config::ProjectConfig {\n                name: \"test\".to_string(),\n                prefix: None,\n                silent: false,\n            },\n            defaults: crate::config::DefaultsConfig::default(),\n            providers: crate::provider::ProviderConfig::default(),\n            parallel: crate::config::ParallelConfig::default(),\n            repos: vec![],\n            enterprise: crate::config::EnterpriseConfig::default(),\n            approval: crate::config::ApprovalConfig::default(),\n            validation: crate::config::OutputValidationConfig::default(),\n            site: crate::config::SiteConfig::default(),\n            lint: crate::config::LintConfig::default(),\n            watch: crate::config::WatchConfig::default(),\n        }\n    }\n\n    #[test]\n    fn test_empty_body_returns_grade_d() {\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: String::new(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::D);\n    }\n\n    #[test]\n    fn test_grade_a_high_bullet_ratio_no_vague() {\n        // 10 bullets, 2 paragraphs = 83% bullet ratio\n        // All bullets have imperative verbs\n        // No vague language\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Acceptance Criteria\n\n- [ ] Implement feature A\n- [ ] Add functionality B\n- [ ] Create component C\n- [ ] Update module D\n- [ ] Fix bug E\n- [ ] Remove deprecated code\n- [ ] Test the implementation\n- [ ] Verify the results\n- [ ] Document the changes\n- [ ] Deploy to production\n\nSome paragraph here.\nAnother paragraph here.\n\"#\n            .to_string(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::A);\n    }\n\n    #[test]\n    fn test_grade_b_medium_bullet_ratio_few_vague() {\n        // 5 bullets, 5 paragraphs = 50% bullet ratio (need \u003e50%)\n        // Actually 6 bullets, 4 paragraphs = 60%\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Acceptance Criteria\n\n- [ ] Implement feature A\n- [ ] Add functionality B\n- [ ] Create component C\n- [ ] Update module D\n- [ ] Fix bug E\n- [ ] Deploy to production\n\nSome paragraph here.\nAnother paragraph here.\nThird paragraph.\nFourth paragraph with improve here.\n\"#\n            .to_string(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::B);\n    }\n\n    #[test]\n    fn test_grade_d_low_bullet_ratio() {\n        // 1 bullet, 10 paragraphs = ~9% bullet ratio (\u003c 20%)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: r#\"\nThis is a wall of prose.\nIt has many paragraphs.\nBut very few bullets.\nThis makes it hard to understand.\nRequirements should be clear.\nBullets help with clarity.\nParagraphs can be ambiguous.\nWe need more structure.\nThis spec is poorly written.\nIt will get a low grade.\n\n- [ ] Implement something\n\"#\n            .to_string(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::D);\n    }\n\n    #[test]\n    fn test_grade_d_many_vague_patterns() {\n        // Even with good structure, \u003e5 vague patterns â Grade D\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Acceptance Criteria\n\n- [ ] Improve performance as needed\n- [ ] Add features and related functionality\n- [ ] Create tests etc\n- [ ] Update components as needed\n- [ ] Fix bugs and related issues\n- [ ] Similar improvements needed\n\"#\n            .to_string(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::D);\n    }\n\n    #[test]\n    fn test_count_bullets_and_paragraphs() {\n        let body = r#\"\nThis is a paragraph.\n\n- [ ] This is a bullet\n- [ ] Another bullet\n\nAnother paragraph here.\n\n- This is also a bullet\n\n# This is a heading (not counted)\n\nFinal paragraph.\n\"#;\n\n        let (bullets, paragraphs) = count_bullets_and_paragraphs(body);\n        assert_eq!(bullets, 3);\n        assert_eq!(paragraphs, 3); // Three paragraph lines\n    }\n\n    #[test]\n    fn test_empty_bullets_not_counted() {\n        let body = r#\"\n- [ ] Valid bullet\n-\n- [ ] Another valid bullet\n\"#;\n\n        let (bullets, paragraphs) = count_bullets_and_paragraphs(body);\n        assert_eq!(bullets, 2); // Empty bullet not counted\n        assert_eq!(paragraphs, 0);\n    }\n\n    #[test]\n    fn test_count_bullets_with_imperative_verbs() {\n        let body = r#\"\n- [ ] Implement feature A\n- [ ] Add functionality B\n- [ ] This does not start with a verb\n- [ ] Create component C\n- Update something without checkbox\n\"#;\n\n        let count = count_bullets_with_imperative_verbs(body);\n        assert_eq!(count, 4); // implement, add, create, update\n    }\n\n    #[test]\n    fn test_code_blocks_ignored() {\n        let body = r#\"\n- [ ] Implement feature\n\n```rust\n// This is code, not a bullet\n- This looks like a bullet but it's in a code block\n```\n\n- [ ] Add another feature\n\"#;\n\n        let (bullets, _) = count_bullets_and_paragraphs(body);\n        assert_eq!(bullets, 2); // Only the two outside code blocks\n    }\n\n    #[test]\n    fn test_case_insensitive_verb_matching() {\n        let body = r#\"\n- [ ] IMPLEMENT feature\n- [ ] Add functionality\n- [ ] CrEaTe component\n\"#;\n\n        let count = count_bullets_with_imperative_verbs(body);\n        assert_eq!(count, 3); // All should match case-insensitively\n    }\n\n    #[test]\n    fn test_grade_c_with_some_vague_patterns() {\n        // Low-medium bullet ratio, some verbs, 3-5 vague patterns\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter::default(),\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Acceptance Criteria\n\n- [ ] Implement feature A\n- [ ] Add functionality B as needed\n- [ ] Create tests etc\n\nSome paragraph here.\nAnother paragraph with improve mentioned.\nThird paragraph and related stuff.\n\"#\n            .to_string(),\n        };\n\n        let config = make_config();\n        assert_eq!(calculate_confidence(\u0026spec, \u0026config), ConfidenceGrade::C);\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":19}},{"line":71,"address":[],"length":0,"stats":{"Line":38}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":54}},{"line":79,"address":[],"length":0,"stats":{"Line":36}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":54}},{"line":87,"address":[],"length":0,"stats":{"Line":36}},{"line":88,"address":[],"length":0,"stats":{"Line":11}},{"line":90,"address":[],"length":0,"stats":{"Line":7}},{"line":94,"address":[],"length":0,"stats":{"Line":54}},{"line":98,"address":[],"length":0,"stats":{"Line":24}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":127,"address":[],"length":0,"stats":{"Line":42}},{"line":128,"address":[],"length":0,"stats":{"Line":42}},{"line":129,"address":[],"length":0,"stats":{"Line":42}},{"line":131,"address":[],"length":0,"stats":{"Line":161}},{"line":132,"address":[],"length":0,"stats":{"Line":357}},{"line":135,"address":[],"length":0,"stats":{"Line":238}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":485}},{"line":142,"address":[],"length":0,"stats":{"Line":54}},{"line":146,"address":[],"length":0,"stats":{"Line":125}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":97}},{"line":153,"address":[],"length":0,"stats":{"Line":126}},{"line":156,"address":[],"length":0,"stats":{"Line":70}},{"line":157,"address":[],"length":0,"stats":{"Line":35}},{"line":161,"address":[],"length":0,"stats":{"Line":27}},{"line":165,"address":[],"length":0,"stats":{"Line":21}},{"line":173,"address":[],"length":0,"stats":{"Line":18}},{"line":174,"address":[],"length":0,"stats":{"Line":54}},{"line":175,"address":[],"length":0,"stats":{"Line":36}},{"line":177,"address":[],"length":0,"stats":{"Line":90}},{"line":178,"address":[],"length":0,"stats":{"Line":270}},{"line":181,"address":[],"length":0,"stats":{"Line":180}},{"line":182,"address":[],"length":0,"stats":{"Line":232}},{"line":183,"address":[],"length":0,"stats":{"Line":26}},{"line":184,"address":[],"length":0,"stats":{"Line":26}},{"line":188,"address":[],"length":0,"stats":{"Line":18}},{"line":196,"address":[],"length":0,"stats":{"Line":20}},{"line":197,"address":[],"length":0,"stats":{"Line":40}},{"line":198,"address":[],"length":0,"stats":{"Line":40}},{"line":200,"address":[],"length":0,"stats":{"Line":143}},{"line":201,"address":[],"length":0,"stats":{"Line":309}},{"line":204,"address":[],"length":0,"stats":{"Line":206}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":103}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":175}},{"line":217,"address":[],"length":0,"stats":{"Line":295}},{"line":219,"address":[],"length":0,"stats":{"Line":36}},{"line":221,"address":[],"length":0,"stats":{"Line":67}},{"line":225,"address":[],"length":0,"stats":{"Line":108}},{"line":226,"address":[],"length":0,"stats":{"Line":70}},{"line":227,"address":[],"length":0,"stats":{"Line":35}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":108}},{"line":239,"address":[],"length":0,"stats":{"Line":72}},{"line":240,"address":[],"length":0,"stats":{"Line":108}},{"line":241,"address":[],"length":0,"stats":{"Line":141}},{"line":242,"address":[],"length":0,"stats":{"Line":33}},{"line":247,"address":[],"length":0,"stats":{"Line":20}}],"covered":71,"coverable":75},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","isolation.rs"],"content":"//! Isolation scoring for group specs to measure member independence.\n//!\n//! Analyzes whether a group's members are well-isolated from each other by examining:\n//! - Cross-references between members in body text\n//! - Shared files across multiple members' target_files\n//!\n//! Only applies to group specs with members.\n\nuse crate::scoring::IsolationGrade;\nuse crate::spec::Spec;\nuse crate::spec_group::get_members;\nuse regex::Regex;\nuse std::collections::HashSet;\n\n/// Calculate isolation grade for group specs to measure member independence.\n///\n/// Grading rules:\n/// - Grade A: \u003e90% isolation, minimal shared files (\u003c20% overlap)\n/// - Grade B: \u003e70% isolation\n/// - Grade C: \u003e50% isolation\n/// - Grade D: â¤50% isolation OR \u003e50% file overlap\n///\n/// Edge cases:\n/// - Returns None for non-group specs (specs without members)\n/// - Groups with 1 member return Grade A (trivially isolated)\n/// - Cross-references detected by \"Member N\" patterns in member body text\n/// - File overlap calculated as files appearing in multiple members' target_files\n///\n/// # Arguments\n///\n/// * `spec` - The group spec to analyze\n/// * `all_specs` - All available specs (to look up members)\n///\n/// # Returns\n///\n/// * `Some(IsolationGrade)` - For group specs with members\n/// * `None` - For non-group specs or groups without members\n///\n/// # Examples\n///\n/// ```ignore\n/// // Group with 5 members, 0 cross-references, no shared files â Grade A\n/// let grade = calculate_isolation(\u0026driver_spec, \u0026all_specs);\n/// assert_eq!(grade, Some(IsolationGrade::A));\n///\n/// // Group with 6 members, 2 with cross-refs, 1 shared file â Grade B (67% isolation)\n/// let grade = calculate_isolation(\u0026driver_spec, \u0026all_specs);\n/// assert_eq!(grade, Some(IsolationGrade::B));\n///\n/// // Group with 4 members, 3 with cross-refs â Grade D (25% isolation)\n/// let grade = calculate_isolation(\u0026driver_spec, \u0026all_specs);\n/// assert_eq!(grade, Some(IsolationGrade::D));\n/// ```\npub fn calculate_isolation(spec: \u0026Spec, all_specs: \u0026[Spec]) -\u003e Option\u003cIsolationGrade\u003e {\n    // Get all members of this spec\n    let members = get_members(\u0026spec.id, all_specs);\n\n    // Return None if this is not a group spec or has no members\n    if members.is_empty() {\n        return None;\n    }\n\n    // Edge case: Groups with 1 member are trivially isolated\n    if members.len() == 1 {\n        return Some(IsolationGrade::A);\n    }\n\n    // Count members with cross-references\n    let members_with_cross_refs = count_members_with_cross_references(\u0026members);\n\n    // Calculate isolation percentage\n    let isolation_percentage =\n        ((members.len() - members_with_cross_refs) as f64 / members.len() as f64) * 100.0;\n\n    // Calculate file overlap percentage\n    let file_overlap_percentage = calculate_file_overlap_percentage(\u0026members);\n\n    // Apply grading logic\n    // Grade D: â¤50% isolation OR \u003e50% file overlap\n    if isolation_percentage \u003c= 50.0 || file_overlap_percentage \u003e 50.0 {\n        return Some(IsolationGrade::D);\n    }\n\n    // Grade A: \u003e90% isolation, minimal shared files (\u003c20% overlap)\n    if isolation_percentage \u003e 90.0 \u0026\u0026 file_overlap_percentage \u003c 20.0 {\n        return Some(IsolationGrade::A);\n    }\n\n    // Grade B: \u003e70% isolation\n    if isolation_percentage \u003e 70.0 {\n        return Some(IsolationGrade::B);\n    }\n\n    // Grade C: \u003e50% isolation (default for remaining cases)\n    Some(IsolationGrade::C)\n}\n\n/// Count how many members have cross-references to other members in their body text.\n///\n/// Detects patterns like \"Member N\", \"Member 1\", \"member 2\", etc. in the body text.\nfn count_members_with_cross_references(members: \u0026[\u0026Spec]) -\u003e usize {\n    // Regex to match \"Member N\" patterns (case-insensitive)\n    let member_pattern = Regex::new(r\"(?i)\\bmember\\s+\\d+\\b\").unwrap();\n\n    members\n        .iter()\n        .filter(|member| member_pattern.is_match(\u0026member.body))\n        .count()\n}\n\n/// Calculate the percentage of files that appear in multiple members' target_files.\n///\n/// Returns a percentage from 0.0 to 100.0.\n/// If there are no target files, returns 0.0 (no overlap).\nfn calculate_file_overlap_percentage(members: \u0026[\u0026Spec]) -\u003e f64 {\n    // Collect all files and count how many members reference each file\n    let mut file_counts: std::collections::HashMap\u003cString, usize\u003e =\n        std::collections::HashMap::new();\n\n    for member in members {\n        if let Some(target_files) = \u0026member.frontmatter.target_files {\n            // Use a HashSet to avoid counting the same file twice in one member\n            let unique_files: HashSet\u003c_\u003e = target_files.iter().collect();\n            for file in unique_files {\n                *file_counts.entry(file.clone()).or_insert(0) += 1;\n            }\n        }\n    }\n\n    // If no files at all, no overlap\n    if file_counts.is_empty() {\n        return 0.0;\n    }\n\n    // Count how many files appear in more than one member\n    let shared_files = file_counts.values().filter(|\u0026\u0026count| count \u003e 1).count();\n\n    // Calculate percentage\n    (shared_files as f64 / file_counts.len() as f64) * 100.0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::SpecFrontmatter;\n\n    fn make_spec(id: \u0026str, body: \u0026str, target_files: Option\u003cVec\u003cString\u003e\u003e) -\u003e Spec {\n        Spec {\n            id: id.to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files,\n                ..Default::default()\n            },\n            title: Some(format!(\"Test spec {}\", id)),\n            body: body.to_string(),\n        }\n    }\n\n    #[test]\n    fn test_non_group_returns_none() {\n        // A spec without members should return None\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec body\", None);\n        let all_specs = vec![driver.clone()];\n\n        assert_eq!(calculate_isolation(\u0026driver, \u0026all_specs), None);\n    }\n\n    #[test]\n    fn test_single_member_returns_grade_a() {\n        // Groups with 1 member are trivially isolated\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\"2026-01-30-abc.1\", \"Member 1 body\", None);\n        let all_specs = vec![driver.clone(), member1];\n\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::A)\n        );\n    }\n\n    #[test]\n    fn test_grade_a_perfect_isolation() {\n        // 5 members, 0 cross-references, no shared files â Grade A\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"Implement feature A\",\n            Some(vec![\"file1.rs\".to_string()]),\n        );\n        let member2 = make_spec(\n            \"2026-01-30-abc.2\",\n            \"Implement feature B\",\n            Some(vec![\"file2.rs\".to_string()]),\n        );\n        let member3 = make_spec(\n            \"2026-01-30-abc.3\",\n            \"Implement feature C\",\n            Some(vec![\"file3.rs\".to_string()]),\n        );\n        let member4 = make_spec(\n            \"2026-01-30-abc.4\",\n            \"Implement feature D\",\n            Some(vec![\"file4.rs\".to_string()]),\n        );\n        let member5 = make_spec(\n            \"2026-01-30-abc.5\",\n            \"Implement feature E\",\n            Some(vec![\"file5.rs\".to_string()]),\n        );\n\n        let all_specs = vec![driver.clone(), member1, member2, member3, member4, member5];\n\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::A)\n        );\n    }\n\n    #[test]\n    fn test_grade_b_good_isolation() {\n        // 6 members, 1 with cross-refs, 1 shared file â Grade B (83% isolation)\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"Implement feature A. See Member 2 for details.\",\n            Some(vec![\"file1.rs\".to_string()]),\n        );\n        let member2 = make_spec(\n            \"2026-01-30-abc.2\",\n            \"Implement feature B independently.\",\n            Some(vec![\"file2.rs\".to_string()]),\n        );\n        let member3 = make_spec(\n            \"2026-01-30-abc.3\",\n            \"Implement feature C\",\n            Some(vec![\"file3.rs\".to_string()]),\n        );\n        let member4 = make_spec(\n            \"2026-01-30-abc.4\",\n            \"Implement feature D\",\n            Some(vec![\"file4.rs\".to_string()]),\n        );\n        let member5 = make_spec(\n            \"2026-01-30-abc.5\",\n            \"Implement feature E\",\n            Some(vec![\"file5.rs\".to_string()]),\n        );\n        let member6 = make_spec(\n            \"2026-01-30-abc.6\",\n            \"Implement feature F\",\n            Some(vec![\"file1.rs\".to_string()]), // Shared with member1\n        );\n\n        let all_specs = vec![\n            driver.clone(),\n            member1,\n            member2,\n            member3,\n            member4,\n            member5,\n            member6,\n        ];\n\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::B)\n        );\n    }\n\n    #[test]\n    fn test_grade_d_low_isolation() {\n        // 4 members, 3 with cross-refs â Grade D (25% isolation)\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"Implement feature A. See Member 2.\",\n            Some(vec![\"file1.rs\".to_string()]),\n        );\n        let member2 = make_spec(\n            \"2026-01-30-abc.2\",\n            \"Implement feature B. Depends on Member 1 and Member 3.\",\n            Some(vec![\"file2.rs\".to_string()]),\n        );\n        let member3 = make_spec(\n            \"2026-01-30-abc.3\",\n            \"Implement feature C. Uses Member 2.\",\n            Some(vec![\"file3.rs\".to_string()]),\n        );\n        let member4 = make_spec(\n            \"2026-01-30-abc.4\",\n            \"Implement feature D\",\n            Some(vec![\"file4.rs\".to_string()]),\n        );\n\n        let all_specs = vec![driver.clone(), member1, member2, member3, member4];\n\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::D)\n        );\n    }\n\n    #[test]\n    fn test_grade_d_high_file_overlap() {\n        // 3 members, 0 cross-refs, but \u003e50% file overlap â Grade D\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"Implement feature A\",\n            Some(vec![\"shared1.rs\".to_string(), \"shared2.rs\".to_string()]),\n        );\n        let member2 = make_spec(\n            \"2026-01-30-abc.2\",\n            \"Implement feature B\",\n            Some(vec![\"shared1.rs\".to_string(), \"shared2.rs\".to_string()]),\n        );\n        let member3 = make_spec(\n            \"2026-01-30-abc.3\",\n            \"Implement feature C\",\n            Some(vec![\"file3.rs\".to_string()]),\n        );\n\n        let all_specs = vec![driver.clone(), member1, member2, member3];\n\n        // 2 out of 3 files are shared = 66% overlap â Grade D\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::D)\n        );\n    }\n\n    #[test]\n    fn test_cross_reference_detection_case_insensitive() {\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"See MEMBER 2 for details. Also check member 3.\",\n            None,\n        );\n        let member2 = make_spec(\"2026-01-30-abc.2\", \"Independent work\", None);\n        let member3 = make_spec(\"2026-01-30-abc.3\", \"Independent work\", None);\n\n        let all_specs = vec![driver.clone(), member1, member2, member3];\n\n        // Member 1 has cross-references, 2 and 3 don't\n        // 2 out of 3 isolated = 67% â Grade C\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::C)\n        );\n    }\n\n    #[test]\n    fn test_no_target_files_no_overlap() {\n        // Members without target_files should have 0% overlap\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\"2026-01-30-abc.1\", \"Feature A\", None);\n        let member2 = make_spec(\"2026-01-30-abc.2\", \"Feature B\", None);\n        let member3 = make_spec(\"2026-01-30-abc.3\", \"Feature C\", None);\n        let member4 = make_spec(\"2026-01-30-abc.4\", \"Feature D\", None);\n        let member5 = make_spec(\"2026-01-30-abc.5\", \"Feature E\", None);\n\n        let all_specs = vec![driver.clone(), member1, member2, member3, member4, member5];\n\n        // 5 members, 0 cross-refs, no files = \u003e90% isolation + \u003c20% overlap â Grade A\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::A)\n        );\n    }\n\n    #[test]\n    fn test_grade_c_medium_isolation() {\n        // 5 members, 2 with cross-refs â 60% isolation â Grade C\n        let driver = make_spec(\"2026-01-30-abc\", \"Driver spec\", None);\n        let member1 = make_spec(\n            \"2026-01-30-abc.1\",\n            \"See Member 2\",\n            Some(vec![\"file1.rs\".to_string()]),\n        );\n        let member2 = make_spec(\n            \"2026-01-30-abc.2\",\n            \"Depends on Member 1\",\n            Some(vec![\"file2.rs\".to_string()]),\n        );\n        let member3 = make_spec(\n            \"2026-01-30-abc.3\",\n            \"Independent\",\n            Some(vec![\"file3.rs\".to_string()]),\n        );\n        let member4 = make_spec(\n            \"2026-01-30-abc.4\",\n            \"Independent\",\n            Some(vec![\"file4.rs\".to_string()]),\n        );\n        let member5 = make_spec(\n            \"2026-01-30-abc.5\",\n            \"Independent\",\n            Some(vec![\"file5.rs\".to_string()]),\n        );\n\n        let all_specs = vec![driver.clone(), member1, member2, member3, member4, member5];\n\n        assert_eq!(\n            calculate_isolation(\u0026driver, \u0026all_specs),\n            Some(IsolationGrade::C)\n        );\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":15}},{"line":56,"address":[],"length":0,"stats":{"Line":60}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":21}},{"line":72,"address":[],"length":0,"stats":{"Line":7}},{"line":73,"address":[],"length":0,"stats":{"Line":21}},{"line":76,"address":[],"length":0,"stats":{"Line":21}},{"line":80,"address":[],"length":0,"stats":{"Line":13}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":7}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":28}},{"line":105,"address":[],"length":0,"stats":{"Line":7}},{"line":107,"address":[],"length":0,"stats":{"Line":100}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":117,"address":[],"length":0,"stats":{"Line":14}},{"line":118,"address":[],"length":0,"stats":{"Line":7}},{"line":120,"address":[],"length":0,"stats":{"Line":38}},{"line":121,"address":[],"length":0,"stats":{"Line":54}},{"line":123,"address":[],"length":0,"stats":{"Line":92}},{"line":124,"address":[],"length":0,"stats":{"Line":73}},{"line":125,"address":[],"length":0,"stats":{"Line":100}},{"line":131,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":47}},{"line":139,"address":[],"length":0,"stats":{"Line":10}}],"covered":33,"coverable":33},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","mod.rs"],"content":"//! Scoring utilities for spec quality analysis.\n\npub mod ac_quality;\npub mod confidence;\npub mod isolation;\npub mod splittability;\npub mod traffic_light;\npub mod vague;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","splittability.rs"],"content":"//! Splittability scoring based on spec structure and decomposability.\n//!\n//! Analyzes whether a spec can be effectively decomposed by examining:\n//! - Number of markdown headers (subsections)\n//! - Number of target files\n//! - Number of acceptance criteria\n//! - Presence of coupling keywords indicating tight dependencies\n\nuse crate::scoring::SplittabilityGrade;\nuse crate::spec::Spec;\n\n/// Coupling keywords that indicate tightly coupled components\nconst COUPLING_KEYWORDS: \u0026[\u0026str] = \u0026[\"shared\", \"depends on each other\", \"tightly coupled\"];\n\n/// Calculate splittability grade based on spec structure and decomposability.\n///\n/// Grading rules:\n/// - Grade A: Clear subsections (3+ headers), multiple target files (3+), independent tasks\n/// - Grade B: Some structure (1-2 headers), 2 target files\n/// - Grade C: Single concern, 1 target file, minimal structure\n/// - Grade D: Tightly coupled indicators (many cross-references, shared state mentioned)\n///\n/// Edge cases:\n/// - Specs already part of a group (has parent_id) should be Grade C (already split)\n/// - Specs with 1 criterion should be Grade C (atomic)\n/// - Detection of coupling keywords: \"shared\", \"depends on each other\", \"tightly coupled\"\n///\n/// # Arguments\n///\n/// * `spec` - The spec to analyze\n///\n/// # Returns\n///\n/// A `SplittabilityGrade` based on the spec's decomposability\npub fn calculate_splittability(spec: \u0026Spec) -\u003e SplittabilityGrade {\n    // Edge case: Check for coupling keywords first (Grade D)\n    if has_coupling_keywords(\u0026spec.body) {\n        return SplittabilityGrade::D;\n    }\n\n    // Edge case: Specs already part of a group (already split) â Grade C\n    if is_part_of_group(\u0026spec.id) {\n        return SplittabilityGrade::C;\n    }\n\n    // Edge case: Specs with 1 criterion are atomic â Grade C\n    let criteria_count = spec.count_total_checkboxes();\n    if criteria_count == 1 {\n        return SplittabilityGrade::C;\n    }\n\n    // Count structural elements\n    let header_count = count_markdown_headers(\u0026spec.body);\n    let file_count = count_target_files(spec);\n\n    // Grade A: 3+ headers, 3+ files, independent tasks\n    if header_count \u003e= 3 \u0026\u0026 file_count \u003e= 3 {\n        return SplittabilityGrade::A;\n    }\n\n    // Grade B: 1-2 headers, 2 files\n    if (1..=2).contains(\u0026header_count) \u0026\u0026 file_count == 2 {\n        return SplittabilityGrade::B;\n    }\n\n    // Grade C: Single concern, 1 target file, minimal structure\n    // This is the default for specs that don't fit A or B criteria\n    SplittabilityGrade::C\n}\n\n/// Count markdown headers (##, ###, etc.) in the spec body.\n///\n/// Only counts headers outside of code fences.\n/// Does not count the top-level title (single #).\nfn count_markdown_headers(body: \u0026str) -\u003e usize {\n    let mut count = 0;\n    let mut in_code_fence = false;\n\n    for line in body.lines() {\n        let trimmed = line.trim();\n\n        // Track code fences\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        // Skip lines inside code blocks\n        if in_code_fence {\n            continue;\n        }\n\n        // Count headers (## or more, not single #)\n        if trimmed.starts_with(\"##\") {\n            count += 1;\n        }\n    }\n\n    count\n}\n\n/// Count the number of target files in the spec.\nfn count_target_files(spec: \u0026Spec) -\u003e usize {\n    spec.frontmatter\n        .target_files\n        .as_ref()\n        .map(|files| files.len())\n        .unwrap_or(0)\n}\n\n/// Check if the spec body contains coupling keywords.\n///\n/// Returns true if any coupling keyword is found (case-insensitive).\nfn has_coupling_keywords(body: \u0026str) -\u003e bool {\n    let body_lower = body.to_lowercase();\n\n    for keyword in COUPLING_KEYWORDS {\n        if body_lower.contains(\u0026keyword.to_lowercase()) {\n            return true;\n        }\n    }\n\n    false\n}\n\n/// Check if a spec ID indicates it's part of a group.\n///\n/// Group members have IDs in the format: DRIVER_ID.N or DRIVER_ID.N.M\n/// where N and M are numbers.\n///\n/// Examples:\n/// - \"2026-01-25-00y-abc.1\" â true (member of group)\n/// - \"2026-01-25-00y-abc.1.2\" â true (nested member)\n/// - \"2026-01-25-00y-abc\" â false (driver, not member)\nfn is_part_of_group(spec_id: \u0026str) -\u003e bool {\n    // A spec is part of a group if its ID contains a dot followed by a number\n    // We need to check if there's a pattern like \".N\" where N is a digit\n\n    // Split by dots and check if there's at least one numeric segment after the base ID\n    let parts: Vec\u003c\u0026str\u003e = spec_id.split('.').collect();\n\n    // If there's more than one part and any part after the first contains only digits,\n    // this is a group member\n    if parts.len() \u003e 1 {\n        for part in \u0026parts[1..] {\n            if !part.is_empty() \u0026\u0026 part.chars().all(|c| c.is_ascii_digit()) {\n                return true;\n            }\n        }\n    }\n\n    false\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::SpecFrontmatter;\n\n    #[test]\n    fn test_grade_a_multiple_headers_and_files() {\n        // 4 headers, 5 files, 8 criteria â Grade A\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                    \"file4.rs\".to_string(),\n                    \"file5.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Criterion 1\n- [ ] Criterion 2\n\n## Section 2\n- [ ] Criterion 3\n- [ ] Criterion 4\n\n## Section 3\n- [ ] Criterion 5\n- [ ] Criterion 6\n\n## Section 4\n- [ ] Criterion 7\n- [ ] Criterion 8\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::A);\n    }\n\n    #[test]\n    fn test_grade_b_some_structure() {\n        // 1 header, 2 files, 3 criteria â Grade B\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string(), \"file2.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Acceptance Criteria\n- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::B);\n    }\n\n    #[test]\n    fn test_grade_c_single_concern() {\n        // 0 headers, 1 file, 1 criterion â Grade C\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n- [ ] Single criterion\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::C);\n    }\n\n    #[test]\n    fn test_grade_d_coupling_keywords() {\n        // Spec mentioning \"tightly coupled components\" â Grade D\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Criterion 1\n\n## Section 2\n- [ ] Criterion 2\n\nThese components are tightly coupled and cannot be separated.\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::D);\n    }\n\n    #[test]\n    fn test_edge_case_group_member() {\n        // Spec with ID indicating group membership â Grade C\n        let spec = Spec {\n            id: \"2026-01-25-00y-abc.1\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Criterion 1\n- [ ] Criterion 2\n\n## Section 2\n- [ ] Criterion 3\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::C);\n    }\n\n    #[test]\n    fn test_edge_case_single_criterion_atomic() {\n        // Spec with only 1 criterion â Grade C (atomic)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Single criterion\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::C);\n    }\n\n    #[test]\n    fn test_count_markdown_headers() {\n        let body = r#\"\n# Title (not counted)\n\n## Section 1\nSome content\n\n## Section 2\nMore content\n\n### Subsection\nEven more\n\n```rust\n// ## This header in code is not counted\n## Neither is this\n```\n\n## Section 3\nFinal section\n\"#;\n\n        assert_eq!(count_markdown_headers(body), 4); // Sections 1, 2, Subsection, Section 3\n    }\n\n    #[test]\n    fn test_count_target_files() {\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: String::new(),\n        };\n\n        assert_eq!(count_target_files(\u0026spec), 3);\n    }\n\n    #[test]\n    fn test_count_target_files_none() {\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: None,\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: String::new(),\n        };\n\n        assert_eq!(count_target_files(\u0026spec), 0);\n    }\n\n    #[test]\n    fn test_has_coupling_keywords_shared() {\n        let body = \"This code uses shared state between components.\";\n        assert!(has_coupling_keywords(body));\n    }\n\n    #[test]\n    fn test_has_coupling_keywords_depends_on_each_other() {\n        let body = \"These modules depends on each other heavily.\";\n        assert!(has_coupling_keywords(body));\n    }\n\n    #[test]\n    fn test_has_coupling_keywords_tightly_coupled() {\n        let body = \"The components are TIGHTLY COUPLED.\";\n        assert!(has_coupling_keywords(body));\n    }\n\n    #[test]\n    fn test_has_coupling_keywords_none() {\n        let body = \"This is a simple independent module.\";\n        assert!(!has_coupling_keywords(body));\n    }\n\n    #[test]\n    fn test_is_part_of_group_member() {\n        assert!(is_part_of_group(\"2026-01-25-00y-abc.1\"));\n        assert!(is_part_of_group(\"2026-01-25-00y-abc.2\"));\n        assert!(is_part_of_group(\"2026-01-25-00y-abc.1.2\"));\n    }\n\n    #[test]\n    fn test_is_part_of_group_driver() {\n        assert!(!is_part_of_group(\"2026-01-25-00y-abc\"));\n    }\n\n    #[test]\n    fn test_is_part_of_group_edge_cases() {\n        // Edge case: dot but not numeric\n        assert!(!is_part_of_group(\"2026-01-25-00y-abc.md\"));\n\n        // Edge case: multiple dots with numbers\n        assert!(is_part_of_group(\"2026-01-25-00y-abc.1.2.3\"));\n    }\n\n    #[test]\n    fn test_grade_b_two_headers() {\n        // 2 headers, 2 files â Grade B\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string(), \"file2.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Criterion 1\n\n## Section 2\n- [ ] Criterion 2\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::B);\n    }\n\n    #[test]\n    fn test_grade_c_no_structure() {\n        // 0 headers, 2 files, 3 criteria â Grade C (default)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string(), \"file2.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::C);\n    }\n\n    #[test]\n    fn test_coupling_overrides_good_structure() {\n        // Even with 4 headers and 5 files, coupling keywords force Grade D\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                    \"file4.rs\".to_string(),\n                    \"file5.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: r#\"\n## Section 1\n- [ ] Criterion 1\n\n## Section 2\n- [ ] Criterion 2\n\n## Section 3\n- [ ] Criterion 3\n\n## Section 4\n- [ ] Criterion 4\n\nNote: These components have shared state.\n\"#\n            .to_string(),\n        };\n\n        assert_eq!(calculate_splittability(\u0026spec), SplittabilityGrade::D);\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":22}},{"line":37,"address":[],"length":0,"stats":{"Line":44}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":40}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":57}},{"line":48,"address":[],"length":0,"stats":{"Line":19}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":51}},{"line":54,"address":[],"length":0,"stats":{"Line":51}},{"line":57,"address":[],"length":0,"stats":{"Line":18}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":51}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":14}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":76,"address":[],"length":0,"stats":{"Line":36}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":79,"address":[],"length":0,"stats":{"Line":108}},{"line":80,"address":[],"length":0,"stats":{"Line":216}},{"line":83,"address":[],"length":0,"stats":{"Line":144}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":70}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":148}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":19}},{"line":104,"address":[],"length":0,"stats":{"Line":19}},{"line":105,"address":[],"length":0,"stats":{"Line":19}},{"line":107,"address":[],"length":0,"stats":{"Line":33}},{"line":114,"address":[],"length":0,"stats":{"Line":26}},{"line":115,"address":[],"length":0,"stats":{"Line":78}},{"line":117,"address":[],"length":0,"stats":{"Line":73}},{"line":118,"address":[],"length":0,"stats":{"Line":219}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":21}},{"line":135,"address":[],"length":0,"stats":{"Line":26}},{"line":140,"address":[],"length":0,"stats":{"Line":130}},{"line":144,"address":[],"length":0,"stats":{"Line":26}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":146,"address":[],"length":0,"stats":{"Line":30}},{"line":147,"address":[],"length":0,"stats":{"Line":5}},{"line":152,"address":[],"length":0,"stats":{"Line":21}}],"covered":45,"coverable":45},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","traffic_light.rs"],"content":"//! Traffic light status determination and suggestion generation.\n//!\n//! Combines dimension grades into an overall traffic light status and generates\n//! actionable suggestions for improving spec quality.\n\nuse crate::scoring::{\n    ACQualityGrade, ComplexityGrade, ConfidenceGrade, IsolationGrade, SpecScore,\n    SplittabilityGrade, TrafficLight,\n};\n\n/// Determine overall traffic light status based on dimension grades\n///\n/// Traffic light logic:\n/// - Ready (green): Complexity â¤ B AND Confidence â¥ B AND AC Quality â¥ B\n/// - Refine (red): Any dimension is D OR Confidence is D\n/// - Review (yellow): All other cases (any dimension is C)\n///\n/// Note: Isolation grade (optional) does not affect traffic light status\npub fn determine_status(score: \u0026SpecScore) -\u003e TrafficLight {\n    // Check for Refine conditions: any dimension is D\n    if matches!(score.complexity, ComplexityGrade::D)\n        || matches!(score.confidence, ConfidenceGrade::D)\n        || matches!(score.ac_quality, ACQualityGrade::D)\n        || matches!(score.splittability, SplittabilityGrade::D)\n        || score\n            .isolation\n            .is_some_and(|iso| matches!(iso, IsolationGrade::D))\n    {\n        return TrafficLight::Refine;\n    }\n\n    // Check for Ready conditions: Complexity â¤ B AND Confidence â¥ B AND AC Quality â¥ B\n    let complexity_ok = matches!(score.complexity, ComplexityGrade::A | ComplexityGrade::B);\n    let confidence_ok = matches!(score.confidence, ConfidenceGrade::A | ConfidenceGrade::B);\n    let ac_quality_ok = matches!(score.ac_quality, ACQualityGrade::A | ACQualityGrade::B);\n\n    if complexity_ok \u0026\u0026 confidence_ok \u0026\u0026 ac_quality_ok {\n        return TrafficLight::Ready;\n    }\n\n    // All other cases: Review (any dimension is C)\n    TrafficLight::Review\n}\n\n/// Generate actionable suggestions based on failing dimensions\n///\n/// Suggestions are specific to each dimension that needs improvement.\n/// Multiple failing dimensions will generate multiple suggestions.\n/// Suggestions are deduplicated to avoid repetition.\npub fn generate_suggestions(score: \u0026SpecScore) -\u003e Vec\u003cString\u003e {\n    let mut suggestions = Vec::new();\n\n    // Complexity suggestions\n    match score.complexity {\n        ComplexityGrade::D =\u003e {\n            suggestions.push(\"Reduce criteria count or split spec into smaller pieces\".to_string());\n        }\n        ComplexityGrade::C =\u003e {\n            suggestions.push(\"Consider reducing scope or splitting into subtasks\".to_string());\n        }\n        _ =\u003e {}\n    }\n\n    // Confidence suggestions\n    match score.confidence {\n        ConfidenceGrade::D =\u003e {\n            suggestions.push(\"Improve spec structure and clarify vague requirements\".to_string());\n        }\n        ConfidenceGrade::C =\u003e {\n            suggestions.push(\"Add more specific details and improve organization\".to_string());\n        }\n        _ =\u003e {}\n    }\n\n    // AC Quality suggestions\n    match score.ac_quality {\n        ACQualityGrade::D =\u003e {\n            suggestions.push(\n                \"Rewrite acceptance criteria to be imperative, valuable, and testable\".to_string(),\n            );\n        }\n        ACQualityGrade::C =\u003e {\n            suggestions.push(\"Improve acceptance criteria phrasing and specificity\".to_string());\n        }\n        _ =\u003e {}\n    }\n\n    // Splittability suggestions\n    match score.splittability {\n        SplittabilityGrade::D =\u003e {\n            suggestions\n                .push(\"Refactor to reduce tight coupling and circular dependencies\".to_string());\n        }\n        SplittabilityGrade::C =\u003e {\n            suggestions.push(\"Consider breaking into more independent subsections\".to_string());\n        }\n        _ =\u003e {}\n    }\n\n    // Isolation suggestions (optional field)\n    if let Some(isolation) = score.isolation {\n        match isolation {\n            IsolationGrade::D =\u003e {\n                suggestions.push(\n                    \"Reduce cross-references between group members to improve isolation\"\n                        .to_string(),\n                );\n            }\n            IsolationGrade::C =\u003e {\n                suggestions.push(\"Consider reducing coupling between group members\".to_string());\n            }\n            _ =\u003e {}\n        }\n    }\n\n    // Deduplicate suggestions (though our specific suggestions shouldn't duplicate)\n    suggestions.sort();\n    suggestions.dedup();\n\n    suggestions\n}\n\n/// Generate detailed actionable guidance with examples for failing dimensions\n///\n/// Provides comprehensive, example-driven guidance on how to fix quality issues.\n/// Returns a multi-line string with \"Why This Matters\" and \"How to Fix\" sections.\npub fn generate_detailed_guidance(score: \u0026SpecScore) -\u003e String {\n    let mut output = String::new();\n\n    // Only generate guidance if there are issues\n    if matches!(score.traffic_light, TrafficLight::Ready) {\n        return output;\n    }\n\n    output.push_str(\"\\nWhy This Matters:\\n\");\n    output.push_str(\n        \"  Agents perform best with ISOLATED tasks that have TESTABLE acceptance criteria.\\n\",\n    );\n    output.push_str(\"  Vague specs lead to scope creep, wrong assumptions, and wasted tokens.\\n\");\n    output.push_str(\"\\nHow to Fix:\\n\");\n\n    // Confidence guidance\n    if matches!(score.confidence, ConfidenceGrade::C | ConfidenceGrade::D) {\n        let grade_letter = match score.confidence {\n            ConfidenceGrade::D =\u003e \"D\",\n            ConfidenceGrade::C =\u003e \"C\",\n            _ =\u003e \"\",\n        };\n        output.push_str(\u0026format!(\"\\n  Confidence ({} â A):\\n\", grade_letter));\n        output.push_str(\"    â \\\"Update the API\\\"\\n\");\n        output.push_str(\"    â \\\"In src/api/users.rs, add `get_user_by_email()` method\\\"\\n\");\n        output.push_str(\"    â Add specific file paths, function names, or line numbers\\n\");\n    }\n\n    // Splittability guidance\n    if matches!(\n        score.splittability,\n        SplittabilityGrade::C | SplittabilityGrade::D\n    ) {\n        let grade_letter = match score.splittability {\n            SplittabilityGrade::D =\u003e \"D\",\n            SplittabilityGrade::C =\u003e \"C\",\n            _ =\u003e \"\",\n        };\n        output.push_str(\u0026format!(\"\\n  Splittability ({} â A):\\n\", grade_letter));\n        output.push_str(\"    â \\\"Add auth and update docs and fix tests\\\"\\n\");\n        output.push_str(\n            \"    â Split into 3 specs: auth, docs, tests (use depends_on for ordering)\\n\",\n        );\n        output.push_str(\"    â Each spec should do ONE thing\\n\");\n    }\n\n    // AC Quality guidance\n    if matches!(score.ac_quality, ACQualityGrade::C | ACQualityGrade::D) {\n        let grade_letter = match score.ac_quality {\n            ACQualityGrade::D =\u003e \"D\",\n            ACQualityGrade::C =\u003e \"C\",\n            _ =\u003e \"\",\n        };\n        output.push_str(\u0026format!(\"\\n  AC Quality ({} â A):\\n\", grade_letter));\n        output.push_str(\"    â \\\"- [ ] Code works correctly\\\"\\n\");\n        output.push_str(\"    â \\\"- [ ] Tests pass\\\"\\n\");\n        output\n            .push_str(\"    â \\\"- [ ] Add `validate_email()` fn in src/utils.rs returning bool\\\"\\n\");\n        output.push_str(\"    â \\\"- [ ] `cargo test test_validate_email` passes\\\"\\n\");\n        output.push_str(\n            \"    â Criteria must be: imperative verb + specific location + verifiable outcome\\n\",\n        );\n    }\n\n    // Complexity guidance\n    if matches!(score.complexity, ComplexityGrade::C | ComplexityGrade::D) {\n        let grade_letter = match score.complexity {\n            ComplexityGrade::D =\u003e \"D\",\n            ComplexityGrade::C =\u003e \"C\",\n            _ =\u003e \"\",\n        };\n        output.push_str(\u0026format!(\"\\n  Complexity ({} â B):\\n\", grade_letter));\n        output.push_str(\"    â Split large specs into smaller, focused tasks\\n\");\n        output.push_str(\"    â Aim for 1-5 acceptance criteria per spec\\n\");\n        output.push_str(\"    â Use `chant split \u003cspec-id\u003e` to break into subtasks\\n\");\n    }\n\n    output\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_determine_status_all_a_ready() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: Some(IsolationGrade::A),\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Ready);\n    }\n\n    #[test]\n    fn test_determine_status_b_grades_ready() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::B,\n            confidence: ConfidenceGrade::B,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::B,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Ready);\n    }\n\n    #[test]\n    fn test_determine_status_complexity_c_review() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::C,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Review,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Review);\n    }\n\n    #[test]\n    fn test_determine_status_confidence_c_review() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::B,\n            confidence: ConfidenceGrade::C,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Review,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Review);\n    }\n\n    #[test]\n    fn test_determine_status_ac_quality_c_review() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::B,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::C,\n            traffic_light: TrafficLight::Review,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Review);\n    }\n\n    #[test]\n    fn test_determine_status_complexity_d_refine() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::D,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Refine);\n    }\n\n    #[test]\n    fn test_determine_status_confidence_d_refine() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::D,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Refine);\n    }\n\n    #[test]\n    fn test_determine_status_isolation_d_refine() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: Some(IsolationGrade::D),\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        assert_eq!(determine_status(\u0026score), TrafficLight::Refine);\n    }\n\n    #[test]\n    fn test_generate_suggestions_all_a_no_suggestions() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: Some(IsolationGrade::A),\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        assert!(suggestions.is_empty());\n    }\n\n    #[test]\n    fn test_generate_suggestions_complexity_d() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::D,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        assert_eq!(suggestions.len(), 1);\n        assert!(suggestions[0].contains(\"Reduce criteria count\"));\n    }\n\n    #[test]\n    fn test_generate_suggestions_confidence_c() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::B,\n            confidence: ConfidenceGrade::C,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Review,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        assert_eq!(suggestions.len(), 1);\n        assert!(suggestions[0].contains(\"Add more specific details\"));\n    }\n\n    #[test]\n    fn test_generate_suggestions_multiple_dimensions() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::D,\n            confidence: ConfidenceGrade::C,\n            splittability: SplittabilityGrade::C,\n            isolation: Some(IsolationGrade::C),\n            ac_quality: ACQualityGrade::D,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        assert_eq!(suggestions.len(), 5);\n        // Verify each dimension has a suggestion\n        assert!(suggestions\n            .iter()\n            .any(|s| s.contains(\"Reduce criteria count\")));\n        assert!(suggestions\n            .iter()\n            .any(|s| s.contains(\"Add more specific details\")));\n        assert!(suggestions\n            .iter()\n            .any(|s| s.contains(\"breaking into more independent\")));\n        assert!(suggestions\n            .iter()\n            .any(|s| s.contains(\"reducing coupling between group\")));\n        assert!(suggestions.iter().any(|s| s.contains(\"imperative\")));\n    }\n\n    #[test]\n    fn test_generate_suggestions_no_duplicates() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::C,\n            confidence: ConfidenceGrade::C,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Review,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        // Check for uniqueness\n        let unique_count = suggestions.len();\n        let mut sorted = suggestions.clone();\n        sorted.sort();\n        sorted.dedup();\n        assert_eq!(unique_count, sorted.len());\n    }\n\n    #[test]\n    fn test_generate_suggestions_isolation_none() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::D,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Refine,\n        };\n\n        let suggestions = generate_suggestions(\u0026score);\n        // Should only have complexity suggestion, no isolation suggestion\n        assert_eq!(suggestions.len(), 1);\n        assert!(suggestions[0].contains(\"Reduce criteria count\"));\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":21}},{"line":21,"address":[],"length":0,"stats":{"Line":41}},{"line":22,"address":[],"length":0,"stats":{"Line":28}},{"line":23,"address":[],"length":0,"stats":{"Line":16}},{"line":24,"address":[],"length":0,"stats":{"Line":16}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":15}},{"line":34,"address":[],"length":0,"stats":{"Line":17}},{"line":35,"address":[],"length":0,"stats":{"Line":15}},{"line":37,"address":[],"length":0,"stats":{"Line":16}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":17}},{"line":51,"address":[],"length":0,"stats":{"Line":34}},{"line":54,"address":[],"length":0,"stats":{"Line":17}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":9}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":13}},{"line":65,"address":[],"length":0,"stats":{"Line":17}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":67,"address":[],"length":0,"stats":{"Line":33}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":36}},{"line":79,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":17}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":36}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":19}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":17}},{"line":118,"address":[],"length":0,"stats":{"Line":34}},{"line":120,"address":[],"length":0,"stats":{"Line":17}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":1}}],"covered":78,"coverable":103},{"path":["/","Users","alex","Documents","checkouts","chant","src","score","vague.rs"],"content":"//! Vague language detection utility for spec text analysis.\n//!\n//! Detects vague language patterns that may indicate unclear requirements\n//! or underspecified acceptance criteria.\n\nuse std::collections::HashSet;\n\n/// Default vague language patterns to detect\npub const DEFAULT_VAGUE_PATTERNS: \u0026[\u0026str] =\n    \u0026[\"improve\", \"as needed\", \"etc\", \"and related\", \"similar\"];\n\n/// Detects vague language patterns in text.\n///\n/// Performs case-insensitive matching and returns a list of matched patterns.\n/// Each pattern is reported at most once, even if it appears multiple times.\n///\n/// # Arguments\n///\n/// * `text` - The text to analyze for vague patterns\n/// * `patterns` - The patterns to search for\n///\n/// # Returns\n///\n/// A vector of matched pattern strings (deduplicated, in order of first match)\n///\n/// # Examples\n///\n/// ```\n/// use chant::score::vague::detect_vague_patterns;\n///\n/// let text = \"improve performance\";\n/// let patterns = vec![\"improve\".to_string()];\n/// let matches = detect_vague_patterns(text, \u0026patterns);\n/// assert_eq!(matches, vec![\"improve\"]);\n/// ```\n///\n/// ```\n/// use chant::score::vague::detect_vague_patterns;\n///\n/// let text = \"Add feature and related tests\";\n/// let patterns = vec![\"and related\".to_string()];\n/// let matches = detect_vague_patterns(text, \u0026patterns);\n/// assert_eq!(matches, vec![\"and related\"]);\n/// ```\n///\n/// ```\n/// use chant::score::vague::detect_vague_patterns;\n///\n/// let text = \"Clean code\";\n/// let patterns = vec![\"improve\".to_string()];\n/// let matches = detect_vague_patterns(text, \u0026patterns);\n/// assert_eq!(matches, Vec::\u003cString\u003e::new());\n/// ```\npub fn detect_vague_patterns(text: \u0026str, patterns: \u0026[String]) -\u003e Vec\u003cString\u003e {\n    // Handle edge cases\n    if text.is_empty() || patterns.is_empty() {\n        return Vec::new();\n    }\n\n    let text_lower = text.to_lowercase();\n    let mut found_patterns = Vec::new();\n    let mut seen = HashSet::new();\n\n    // Check each pattern\n    for pattern in patterns {\n        let pattern_lower = pattern.to_lowercase();\n\n        // Only add if we haven't seen this pattern yet and it's in the text\n        if !seen.contains(\u0026pattern_lower) \u0026\u0026 text_lower.contains(\u0026pattern_lower) {\n            found_patterns.push(pattern.clone());\n            seen.insert(pattern_lower);\n        }\n    }\n\n    found_patterns\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_detect_single_pattern() {\n        let text = \"improve performance\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"improve\"]);\n    }\n\n    #[test]\n    fn test_detect_pattern_in_phrase() {\n        let text = \"Add feature and related tests\";\n        let patterns = vec![\"and related\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"and related\"]);\n    }\n\n    #[test]\n    fn test_no_match() {\n        let text = \"Clean code\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    fn test_empty_text() {\n        let text = \"\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    fn test_empty_patterns() {\n        let text = \"improve performance\";\n        let patterns: Vec\u003cString\u003e = vec![];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    fn test_case_insensitive() {\n        let text = \"IMPROVE Performance\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"improve\"]);\n    }\n\n    #[test]\n    fn test_case_insensitive_pattern() {\n        let text = \"improve performance\";\n        let patterns = vec![\"IMPROVE\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"IMPROVE\"]);\n    }\n\n    #[test]\n    fn test_multiple_patterns() {\n        let text = \"improve performance and related metrics etc\";\n        let patterns = vec![\n            \"improve\".to_string(),\n            \"and related\".to_string(),\n            \"etc\".to_string(),\n        ];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"improve\", \"and related\", \"etc\"]);\n    }\n\n    #[test]\n    fn test_overlapping_patterns_reported_once() {\n        let text = \"improve improve improve\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        // Should only be reported once\n        assert_eq!(result, vec![\"improve\"]);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_duplicate_patterns_in_list() {\n        let text = \"improve performance\";\n        let patterns = vec![\"improve\".to_string(), \"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        // Should only report first occurrence\n        assert_eq!(result, vec![\"improve\"]);\n        assert_eq!(result.len(), 1);\n    }\n\n    #[test]\n    fn test_partial_word_match() {\n        // \"improve\" should match \"improved\" or \"improvement\"\n        let text = \"we need improvement here\";\n        let patterns = vec![\"improve\".to_string()];\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result, vec![\"improve\"]);\n    }\n\n    #[test]\n    fn test_default_patterns() {\n        // Test that default patterns are defined\n        assert!(DEFAULT_VAGUE_PATTERNS.contains(\u0026\"improve\"));\n        assert!(DEFAULT_VAGUE_PATTERNS.contains(\u0026\"as needed\"));\n        assert!(DEFAULT_VAGUE_PATTERNS.contains(\u0026\"etc\"));\n        assert!(DEFAULT_VAGUE_PATTERNS.contains(\u0026\"and related\"));\n        assert!(DEFAULT_VAGUE_PATTERNS.contains(\u0026\"similar\"));\n    }\n\n    #[test]\n    fn test_all_default_patterns() {\n        let text = \"improve as needed, etc and related similar things\";\n        let patterns: Vec\u003cString\u003e = DEFAULT_VAGUE_PATTERNS\n            .iter()\n            .map(|s| s.to_string())\n            .collect();\n        let result = detect_vague_patterns(text, \u0026patterns);\n        assert_eq!(result.len(), 5);\n        assert!(result.contains(\u0026\"improve\".to_string()));\n        assert!(result.contains(\u0026\"as needed\".to_string()));\n        assert!(result.contains(\u0026\"etc\".to_string()));\n        assert!(result.contains(\u0026\"and related\".to_string()));\n        assert!(result.contains(\u0026\"similar\".to_string()));\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":46}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":30}},{"line":61,"address":[],"length":0,"stats":{"Line":20}},{"line":62,"address":[],"length":0,"stats":{"Line":20}},{"line":65,"address":[],"length":0,"stats":{"Line":27}},{"line":66,"address":[],"length":0,"stats":{"Line":34}},{"line":69,"address":[],"length":0,"stats":{"Line":81}},{"line":70,"address":[],"length":0,"stats":{"Line":75}},{"line":71,"address":[],"length":0,"stats":{"Line":30}},{"line":75,"address":[],"length":0,"stats":{"Line":10}}],"covered":12,"coverable":12},{"path":["/","Users","alex","Documents","checkouts","chant","src","scoring.rs"],"content":"//! Spec quality scoring system\n//!\n//! Multi-dimensional analysis of spec quality including complexity, confidence,\n//! splittability, isolation, and acceptance criteria quality.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Macro to generate Display implementations for letter grade enums (A, B, C, D)\nmacro_rules! impl_letter_grade_display {\n    ($type:ty) =\u003e {\n        impl fmt::Display for $type {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                match self {\n                    Self::A =\u003e write!(f, \"A\"),\n                    Self::B =\u003e write!(f, \"B\"),\n                    Self::C =\u003e write!(f, \"C\"),\n                    Self::D =\u003e write!(f, \"D\"),\n                }\n            }\n        }\n    };\n}\n\n/// Overall score for a spec across all dimensions\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SpecScore {\n    /// Complexity grade (size/effort)\n    pub complexity: ComplexityGrade,\n    /// Confidence grade (structure/clarity)\n    pub confidence: ConfidenceGrade,\n    /// Splittability grade (decomposability)\n    pub splittability: SplittabilityGrade,\n    /// Isolation grade (group/split quality) - only for groups with members\n    pub isolation: Option\u003cIsolationGrade\u003e,\n    /// Acceptance criteria quality grade\n    pub ac_quality: ACQualityGrade,\n    /// Overall traffic light status\n    pub traffic_light: TrafficLight,\n}\n\nimpl Default for SpecScore {\n    fn default() -\u003e Self {\n        Self {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        }\n    }\n}\n\n/// Complexity grade based on criteria count, target files, and word count\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ComplexityGrade {\n    /// 1-3 criteria, 1-2 files, \u003c200 words\n    A,\n    /// 4-5 criteria, 3 files, 200-400 words\n    B,\n    /// 6-7 criteria, 4 files, 400-600 words\n    C,\n    /// 8+ criteria, 5+ files, 600+ words\n    D,\n}\n\nimpl_letter_grade_display!(ComplexityGrade);\n\n/// Confidence grade based on structure and clarity\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ConfidenceGrade {\n    /// Excellent structure, clear requirements\n    A,\n    /// Good structure, mostly clear\n    B,\n    /// Some structure issues or vague language\n    C,\n    /// Poor structure, vague requirements\n    D,\n}\n\nimpl_letter_grade_display!(ConfidenceGrade);\n\n/// Splittability grade - can this spec be effectively split\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum SplittabilityGrade {\n    /// Clear subsections, independent tasks, multiple target files\n    A,\n    /// Some structure, could be split with effort\n    B,\n    /// Monolithic, single concern, splitting would fragment\n    C,\n    /// Tightly coupled, splitting would create circular deps\n    D,\n}\n\nimpl_letter_grade_display!(SplittabilityGrade);\n\n/// Isolation grade - for groups with members, measures independence\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum IsolationGrade {\n    /// Excellent isolation, minimal cross-references\n    A,\n    /// Good isolation, some cross-references\n    B,\n    /// Some coupling, multiple cross-references\n    C,\n    /// Tightly coupled, many cross-references\n    D,\n}\n\nimpl_letter_grade_display!(IsolationGrade);\n\n/// Acceptance criteria quality grade\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ACQualityGrade {\n    /// Excellent AC: imperative, valuable, testable\n    A,\n    /// Good AC: mostly well-phrased\n    B,\n    /// Some AC issues\n    C,\n    /// Poor AC quality\n    D,\n}\n\nimpl_letter_grade_display!(ACQualityGrade);\n\n/// Overall traffic light status combining all dimensions\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum TrafficLight {\n    /// Ready - All dimensions pass (Complexity â¤ B AND Confidence â¥ B AND AC Quality â¥ B)\n    Ready,\n    /// Review - Some dimensions need attention (Any dimension is C)\n    Review,\n    /// Refine - Significant issues (Any dimension is D OR Confidence is D)\n    Refine,\n}\n\nimpl fmt::Display for TrafficLight {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::Ready =\u003e write!(f, \"ð¢ Ready\"),\n            Self::Review =\u003e write!(f, \"ð¡ Review\"),\n            Self::Refine =\u003e write!(f, \"ð´ Refine\"),\n        }\n    }\n}\n\n/// Calculate complexity grade based on criteria count, target files, and word count\n///\n/// Grading rules:\n/// - Grade A: 1-3 criteria, 1-2 files, \u003c200 words\n/// - Grade B: 4-5 criteria, 3 files, 200-400 words\n/// - Grade C: 6-7 criteria, 4 files, 400-600 words\n/// - Grade D: 8+ criteria OR 5+ files OR 600+ words\n///\n/// If any single metric triggers D, overall grade is D.\npub fn calculate_complexity(spec: \u0026crate::spec::Spec) -\u003e ComplexityGrade {\n    // Count acceptance criteria\n    let criteria_count = spec.count_total_checkboxes();\n\n    // Count target files (default to 0 if None)\n    let file_count = spec\n        .frontmatter\n        .target_files\n        .as_ref()\n        .map(|files| files.len())\n        .unwrap_or(0);\n\n    // Count words in body (split by whitespace, filter empty)\n    let word_count = spec.body.split_whitespace().count();\n\n    // Determine grade based on all three metrics\n    // If any single metric triggers D, overall is D\n    if criteria_count \u003e= 8 || file_count \u003e= 5 || word_count \u003e= 600 {\n        return ComplexityGrade::D;\n    }\n\n    // Check for Grade C thresholds\n    if criteria_count \u003e= 6 || file_count \u003e= 4 || word_count \u003e= 400 {\n        return ComplexityGrade::C;\n    }\n\n    // Check for Grade B thresholds\n    if criteria_count \u003e= 4 || file_count \u003e= 3 || word_count \u003e= 200 {\n        return ComplexityGrade::B;\n    }\n\n    // Otherwise Grade A\n    ComplexityGrade::A\n}\n\n/// Extract acceptance criteria from a spec's body\nfn extract_acceptance_criteria(spec: \u0026crate::spec::Spec) -\u003e Vec\u003cString\u003e {\n    let acceptance_criteria_marker = \"## Acceptance Criteria\";\n    let mut criteria = Vec::new();\n    let mut in_code_fence = false;\n    let mut in_ac_section = false;\n\n    for line in spec.body.lines() {\n        let trimmed = line.trim_start();\n\n        if trimmed.starts_with(\"```\") {\n            in_code_fence = !in_code_fence;\n            continue;\n        }\n\n        if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n            in_ac_section = true;\n            continue;\n        }\n\n        // Stop if we hit another ## heading\n        if in_ac_section \u0026\u0026 !in_code_fence \u0026\u0026 trimmed.starts_with(\"## \") {\n            break;\n        }\n\n        // Extract checkbox items\n        if in_ac_section\n            \u0026\u0026 !in_code_fence\n            \u0026\u0026 (trimmed.starts_with(\"- [ ]\") || trimmed.starts_with(\"- [x]\"))\n        {\n            // Extract text after checkbox\n            let text = trimmed\n                .trim_start_matches(\"- [ ]\")\n                .trim_start_matches(\"- [x]\")\n                .trim()\n                .to_string();\n            criteria.push(text);\n        }\n    }\n\n    criteria\n}\n\n/// Calculate the overall SpecScore for a given spec\n///\n/// This function computes all scoring dimensions and determines the traffic light status.\npub fn calculate_spec_score(\n    spec: \u0026crate::spec::Spec,\n    all_specs: \u0026[crate::spec::Spec],\n    config: \u0026crate::config::Config,\n) -\u003e SpecScore {\n    use crate::score::{ac_quality, confidence, isolation, splittability, traffic_light};\n\n    // Calculate each dimension\n    let complexity = calculate_complexity(spec);\n    let confidence_grade = confidence::calculate_confidence(spec, config);\n    let splittability_grade = splittability::calculate_splittability(spec);\n    let isolation_grade = isolation::calculate_isolation(spec, all_specs);\n\n    // Calculate AC quality from the spec's acceptance criteria\n    let criteria = extract_acceptance_criteria(spec);\n    let ac_quality_grade = ac_quality::calculate_ac_quality(\u0026criteria);\n\n    // Create the score struct\n    let mut score = SpecScore {\n        complexity,\n        confidence: confidence_grade,\n        splittability: splittability_grade,\n        isolation: isolation_grade,\n        ac_quality: ac_quality_grade,\n        traffic_light: TrafficLight::Ready, // Temporary, will be recalculated\n    };\n\n    // Determine the traffic light status\n    score.traffic_light = traffic_light::determine_status(\u0026score);\n\n    score\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_spec_score_creation_with_all_a() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: Some(IsolationGrade::A),\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        assert_eq!(score.complexity, ComplexityGrade::A);\n        assert_eq!(score.confidence, ConfidenceGrade::A);\n        assert_eq!(score.splittability, SplittabilityGrade::A);\n        assert_eq!(score.isolation, Some(IsolationGrade::A));\n        assert_eq!(score.ac_quality, ACQualityGrade::A);\n        assert_eq!(score.traffic_light, TrafficLight::Ready);\n    }\n\n    #[test]\n    fn test_complexity_grade_display() {\n        assert_eq!(ComplexityGrade::B.to_string(), \"B\");\n        assert_eq!(ComplexityGrade::A.to_string(), \"A\");\n        assert_eq!(ComplexityGrade::C.to_string(), \"C\");\n        assert_eq!(ComplexityGrade::D.to_string(), \"D\");\n    }\n\n    #[test]\n    fn test_confidence_grade_display() {\n        assert_eq!(ConfidenceGrade::B.to_string(), \"B\");\n    }\n\n    #[test]\n    fn test_splittability_grade_display() {\n        assert_eq!(SplittabilityGrade::B.to_string(), \"B\");\n    }\n\n    #[test]\n    fn test_isolation_grade_display() {\n        assert_eq!(IsolationGrade::B.to_string(), \"B\");\n    }\n\n    #[test]\n    fn test_ac_quality_grade_display() {\n        assert_eq!(ACQualityGrade::B.to_string(), \"B\");\n    }\n\n    #[test]\n    fn test_traffic_light_display() {\n        assert_eq!(TrafficLight::Ready.to_string(), \"ð¢ Ready\");\n        assert_eq!(TrafficLight::Review.to_string(), \"ð¡ Review\");\n        assert_eq!(TrafficLight::Refine.to_string(), \"ð´ Refine\");\n    }\n\n    #[test]\n    fn test_spec_score_serialization() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::B,\n            splittability: SplittabilityGrade::A,\n            isolation: None,\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        let json = serde_json::to_string(\u0026score).unwrap();\n        let deserialized: SpecScore = serde_json::from_str(\u0026json).unwrap();\n\n        assert_eq!(deserialized.complexity, ComplexityGrade::A);\n        assert_eq!(deserialized.confidence, ConfidenceGrade::B);\n        assert_eq!(deserialized.splittability, SplittabilityGrade::A);\n        assert_eq!(deserialized.isolation, None);\n        assert_eq!(deserialized.ac_quality, ACQualityGrade::A);\n        assert_eq!(deserialized.traffic_light, TrafficLight::Ready);\n    }\n\n    #[test]\n    fn test_isolation_is_optional() {\n        let score = SpecScore {\n            complexity: ComplexityGrade::A,\n            confidence: ConfidenceGrade::A,\n            splittability: SplittabilityGrade::A,\n            isolation: None, // Should work fine without isolation\n            ac_quality: ACQualityGrade::A,\n            traffic_light: TrafficLight::Ready,\n        };\n\n        assert_eq!(score.isolation, None);\n    }\n\n    #[test]\n    fn test_default_spec_score() {\n        let score = SpecScore::default();\n        assert_eq!(score.complexity, ComplexityGrade::A);\n        assert_eq!(score.confidence, ConfidenceGrade::A);\n        assert_eq!(score.splittability, SplittabilityGrade::A);\n        assert_eq!(score.isolation, None);\n        assert_eq!(score.ac_quality, ACQualityGrade::A);\n        assert_eq!(score.traffic_light, TrafficLight::Ready);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_a() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 2 criteria, 1 file, 150 words â Grade A\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n\\n{}\",\n                \"word \".repeat(150)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::A);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_b() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 5 criteria, 3 files, 300 words â Grade B\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n- [ ] Third\\n- [ ] Fourth\\n- [ ] Fifth\\n\\n{}\",\n                \"word \".repeat(300)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::B);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_c() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 6 criteria, 4 files, 500 words â Grade C\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                    \"file4.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n- [ ] Third\\n- [ ] Fourth\\n- [ ] Fifth\\n- [ ] Sixth\\n\\n{}\",\n                \"word \".repeat(500)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::C);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_d_criteria() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 10 criteria, 2 files, 100 words â Grade D (criteria exceeds threshold)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string(), \"file2.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n{}\\n\\n{}\",\n                (1..=10)\n                    .map(|i| format!(\"- [ ] Item {}\", i))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\"\\n\"),\n                \"word \".repeat(100)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::D);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_d_files() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 2 criteria, 5 files, 100 words â Grade D (files exceeds threshold)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\n                    \"file1.rs\".to_string(),\n                    \"file2.rs\".to_string(),\n                    \"file3.rs\".to_string(),\n                    \"file4.rs\".to_string(),\n                    \"file5.rs\".to_string(),\n                ]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n\\n{}\",\n                \"word \".repeat(100)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::D);\n    }\n\n    #[test]\n    fn test_calculate_complexity_grade_d_words() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // 2 criteria, 1 file, 700 words â Grade D (words exceeds threshold)\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: format!(\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n\\n{}\",\n                \"word \".repeat(700)\n            ),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::D);\n    }\n\n    #[test]\n    fn test_calculate_complexity_no_target_files() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // Specs with no target_files should default to 0 files\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: None,\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body:\n                \"## Acceptance Criteria\\n- [ ] First\\n- [ ] Second\\n\\nSome content here with words.\"\n                    .to_string(),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::A);\n    }\n\n    #[test]\n    fn test_calculate_complexity_empty_body() {\n        use crate::spec::{Spec, SpecFrontmatter};\n\n        // Empty body should have word count of 0\n        let spec = Spec {\n            id: \"test\".to_string(),\n            frontmatter: SpecFrontmatter {\n                target_files: Some(vec![\"file1.rs\".to_string()]),\n                ..Default::default()\n            },\n            title: Some(\"Test\".to_string()),\n            body: String::new(),\n        };\n\n        assert_eq!(calculate_complexity(\u0026spec), ComplexityGrade::A);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":46}},{"line":14,"address":[],"length":0,"stats":{"Line":46}},{"line":15,"address":[],"length":0,"stats":{"Line":24}},{"line":16,"address":[],"length":0,"stats":{"Line":10}},{"line":17,"address":[],"length":0,"stats":{"Line":18}},{"line":18,"address":[],"length":0,"stats":{"Line":40}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":22}},{"line":160,"address":[],"length":0,"stats":{"Line":21}},{"line":162,"address":[],"length":0,"stats":{"Line":63}},{"line":165,"address":[],"length":0,"stats":{"Line":42}},{"line":166,"address":[],"length":0,"stats":{"Line":21}},{"line":167,"address":[],"length":0,"stats":{"Line":21}},{"line":169,"address":[],"length":0,"stats":{"Line":35}},{"line":173,"address":[],"length":0,"stats":{"Line":63}},{"line":177,"address":[],"length":0,"stats":{"Line":60}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":52}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":49}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":16}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":6}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":18}},{"line":203,"address":[],"length":0,"stats":{"Line":45}},{"line":205,"address":[],"length":0,"stats":{"Line":30}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":60}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":25}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":13}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":16}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":250,"address":[],"length":0,"stats":{"Line":12}},{"line":251,"address":[],"length":0,"stats":{"Line":9}},{"line":252,"address":[],"length":0,"stats":{"Line":12}},{"line":255,"address":[],"length":0,"stats":{"Line":9}},{"line":256,"address":[],"length":0,"stats":{"Line":9}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":271,"address":[],"length":0,"stats":{"Line":3}}],"covered":53,"coverable":56},{"path":["/","Users","alex","Documents","checkouts","chant","src","site","graph.rs"],"content":"//! ASCII dependency graph generation for specs.\n//!\n//! This module generates ASCII art representations of spec dependencies\n//! using box-drawing characters.\n\nuse std::collections::{HashMap, HashSet};\n\nuse crate::config::GraphDetailLevel;\nuse crate::spec::Spec;\n\n/// Build an ASCII dependency graph from specs.\n///\n/// Returns:\n/// - The ASCII graph as a string\n/// - List of root spec IDs (no dependencies)\n/// - List of leaf spec IDs (nothing depends on them)\npub fn build_dependency_graph(\n    specs: \u0026[\u0026Spec],\n    detail_level: GraphDetailLevel,\n) -\u003e (String, Vec\u003cString\u003e, Vec\u003cString\u003e) {\n    // Build adjacency lists\n    let mut depends_on: HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e = HashMap::new();\n    let mut depended_by: HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e = HashMap::new();\n    let mut all_ids: HashSet\u003c\u0026str\u003e = HashSet::new();\n\n    for spec in specs {\n        all_ids.insert(\u0026spec.id);\n        if let Some(deps) = \u0026spec.frontmatter.depends_on {\n            for dep in deps {\n                depends_on.entry(\u0026spec.id).or_default().push(dep.as_str());\n                depended_by.entry(dep.as_str()).or_default().push(\u0026spec.id);\n            }\n        }\n    }\n\n    // Find roots (specs with no dependencies)\n    let roots: Vec\u003cString\u003e = specs\n        .iter()\n        .filter(|s| {\n            s.frontmatter\n                .depends_on\n                .as_ref()\n                .map(|d| d.is_empty())\n                .unwrap_or(true)\n        })\n        .map(|s| s.id.clone())\n        .collect();\n\n    // Find leaves (specs that nothing depends on)\n    let leaves: Vec\u003cString\u003e = specs\n        .iter()\n        .filter(|s| !depended_by.contains_key(s.id.as_str()))\n        .map(|s| s.id.clone())\n        .collect();\n\n    // Build the ASCII graph\n    let graph = build_ascii_graph(specs, \u0026depends_on, detail_level);\n\n    (graph, roots, leaves)\n}\n\n/// Build the ASCII representation of the graph\nfn build_ascii_graph(\n    specs: \u0026[\u0026Spec],\n    depends_on: \u0026HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e,\n    detail_level: GraphDetailLevel,\n) -\u003e String {\n    if specs.is_empty() {\n        return \"(No specs to display)\".to_string();\n    }\n\n    let mut output = String::new();\n\n    // Group specs by their dependency depth\n    let depths = calculate_depths(specs, depends_on);\n\n    // Find specs at each depth level\n    let mut depth_groups: HashMap\u003cusize, Vec\u003c\u0026Spec\u003e\u003e = HashMap::new();\n    for spec in specs {\n        let depth = *depths.get(spec.id.as_str()).unwrap_or(\u00260);\n        depth_groups.entry(depth).or_default().push(*spec);\n    }\n\n    // Get max depth\n    let max_depth = depth_groups.keys().max().copied().unwrap_or(0);\n\n    // Render each depth level\n    for depth in 0..=max_depth {\n        if let Some(level_specs) = depth_groups.get(\u0026depth) {\n            // Render boxes for this level\n            let boxes = render_spec_boxes(level_specs, detail_level);\n            output.push_str(\u0026boxes);\n            output.push('\\n');\n\n            // Render connections to next level if not last\n            if depth \u003c max_depth {\n                if let Some(next_specs) = depth_groups.get(\u0026(depth + 1)) {\n                    let connections = render_connections(level_specs, next_specs, depends_on);\n                    output.push_str(\u0026connections);\n                    output.push('\\n');\n                }\n            }\n        }\n    }\n\n    output\n}\n\n/// Calculate the depth (distance from root) of each spec\nfn calculate_depths\u003c'a\u003e(\n    specs: \u0026[\u0026'a Spec],\n    depends_on: \u0026HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e,\n) -\u003e HashMap\u003c\u0026'a str, usize\u003e {\n    let mut depths: HashMap\u003c\u0026str, usize\u003e = HashMap::new();\n\n    // Initialize roots at depth 0\n    for spec in specs {\n        let has_deps = depends_on\n            .get(spec.id.as_str())\n            .map(|d| !d.is_empty())\n            .unwrap_or(false);\n\n        if !has_deps {\n            depths.insert(\u0026spec.id, 0);\n        }\n    }\n\n    // Calculate depths iteratively\n    let mut changed = true;\n    while changed {\n        changed = false;\n        for spec in specs {\n            if let Some(deps) = depends_on.get(spec.id.as_str()) {\n                // Find max depth of dependencies\n                let max_dep_depth = deps\n                    .iter()\n                    .filter_map(|d| depths.get(d))\n                    .max()\n                    .copied()\n                    .unwrap_or(0);\n\n                let new_depth = max_dep_depth + 1;\n                let current = depths.get(spec.id.as_str()).copied();\n\n                if current.map(|c| new_depth \u003e c).unwrap_or(true) {\n                    depths.insert(\u0026spec.id, new_depth);\n                    changed = true;\n                }\n            }\n        }\n    }\n\n    // Handle any remaining specs without computed depths\n    for spec in specs {\n        depths.entry(\u0026spec.id).or_insert(0);\n    }\n\n    depths\n}\n\n/// Render spec boxes at the same level\nfn render_spec_boxes(specs: \u0026[\u0026Spec], detail_level: GraphDetailLevel) -\u003e String {\n    if specs.is_empty() {\n        return String::new();\n    }\n\n    let boxes: Vec\u003cString\u003e = specs.iter().map(|s| render_box(s, detail_level)).collect();\n\n    // Find the height of the tallest box\n    let max_height = boxes.iter().map(|b| b.lines().count()).max().unwrap_or(0);\n\n    // Pad all boxes to the same height\n    let padded_boxes: Vec\u003cVec\u003cString\u003e\u003e = boxes\n        .iter()\n        .map(|b| {\n            let lines: Vec\u003cString\u003e = b.lines().map(|l| l.to_string()).collect();\n            let width = lines.first().map(|l| l.chars().count()).unwrap_or(0);\n            let mut padded = lines;\n            while padded.len() \u003c max_height {\n                padded.push(\" \".repeat(width));\n            }\n            padded\n        })\n        .collect();\n\n    // Combine horizontally\n    let mut result = String::new();\n    for row in 0..max_height {\n        for (i, box_lines) in padded_boxes.iter().enumerate() {\n            if i \u003e 0 {\n                result.push_str(\"     \"); // Space between boxes\n            }\n            if row \u003c box_lines.len() {\n                result.push_str(\u0026box_lines[row]);\n            }\n        }\n        result.push('\\n');\n    }\n\n    result\n}\n\n/// Render a single spec box\nfn render_box(spec: \u0026Spec, detail_level: GraphDetailLevel) -\u003e String {\n    let short_id = spec.id.split('-').skip(3).collect::\u003cVec\u003c_\u003e\u003e().join(\"-\");\n\n    let short_id = if short_id.is_empty() {\n        \u0026spec.id\n    } else {\n        \u0026short_id\n    };\n\n    match detail_level {\n        GraphDetailLevel::Minimal =\u003e {\n            let width = short_id.len().max(5) + 4;\n            let top = format!(\"â{}â\", \"â\".repeat(width - 2));\n            let content = format!(\"â {:^width$} â\", short_id, width = width - 4);\n            let bottom = format!(\"â{}â\", \"â\".repeat(width - 2));\n            format!(\"{}\\n{}\\n{}\", top, content, bottom)\n        }\n        GraphDetailLevel::Titles =\u003e {\n            let title = spec\n                .title\n                .as_ref()\n                .map(|t| truncate(t, 15))\n                .unwrap_or_else(|| \"Untitled\".to_string());\n\n            let width = short_id.len().max(title.len()).max(10) + 4;\n            let top = format!(\"â{}â\", \"â\".repeat(width - 2));\n            let id_line = format!(\"â {:^width$} â\", short_id, width = width - 4);\n            let title_line = format!(\"â {:^width$} â\", title, width = width - 4);\n            let bottom = format!(\"â{}â\", \"â\".repeat(width - 2));\n            format!(\"{}\\n{}\\n{}\\n{}\", top, id_line, title_line, bottom)\n        }\n        GraphDetailLevel::Full =\u003e {\n            let title = spec\n                .title\n                .as_ref()\n                .map(|t| truncate(t, 15))\n                .unwrap_or_else(|| \"Untitled\".to_string());\n\n            let status = format!(\"{:?}\", spec.frontmatter.status);\n            let status = truncate(\u0026status, 12);\n\n            let labels = spec\n                .frontmatter\n                .labels\n                .as_ref()\n                .map(|l| l.join(\", \"))\n                .map(|l| truncate(\u0026l, 12))\n                .unwrap_or_default();\n\n            let width = short_id\n                .len()\n                .max(title.len())\n                .max(status.len())\n                .max(labels.len())\n                .max(10)\n                + 4;\n\n            let top = format!(\"â{}â\", \"â\".repeat(width - 2));\n            let id_line = format!(\"â {:^width$} â\", short_id, width = width - 4);\n            let title_line = format!(\"â {:^width$} â\", title, width = width - 4);\n            let status_line = format!(\"â {:^width$} â\", status, width = width - 4);\n            let bottom = format!(\"â{}â\", \"â\".repeat(width - 2));\n\n            if labels.is_empty() {\n                format!(\n                    \"{}\\n{}\\n{}\\n{}\\n{}\",\n                    top, id_line, title_line, status_line, bottom\n                )\n            } else {\n                let labels_line = format!(\"â {:^width$} â\", labels, width = width - 4);\n                format!(\n                    \"{}\\n{}\\n{}\\n{}\\n{}\\n{}\",\n                    top, id_line, title_line, status_line, labels_line, bottom\n                )\n            }\n        }\n    }\n}\n\n/// Render connections between levels\nfn render_connections(\n    from_specs: \u0026[\u0026Spec],\n    to_specs: \u0026[\u0026Spec],\n    depends_on: \u0026HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e,\n) -\u003e String {\n    // Simple connection rendering\n    let mut has_connections = false;\n\n    for to_spec in to_specs {\n        if let Some(deps) = depends_on.get(to_spec.id.as_str()) {\n            for dep in deps {\n                if from_specs.iter().any(|s| s.id == *dep) {\n                    has_connections = true;\n                    break;\n                }\n            }\n        }\n        if has_connections {\n            break;\n        }\n    }\n\n    if has_connections {\n        let width = from_specs.len() * 20; // Approximate width\n        let padding = \" \".repeat(width / 4);\n        format!(\"{}â\\n{}â¼\", padding, padding)\n    } else {\n        String::new()\n    }\n}\n\n/// Truncate a string to max length\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len - 2).collect();\n        format!(\"{}â¦\", truncated)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::{SpecFrontmatter, SpecStatus};\n\n    fn make_spec(id: \u0026str, title: \u0026str, deps: Option\u003cVec\u003c\u0026str\u003e\u003e) -\u003e Spec {\n        Spec {\n            id: id.to_string(),\n            title: Some(title.to_string()),\n            body: String::new(),\n            frontmatter: SpecFrontmatter {\n                status: SpecStatus::Pending,\n                depends_on: deps.map(|d| d.iter().map(|s| s.to_string()).collect()),\n                ..Default::default()\n            },\n        }\n    }\n\n    #[test]\n    fn test_build_dependency_graph_empty() {\n        let specs: Vec\u003c\u0026Spec\u003e = vec![];\n        let (graph, roots, leaves) = build_dependency_graph(\u0026specs, GraphDetailLevel::Minimal);\n        assert!(graph.contains(\"No specs\"));\n        assert!(roots.is_empty());\n        assert!(leaves.is_empty());\n    }\n\n    #[test]\n    fn test_build_dependency_graph_single() {\n        let spec = make_spec(\"2026-01-30-00a-xyz\", \"Test Spec\", None);\n        let specs = vec![\u0026spec];\n        let (graph, roots, leaves) = build_dependency_graph(\u0026specs, GraphDetailLevel::Minimal);\n        assert!(graph.contains(\"00a-xyz\"));\n        assert_eq!(roots.len(), 1);\n        assert_eq!(leaves.len(), 1);\n    }\n\n    #[test]\n    fn test_truncate() {\n        assert_eq!(truncate(\"short\", 10), \"short\");\n        assert_eq!(truncate(\"a very long string\", 10), \"a very lâ¦\");\n    }\n\n    #[test]\n    fn test_render_box_minimal() {\n        let spec = make_spec(\"2026-01-30-00a-xyz\", \"Test\", None);\n        let box_str = render_box(\u0026spec, GraphDetailLevel::Minimal);\n        assert!(box_str.contains(\"00a-xyz\"));\n        assert!(box_str.contains(\"â\"));\n        assert!(box_str.contains(\"â\"));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":9}},{"line":170,"address":[],"length":0,"stats":{"Line":7}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":11}},{"line":177,"address":[],"length":0,"stats":{"Line":6}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":9}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":8}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":10}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":7}},{"line":321,"address":[],"length":0,"stats":{"Line":1}}],"covered":87,"coverable":157},{"path":["/","Users","alex","Documents","checkouts","chant","src","site","mod.rs"],"content":"//! Static site generation for chant specs.\n//!\n//! This module provides functionality to generate a static HTML documentation\n//! site from chant specs, including:\n//! - Individual spec pages\n//! - Index pages (by status, by label)\n//! - Timeline visualization\n//! - Dependency graph visualization\n//! - Changelog\n\npub mod graph;\npub mod theme;\npub mod timeline;\n\nuse anyhow::{Context, Result};\nuse std::collections::{HashMap, HashSet};\nuse std::fs;\nuse std::path::Path;\nuse tera::Tera;\n\nuse crate::config::SiteConfig;\nuse crate::spec::{Spec, SpecStatus};\n\n/// Embedded default theme templates\npub mod embedded {\n    pub const BASE_HTML: \u0026str = include_str!(\"../../templates/site/base.html\");\n    pub const INDEX_HTML: \u0026str = include_str!(\"../../templates/site/index.html\");\n    pub const SPEC_HTML: \u0026str = include_str!(\"../../templates/site/spec.html\");\n    pub const STATUS_INDEX_HTML: \u0026str = include_str!(\"../../templates/site/status-index.html\");\n    pub const LABEL_INDEX_HTML: \u0026str = include_str!(\"../../templates/site/label-index.html\");\n    pub const TIMELINE_HTML: \u0026str = include_str!(\"../../templates/site/timeline.html\");\n    pub const GRAPH_HTML: \u0026str = include_str!(\"../../templates/site/graph.html\");\n    pub const CHANGELOG_HTML: \u0026str = include_str!(\"../../templates/site/changelog.html\");\n    pub const STYLES_CSS: \u0026str = include_str!(\"../../templates/site/styles.css\");\n}\n\n/// Site statistics\n#[derive(Debug, Clone, serde::Serialize)]\npub struct SiteStats {\n    pub total: usize,\n    pub completed: usize,\n    pub in_progress: usize,\n    pub pending: usize,\n    pub failed: usize,\n    pub other: usize,\n}\n\nimpl SiteStats {\n    pub fn from_specs(specs: \u0026[\u0026Spec]) -\u003e Self {\n        let mut stats = Self {\n            total: specs.len(),\n            completed: 0,\n            in_progress: 0,\n            pending: 0,\n            failed: 0,\n            other: 0,\n        };\n\n        for spec in specs {\n            match spec.frontmatter.status {\n                SpecStatus::Completed =\u003e stats.completed += 1,\n                SpecStatus::InProgress =\u003e stats.in_progress += 1,\n                SpecStatus::Pending =\u003e stats.pending += 1,\n                SpecStatus::Failed =\u003e stats.failed += 1,\n                _ =\u003e stats.other += 1,\n            }\n        }\n\n        stats\n    }\n}\n\n/// Spec data for templates\n#[derive(Debug, Clone, serde::Serialize)]\npub struct SpecTemplateData {\n    pub id: String,\n    pub short_id: String,\n    pub title: Option\u003cString\u003e,\n    pub status: String,\n    pub r#type: String,\n    pub labels: Vec\u003cString\u003e,\n    pub depends_on: Vec\u003cString\u003e,\n    pub target_files: Vec\u003cString\u003e,\n    pub completed_at: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub body_html: String,\n}\n\nimpl SpecTemplateData {\n    pub fn from_spec(spec: \u0026Spec, redacted_fields: \u0026[String]) -\u003e Self {\n        // Extract short ID (last part after date)\n        let short_id = spec\n            .id\n            .split('-')\n            .next_back()\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| spec.id.clone());\n\n        // Convert body to HTML\n        let body_html = markdown_to_html(\u0026spec.body);\n\n        // Get status as string\n        let status = format!(\"{:?}\", spec.frontmatter.status).to_lowercase();\n\n        Self {\n            id: spec.id.clone(),\n            short_id,\n            title: spec.title.clone(),\n            status,\n            r#type: spec.frontmatter.r#type.clone(),\n            labels: spec.frontmatter.labels.clone().unwrap_or_default(),\n            depends_on: if redacted_fields.contains(\u0026\"depends_on\".to_string()) {\n                vec![]\n            } else {\n                spec.frontmatter.depends_on.clone().unwrap_or_default()\n            },\n            target_files: if redacted_fields.contains(\u0026\"target_files\".to_string()) {\n                vec![]\n            } else {\n                spec.frontmatter.target_files.clone().unwrap_or_default()\n            },\n            completed_at: if redacted_fields.contains(\u0026\"completed_at\".to_string()) {\n                None\n            } else {\n                spec.frontmatter.completed_at.clone()\n            },\n            model: if redacted_fields.contains(\u0026\"model\".to_string()) {\n                None\n            } else {\n                spec.frontmatter.model.clone()\n            },\n            body_html,\n        }\n    }\n}\n\n/// Convert markdown to HTML using pulldown-cmark\nfn markdown_to_html(markdown: \u0026str) -\u003e String {\n    use pulldown_cmark::{html, Options, Parser};\n\n    let options = Options::all();\n    let parser = Parser::new_ext(markdown, options);\n\n    let mut html_output = String::new();\n    html::push_html(\u0026mut html_output, parser);\n\n    html_output\n}\n\n/// Site generator\npub struct SiteGenerator {\n    config: SiteConfig,\n    tera: Tera,\n    specs: Vec\u003cSpec\u003e,\n}\n\nimpl SiteGenerator {\n    /// Create a new site generator with the given configuration\n    pub fn new(config: SiteConfig, specs: Vec\u003cSpec\u003e, theme_dir: Option\u003c\u0026Path\u003e) -\u003e Result\u003cSelf\u003e {\n        let tera = if let Some(dir) = theme_dir {\n            if dir.exists() {\n                // Load templates from theme directory\n                let pattern = format!(\"{}/**/*.html\", dir.display());\n                Tera::new(\u0026pattern)\n                    .with_context(|| format!(\"Failed to load templates from {}\", dir.display()))?\n            } else {\n                Self::create_embedded_tera()?\n            }\n        } else {\n            Self::create_embedded_tera()?\n        };\n\n        Ok(Self {\n            config,\n            tera,\n            specs,\n        })\n    }\n\n    /// Create a Tera instance with embedded templates\n    fn create_embedded_tera() -\u003e Result\u003cTera\u003e {\n        let mut tera = Tera::default();\n\n        tera.add_raw_template(\"base.html\", embedded::BASE_HTML)?;\n        tera.add_raw_template(\"index.html\", embedded::INDEX_HTML)?;\n        tera.add_raw_template(\"spec.html\", embedded::SPEC_HTML)?;\n        tera.add_raw_template(\"status-index.html\", embedded::STATUS_INDEX_HTML)?;\n        tera.add_raw_template(\"label-index.html\", embedded::LABEL_INDEX_HTML)?;\n        tera.add_raw_template(\"timeline.html\", embedded::TIMELINE_HTML)?;\n        tera.add_raw_template(\"graph.html\", embedded::GRAPH_HTML)?;\n        tera.add_raw_template(\"changelog.html\", embedded::CHANGELOG_HTML)?;\n\n        // Register custom filter for slugify\n        tera.register_filter(\"slugify\", slugify_filter);\n\n        Ok(tera)\n    }\n\n    /// Filter specs based on configuration\n    fn filter_specs(\u0026self) -\u003e Vec\u003c\u0026Spec\u003e {\n        self.specs\n            .iter()\n            .filter(|spec| {\n                // Check public flag\n                if let Some(false) = spec.frontmatter.public {\n                    return false;\n                }\n\n                // Check status filter\n                let status_str = format!(\"{:?}\", spec.frontmatter.status).to_lowercase();\n                if !self.config.include.statuses.is_empty()\n                    \u0026\u0026 !self.config.include.statuses.contains(\u0026status_str)\n                {\n                    return false;\n                }\n\n                // Check include labels (empty = include all)\n                if !self.config.include.labels.is_empty() {\n                    let spec_labels = spec.frontmatter.labels.as_ref();\n                    if let Some(labels) = spec_labels {\n                        if !labels\n                            .iter()\n                            .any(|l| self.config.include.labels.contains(l))\n                        {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n\n                // Check exclude labels\n                if let Some(labels) = \u0026spec.frontmatter.labels {\n                    if labels\n                        .iter()\n                        .any(|l| self.config.exclude.labels.contains(l))\n                    {\n                        return false;\n                    }\n                }\n\n                true\n            })\n            .collect()\n    }\n\n    /// Collect all unique labels from filtered specs\n    fn collect_labels(\u0026self, specs: \u0026[\u0026Spec]) -\u003e Vec\u003cString\u003e {\n        let mut labels: HashSet\u003cString\u003e = HashSet::new();\n\n        for spec in specs {\n            if let Some(spec_labels) = \u0026spec.frontmatter.labels {\n                for label in spec_labels {\n                    labels.insert(label.clone());\n                }\n            }\n        }\n\n        let mut labels: Vec\u003c_\u003e = labels.into_iter().collect();\n        labels.sort();\n        labels\n    }\n\n    /// Build the static site\n    pub fn build(\u0026self, output_dir: \u0026Path) -\u003e Result\u003cBuildResult\u003e {\n        let mut result = BuildResult::default();\n\n        // Create output directory structure\n        fs::create_dir_all(output_dir)?;\n        fs::create_dir_all(output_dir.join(\"specs\"))?;\n        fs::create_dir_all(output_dir.join(\"status\"))?;\n        fs::create_dir_all(output_dir.join(\"labels\"))?;\n\n        // Filter specs\n        let filtered_specs = self.filter_specs();\n        let labels = self.collect_labels(\u0026filtered_specs);\n        let stats = SiteStats::from_specs(\u0026filtered_specs);\n\n        // Prepare common context\n        let mut base_context = tera::Context::new();\n        base_context.insert(\"site_title\", \u0026self.config.title);\n        base_context.insert(\"base_url\", \u0026self.config.base_url);\n        base_context.insert(\"features\", \u0026self.config.features);\n        base_context.insert(\"labels\", \u0026labels);\n\n        // Write CSS\n        let css_content = if let Some(theme_path) = self.find_theme_file(\"styles.css\") {\n            fs::read_to_string(\u0026theme_path)?\n        } else {\n            embedded::STYLES_CSS.to_string()\n        };\n        fs::write(output_dir.join(\"styles.css\"), css_content)?;\n        result.files_written += 1;\n\n        // Generate individual spec pages\n        let spec_data: Vec\u003cSpecTemplateData\u003e = filtered_specs\n            .iter()\n            .map(|s| SpecTemplateData::from_spec(s, \u0026self.config.exclude.fields))\n            .collect();\n\n        for (i, spec) in spec_data.iter().enumerate() {\n            let mut context = base_context.clone();\n            context.insert(\"spec\", spec);\n\n            // Add prev/next navigation\n            if i \u003e 0 {\n                context.insert(\"prev_spec\", \u0026spec_data[i - 1]);\n            }\n            if i \u003c spec_data.len() - 1 {\n                context.insert(\"next_spec\", \u0026spec_data[i + 1]);\n            }\n\n            let html = self.tera.render(\"spec.html\", \u0026context)?;\n            let spec_path = output_dir.join(\"specs\").join(format!(\"{}.html\", spec.id));\n            fs::write(\u0026spec_path, html)?;\n            result.files_written += 1;\n        }\n\n        // Generate index page\n        {\n            let mut context = base_context.clone();\n            context.insert(\"specs\", \u0026spec_data);\n            context.insert(\"stats\", \u0026stats);\n\n            let html = self.tera.render(\"index.html\", \u0026context)?;\n            fs::write(output_dir.join(\"index.html\"), html)?;\n            result.files_written += 1;\n        }\n\n        // Generate status index pages\n        if self.config.features.status_indexes {\n            for (status, display) in [\n                (\"completed\", \"Completed\"),\n                (\"in_progress\", \"In Progress\"),\n                (\"pending\", \"Pending\"),\n            ] {\n                let status_specs: Vec\u003c_\u003e = spec_data\n                    .iter()\n                    .filter(|s| s.status == status)\n                    .cloned()\n                    .collect();\n\n                let mut context = base_context.clone();\n                context.insert(\"status\", status);\n                context.insert(\"status_display\", display);\n                context.insert(\"specs\", \u0026status_specs);\n\n                let html = self.tera.render(\"status-index.html\", \u0026context)?;\n                let filename = format!(\"{}.html\", status.replace('_', \"-\"));\n                fs::write(output_dir.join(\"status\").join(\u0026filename), html)?;\n                result.files_written += 1;\n            }\n        }\n\n        // Generate label index pages\n        if self.config.features.label_indexes {\n            for label in \u0026labels {\n                let label_specs: Vec\u003c_\u003e = spec_data\n                    .iter()\n                    .filter(|s| s.labels.contains(label))\n                    .cloned()\n                    .collect();\n\n                let mut context = base_context.clone();\n                context.insert(\"label\", label);\n                context.insert(\"specs\", \u0026label_specs);\n\n                let html = self.tera.render(\"label-index.html\", \u0026context)?;\n                let filename = format!(\"{}.html\", slugify(label));\n                fs::write(output_dir.join(\"labels\").join(\u0026filename), html)?;\n                result.files_written += 1;\n            }\n        }\n\n        // Generate timeline page\n        if self.config.features.timeline {\n            let timeline_groups = timeline::build_timeline_groups(\n                \u0026filtered_specs,\n                self.config.timeline.group_by,\n                self.config.timeline.include_pending,\n            );\n\n            let mut context = base_context.clone();\n            context.insert(\"timeline_groups\", \u0026timeline_groups);\n\n            let html = self.tera.render(\"timeline.html\", \u0026context)?;\n            fs::write(output_dir.join(\"timeline.html\"), html)?;\n            result.files_written += 1;\n        }\n\n        // Generate dependency graph page\n        if self.config.features.dependency_graph {\n            let (ascii_graph, roots, leaves) =\n                graph::build_dependency_graph(\u0026filtered_specs, self.config.graph.detail);\n\n            let roots_data: Vec\u003c_\u003e = roots\n                .iter()\n                .map(|id| {\n                    spec_data\n                        .iter()\n                        .find(|s| \u0026s.id == id)\n                        .cloned()\n                        .unwrap_or_else(|| SpecTemplateData {\n                            id: id.clone(),\n                            short_id: id.clone(),\n                            title: None,\n                            status: \"unknown\".to_string(),\n                            r#type: \"unknown\".to_string(),\n                            labels: vec![],\n                            depends_on: vec![],\n                            target_files: vec![],\n                            completed_at: None,\n                            model: None,\n                            body_html: String::new(),\n                        })\n                })\n                .collect();\n\n            let leaves_data: Vec\u003c_\u003e = leaves\n                .iter()\n                .map(|id| {\n                    spec_data\n                        .iter()\n                        .find(|s| \u0026s.id == id)\n                        .cloned()\n                        .unwrap_or_else(|| SpecTemplateData {\n                            id: id.clone(),\n                            short_id: id.clone(),\n                            title: None,\n                            status: \"unknown\".to_string(),\n                            r#type: \"unknown\".to_string(),\n                            labels: vec![],\n                            depends_on: vec![],\n                            target_files: vec![],\n                            completed_at: None,\n                            model: None,\n                            body_html: String::new(),\n                        })\n                })\n                .collect();\n\n            let mut context = base_context.clone();\n            context.insert(\"ascii_graph\", \u0026ascii_graph);\n            context.insert(\"roots\", \u0026roots_data);\n            context.insert(\"leaves\", \u0026leaves_data);\n\n            let html = self.tera.render(\"graph.html\", \u0026context)?;\n            fs::write(output_dir.join(\"graph.html\"), html)?;\n            result.files_written += 1;\n        }\n\n        // Generate changelog page\n        if self.config.features.changelog {\n            let changelog_groups = build_changelog_groups(\u0026filtered_specs);\n\n            let changelog_data: Vec\u003cHashMap\u003cString, serde_json::Value\u003e\u003e = changelog_groups\n                .into_iter()\n                .map(|(date, specs)| {\n                    let mut map = HashMap::new();\n                    map.insert(\"date\".to_string(), serde_json::json!(date));\n                    let specs_data: Vec\u003c_\u003e = specs\n                        .iter()\n                        .map(|s| SpecTemplateData::from_spec(s, \u0026self.config.exclude.fields))\n                        .collect();\n                    map.insert(\"specs\".to_string(), serde_json::json!(specs_data));\n                    map\n                })\n                .collect();\n\n            let mut context = base_context.clone();\n            context.insert(\"changelog_groups\", \u0026changelog_data);\n\n            let html = self.tera.render(\"changelog.html\", \u0026context)?;\n            fs::write(output_dir.join(\"changelog.html\"), html)?;\n            result.files_written += 1;\n        }\n\n        result.specs_included = filtered_specs.len();\n        Ok(result)\n    }\n\n    /// Find a theme file in the custom theme directory\n    fn find_theme_file(\u0026self, filename: \u0026str) -\u003e Option\u003cstd::path::PathBuf\u003e {\n        let theme_dir = Path::new(\".chant/site/theme\");\n        if theme_dir.exists() {\n            let path = theme_dir.join(filename);\n            if path.exists() {\n                return Some(path);\n            }\n        }\n        None\n    }\n}\n\n/// Build changelog groups from completed specs\nfn build_changelog_groups\u003c'a\u003e(specs: \u0026[\u0026'a Spec]) -\u003e Vec\u003c(String, Vec\u003c\u0026'a Spec\u003e)\u003e {\n    let mut groups: HashMap\u003cString, Vec\u003c\u0026'a Spec\u003e\u003e = HashMap::new();\n\n    for spec in specs {\n        if spec.frontmatter.status == SpecStatus::Completed {\n            // Get date from completed_at or extract from ID\n            let date = if let Some(completed_at) = \u0026spec.frontmatter.completed_at {\n                completed_at\n                    .split('T')\n                    .next()\n                    .unwrap_or(\"Unknown\")\n                    .to_string()\n            } else {\n                // Extract date from ID (e.g., 2026-01-30-00a-xyz -\u003e 2026-01-30)\n                let parts: Vec\u003c_\u003e = spec.id.split('-').collect();\n                if parts.len() \u003e= 3 {\n                    format!(\"{}-{}-{}\", parts[0], parts[1], parts[2])\n                } else {\n                    \"Unknown\".to_string()\n                }\n            };\n\n            groups.entry(date).or_default().push(*spec);\n        }\n    }\n\n    // Sort by date descending\n    let mut sorted: Vec\u003c_\u003e = groups.into_iter().collect();\n    sorted.sort_by(|a, b| b.0.cmp(\u0026a.0));\n    sorted\n}\n\n/// Slugify a string for use in URLs\npub fn slugify(s: \u0026str) -\u003e String {\n    s.to_lowercase()\n        .chars()\n        .map(|c| if c.is_alphanumeric() { c } else { '-' })\n        .collect::\u003cString\u003e()\n        .split('-')\n        .filter(|s| !s.is_empty())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"-\")\n}\n\n/// Tera filter for slugify\nfn slugify_filter(\n    value: \u0026tera::Value,\n    _args: \u0026HashMap\u003cString, tera::Value\u003e,\n) -\u003e tera::Result\u003ctera::Value\u003e {\n    match value.as_str() {\n        Some(s) =\u003e Ok(tera::Value::String(slugify(s))),\n        None =\u003e Ok(value.clone()),\n    }\n}\n\n/// Result of building the site\n#[derive(Debug, Default)]\npub struct BuildResult {\n    pub files_written: usize,\n    pub specs_included: usize,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slugify() {\n        assert_eq!(slugify(\"Hello World\"), \"hello-world\");\n        assert_eq!(slugify(\"API_Integration\"), \"api-integration\");\n        assert_eq!(slugify(\"feature/auth\"), \"feature-auth\");\n        assert_eq!(slugify(\"multiple   spaces\"), \"multiple-spaces\");\n    }\n\n    #[test]\n    fn test_markdown_to_html() {\n        let md = \"# Hello\\n\\nThis is **bold** text.\";\n        let html = markdown_to_html(md);\n        assert!(html.contains(\"\u003ch1\u003eHello\u003c/h1\u003e\"));\n        assert!(html.contains(\"\u003cstrong\u003ebold\u003c/strong\u003e\"));\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":530,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":224}},{"line":535,"address":[],"length":0,"stats":{"Line":24}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":254},{"path":["/","Users","alex","Documents","checkouts","chant","src","site","theme.rs"],"content":"//! Theme management for site generation.\n//!\n//! This module handles copying the default theme to the user's project\n//! for customization.\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\n\nuse super::embedded;\n\n/// Theme file information\npub struct ThemeFile {\n    pub name: \u0026'static str,\n    pub content: \u0026'static str,\n    pub description: \u0026'static str,\n}\n\n/// Get all embedded theme files\npub fn get_theme_files() -\u003e Vec\u003cThemeFile\u003e {\n    vec![\n        ThemeFile {\n            name: \"base.html\",\n            content: embedded::BASE_HTML,\n            description: \"Page skeleton, head, nav\",\n        },\n        ThemeFile {\n            name: \"spec.html\",\n            content: embedded::SPEC_HTML,\n            description: \"Individual spec page\",\n        },\n        ThemeFile {\n            name: \"index.html\",\n            content: embedded::INDEX_HTML,\n            description: \"Main index page\",\n        },\n        ThemeFile {\n            name: \"status-index.html\",\n            content: embedded::STATUS_INDEX_HTML,\n            description: \"By-status listing\",\n        },\n        ThemeFile {\n            name: \"label-index.html\",\n            content: embedded::LABEL_INDEX_HTML,\n            description: \"By-label listing\",\n        },\n        ThemeFile {\n            name: \"timeline.html\",\n            content: embedded::TIMELINE_HTML,\n            description: \"Timeline view\",\n        },\n        ThemeFile {\n            name: \"graph.html\",\n            content: embedded::GRAPH_HTML,\n            description: \"Dependency graph view\",\n        },\n        ThemeFile {\n            name: \"changelog.html\",\n            content: embedded::CHANGELOG_HTML,\n            description: \"Changelog view\",\n        },\n        ThemeFile {\n            name: \"styles.css\",\n            content: embedded::STYLES_CSS,\n            description: \"All styling\",\n        },\n    ]\n}\n\n/// Initialize the theme directory with default templates\npub fn init_theme(theme_dir: \u0026Path, force: bool) -\u003e Result\u003cInitResult\u003e {\n    let mut result = InitResult::default();\n\n    // Create theme directory\n    fs::create_dir_all(theme_dir).with_context(|| {\n        format!(\n            \"Failed to create theme directory at {}\",\n            theme_dir.display()\n        )\n    })?;\n\n    // Copy each template file\n    for file in get_theme_files() {\n        let target_path = theme_dir.join(file.name);\n\n        if target_path.exists() \u0026\u0026 !force {\n            result.skipped.push(file.name.to_string());\n            continue;\n        }\n\n        fs::write(\u0026target_path, file.content)\n            .with_context(|| format!(\"Failed to write {}\", target_path.display()))?;\n\n        result.created.push(file.name.to_string());\n    }\n\n    Ok(result)\n}\n\n/// Check if a custom theme directory exists\npub fn theme_exists(theme_dir: \u0026Path) -\u003e bool {\n    theme_dir.exists() \u0026\u0026 theme_dir.is_dir()\n}\n\n/// List files in a custom theme directory\npub fn list_theme_files(theme_dir: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut files = Vec::new();\n\n    if !theme_dir.exists() {\n        return Ok(files);\n    }\n\n    for entry in fs::read_dir(theme_dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() {\n            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                files.push(name.to_string());\n            }\n        }\n    }\n\n    files.sort();\n    Ok(files)\n}\n\n/// Result of theme initialization\n#[derive(Debug, Default)]\npub struct InitResult {\n    /// Files that were created\n    pub created: Vec\u003cString\u003e,\n    /// Files that were skipped (already exist)\n    pub skipped: Vec\u003cString\u003e,\n}\n\nimpl InitResult {\n    /// Check if any files were created\n    pub fn has_changes(\u0026self) -\u003e bool {\n        !self.created.is_empty()\n    }\n}\n\n/// Template variable documentation\npub fn get_template_variables_doc() -\u003e \u0026'static str {\n    r#\"# Template Variables Reference\n\n## Global Variables (available in all templates)\n\n- `site_title` - The site title from config\n- `base_url` - The base URL for all links\n- `features` - Object with feature toggles:\n  - `features.changelog`\n  - `features.dependency_graph`\n  - `features.timeline`\n  - `features.status_indexes`\n  - `features.label_indexes`\n- `labels` - List of all labels used across specs\n\n## Index Page (`index.html`)\n\n- `specs` - List of all spec objects\n- `stats` - Site statistics object:\n  - `stats.total`\n  - `stats.completed`\n  - `stats.in_progress`\n  - `stats.pending`\n  - `stats.failed`\n  - `stats.other`\n\n## Spec Page (`spec.html`)\n\n- `spec` - The current spec object:\n  - `spec.id` - Full spec ID\n  - `spec.short_id` - Short ID (last segment)\n  - `spec.title` - Spec title (may be null)\n  - `spec.status` - Status string (lowercase)\n  - `spec.type` - Spec type\n  - `spec.labels` - List of label strings\n  - `spec.depends_on` - List of dependency IDs\n  - `spec.target_files` - List of target file paths\n  - `spec.completed_at` - Completion timestamp (may be null)\n  - `spec.model` - Model used (may be null)\n  - `spec.body_html` - Rendered markdown body as HTML\n- `prev_spec` - Previous spec (may be null)\n- `next_spec` - Next spec (may be null)\n\n## Status Index Page (`status-index.html`)\n\n- `status` - Status key (e.g., \"completed\")\n- `status_display` - Display name (e.g., \"Completed\")\n- `specs` - List of specs with this status\n\n## Label Index Page (`label-index.html`)\n\n- `label` - The label name\n- `specs` - List of specs with this label\n\n## Timeline Page (`timeline.html`)\n\n- `timeline_groups` - List of timeline groups:\n  - `group.date` - Date/period label\n  - `group.ascii_tree` - ASCII tree visualization\n\n## Graph Page (`graph.html`)\n\n- `ascii_graph` - ASCII dependency graph\n- `roots` - List of root specs (no dependencies)\n- `leaves` - List of leaf specs (no dependents)\n\n## Changelog Page (`changelog.html`)\n\n- `changelog_groups` - List of changelog entries:\n  - `group.date` - Completion date\n  - `group.specs` - List of specs completed on this date\n\n## Filters\n\n- `slugify` - Convert string to URL-safe slug\n  - Example: `{{ label | slugify }}`\n\n## Example Template Snippet\n\n```html\n{% for spec in specs %}\n\u003cdiv class=\"spec-card\"\u003e\n  \u003ch2\u003e{{ spec.title | default(value=\"Untitled\") }}\u003c/h2\u003e\n  \u003cspan class=\"status-{{ spec.status | slugify }}\"\u003e{{ spec.status }}\u003c/span\u003e\n  {% for label in spec.labels %}\n    \u003cspan class=\"label\"\u003e{{ label }}\u003c/span\u003e\n  {% endfor %}\n\u003c/div\u003e\n{% endfor %}\n```\n\"#\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_get_theme_files() {\n        let files = get_theme_files();\n        assert!(!files.is_empty());\n\n        // Check required files exist\n        let names: Vec\u003c_\u003e = files.iter().map(|f| f.name).collect();\n        assert!(names.contains(\u0026\"base.html\"));\n        assert!(names.contains(\u0026\"index.html\"));\n        assert!(names.contains(\u0026\"spec.html\"));\n        assert!(names.contains(\u0026\"styles.css\"));\n    }\n\n    #[test]\n    fn test_init_theme() {\n        let tmp = TempDir::new().unwrap();\n        let theme_dir = tmp.path().join(\"theme\");\n\n        let result = init_theme(\u0026theme_dir, false).unwrap();\n\n        assert!(result.has_changes());\n        assert!(result.skipped.is_empty());\n        assert!(theme_dir.join(\"base.html\").exists());\n        assert!(theme_dir.join(\"styles.css\").exists());\n    }\n\n    #[test]\n    fn test_init_theme_skip_existing() {\n        let tmp = TempDir::new().unwrap();\n        let theme_dir = tmp.path().join(\"theme\");\n\n        // First init\n        init_theme(\u0026theme_dir, false).unwrap();\n\n        // Second init should skip\n        let result = init_theme(\u0026theme_dir, false).unwrap();\n        assert!(!result.has_changes());\n        assert!(!result.skipped.is_empty());\n    }\n\n    #[test]\n    fn test_init_theme_force() {\n        let tmp = TempDir::new().unwrap();\n        let theme_dir = tmp.path().join(\"theme\");\n\n        // First init\n        init_theme(\u0026theme_dir, false).unwrap();\n\n        // Force should overwrite\n        let result = init_theme(\u0026theme_dir, true).unwrap();\n        assert!(result.has_changes());\n        assert!(result.skipped.is_empty());\n    }\n\n    #[test]\n    fn test_list_theme_files() {\n        let tmp = TempDir::new().unwrap();\n        let theme_dir = tmp.path().join(\"theme\");\n\n        init_theme(\u0026theme_dir, false).unwrap();\n\n        let files = list_theme_files(\u0026theme_dir).unwrap();\n        assert!(files.contains(\u0026\"base.html\".to_string()));\n        assert!(files.contains(\u0026\"styles.css\".to_string()));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":7}},{"line":21,"address":[],"length":0,"stats":{"Line":7}},{"line":22,"address":[],"length":0,"stats":{"Line":7}},{"line":23,"address":[],"length":0,"stats":{"Line":7}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":7}},{"line":32,"address":[],"length":0,"stats":{"Line":7}},{"line":33,"address":[],"length":0,"stats":{"Line":7}},{"line":34,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":7}},{"line":37,"address":[],"length":0,"stats":{"Line":7}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":7}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":7}},{"line":45,"address":[],"length":0,"stats":{"Line":7}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":49,"address":[],"length":0,"stats":{"Line":7}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":52,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":7}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":57,"address":[],"length":0,"stats":{"Line":7}},{"line":58,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[],"length":0,"stats":{"Line":7}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[],"length":0,"stats":{"Line":7}},{"line":65,"address":[],"length":0,"stats":{"Line":7}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":60}},{"line":84,"address":[],"length":0,"stats":{"Line":216}},{"line":86,"address":[],"length":0,"stats":{"Line":72}},{"line":87,"address":[],"length":0,"stats":{"Line":36}},{"line":88,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":135}},{"line":92,"address":[],"length":0,"stats":{"Line":45}},{"line":94,"address":[],"length":0,"stats":{"Line":180}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":114,"address":[],"length":0,"stats":{"Line":18}},{"line":115,"address":[],"length":0,"stats":{"Line":27}},{"line":116,"address":[],"length":0,"stats":{"Line":9}},{"line":117,"address":[],"length":0,"stats":{"Line":54}},{"line":118,"address":[],"length":0,"stats":{"Line":27}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}}],"covered":63,"coverable":139},{"path":["/","Users","alex","Documents","checkouts","chant","src","site","timeline.rs"],"content":"//! ASCII timeline generation for specs.\n//!\n//! This module generates ASCII art timelines showing spec activity\n//! grouped by date, week, or month.\n\nuse std::collections::HashMap;\n\nuse chrono::Datelike;\n\nuse crate::config::TimelineGroupBy;\nuse crate::spec::{Spec, SpecStatus};\n\n/// A group of specs for a timeline entry\n#[derive(Debug, Clone, serde::Serialize)]\npub struct TimelineGroup {\n    /// The date/period label for this group\n    pub date: String,\n    /// ASCII tree representation of specs in this group\n    pub ascii_tree: String,\n}\n\n/// Build timeline groups from specs\npub fn build_timeline_groups(\n    specs: \u0026[\u0026Spec],\n    group_by: TimelineGroupBy,\n    include_pending: bool,\n) -\u003e Vec\u003cTimelineGroup\u003e {\n    // Filter specs based on include_pending\n    let filtered_specs: Vec\u003c_\u003e = specs\n        .iter()\n        .filter(|s| {\n            if !include_pending \u0026\u0026 s.frontmatter.status == SpecStatus::Pending {\n                return false;\n            }\n            true\n        })\n        .collect();\n\n    // Group specs by date\n    let mut groups: HashMap\u003cString, Vec\u003c\u0026\u0026Spec\u003e\u003e = HashMap::new();\n\n    for spec in \u0026filtered_specs {\n        let date_key = extract_date_key(spec, group_by);\n        groups.entry(date_key).or_default().push(spec);\n    }\n\n    // Sort groups by date descending\n    let mut sorted_keys: Vec\u003c_\u003e = groups.keys().cloned().collect();\n    sorted_keys.sort_by(|a, b| b.cmp(a));\n\n    // Build timeline groups\n    sorted_keys\n        .into_iter()\n        .map(|date| {\n            let specs_in_group = groups.get(\u0026date).unwrap();\n            let ascii_tree = render_tree(specs_in_group);\n            let display_date = format_date_display(\u0026date, group_by);\n            TimelineGroup {\n                date: display_date,\n                ascii_tree,\n            }\n        })\n        .collect()\n}\n\n/// Extract the date key for grouping\nfn extract_date_key(spec: \u0026Spec, group_by: TimelineGroupBy) -\u003e String {\n    // Try to get date from completed_at or from spec ID\n    let date_str = spec\n        .frontmatter\n        .completed_at\n        .as_ref()\n        .and_then(|s| s.split('T').next())\n        .map(|s| s.to_string())\n        .unwrap_or_else(|| {\n            // Extract date from ID (e.g., 2026-01-30-00a-xyz -\u003e 2026-01-30)\n            let parts: Vec\u003c_\u003e = spec.id.split('-').collect();\n            if parts.len() \u003e= 3 {\n                format!(\"{}-{}-{}\", parts[0], parts[1], parts[2])\n            } else {\n                \"unknown\".to_string()\n            }\n        });\n\n    match group_by {\n        TimelineGroupBy::Day =\u003e date_str,\n        TimelineGroupBy::Week =\u003e {\n            // Get the week start (Monday)\n            if let Some(date) = parse_date(\u0026date_str) {\n                let weekday = date.weekday();\n                let days_since_monday = weekday.num_days_from_monday();\n                let monday = date - chrono::Duration::days(days_since_monday as i64);\n                monday.format(\"%Y-%m-%d\").to_string()\n            } else {\n                date_str\n            }\n        }\n        TimelineGroupBy::Month =\u003e {\n            // Get YYYY-MM\n            let parts: Vec\u003c_\u003e = date_str.split('-').collect();\n            if parts.len() \u003e= 2 {\n                format!(\"{}-{}\", parts[0], parts[1])\n            } else {\n                date_str\n            }\n        }\n    }\n}\n\n/// Parse a date string to a chrono NaiveDate\nfn parse_date(s: \u0026str) -\u003e Option\u003cchrono::NaiveDate\u003e {\n    chrono::NaiveDate::parse_from_str(s, \"%Y-%m-%d\").ok()\n}\n\n/// Format the date for display\nfn format_date_display(date_key: \u0026str, group_by: TimelineGroupBy) -\u003e String {\n    match group_by {\n        TimelineGroupBy::Day =\u003e date_key.to_string(),\n        TimelineGroupBy::Week =\u003e format!(\"Week of {}\", date_key),\n        TimelineGroupBy::Month =\u003e {\n            if let Some(date) = parse_month(date_key) {\n                date.format(\"%B %Y\").to_string()\n            } else {\n                date_key.to_string()\n            }\n        }\n    }\n}\n\n/// Parse a month string (YYYY-MM) to a date\nfn parse_month(s: \u0026str) -\u003e Option\u003cchrono::NaiveDate\u003e {\n    let full = format!(\"{}-01\", s);\n    chrono::NaiveDate::parse_from_str(\u0026full, \"%Y-%m-%d\").ok()\n}\n\n/// Render specs as an ASCII tree\nfn render_tree(specs: \u0026[\u0026\u0026Spec]) -\u003e String {\n    if specs.is_empty() {\n        return String::new();\n    }\n\n    let mut lines = Vec::new();\n\n    for (i, spec) in specs.iter().enumerate() {\n        let is_last = i == specs.len() - 1;\n        let prefix = if is_last { \"âââ \" } else { \"âââ \" };\n\n        let status_icon = match spec.frontmatter.status {\n            SpecStatus::Completed =\u003e \"â\",\n            SpecStatus::InProgress =\u003e \"â\",\n            SpecStatus::Pending =\u003e \"â\",\n            SpecStatus::Failed =\u003e \"â\",\n            SpecStatus::NeedsAttention =\u003e \"â \",\n            _ =\u003e \"â¢\",\n        };\n\n        let short_id = spec.id.split('-').skip(3).collect::\u003cVec\u003c_\u003e\u003e().join(\"-\");\n\n        let short_id = if short_id.is_empty() {\n            \u0026spec.id\n        } else {\n            \u0026short_id\n        };\n\n        let title = spec\n            .title\n            .as_ref()\n            .map(|t| truncate(t, 30))\n            .unwrap_or_else(|| \"Untitled\".to_string());\n\n        let status_display = match spec.frontmatter.status {\n            SpecStatus::Completed =\u003e \"completed\",\n            SpecStatus::InProgress =\u003e \"in_progress\",\n            SpecStatus::Pending =\u003e \"pending\",\n            SpecStatus::Failed =\u003e \"failed\",\n            _ =\u003e \"other\",\n        };\n\n        lines.push(format!(\n            \"{}{} {}  {} ({})\",\n            prefix, status_icon, short_id, title, status_display\n        ));\n    }\n\n    lines.join(\"\\n\")\n}\n\n/// Truncate a string to max length\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len - 1).collect();\n        format!(\"{}â¦\", truncated)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::spec::SpecFrontmatter;\n\n    fn make_spec(id: \u0026str, status: SpecStatus, completed_at: Option\u003c\u0026str\u003e) -\u003e Spec {\n        Spec {\n            id: id.to_string(),\n            title: Some(\"Test Spec\".to_string()),\n            body: String::new(),\n            frontmatter: SpecFrontmatter {\n                status,\n                completed_at: completed_at.map(|s| s.to_string()),\n                ..Default::default()\n            },\n        }\n    }\n\n    #[test]\n    fn test_build_timeline_groups_empty() {\n        let specs: Vec\u003c\u0026Spec\u003e = vec![];\n        let groups = build_timeline_groups(\u0026specs, TimelineGroupBy::Day, false);\n        assert!(groups.is_empty());\n    }\n\n    #[test]\n    fn test_extract_date_key_from_id() {\n        let spec = make_spec(\"2026-01-30-00a-xyz\", SpecStatus::Pending, None);\n        let key = extract_date_key(\u0026spec, TimelineGroupBy::Day);\n        assert_eq!(key, \"2026-01-30\");\n    }\n\n    #[test]\n    fn test_extract_date_key_from_completed_at() {\n        let spec = make_spec(\n            \"2026-01-30-00a-xyz\",\n            SpecStatus::Completed,\n            Some(\"2026-01-29T12:00:00Z\"),\n        );\n        let key = extract_date_key(\u0026spec, TimelineGroupBy::Day);\n        assert_eq!(key, \"2026-01-29\");\n    }\n\n    #[test]\n    fn test_render_tree() {\n        let spec1 = make_spec(\"2026-01-30-00a-xyz\", SpecStatus::Completed, None);\n        let spec2 = make_spec(\"2026-01-30-00b-abc\", SpecStatus::InProgress, None);\n        let specs: Vec\u003c\u0026Spec\u003e = vec![\u0026spec1, \u0026spec2];\n        let refs: Vec\u003c\u0026\u0026Spec\u003e = specs.iter().collect();\n        let tree = render_tree(\u0026refs);\n\n        assert!(tree.contains(\"â\"));\n        assert!(tree.contains(\"â\"));\n        assert!(tree.contains(\"âââ\"));\n        assert!(tree.contains(\"âââ\"));\n    }\n\n    #[test]\n    fn test_truncate() {\n        assert_eq!(truncate(\"short\", 10), \"short\");\n        assert_eq!(truncate(\"a very long title here\", 10), \"a very loâ¦\");\n    }\n\n    #[test]\n    fn test_format_date_display() {\n        assert_eq!(\n            format_date_display(\"2026-01-30\", TimelineGroupBy::Day),\n            \"2026-01-30\"\n        );\n        assert_eq!(\n            format_date_display(\"2026-01-27\", TimelineGroupBy::Week),\n            \"Week of 2026-01-27\"\n        );\n        assert_eq!(\n            format_date_display(\"2026-01\", TimelineGroupBy::Month),\n            \"January 2026\"\n        );\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[],"length":0,"stats":{"Line":6}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":12}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":7}},{"line":194,"address":[],"length":0,"stats":{"Line":1}}],"covered":56,"coverable":90},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec","frontmatter.rs"],"content":"//! Frontmatter types and defaults for specs.\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum SpecStatus {\n    #[default]\n    Pending,\n    InProgress,\n    Paused,\n    Completed,\n    Failed,\n    NeedsAttention,\n    Ready,\n    Blocked,\n    Cancelled,\n}\n\n/// Approval status for a spec\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ApprovalStatus {\n    #[default]\n    Pending,\n    Approved,\n    Rejected,\n}\n\n/// Approval information for a spec\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct Approval {\n    /// Whether approval is required for this spec\n    #[serde(default)]\n    pub required: bool,\n    /// Current approval status\n    #[serde(default)]\n    pub status: ApprovalStatus,\n    /// Name of the person who approved/rejected\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub by: Option\u003cString\u003e,\n    /// Timestamp of approval/rejection\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub at: Option\u003cString\u003e,\n}\n\n/// Represents a dependency that is blocking a spec from being ready.\n#[derive(Debug, Clone)]\npub struct BlockingDependency {\n    /// The spec ID of the blocking dependency.\n    pub spec_id: String,\n    /// The title of the blocking dependency, if available.\n    pub title: Option\u003cString\u003e,\n    /// The current status of the blocking dependency.\n    pub status: SpecStatus,\n    /// When the dependency was completed, if applicable.\n    pub completed_at: Option\u003cString\u003e,\n    /// Whether this is a sibling dependency (from group ordering).\n    pub is_sibling: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SpecFrontmatter {\n    #[serde(default = \"default_type\")]\n    pub r#type: String,\n    #[serde(default)]\n    pub status: SpecStatus,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub depends_on: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub labels: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub target_files: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub context: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub prompt: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub branch: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub commits: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub completed_at: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub model: Option\u003cString\u003e,\n    // Documentation-specific fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tracks: Option\u003cVec\u003cString\u003e\u003e,\n    // Research-specific fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub informed_by: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub origin: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub schedule: Option\u003cString\u003e,\n    // Conflict-specific fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub source_branch: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub target_branch: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub conflicting_files: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub blocked_specs: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub original_spec: Option\u003cString\u003e,\n    // Verification-specific fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub last_verified: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub verification_status: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub verification_failures: Option\u003cVec\u003cString\u003e\u003e,\n    // Replay tracking fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub replayed_at: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub replay_count: Option\u003cu32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub original_completed_at: Option\u003cString\u003e,\n    // Derivation tracking - which fields were automatically derived\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub derived_fields: Option\u003cVec\u003cString\u003e\u003e,\n    // Approval workflow fields\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub approval: Option\u003cApproval\u003e,\n    // Driver/group member tracking\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub members: Option\u003cVec\u003cString\u003e\u003e,\n    // Output schema validation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub output_schema: Option\u003cString\u003e,\n    // Site generation control - set to false to exclude from site\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub public: Option\u003cbool\u003e,\n    // Retry state for failed specs (watch mode)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub retry_state: Option\u003ccrate::retry::RetryState\u003e,\n}\n\npub(crate) fn default_type() -\u003e String {\n    \"code\".to_string()\n}\n\nimpl Default for SpecFrontmatter {\n    fn default() -\u003e Self {\n        Self {\n            r#type: default_type(),\n            status: SpecStatus::Pending,\n            depends_on: None,\n            labels: None,\n            target_files: None,\n            context: None,\n            prompt: None,\n            branch: None,\n            commits: None,\n            completed_at: None,\n            model: None,\n            tracks: None,\n            informed_by: None,\n            origin: None,\n            schedule: None,\n            source_branch: None,\n            target_branch: None,\n            conflicting_files: None,\n            blocked_specs: None,\n            original_spec: None,\n            last_verified: None,\n            verification_status: None,\n            verification_failures: None,\n            replayed_at: None,\n            replay_count: None,\n            original_completed_at: None,\n            derived_fields: None,\n            approval: None,\n            members: None,\n            output_schema: None,\n            public: None,\n            retry_state: None,\n        }\n    }\n}\n","traces":[{"line":141,"address":[],"length":0,"stats":{"Line":324}},{"line":142,"address":[],"length":0,"stats":{"Line":648}},{"line":146,"address":[],"length":0,"stats":{"Line":287}},{"line":148,"address":[],"length":0,"stats":{"Line":574}}],"covered":4,"coverable":4},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec","lifecycle.rs"],"content":"//! Spec lifecycle operations.\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\nuse std::process::Command;\n\nuse super::frontmatter::SpecStatus;\nuse super::parse::Spec;\n\n/// Apply blocked status to specs with unmet dependencies.\n/// For pending specs that have incomplete dependencies, updates their status to blocked.\n/// This is a local-only version that only checks dependencies within the current repo.\nfn apply_blocked_status(specs: \u0026mut [Spec]) {\n    apply_blocked_status_with_repos(specs, std::path::Path::new(\".chant/specs\"), \u0026[]);\n}\n\n/// Apply blocked status considering both local and cross-repo dependencies.\n/// This version supports cross-repo dependency checking when repos config is available.\npub fn apply_blocked_status_with_repos(\n    specs: \u0026mut [Spec],\n    specs_dir: \u0026std::path::Path,\n    repos: \u0026[crate::config::RepoConfig],\n) {\n    // Build a reference list of specs for dependency checking\n    let specs_snapshot = specs.to_vec();\n\n    for spec in specs.iter_mut() {\n        // Handle both Pending and Blocked specs\n        if spec.frontmatter.status != SpecStatus::Pending\n            \u0026\u0026 spec.frontmatter.status != SpecStatus::Blocked\n        {\n            continue;\n        }\n\n        // Check if this spec has unmet dependencies (local only)\n        let is_blocked_locally = spec.is_blocked(\u0026specs_snapshot);\n\n        // Check cross-repo dependencies if repos config is available\n        let is_blocked_cross_repo = !repos.is_empty()\n            \u0026\u0026 crate::deps::is_blocked_by_dependencies(spec, \u0026specs_snapshot, specs_dir, repos);\n\n        if is_blocked_locally || is_blocked_cross_repo {\n            // Has unmet dependencies - mark as blocked\n            spec.frontmatter.status = SpecStatus::Blocked;\n        } else if spec.frontmatter.status == SpecStatus::Blocked {\n            // No unmet dependencies and was previously blocked - revert to pending\n            spec.frontmatter.status = SpecStatus::Pending;\n        }\n    }\n}\n\npub fn load_all_specs(specs_dir: \u0026Path) -\u003e Result\u003cVec\u003cSpec\u003e\u003e {\n    load_all_specs_with_options(specs_dir, true)\n}\n\n/// Load all specs with optional branch resolution.\npub fn load_all_specs_with_options(\n    specs_dir: \u0026Path,\n    use_branch_resolution: bool,\n) -\u003e Result\u003cVec\u003cSpec\u003e\u003e {\n    let mut specs = Vec::new();\n\n    if !specs_dir.exists() {\n        return Ok(specs);\n    }\n\n    load_specs_recursive(specs_dir, \u0026mut specs, use_branch_resolution)?;\n\n    // Apply blocked status to specs with unmet dependencies\n    apply_blocked_status(\u0026mut specs);\n\n    Ok(specs)\n}\n\n/// Recursively load specs from a directory and its subdirectories.\nfn load_specs_recursive(\n    dir: \u0026Path,\n    specs: \u0026mut Vec\u003cSpec\u003e,\n    use_branch_resolution: bool,\n) -\u003e Result\u003c()\u003e {\n    if !dir.exists() {\n        return Ok(());\n    }\n\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        let metadata = entry.metadata()?;\n\n        if metadata.is_dir() {\n            // Recursively load from subdirectories\n            load_specs_recursive(\u0026path, specs, use_branch_resolution)?;\n        } else if path.extension().map(|e| e == \"md\").unwrap_or(false) {\n            let load_result = if use_branch_resolution {\n                Spec::load_with_branch_resolution(\u0026path)\n            } else {\n                Spec::load(\u0026path)\n            };\n\n            match load_result {\n                Ok(spec) =\u003e specs.push(spec),\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Failed to load spec {:?}: {}\", path, e);\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Resolve a partial spec ID to a full spec.\n/// Only searches active specs (in .chant/specs/), not archived specs.\npub fn resolve_spec(specs_dir: \u0026Path, partial_id: \u0026str) -\u003e Result\u003cSpec\u003e {\n    let specs = load_all_specs(specs_dir)?;\n\n    // Exact match\n    if let Some(spec) = specs.iter().find(|s| s.id == partial_id) {\n        return Ok(spec.clone());\n    }\n\n    // Suffix match (random suffix)\n    let suffix_matches: Vec\u003c_\u003e = specs\n        .iter()\n        .filter(|s| s.id.ends_with(partial_id))\n        .collect();\n    if suffix_matches.len() == 1 {\n        return Ok(suffix_matches[0].clone());\n    }\n\n    // Sequence match for today (e.g., \"001\")\n    if partial_id.len() == 3 {\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        let today_pattern = format!(\"{}-{}-\", today, partial_id);\n        let today_matches: Vec\u003c_\u003e = specs\n            .iter()\n            .filter(|s| s.id.starts_with(\u0026today_pattern))\n            .collect();\n        if today_matches.len() == 1 {\n            return Ok(today_matches[0].clone());\n        }\n    }\n\n    // Partial date match (e.g., \"22-001\" or \"01-22-001\")\n    let partial_matches: Vec\u003c_\u003e = specs.iter().filter(|s| s.id.contains(partial_id)).collect();\n    if partial_matches.len() == 1 {\n        return Ok(partial_matches[0].clone());\n    }\n\n    if partial_matches.len() \u003e 1 {\n        anyhow::bail!(\n            \"Ambiguous spec ID '{}'. Matches: {}\",\n            partial_id,\n            partial_matches\n                .iter()\n                .map(|s| s.id.as_str())\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\", \")\n        );\n    }\n\n    anyhow::bail!(\"Spec not found: {}\", partial_id)\n}\n\n/// Check if a spec is completed (ready for finalization).\n///\n/// A spec is considered completed if:\n/// - Status is `in_progress`\n/// - All acceptance criteria checkboxes are checked (`[x]`)\n/// - Worktree is clean (no uncommitted changes including untracked files)\n///\n/// Edge cases:\n/// - Spec with no acceptance criteria: Treated as completed if worktree clean\n/// - Spec already finalized: Returns false (status not `in_progress`)\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - Spec file is unreadable\n/// - Worktree is inaccessible (git status fails)\npub fn is_completed(spec_id: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Load the spec\n    let spec_path = Path::new(\".chant/specs\").join(format!(\"{}.md\", spec_id));\n    let spec = Spec::load(\u0026spec_path)\n        .with_context(|| format!(\"Failed to read spec file: {}\", spec_path.display()))?;\n\n    // Only in_progress specs can be completed\n    if spec.frontmatter.status != SpecStatus::InProgress {\n        return Ok(false);\n    }\n\n    // Check if all criteria are checked\n    let unchecked_count = spec.count_unchecked_checkboxes();\n    if unchecked_count \u003e 0 {\n        return Ok(false);\n    }\n\n    // Check if worktree is clean\n    is_worktree_clean(spec_id)\n}\n\n/// Check if a spec has success signals indicating work was completed.\n///\n/// Success signals include:\n/// - Commits matching the `chant(spec_id):` pattern\n///\n/// # Errors\n///\n/// Returns an error if git command fails\npub(crate) fn has_success_signals(spec_id: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Check for commits with the chant(spec_id): pattern\n    let pattern = format!(\"chant({}):\", spec_id);\n    let output = Command::new(\"git\")\n        .args([\"log\", \"--all\", \"--grep\", \u0026pattern, \"--format=%H\"])\n        .output()\n        .context(\"Failed to check git log for spec commits\")?;\n\n    if !output.status.success() {\n        return Ok(false);\n    }\n\n    let commits_output = String::from_utf8_lossy(\u0026output.stdout);\n    let has_commits = !commits_output.trim().is_empty();\n\n    Ok(has_commits)\n}\n\n/// Check if a spec has failed.\n///\n/// A spec is considered failed if:\n/// - Status is `in_progress`\n/// - Agent has exited (no lock file present)\n/// - Some acceptance criteria are still incomplete\n/// - No success signals present (commits matching `chant(spec_id):` pattern)\n///\n/// Edge cases:\n/// - Agent still running: Returns false\n/// - Spec already finalized/failed: Returns false (status not `in_progress`)\n/// - Has commits matching chant(spec_id) pattern: Returns false (agent completed work)\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - Spec file is unreadable\n/// - Git commands fail\npub fn is_failed(spec_id: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Load the spec\n    let spec_path = Path::new(\".chant/specs\").join(format!(\"{}.md\", spec_id));\n    let spec = Spec::load(\u0026spec_path)\n        .with_context(|| format!(\"Failed to read spec file: {}\", spec_path.display()))?;\n\n    // Only in_progress specs can fail\n    if spec.frontmatter.status != SpecStatus::InProgress {\n        return Ok(false);\n    }\n\n    // Check if agent is still running (lock file exists)\n    let lock_file = Path::new(crate::paths::LOCKS_DIR).join(format!(\"{}.lock\", spec_id));\n    if lock_file.exists() {\n        return Ok(false);\n    }\n\n    // Check if criteria are incomplete\n    let unchecked_count = spec.count_unchecked_checkboxes();\n    if unchecked_count == 0 {\n        // All criteria checked - not failed\n        return Ok(false);\n    }\n\n    // Check for success signals before flagging as failed\n    // If work was committed, don't mark as failed even if criteria unchecked\n    if has_success_signals(spec_id)? {\n        return Ok(false);\n    }\n\n    // No lock, incomplete criteria, no success signals - failed\n    Ok(true)\n}\n\n/// Check if worktree for a spec is clean (no uncommitted changes).\n///\n/// Uses `git status --porcelain` to check for uncommitted changes.\n/// Untracked files count as dirty for safety.\n///\n/// # Errors\n///\n/// Returns an error if git status command fails or worktree is inaccessible.\nfn is_worktree_clean(spec_id: \u0026str) -\u003e Result\u003cbool\u003e {\n    let worktree_path = Path::new(\"/tmp\").join(format!(\"chant-{}\", spec_id));\n\n    // If worktree doesn't exist, check in current directory\n    let check_path = if worktree_path.exists() {\n        \u0026worktree_path\n    } else {\n        Path::new(\".\")\n    };\n\n    let output = Command::new(\"git\")\n        .args([\"status\", \"--porcelain\"])\n        .current_dir(check_path)\n        .output()\n        .with_context(|| format!(\"Failed to check git status in {:?}\", check_path))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git status failed: {}\", stderr);\n    }\n\n    let status_output = String::from_utf8_lossy(\u0026output.stdout);\n    Ok(status_output.trim().is_empty())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":111}},{"line":15,"address":[],"length":0,"stats":{"Line":444}},{"line":20,"address":[],"length":0,"stats":{"Line":111}},{"line":26,"address":[],"length":0,"stats":{"Line":333}},{"line":28,"address":[],"length":0,"stats":{"Line":413}},{"line":30,"address":[],"length":0,"stats":{"Line":191}},{"line":31,"address":[],"length":0,"stats":{"Line":70}},{"line":33,"address":[],"length":0,"stats":{"Line":70}},{"line":37,"address":[],"length":0,"stats":{"Line":484}},{"line":40,"address":[],"length":0,"stats":{"Line":242}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":242}},{"line":45,"address":[],"length":0,"stats":{"Line":37}},{"line":46,"address":[],"length":0,"stats":{"Line":121}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":91}},{"line":54,"address":[],"length":0,"stats":{"Line":182}},{"line":58,"address":[],"length":0,"stats":{"Line":111}},{"line":62,"address":[],"length":0,"stats":{"Line":222}},{"line":64,"address":[],"length":0,"stats":{"Line":111}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":444}},{"line":71,"address":[],"length":0,"stats":{"Line":222}},{"line":73,"address":[],"length":0,"stats":{"Line":111}},{"line":77,"address":[],"length":0,"stats":{"Line":111}},{"line":82,"address":[],"length":0,"stats":{"Line":111}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":413}},{"line":87,"address":[],"length":0,"stats":{"Line":382}},{"line":88,"address":[],"length":0,"stats":{"Line":573}},{"line":89,"address":[],"length":0,"stats":{"Line":573}},{"line":91,"address":[],"length":0,"stats":{"Line":382}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1189}},{"line":95,"address":[],"length":0,"stats":{"Line":382}},{"line":96,"address":[],"length":0,"stats":{"Line":382}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":191}},{"line":102,"address":[],"length":0,"stats":{"Line":764}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":111}},{"line":115,"address":[],"length":0,"stats":{"Line":45}},{"line":116,"address":[],"length":0,"stats":{"Line":135}},{"line":119,"address":[],"length":0,"stats":{"Line":318}},{"line":120,"address":[],"length":0,"stats":{"Line":36}},{"line":124,"address":[],"length":0,"stats":{"Line":27}},{"line":126,"address":[],"length":0,"stats":{"Line":63}},{"line":128,"address":[],"length":0,"stats":{"Line":9}},{"line":129,"address":[],"length":0,"stats":{"Line":8}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":23}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}}],"covered":47,"coverable":116},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec","parse.rs"],"content":"//! Spec parsing functions.\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\nuse std::process::Command;\n\nuse super::frontmatter::{SpecFrontmatter, SpecStatus};\n\n#[derive(Debug, Clone)]\npub struct Spec {\n    pub id: String,\n    pub frontmatter: SpecFrontmatter,\n    pub title: Option\u003cString\u003e,\n    pub body: String,\n}\n\n/// Normalize model names from full Claude model IDs to short names.\n/// Examples: \"claude-sonnet-4-20250514\" -\u003e \"sonnet\", \"claude-opus-4-5\" -\u003e \"opus\"\nfn normalize_model_name(model: \u0026str) -\u003e String {\n    let lower = model.to_lowercase();\n    if lower.contains(\"opus\") {\n        \"opus\".to_string()\n    } else if lower.contains(\"sonnet\") {\n        \"sonnet\".to_string()\n    } else if lower.contains(\"haiku\") {\n        \"haiku\".to_string()\n    } else {\n        model.to_string()\n    }\n}\n\n/// Split content into frontmatter and body.\n///\n/// If the content starts with `---`, extracts the YAML frontmatter between\n/// the first and second `---` delimiters, and returns the body after.\n/// Otherwise returns None for frontmatter and the entire content as body.\npub fn split_frontmatter(content: \u0026str) -\u003e (Option\u003cString\u003e, \u0026str) {\n    let content = content.trim();\n\n    if !content.starts_with(\"---\") {\n        return (None, content);\n    }\n\n    let rest = \u0026content[3..];\n    if let Some(end) = rest.find(\"---\") {\n        let frontmatter = rest[..end].to_string();\n        let body = rest[end + 3..].trim_start();\n        (Some(frontmatter), body)\n    } else {\n        (None, content)\n    }\n}\n\nfn extract_title(body: \u0026str) -\u003e Option\u003cString\u003e {\n    for line in body.lines() {\n        let trimmed = line.trim();\n        if let Some(title) = trimmed.strip_prefix(\"# \") {\n            return Some(title.to_string());\n        }\n    }\n    None\n}\n\nfn branch_exists(branch: \u0026str) -\u003e Result\u003cbool\u003e {\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", \"--verify\", branch])\n        .output()\n        .context(\"Failed to check if branch exists\")?;\n\n    Ok(output.status.success())\n}\n\nfn read_spec_from_branch(spec_id: \u0026str, branch: \u0026str) -\u003e Result\u003cSpec\u003e {\n    let spec_path = format!(\".chant/specs/{}.md\", spec_id);\n\n    // Read spec content from branch\n    let output = Command::new(\"git\")\n        .args([\"show\", \u0026format!(\"{}:{}\", branch, spec_path)])\n        .output()\n        .context(format!(\"Failed to read spec from branch {}\", branch))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git show failed: {}\", stderr);\n    }\n\n    let content =\n        String::from_utf8(output.stdout).context(\"Failed to parse spec content as UTF-8\")?;\n\n    Spec::parse(spec_id, \u0026content)\n}\n\nimpl Spec {\n    /// Parse a spec from file content.\n    pub fn parse(id: \u0026str, content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let (frontmatter_str, body) = split_frontmatter(content);\n\n        let mut frontmatter: SpecFrontmatter = if let Some(fm) = frontmatter_str {\n            serde_yaml::from_str(\u0026fm).context(\"Failed to parse spec frontmatter\")?\n        } else {\n            SpecFrontmatter::default()\n        };\n\n        // Normalize model name if present\n        if let Some(model) = \u0026frontmatter.model {\n            frontmatter.model = Some(normalize_model_name(model));\n        }\n\n        // Extract title from first heading\n        let title = extract_title(body);\n\n        Ok(Self {\n            id: id.to_string(),\n            frontmatter,\n            title,\n            body: body.to_string(),\n        })\n    }\n\n    /// Load a spec from a file path.\n    pub fn load(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read spec from {}\", path.display()))?;\n\n        let id = path\n            .file_stem()\n            .and_then(|s| s.to_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid spec filename\"))?;\n\n        Self::parse(id, \u0026content)\n    }\n\n    /// Load a spec, optionally resolving from its working branch.\n    ///\n    /// If the spec is in_progress and has a branch (frontmatter.branch or chant/{id}),\n    /// attempt to read the spec content from that branch for live progress.\n    pub fn load_with_branch_resolution(spec_path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let spec = Self::load(spec_path)?;\n\n        // Only resolve for in_progress specs\n        if spec.frontmatter.status != SpecStatus::InProgress {\n            return Ok(spec);\n        }\n\n        // Try to find the working branch\n        let branch_name = spec\n            .frontmatter\n            .branch\n            .clone()\n            .unwrap_or_else(|| format!(\"chant/{}\", spec.id));\n\n        // Check if branch exists\n        if !branch_exists(\u0026branch_name)? {\n            return Ok(spec);\n        }\n\n        // Read spec from branch\n        match read_spec_from_branch(\u0026spec.id, \u0026branch_name) {\n            Ok(branch_spec) =\u003e Ok(branch_spec),\n            Err(_) =\u003e Ok(spec), // Fall back to main version\n        }\n    }\n\n    /// Save the spec to a file.\n    pub fn save(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let frontmatter = serde_yaml::to_string(\u0026self.frontmatter)?;\n        let content = format!(\"---\\n{}---\\n{}\", frontmatter, self.body);\n        fs::write(path, content)?;\n        Ok(())\n    }\n\n    /// Count unchecked checkboxes (`- [ ]`) in the Acceptance Criteria section only.\n    /// Returns the count of unchecked items in that section, skipping code fences.\n    /// Uses the LAST `## Acceptance Criteria` heading outside code fences.\n    pub fn count_unchecked_checkboxes(\u0026self) -\u003e usize {\n        let acceptance_criteria_marker = \"## Acceptance Criteria\";\n\n        // First pass: find the line number of the LAST AC heading outside code fences\n        let mut in_code_fence = false;\n        let mut last_ac_line: Option\u003cusize\u003e = None;\n\n        for (line_num, line) in self.body.lines().enumerate() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n                last_ac_line = Some(line_num);\n            }\n        }\n\n        let Some(ac_start) = last_ac_line else {\n            return 0;\n        };\n\n        // Second pass: count checkboxes from the AC section until next ## heading\n        let mut in_code_fence = false;\n        let mut in_ac_section = false;\n        let mut count = 0;\n\n        for (line_num, line) in self.body.lines().enumerate() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if in_code_fence {\n                continue;\n            }\n\n            // Start counting at the last AC heading we found\n            if line_num == ac_start {\n                in_ac_section = true;\n                continue;\n            }\n\n            // Stop at the next ## heading after our AC section\n            if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") {\n                break;\n            }\n\n            if in_ac_section \u0026\u0026 line.contains(\"- [ ]\") {\n                count += line.matches(\"- [ ]\").count();\n            }\n        }\n\n        count\n    }\n\n    /// Count total checkboxes (both checked and unchecked) in the Acceptance Criteria section.\n    /// Used to assess spec complexity.\n    pub fn count_total_checkboxes(\u0026self) -\u003e usize {\n        let acceptance_criteria_marker = \"## Acceptance Criteria\";\n\n        // First pass: find the line number of the LAST AC heading outside code fences\n        let mut in_code_fence = false;\n        let mut last_ac_line: Option\u003cusize\u003e = None;\n\n        for (line_num, line) in self.body.lines().enumerate() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n                last_ac_line = Some(line_num);\n            }\n        }\n\n        let Some(ac_start) = last_ac_line else {\n            return 0;\n        };\n\n        // Second pass: count all checkboxes from the AC section until next ## heading\n        let mut in_code_fence = false;\n        let mut in_ac_section = false;\n        let mut count = 0;\n\n        for (line_num, line) in self.body.lines().enumerate() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n                continue;\n            }\n\n            if in_code_fence {\n                continue;\n            }\n\n            if line_num == ac_start {\n                in_ac_section = true;\n                continue;\n            }\n\n            if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") {\n                break;\n            }\n\n            // Count both unchecked and checked checkboxes\n            if in_ac_section {\n                count += line.matches(\"- [ ]\").count();\n                count += line.matches(\"- [x]\").count();\n                count += line.matches(\"- [X]\").count();\n            }\n        }\n\n        count\n    }\n\n    /// Add derived fields to the spec's frontmatter.\n    /// Updates the frontmatter with the provided derived fields.\n    pub fn add_derived_fields(\u0026mut self, fields: std::collections::HashMap\u003cString, String\u003e) {\n        let mut derived_field_names = Vec::new();\n\n        for (key, value) in fields {\n            // Track which fields were derived\n            derived_field_names.push(key.clone());\n\n            // Handle specific known derived fields that map to frontmatter\n            match key.as_str() {\n                \"labels\" =\u003e {\n                    let label_vec = value.split(',').map(|s| s.trim().to_string()).collect();\n                    self.frontmatter.labels = Some(label_vec);\n                }\n                \"context\" =\u003e {\n                    let context_vec = value.split(',').map(|s| s.trim().to_string()).collect();\n                    self.frontmatter.context = Some(context_vec);\n                }\n                _ =\u003e {\n                    if self.frontmatter.context.is_none() {\n                        self.frontmatter.context = Some(vec![]);\n                    }\n                    if let Some(ref mut ctx) = self.frontmatter.context {\n                        ctx.push(format!(\"derived_{}={}\", key, value));\n                    }\n                }\n            }\n        }\n\n        // Update the derived_fields tracking\n        if !derived_field_names.is_empty() {\n            self.frontmatter.derived_fields = Some(derived_field_names);\n        }\n    }\n\n    /// Check if this spec has acceptance criteria.\n    /// Returns true if the spec body contains an \"## Acceptance Criteria\" section\n    /// with at least one checkbox item.\n    pub fn has_acceptance_criteria(\u0026self) -\u003e bool {\n        let acceptance_criteria_marker = \"## Acceptance Criteria\";\n        let mut in_ac_section = false;\n        let mut in_code_fence = false;\n\n        for line in self.body.lines() {\n            let trimmed = line.trim_start();\n\n            if trimmed.starts_with(\"```\") {\n                in_code_fence = !in_code_fence;\n            }\n\n            if !in_code_fence \u0026\u0026 trimmed.starts_with(acceptance_criteria_marker) {\n                in_ac_section = true;\n                continue;\n            }\n\n            if in_ac_section \u0026\u0026 trimmed.starts_with(\"## \") {\n                break;\n            }\n\n            if in_ac_section\n                \u0026\u0026 (trimmed.starts_with(\"- [ ] \")\n                    || trimmed.starts_with(\"- [x] \")\n                    || trimmed.starts_with(\"- [X] \"))\n            {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Check if this spec has unmet dependencies or approval requirements that would block it.\n    pub fn is_blocked(\u0026self, all_specs: \u0026[Spec]) -\u003e bool {\n        if let Some(deps) = \u0026self.frontmatter.depends_on {\n            for dep_id in deps {\n                let dep = all_specs.iter().find(|s| s.id == *dep_id);\n                match dep {\n                    Some(d) if d.frontmatter.status == SpecStatus::Completed =\u003e continue,\n                    _ =\u003e return true,\n                }\n            }\n        }\n\n        if self.frontmatter.status == SpecStatus::Pending \u0026\u0026 self.requires_approval() {\n            return true;\n        }\n\n        false\n    }\n\n    /// Check if this spec is ready to execute.\n    pub fn is_ready(\u0026self, all_specs: \u0026[Spec]) -\u003e bool {\n        use crate::spec_group::{all_prior_siblings_completed, is_member_of};\n\n        if self.frontmatter.status != SpecStatus::Pending {\n            return false;\n        }\n\n        if self.is_blocked(all_specs) {\n            return false;\n        }\n\n        if !all_prior_siblings_completed(\u0026self.id, all_specs) {\n            return false;\n        }\n\n        let members: Vec\u003c_\u003e = all_specs\n            .iter()\n            .filter(|s| is_member_of(\u0026s.id, \u0026self.id))\n            .collect();\n\n        if !members.is_empty() \u0026\u0026 self.has_acceptance_criteria() {\n            for member in members {\n                if member.frontmatter.status != SpecStatus::Completed {\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n\n    /// Get the list of dependencies that are blocking this spec.\n    pub fn get_blocking_dependencies(\n        \u0026self,\n        all_specs: \u0026[Spec],\n        specs_dir: \u0026Path,\n    ) -\u003e Vec\u003csuper::frontmatter::BlockingDependency\u003e {\n        use super::frontmatter::BlockingDependency;\n        use crate::spec_group::{extract_driver_id, extract_member_number};\n\n        let mut blockers = Vec::new();\n\n        if let Some(deps) = \u0026self.frontmatter.depends_on {\n            for dep_id in deps {\n                let spec_path = specs_dir.join(format!(\"{}.md\", dep_id));\n                let dep_spec = if spec_path.exists() {\n                    Spec::load(\u0026spec_path).ok()\n                } else {\n                    None\n                };\n\n                let dep_spec =\n                    dep_spec.or_else(|| all_specs.iter().find(|s| s.id == *dep_id).cloned());\n\n                if let Some(spec) = dep_spec {\n                    // Only add if not completed\n                    if spec.frontmatter.status != SpecStatus::Completed {\n                        blockers.push(BlockingDependency {\n                            spec_id: spec.id.clone(),\n                            title: spec.title.clone(),\n                            status: spec.frontmatter.status.clone(),\n                            completed_at: spec.frontmatter.completed_at.clone(),\n                            is_sibling: false,\n                        });\n                    }\n                } else {\n                    blockers.push(BlockingDependency {\n                        spec_id: dep_id.clone(),\n                        title: None,\n                        status: SpecStatus::Pending,\n                        completed_at: None,\n                        is_sibling: false,\n                    });\n                }\n            }\n        }\n\n        if let Some(driver_id) = extract_driver_id(\u0026self.id) {\n            if let Some(member_num) = extract_member_number(\u0026self.id) {\n                for i in 1..member_num {\n                    let sibling_id = format!(\"{}.{}\", driver_id, i);\n                    let spec_path = specs_dir.join(format!(\"{}.md\", sibling_id));\n                    let sibling_spec = if spec_path.exists() {\n                        Spec::load(\u0026spec_path).ok()\n                    } else {\n                        None\n                    };\n\n                    let sibling_spec = sibling_spec\n                        .or_else(|| all_specs.iter().find(|s| s.id == sibling_id).cloned());\n\n                    if let Some(spec) = sibling_spec {\n                        if spec.frontmatter.status != SpecStatus::Completed {\n                            blockers.push(BlockingDependency {\n                                spec_id: spec.id.clone(),\n                                title: spec.title.clone(),\n                                status: spec.frontmatter.status.clone(),\n                                completed_at: spec.frontmatter.completed_at.clone(),\n                                is_sibling: true,\n                            });\n                        }\n                    } else {\n                        blockers.push(BlockingDependency {\n                            spec_id: sibling_id,\n                            title: None,\n                            status: SpecStatus::Pending,\n                            completed_at: None,\n                            is_sibling: true,\n                        });\n                    }\n                }\n            }\n        }\n\n        blockers\n    }\n\n    /// Check if the spec's frontmatter contains a specific field.\n    pub fn has_frontmatter_field(\u0026self, field: \u0026str) -\u003e bool {\n        match field {\n            \"type\" =\u003e true,\n            \"status\" =\u003e true,\n            \"depends_on\" =\u003e self.frontmatter.depends_on.is_some(),\n            \"labels\" =\u003e self.frontmatter.labels.is_some(),\n            \"target_files\" =\u003e self.frontmatter.target_files.is_some(),\n            \"context\" =\u003e self.frontmatter.context.is_some(),\n            \"prompt\" =\u003e self.frontmatter.prompt.is_some(),\n            \"branch\" =\u003e self.frontmatter.branch.is_some(),\n            \"commits\" =\u003e self.frontmatter.commits.is_some(),\n            \"completed_at\" =\u003e self.frontmatter.completed_at.is_some(),\n            \"model\" =\u003e self.frontmatter.model.is_some(),\n            \"tracks\" =\u003e self.frontmatter.tracks.is_some(),\n            \"informed_by\" =\u003e self.frontmatter.informed_by.is_some(),\n            \"origin\" =\u003e self.frontmatter.origin.is_some(),\n            \"schedule\" =\u003e self.frontmatter.schedule.is_some(),\n            \"source_branch\" =\u003e self.frontmatter.source_branch.is_some(),\n            \"target_branch\" =\u003e self.frontmatter.target_branch.is_some(),\n            \"conflicting_files\" =\u003e self.frontmatter.conflicting_files.is_some(),\n            \"blocked_specs\" =\u003e self.frontmatter.blocked_specs.is_some(),\n            \"original_spec\" =\u003e self.frontmatter.original_spec.is_some(),\n            \"last_verified\" =\u003e self.frontmatter.last_verified.is_some(),\n            \"verification_status\" =\u003e self.frontmatter.verification_status.is_some(),\n            \"verification_failures\" =\u003e self.frontmatter.verification_failures.is_some(),\n            \"replayed_at\" =\u003e self.frontmatter.replayed_at.is_some(),\n            \"replay_count\" =\u003e self.frontmatter.replay_count.is_some(),\n            \"original_completed_at\" =\u003e self.frontmatter.original_completed_at.is_some(),\n            \"approval\" =\u003e self.frontmatter.approval.is_some(),\n            \"members\" =\u003e self.frontmatter.members.is_some(),\n            \"output_schema\" =\u003e self.frontmatter.output_schema.is_some(),\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if this spec requires approval before work can begin.\n    pub fn requires_approval(\u0026self) -\u003e bool {\n        use super::frontmatter::ApprovalStatus;\n\n        if let Some(ref approval) = self.frontmatter.approval {\n            approval.required \u0026\u0026 approval.status != ApprovalStatus::Approved\n        } else {\n            false\n        }\n    }\n\n    /// Check if this spec has been approved.\n    pub fn is_approved(\u0026self) -\u003e bool {\n        use super::frontmatter::ApprovalStatus;\n\n        if let Some(ref approval) = self.frontmatter.approval {\n            approval.status == ApprovalStatus::Approved\n        } else {\n            true\n        }\n    }\n\n    /// Check if this spec has been rejected.\n    pub fn is_rejected(\u0026self) -\u003e bool {\n        use super::frontmatter::ApprovalStatus;\n\n        if let Some(ref approval) = self.frontmatter.approval {\n            approval.status == ApprovalStatus::Rejected\n        } else {\n            false\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":22}},{"line":21,"address":[],"length":0,"stats":{"Line":66}},{"line":22,"address":[],"length":0,"stats":{"Line":22}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":22}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":38}},{"line":38,"address":[],"length":0,"stats":{"Line":896}},{"line":39,"address":[],"length":0,"stats":{"Line":2688}},{"line":41,"address":[],"length":0,"stats":{"Line":896}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":45,"address":[],"length":0,"stats":{"Line":1772}},{"line":46,"address":[],"length":0,"stats":{"Line":1772}},{"line":47,"address":[],"length":0,"stats":{"Line":2658}},{"line":48,"address":[],"length":0,"stats":{"Line":2658}},{"line":49,"address":[],"length":0,"stats":{"Line":886}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":451}},{"line":56,"address":[],"length":0,"stats":{"Line":1353}},{"line":57,"address":[],"length":0,"stats":{"Line":1353}},{"line":58,"address":[],"length":0,"stats":{"Line":902}},{"line":59,"address":[],"length":0,"stats":{"Line":451}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":34}},{"line":66,"address":[],"length":0,"stats":{"Line":102}},{"line":67,"address":[],"length":0,"stats":{"Line":68}},{"line":71,"address":[],"length":0,"stats":{"Line":34}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":24}},{"line":78,"address":[],"length":0,"stats":{"Line":36}},{"line":79,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":24}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":89,"address":[],"length":0,"stats":{"Line":30}},{"line":91,"address":[],"length":0,"stats":{"Line":30}},{"line":96,"address":[],"length":0,"stats":{"Line":451}},{"line":97,"address":[],"length":0,"stats":{"Line":1353}},{"line":99,"address":[],"length":0,"stats":{"Line":1804}},{"line":100,"address":[],"length":0,"stats":{"Line":1353}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":495}},{"line":107,"address":[],"length":0,"stats":{"Line":44}},{"line":111,"address":[],"length":0,"stats":{"Line":1353}},{"line":113,"address":[],"length":0,"stats":{"Line":451}},{"line":114,"address":[],"length":0,"stats":{"Line":1353}},{"line":115,"address":[],"length":0,"stats":{"Line":902}},{"line":116,"address":[],"length":0,"stats":{"Line":902}},{"line":117,"address":[],"length":0,"stats":{"Line":451}},{"line":122,"address":[],"length":0,"stats":{"Line":405}},{"line":123,"address":[],"length":0,"stats":{"Line":1215}},{"line":124,"address":[],"length":0,"stats":{"Line":405}},{"line":126,"address":[],"length":0,"stats":{"Line":810}},{"line":128,"address":[],"length":0,"stats":{"Line":1215}},{"line":129,"address":[],"length":0,"stats":{"Line":405}},{"line":131,"address":[],"length":0,"stats":{"Line":1215}},{"line":138,"address":[],"length":0,"stats":{"Line":318}},{"line":139,"address":[],"length":0,"stats":{"Line":954}},{"line":142,"address":[],"length":0,"stats":{"Line":318}},{"line":143,"address":[],"length":0,"stats":{"Line":284}},{"line":147,"address":[],"length":0,"stats":{"Line":68}},{"line":148,"address":[],"length":0,"stats":{"Line":34}},{"line":149,"address":[],"length":0,"stats":{"Line":34}},{"line":151,"address":[],"length":0,"stats":{"Line":60}},{"line":154,"address":[],"length":0,"stats":{"Line":68}},{"line":155,"address":[],"length":0,"stats":{"Line":22}},{"line":159,"address":[],"length":0,"stats":{"Line":24}},{"line":160,"address":[],"length":0,"stats":{"Line":20}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":108}},{"line":167,"address":[],"length":0,"stats":{"Line":324}},{"line":168,"address":[],"length":0,"stats":{"Line":216}},{"line":169,"address":[],"length":0,"stats":{"Line":324}},{"line":170,"address":[],"length":0,"stats":{"Line":108}},{"line":176,"address":[],"length":0,"stats":{"Line":17}},{"line":177,"address":[],"length":0,"stats":{"Line":34}},{"line":180,"address":[],"length":0,"stats":{"Line":34}},{"line":181,"address":[],"length":0,"stats":{"Line":51}},{"line":183,"address":[],"length":0,"stats":{"Line":244}},{"line":184,"address":[],"length":0,"stats":{"Line":315}},{"line":186,"address":[],"length":0,"stats":{"Line":210}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":437}},{"line":192,"address":[],"length":0,"stats":{"Line":17}},{"line":196,"address":[],"length":0,"stats":{"Line":34}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":34}},{"line":202,"address":[],"length":0,"stats":{"Line":34}},{"line":203,"address":[],"length":0,"stats":{"Line":34}},{"line":205,"address":[],"length":0,"stats":{"Line":244}},{"line":206,"address":[],"length":0,"stats":{"Line":315}},{"line":208,"address":[],"length":0,"stats":{"Line":210}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":105}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":105}},{"line":219,"address":[],"length":0,"stats":{"Line":17}},{"line":220,"address":[],"length":0,"stats":{"Line":17}},{"line":224,"address":[],"length":0,"stats":{"Line":164}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":175}},{"line":229,"address":[],"length":0,"stats":{"Line":22}},{"line":233,"address":[],"length":0,"stats":{"Line":17}},{"line":238,"address":[],"length":0,"stats":{"Line":105}},{"line":239,"address":[],"length":0,"stats":{"Line":210}},{"line":242,"address":[],"length":0,"stats":{"Line":210}},{"line":243,"address":[],"length":0,"stats":{"Line":315}},{"line":245,"address":[],"length":0,"stats":{"Line":1032}},{"line":246,"address":[],"length":0,"stats":{"Line":1233}},{"line":248,"address":[],"length":0,"stats":{"Line":822}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":1675}},{"line":254,"address":[],"length":0,"stats":{"Line":31}},{"line":258,"address":[],"length":0,"stats":{"Line":136}},{"line":259,"address":[],"length":0,"stats":{"Line":74}},{"line":263,"address":[],"length":0,"stats":{"Line":62}},{"line":264,"address":[],"length":0,"stats":{"Line":62}},{"line":265,"address":[],"length":0,"stats":{"Line":62}},{"line":267,"address":[],"length":0,"stats":{"Line":622}},{"line":268,"address":[],"length":0,"stats":{"Line":840}},{"line":270,"address":[],"length":0,"stats":{"Line":560}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":280}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":280}},{"line":280,"address":[],"length":0,"stats":{"Line":31}},{"line":281,"address":[],"length":0,"stats":{"Line":31}},{"line":284,"address":[],"length":0,"stats":{"Line":625}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":437}},{"line":290,"address":[],"length":0,"stats":{"Line":564}},{"line":291,"address":[],"length":0,"stats":{"Line":564}},{"line":292,"address":[],"length":0,"stats":{"Line":376}},{"line":296,"address":[],"length":0,"stats":{"Line":31}},{"line":301,"address":[],"length":0,"stats":{"Line":10}},{"line":302,"address":[],"length":0,"stats":{"Line":20}},{"line":304,"address":[],"length":0,"stats":{"Line":34}},{"line":306,"address":[],"length":0,"stats":{"Line":48}},{"line":309,"address":[],"length":0,"stats":{"Line":12}},{"line":310,"address":[],"length":0,"stats":{"Line":12}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":12}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":34}},{"line":320,"address":[],"length":0,"stats":{"Line":10}},{"line":322,"address":[],"length":0,"stats":{"Line":36}},{"line":323,"address":[],"length":0,"stats":{"Line":24}},{"line":330,"address":[],"length":0,"stats":{"Line":20}},{"line":331,"address":[],"length":0,"stats":{"Line":10}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":10}},{"line":344,"address":[],"length":0,"stats":{"Line":24}},{"line":346,"address":[],"length":0,"stats":{"Line":16}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":32}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":11}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":7}},{"line":360,"address":[],"length":0,"stats":{"Line":4}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":239}},{"line":373,"address":[],"length":0,"stats":{"Line":343}},{"line":374,"address":[],"length":0,"stats":{"Line":214}},{"line":375,"address":[],"length":0,"stats":{"Line":814}},{"line":376,"address":[],"length":0,"stats":{"Line":104}},{"line":377,"address":[],"length":0,"stats":{"Line":224}},{"line":378,"address":[],"length":0,"stats":{"Line":70}},{"line":383,"address":[],"length":0,"stats":{"Line":507}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":167}},{"line":391,"address":[],"length":0,"stats":{"Line":40}},{"line":394,"address":[],"length":0,"stats":{"Line":40}},{"line":395,"address":[],"length":0,"stats":{"Line":19}},{"line":398,"address":[],"length":0,"stats":{"Line":63}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":42}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":63}},{"line":408,"address":[],"length":0,"stats":{"Line":141}},{"line":411,"address":[],"length":0,"stats":{"Line":21}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":21}},{"line":423,"address":[],"length":0,"stats":{"Line":8}},{"line":431,"address":[],"length":0,"stats":{"Line":16}},{"line":433,"address":[],"length":0,"stats":{"Line":16}},{"line":434,"address":[],"length":0,"stats":{"Line":18}},{"line":435,"address":[],"length":0,"stats":{"Line":40}},{"line":436,"address":[],"length":0,"stats":{"Line":20}},{"line":437,"address":[],"length":0,"stats":{"Line":30}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":10}},{"line":443,"address":[],"length":0,"stats":{"Line":20}},{"line":445,"address":[],"length":0,"stats":{"Line":20}},{"line":447,"address":[],"length":0,"stats":{"Line":20}},{"line":448,"address":[],"length":0,"stats":{"Line":30}},{"line":449,"address":[],"length":0,"stats":{"Line":30}},{"line":450,"address":[],"length":0,"stats":{"Line":30}},{"line":451,"address":[],"length":0,"stats":{"Line":30}},{"line":452,"address":[],"length":0,"stats":{"Line":10}},{"line":453,"address":[],"length":0,"stats":{"Line":10}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":8}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":8}},{"line":509,"address":[],"length":0,"stats":{"Line":14}},{"line":510,"address":[],"length":0,"stats":{"Line":14}},{"line":511,"address":[],"length":0,"stats":{"Line":14}},{"line":512,"address":[],"length":0,"stats":{"Line":15}},{"line":513,"address":[],"length":0,"stats":{"Line":13}},{"line":514,"address":[],"length":0,"stats":{"Line":23}},{"line":515,"address":[],"length":0,"stats":{"Line":8}},{"line":516,"address":[],"length":0,"stats":{"Line":10}},{"line":517,"address":[],"length":0,"stats":{"Line":7}},{"line":518,"address":[],"length":0,"stats":{"Line":15}},{"line":519,"address":[],"length":0,"stats":{"Line":3}},{"line":520,"address":[],"length":0,"stats":{"Line":3}},{"line":521,"address":[],"length":0,"stats":{"Line":9}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":198}},{"line":548,"address":[],"length":0,"stats":{"Line":209}},{"line":549,"address":[],"length":0,"stats":{"Line":22}},{"line":551,"address":[],"length":0,"stats":{"Line":187}},{"line":556,"address":[],"length":0,"stats":{"Line":3}},{"line":559,"address":[],"length":0,"stats":{"Line":6}},{"line":560,"address":[],"length":0,"stats":{"Line":3}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":3}},{"line":570,"address":[],"length":0,"stats":{"Line":6}},{"line":571,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":0}}],"covered":216,"coverable":295},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec.rs"],"content":"//! Spec parsing, frontmatter handling, and spec lifecycle management.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: concepts/specs.md, reference/schema.md\n//! - ignore: false\n\n// Submodules\nmod frontmatter;\nmod lifecycle;\nmod parse;\n\n// Re-export types from submodules\npub use frontmatter::{Approval, ApprovalStatus, BlockingDependency, SpecFrontmatter, SpecStatus};\npub use lifecycle::{\n    apply_blocked_status_with_repos, is_completed, is_failed, load_all_specs,\n    load_all_specs_with_options, resolve_spec,\n};\npub use parse::{split_frontmatter, Spec};\n\n// Re-export group/driver functions from spec_group for backward compatibility\npub use crate::spec_group::{\n    all_members_completed, all_prior_siblings_completed, auto_complete_driver_if_ready,\n    extract_driver_id, extract_member_number, get_incomplete_members, get_members, is_member_of,\n    mark_driver_in_progress,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn assert_verification_fields(\n        spec: \u0026Spec,\n        last_verified: Option\u003c\u0026str\u003e,\n        verification_status: Option\u003c\u0026str\u003e,\n        verification_failures: Option\u003cVec\u003c\u0026str\u003e\u003e,\n    ) {\n        assert_eq!(\n            spec.frontmatter.last_verified,\n            last_verified.map(String::from)\n        );\n        assert_eq!(\n            spec.frontmatter.verification_status,\n            verification_status.map(String::from)\n        );\n        assert_eq!(\n            spec.frontmatter.verification_failures,\n            verification_failures.map(|v| v.iter().map(|s| s.to_string()).collect())\n        );\n    }\n\n    fn assert_replay_fields(\n        spec: \u0026Spec,\n        replayed_at: Option\u003c\u0026str\u003e,\n        replay_count: Option\u003cu32\u003e,\n        original_completed_at: Option\u003c\u0026str\u003e,\n    ) {\n        assert_eq!(spec.frontmatter.replayed_at, replayed_at.map(String::from));\n        assert_eq!(spec.frontmatter.replay_count, replay_count);\n        assert_eq!(\n            spec.frontmatter.original_completed_at,\n            original_completed_at.map(String::from)\n        );\n    }\n\n    #[test]\n    fn test_parse_spec() {\n        let content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Fix the bug\n\nDescription here.\n\"#;\n        let spec = Spec::parse(\"2026-01-22-001-x7m\", content).unwrap();\n        assert_eq!(spec.id, \"2026-01-22-001-x7m\");\n        assert_eq!(spec.frontmatter.status, SpecStatus::Pending);\n        assert_eq!(spec.title, Some(\"Fix the bug\".to_string()));\n    }\n\n    #[test]\n    fn test_spec_is_ready() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(spec.is_ready(\u0026[]));\n\n        let spec2 = Spec::parse(\n            \"002\",\n            r#\"---\nstatus: in_progress\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(!spec2.is_ready(\u0026[]));\n    }\n\n    #[test]\n    fn test_spec_has_acceptance_criteria() {\n        let spec_with_ac = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\n---\n# Test\n\n## Acceptance Criteria\n\n- [ ] Thing 1\n- [ ] Thing 2\n\"#,\n        )\n        .unwrap();\n        assert!(spec_with_ac.has_acceptance_criteria());\n\n        let spec_without_ac = Spec::parse(\n            \"002\",\n            r#\"---\nstatus: pending\n---\n# Test\n\nDescription\n\"#,\n        )\n        .unwrap();\n        assert!(!spec_without_ac.has_acceptance_criteria());\n    }\n\n    #[test]\n    fn test_count_checkboxes() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\n---\n# Test\n\n## Acceptance Criteria\n\n- [ ] Thing 1\n- [x] Thing 2\n- [ ] Thing 3\n\"#,\n        )\n        .unwrap();\n        assert_eq!(spec.count_unchecked_checkboxes(), 2);\n        assert_eq!(spec.count_total_checkboxes(), 3);\n    }\n\n    #[test]\n    fn test_split_frontmatter() {\n        let content = r#\"---\ntype: code\nstatus: pending\n---\n\n# Title\n\nBody\"#;\n        let (fm, body) = split_frontmatter(content);\n        assert!(fm.is_some());\n        assert!(body.contains(\"# Title\"));\n    }\n\n    #[test]\n    fn test_split_frontmatter_no_frontmatter() {\n        let content = \"# Title\\n\\nBody\";\n        let (fm, body) = split_frontmatter(content);\n        assert!(fm.is_none());\n        assert_eq!(body, content);\n    }\n\n    #[test]\n    fn test_approval_required() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\napproval:\n  required: true\n  status: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(spec.requires_approval());\n        assert!(!spec.is_approved());\n        assert!(!spec.is_rejected());\n    }\n\n    #[test]\n    fn test_approval_granted() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\napproval:\n  required: true\n  status: approved\n  by: \"user@example.com\"\n  at: \"2026-01-25T12:00:00Z\"\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(!spec.requires_approval());\n        assert!(spec.is_approved());\n        assert!(!spec.is_rejected());\n    }\n\n    #[test]\n    fn test_approval_rejected() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\napproval:\n  required: true\n  status: rejected\n  by: \"user@example.com\"\n  at: \"2026-01-25T12:00:00Z\"\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(spec.requires_approval());\n        assert!(!spec.is_approved());\n        assert!(spec.is_rejected());\n    }\n\n    #[test]\n    fn test_verification_fields() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: completed\nlast_verified: \"2026-01-25T12:00:00Z\"\nverification_status: \"passed\"\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert_verification_fields(\u0026spec, Some(\"2026-01-25T12:00:00Z\"), Some(\"passed\"), None);\n    }\n\n    #[test]\n    fn test_replay_fields() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\nreplayed_at: \"2026-01-25T14:00:00Z\"\nreplay_count: 2\noriginal_completed_at: \"2026-01-24T12:00:00Z\"\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert_replay_fields(\n            \u0026spec,\n            Some(\"2026-01-25T14:00:00Z\"),\n            Some(2),\n            Some(\"2026-01-24T12:00:00Z\"),\n        );\n    }\n\n    #[test]\n    fn test_has_frontmatter_field() {\n        let spec = Spec::parse(\n            \"001\",\n            r#\"---\nstatus: pending\nmodel: \"sonnet\"\nlabels: [\"bug\", \"urgent\"]\n---\n# Test\n\"#,\n        )\n        .unwrap();\n        assert!(spec.has_frontmatter_field(\"status\"));\n        assert!(spec.has_frontmatter_field(\"model\"));\n        assert!(spec.has_frontmatter_field(\"labels\"));\n        assert!(!spec.has_frontmatter_field(\"context\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec_group.rs"],"content":"//! Spec group/driver orchestration logic.\n//!\n//! This module manages spec membership and group completion tracking for driver specs.\n//! Driver specs can have member specs identified by numeric suffixes (e.g., `.1`, `.2`).\n//! This module handles relationships between drivers and their members.\n\nuse crate::spec::{Spec, SpecStatus};\nuse anyhow::Result;\nuse std::path::Path;\n\n/// Check if `member_id` is a group member of `driver_id`.\n///\n/// Member IDs have format: `DRIVER_ID.N` or `DRIVER_ID.N.M` where N and M are numbers.\n/// For example: `2026-01-25-00y-abc.1` is a member of `2026-01-25-00y-abc`.\n///\n/// # Examples\n///\n/// ```ignore\n/// assert!(is_member_of(\"2026-01-25-00y-abc.1\", \"2026-01-25-00y-abc\"));\n/// assert!(is_member_of(\"2026-01-25-00y-abc.2.1\", \"2026-01-25-00y-abc\"));\n/// assert!(!is_member_of(\"2026-01-25-00y-abc\", \"2026-01-25-00y-abc\")); // Not a member\n/// assert!(!is_member_of(\"2026-01-25-00x-xyz\", \"2026-01-25-00y-abc\")); // Different driver\n/// ```\npub fn is_member_of(member_id: \u0026str, driver_id: \u0026str) -\u003e bool {\n    // Member IDs have format: DRIVER_ID.N or DRIVER_ID.N.M\n    if !member_id.starts_with(driver_id) {\n        return false;\n    }\n\n    let suffix = \u0026member_id[driver_id.len()..];\n    suffix.starts_with('.') \u0026\u0026 suffix.len() \u003e 1\n}\n\n/// Get all member specs of a driver spec.\n///\n/// Returns a vector of references to all spec members of the given driver.\n/// If the driver has no members, returns an empty vector.\n///\n/// # Arguments\n///\n/// * `driver_id` - The ID of the driver spec\n/// * `specs` - All available specs to search\n///\n/// # Examples\n///\n/// ```ignore\n/// let members = get_members(\"2026-01-25-00y-abc\", \u0026specs);\n/// ```\npub fn get_members\u003c'a\u003e(driver_id: \u0026str, specs: \u0026'a [Spec]) -\u003e Vec\u003c\u0026'a Spec\u003e {\n    specs\n        .iter()\n        .filter(|s| is_member_of(\u0026s.id, driver_id))\n        .collect()\n}\n\n/// Check if all members of a driver spec are completed.\n///\n/// Returns true if:\n/// - The driver has no members, or\n/// - All members have status `Completed`\n///\n/// # Arguments\n///\n/// * `driver_id` - The ID of the driver spec\n/// * `specs` - All available specs\n///\n/// # Examples\n///\n/// ```ignore\n/// if all_members_completed(\"2026-01-25-00y-abc\", \u0026specs) {\n///     println!(\"All members are done!\");\n/// }\n/// ```\npub fn all_members_completed(driver_id: \u0026str, specs: \u0026[Spec]) -\u003e bool {\n    let members = get_members(driver_id, specs);\n    if members.is_empty() {\n        return true; // No members, so all are \"completed\"\n    }\n    members\n        .iter()\n        .all(|m| m.frontmatter.status == SpecStatus::Completed)\n}\n\n/// Get list of incomplete member spec IDs for a driver spec.\n///\n/// Returns a vector of IDs for all members that are not in `Completed` status.\n/// Returns an empty vector if the spec is not a driver or has no incomplete members.\n///\n/// # Arguments\n///\n/// * `driver_id` - The ID of the driver spec\n/// * `all_specs` - All available specs\n///\n/// # Examples\n///\n/// ```ignore\n/// let incomplete = get_incomplete_members(\"2026-01-25-00y-abc\", \u0026specs);\n/// for member_id in incomplete {\n///     println!(\"Incomplete member: {}\", member_id);\n/// }\n/// ```\npub fn get_incomplete_members(driver_id: \u0026str, all_specs: \u0026[Spec]) -\u003e Vec\u003cString\u003e {\n    get_members(driver_id, all_specs)\n        .into_iter()\n        .filter(|m| m.frontmatter.status != SpecStatus::Completed)\n        .map(|m| m.id.clone())\n        .collect()\n}\n\n/// Extract the driver ID from a member ID.\n///\n/// For member specs with numeric suffixes, returns the base driver ID.\n/// For non-member specs, returns None.\n///\n/// # Examples\n///\n/// ```ignore\n/// assert_eq!(extract_driver_id(\"2026-01-25-00y-abc.1\"), Some(\"2026-01-25-00y-abc\".to_string()));\n/// assert_eq!(extract_driver_id(\"2026-01-25-00y-abc.3.2\"), Some(\"2026-01-25-00y-abc\".to_string()));\n/// assert_eq!(extract_driver_id(\"2026-01-25-00y-abc\"), None);\n/// assert_eq!(extract_driver_id(\"2026-01-25-00y-abc.abc\"), None);\n/// ```\npub fn extract_driver_id(member_id: \u0026str) -\u003e Option\u003cString\u003e {\n    // Member IDs have format: DRIVER_ID.N or DRIVER_ID.N.M\n    if let Some(pos) = member_id.find('.') {\n        let (prefix, suffix) = member_id.split_at(pos);\n        // Check that what follows the dot is numeric (at least up to the first non-digit)\n        if suffix.len() \u003e 1\n            \u0026\u0026 suffix[1..]\n                .chars()\n                .next()\n                .is_some_and(|c| c.is_ascii_digit())\n        {\n            return Some(prefix.to_string());\n        }\n    }\n    None\n}\n\n/// Extract the member number from a member ID.\n///\n/// For member specs with format `DRIVER_ID.N` or `DRIVER_ID.N.M`, extracts `N`.\n/// For non-member specs, returns None.\n///\n/// # Examples\n///\n/// ```ignore\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc.1\"), Some(1));\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc.3\"), Some(3));\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc.10\"), Some(10));\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc.3.2\"), Some(3));\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc\"), None);\n/// assert_eq!(extract_member_number(\"2026-01-25-00y-abc.abc\"), None);\n/// ```\npub fn extract_member_number(member_id: \u0026str) -\u003e Option\u003cu32\u003e {\n    if let Some(pos) = member_id.find('.') {\n        let suffix = \u0026member_id[pos + 1..];\n        // Extract just the first numeric part after the dot\n        let num_str: String = suffix.chars().take_while(|c| c.is_ascii_digit()).collect();\n        if !num_str.is_empty() {\n            return num_str.parse::\u003cu32\u003e().ok();\n        }\n    }\n    None\n}\n\n/// Compare two spec IDs with numeric sorting for member specs and base36 sequences.\n///\n/// This function provides a natural sort order where member spec numbers and base36\n/// sequence portions are compared numerically rather than lexicographically. This ensures:\n/// - Specs like `2026-01-25-00y-abc.10` sort after `2026-01-25-00y-abc.2`\n/// - Specs like `2026-01-25-010-xxx` sort after `2026-01-25-00z-yyy`\n///\n/// # Sorting behavior\n///\n/// - For non-member specs, parses date/sequence/suffix and compares sequence numerically\n/// - For member specs (with `.N` suffix), compares the base ID using date/sequence/suffix\n///   parsing first, then compares member numbers numerically\n/// - Mixed member/non-member specs: non-members sort before members with the same base\n///\n/// # Examples\n///\n/// ```ignore\n/// use std::cmp::Ordering;\n/// assert_eq!(compare_spec_ids(\"2026-01-25-00y-abc.2\", \"2026-01-25-00y-abc.10\"), Ordering::Less);\n/// assert_eq!(compare_spec_ids(\"2026-01-25-00y-abc.10\", \"2026-01-25-00y-abc.2\"), Ordering::Greater);\n/// assert_eq!(compare_spec_ids(\"2026-01-25-00y-abc\", \"2026-01-25-00y-def\"), Ordering::Less);\n/// assert_eq!(compare_spec_ids(\"2026-01-25-00y-abc\", \"2026-01-25-00y-abc.1\"), Ordering::Less);\n/// assert_eq!(compare_spec_ids(\"2026-01-25-010-xxx\", \"2026-01-25-00z-yyy\"), Ordering::Greater);\n/// ```\npub fn compare_spec_ids(a: \u0026str, b: \u0026str) -\u003e std::cmp::Ordering {\n    use std::cmp::Ordering;\n\n    // Try to extract driver IDs and member numbers\n    let a_driver = extract_driver_id(a);\n    let b_driver = extract_driver_id(b);\n\n    match (a_driver, b_driver) {\n        (Some(a_base), Some(b_base)) =\u003e {\n            // Both are member specs\n            // First compare the base IDs with sequence parsing\n            match compare_base_ids(\u0026a_base, \u0026b_base) {\n                Ordering::Equal =\u003e {\n                    // Same base ID, compare member numbers numerically\n                    let a_num = extract_member_number(a).unwrap_or(u32::MAX);\n                    let b_num = extract_member_number(b).unwrap_or(u32::MAX);\n                    a_num.cmp(\u0026b_num)\n                }\n                other =\u003e other,\n            }\n        }\n        (Some(a_base), None) =\u003e {\n            // a is a member, b is not\n            // Compare a's base with b using sequence parsing\n            match compare_base_ids(\u0026a_base, b) {\n                Ordering::Equal =\u003e {\n                    // b is the driver of a, so b comes first\n                    Ordering::Greater\n                }\n                other =\u003e other,\n            }\n        }\n        (None, Some(b_base)) =\u003e {\n            // a is not a member, b is\n            // Compare a with b's base using sequence parsing\n            match compare_base_ids(a, \u0026b_base) {\n                Ordering::Equal =\u003e {\n                    // a is the driver of b, so a comes first\n                    Ordering::Less\n                }\n                other =\u003e other,\n            }\n        }\n        (None, None) =\u003e {\n            // Neither are member specs, use sequence parsing\n            compare_base_ids(a, b)\n        }\n    }\n}\n\n/// Compare two base spec IDs by parsing date, sequence, and suffix.\n///\n/// Spec IDs have format: YYYY-MM-DD-SSS-XXX where:\n/// - YYYY-MM-DD is the date (compared lexicographically)\n/// - SSS is a base36 sequence (compared numerically)\n/// - XXX is a random base36 suffix (compared lexicographically as tiebreaker)\nfn compare_base_ids(a: \u0026str, b: \u0026str) -\u003e std::cmp::Ordering {\n    use std::cmp::Ordering;\n\n    // Parse both IDs into (date, sequence, suffix)\n    let a_parts = parse_spec_id_parts(a);\n    let b_parts = parse_spec_id_parts(b);\n\n    match (a_parts, b_parts) {\n        (Some((a_date, a_seq, a_suffix)), Some((b_date, b_seq, b_suffix))) =\u003e {\n            // Compare date lexicographically\n            match a_date.cmp(b_date) {\n                Ordering::Equal =\u003e {\n                    // Same date, compare sequence numerically\n                    match a_seq.cmp(\u0026b_seq) {\n                        Ordering::Equal =\u003e {\n                            // Same sequence, compare suffix lexicographically\n                            a_suffix.cmp(b_suffix)\n                        }\n                        other =\u003e other,\n                    }\n                }\n                other =\u003e other,\n            }\n        }\n        // If parsing fails, fall back to lexicographic comparison\n        _ =\u003e a.cmp(b),\n    }\n}\n\n/// Parse a spec ID into (date, sequence_number, suffix).\n/// Returns None if the ID doesn't match the expected format.\nfn parse_spec_id_parts(id: \u0026str) -\u003e Option\u003c(\u0026str, u32, \u0026str)\u003e {\n    let parts: Vec\u003c\u0026str\u003e = id.split('-').collect();\n\n    // Expected format: YYYY-MM-DD-SSS-XXX (5 parts minimum)\n    if parts.len() \u003c 5 {\n        return None;\n    }\n\n    // Date is parts[0..3] joined: YYYY-MM-DD\n    let date = \u0026id[..10]; // \"YYYY-MM-DD\" is always 10 chars\n\n    // Sequence is parts[3], parse from base36\n    let seq = crate::id::parse_base36(parts[3])?;\n\n    // Suffix is parts[4]\n    let suffix = parts[4];\n\n    Some((date, seq, suffix))\n}\n\n/// Check if all prior siblings of a member spec are completed.\n///\n/// For a member spec like `DRIVER_ID.3`, checks that `DRIVER_ID.1` and `DRIVER_ID.2`\n/// are both in `Completed` status. For `DRIVER_ID.1`, returns true (no prior siblings).\n/// For non-member specs, returns true (sibling check doesn't apply).\n///\n/// # Arguments\n///\n/// * `member_id` - The ID of the member spec to check\n/// * `all_specs` - All available specs\n///\n/// # Examples\n///\n/// ```ignore\n/// // For a spec DRIVER_ID.3, checks that DRIVER_ID.1 and DRIVER_ID.2 are completed\n/// assert!(all_prior_siblings_completed(\"2026-01-25-00y-abc.3\", \u0026specs));\n/// ```\npub fn all_prior_siblings_completed(member_id: \u0026str, all_specs: \u0026[Spec]) -\u003e bool {\n    // Find the current member spec\n    if let Some(member_spec) = all_specs.iter().find(|s| s.id == member_id) {\n        // If member has explicit depends_on, skip sequential check (use DAG dependencies instead)\n        if member_spec.frontmatter.depends_on.is_some() {\n            return true;\n        }\n    }\n\n    // Fall back to sequential ordering if no explicit dependencies\n    if let Some(driver_id) = extract_driver_id(member_id) {\n        if let Some(member_num) = extract_member_number(member_id) {\n            // Check all specs with numbers less than member_num\n            for i in 1..member_num {\n                let sibling_id = format!(\"{}.{}\", driver_id, i);\n                let sibling = all_specs.iter().find(|s| s.id == sibling_id);\n                if let Some(s) = sibling {\n                    if s.frontmatter.status != SpecStatus::Completed {\n                        return false;\n                    }\n                } else {\n                    // Sibling doesn't exist, so it's not completed\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // Not a member spec, so this check doesn't apply\n    true\n}\n\n/// Mark the driver spec as in_progress if the current spec is a member.\n///\n/// When a member spec begins execution, its driver spec should transition from\n/// `Pending` to `InProgress` (if not already). This function handles that transition.\n///\n/// # Arguments\n///\n/// * `specs_dir` - Path to the specs directory\n/// * `member_id` - The ID of the member spec that is starting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful or the driver doesn't exist.\n/// Returns `Err` if file I/O fails.\n///\n/// # Examples\n///\n/// ```ignore\n/// mark_driver_in_progress(\u0026specs_dir, \"2026-01-25-00y-abc.1\")?;\n/// ```\npub fn mark_driver_in_progress(specs_dir: \u0026Path, member_id: \u0026str) -\u003e Result\u003c()\u003e {\n    if let Some(driver_id) = extract_driver_id(member_id) {\n        // Try to load the driver spec\n        let driver_path = specs_dir.join(format!(\"{}.md\", driver_id));\n        if driver_path.exists() {\n            let mut driver = Spec::load(\u0026driver_path)?;\n            if driver.frontmatter.status == SpecStatus::Pending {\n                driver.frontmatter.status = SpecStatus::InProgress;\n                driver.save(\u0026driver_path)?;\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Auto-complete a driver spec if all its members are now completed.\n///\n/// When a member spec completes, check if all other members are also completed.\n/// If so, and the driver is in `InProgress` status, automatically mark the driver\n/// as `Completed` with completion timestamp.\n///\n/// # Arguments\n///\n/// * `member_id` - The ID of the member spec that just completed\n/// * `all_specs` - All available specs\n/// * `specs_dir` - Path to the specs directory\n///\n/// # Returns\n///\n/// Returns `Ok(true)` if the driver was auto-completed.\n/// Returns `Ok(false)` if the driver was not ready for completion.\n/// Returns `Err` if file I/O fails.\n///\n/// # Examples\n///\n/// ```ignore\n/// if auto_complete_driver_if_ready(\"2026-01-25-00y-abc.2\", \u0026specs, \u0026specs_dir)? {\n///     println!(\"Driver was auto-completed!\");\n/// }\n/// ```\npub fn auto_complete_driver_if_ready(\n    member_id: \u0026str,\n    all_specs: \u0026[Spec],\n    specs_dir: \u0026Path,\n) -\u003e Result\u003cbool\u003e {\n    // Only member specs can trigger driver auto-completion\n    let Some(driver_id) = extract_driver_id(member_id) else {\n        return Ok(false);\n    };\n\n    // Find the driver spec\n    let Some(driver_spec) = all_specs.iter().find(|s| s.id == driver_id) else {\n        return Ok(false);\n    };\n\n    // Only auto-complete if driver is in_progress\n    if driver_spec.frontmatter.status != SpecStatus::InProgress {\n        return Ok(false);\n    }\n\n    // Check if all members are completed\n    if !all_members_completed(\u0026driver_id, all_specs) {\n        return Ok(false);\n    }\n\n    // All members are completed, so auto-complete the driver\n    let driver_path = specs_dir.join(format!(\"{}.md\", driver_id));\n    let mut driver = Spec::load(\u0026driver_path)?;\n\n    driver.frontmatter.status = SpecStatus::Completed;\n    driver.frontmatter.completed_at = Some(\n        chrono::Local::now()\n            .format(\"%Y-%m-%dT%H:%M:%SZ\")\n            .to_string(),\n    );\n    driver.frontmatter.model = Some(\"auto-completed\".to_string());\n\n    driver.save(\u0026driver_path)?;\n\n    Ok(true)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_member_of() {\n        assert!(is_member_of(\"2026-01-22-001-x7m.1\", \"2026-01-22-001-x7m\"));\n        assert!(is_member_of(\"2026-01-22-001-x7m.2.1\", \"2026-01-22-001-x7m\"));\n        assert!(!is_member_of(\"2026-01-22-001-x7m\", \"2026-01-22-001-x7m\"));\n        assert!(!is_member_of(\"2026-01-22-002-y8n\", \"2026-01-22-001-x7m\"));\n    }\n\n    #[test]\n    fn test_extract_driver_id() {\n        assert_eq!(\n            extract_driver_id(\"2026-01-22-001-x7m.1\"),\n            Some(\"2026-01-22-001-x7m\".to_string())\n        );\n        assert_eq!(\n            extract_driver_id(\"2026-01-22-001-x7m.2.1\"),\n            Some(\"2026-01-22-001-x7m\".to_string())\n        );\n        assert_eq!(extract_driver_id(\"2026-01-22-001-x7m\"), None);\n        assert_eq!(extract_driver_id(\"2026-01-22-001-x7m.abc\"), None);\n    }\n\n    #[test]\n    fn test_extract_member_number() {\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc.1\"), Some(1));\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc.3\"), Some(3));\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc.10\"), Some(10));\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc.3.2\"), Some(3));\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc\"), None);\n        assert_eq!(extract_member_number(\"2026-01-24-001-abc.abc\"), None);\n    }\n\n    #[test]\n    fn test_all_prior_siblings_completed() {\n        // Test spec for member .1 with no prior siblings\n        let spec1 = Spec::parse(\n            \"2026-01-24-001-abc.1\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        // Should be ready since it has no prior siblings\n        assert!(all_prior_siblings_completed(\u0026spec1.id, \u0026[]));\n\n        // Test spec for member .3 with completed prior siblings\n        let spec_prior_1 = Spec::parse(\n            \"2026-01-24-001-abc.1\",\n            r#\"---\nstatus: completed\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let spec_prior_2 = Spec::parse(\n            \"2026-01-24-001-abc.2\",\n            r#\"---\nstatus: completed\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let spec3 = Spec::parse(\n            \"2026-01-24-001-abc.3\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![spec_prior_1, spec_prior_2, spec3.clone()];\n        assert!(all_prior_siblings_completed(\u0026spec3.id, \u0026all_specs));\n    }\n\n    #[test]\n    fn test_all_prior_siblings_completed_missing() {\n        // Test spec for member .3 with missing prior sibling\n        let spec_prior_1 = Spec::parse(\n            \"2026-01-24-001-abc.1\",\n            r#\"---\nstatus: completed\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let spec3 = Spec::parse(\n            \"2026-01-24-001-abc.3\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        // Only spec .1 exists, .2 is missing\n        let all_specs = vec![spec_prior_1, spec3.clone()];\n        assert!(!all_prior_siblings_completed(\u0026spec3.id, \u0026all_specs));\n    }\n\n    #[test]\n    fn test_all_prior_siblings_completed_not_completed() {\n        // Test spec for member .2 with incomplete prior sibling\n        let spec_prior_1 = Spec::parse(\n            \"2026-01-24-001-abc.1\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let spec2 = Spec::parse(\n            \"2026-01-24-001-abc.2\",\n            r#\"---\nstatus: pending\n---\n# Test\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![spec_prior_1, spec2.clone()];\n        assert!(!all_prior_siblings_completed(\u0026spec2.id, \u0026all_specs));\n    }\n\n    #[test]\n    fn test_mark_driver_in_progress_when_member_starts() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that is pending\n        let driver_spec = Spec {\n            id: \"2026-01-24-001-abc\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Driver spec\".to_string()),\n            body: \"# Driver spec\\n\\nBody content.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-001-abc.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Mark driver as in_progress when member starts\n        mark_driver_in_progress(specs_dir, \"2026-01-24-001-abc.1\").unwrap();\n\n        // Verify driver status was updated to in_progress\n        let updated_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(updated_driver.frontmatter.status, SpecStatus::InProgress);\n    }\n\n    #[test]\n    fn test_mark_driver_in_progress_skips_if_already_in_progress() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that is already in_progress\n        let driver_spec = Spec {\n            id: \"2026-01-24-002-def\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::InProgress,\n                ..Default::default()\n            },\n            title: Some(\"Driver spec\".to_string()),\n            body: \"# Driver spec\\n\\nBody content.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-002-def.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Try to mark driver as in_progress\n        mark_driver_in_progress(specs_dir, \"2026-01-24-002-def.1\").unwrap();\n\n        // Verify driver status is still in_progress (not changed)\n        let updated_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(updated_driver.frontmatter.status, SpecStatus::InProgress);\n    }\n\n    #[test]\n    fn test_mark_driver_in_progress_nonexistent_driver() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Try to mark driver as in_progress when driver doesn't exist\n        // Should not error, just skip\n        mark_driver_in_progress(specs_dir, \"2026-01-24-003-ghi.1\").unwrap();\n    }\n\n    #[test]\n    fn test_get_incomplete_members() {\n        // Driver with multiple incomplete members\n        let driver = Spec::parse(\n            \"2026-01-24-005-mno\",\n            r#\"---\nstatus: in_progress\n---\n# Driver\n\"#,\n        )\n        .unwrap();\n\n        let member1 = Spec::parse(\n            \"2026-01-24-005-mno.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let member2 = Spec::parse(\n            \"2026-01-24-005-mno.2\",\n            r#\"---\nstatus: pending\n---\n# Member 2\n\"#,\n        )\n        .unwrap();\n\n        let member3 = Spec::parse(\n            \"2026-01-24-005-mno.3\",\n            r#\"---\nstatus: in_progress\n---\n# Member 3\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![driver.clone(), member1, member2, member3];\n        let incomplete = get_incomplete_members(\u0026driver.id, \u0026all_specs);\n        assert_eq!(incomplete.len(), 2);\n        assert!(incomplete.contains(\u0026\"2026-01-24-005-mno.2\".to_string()));\n        assert!(incomplete.contains(\u0026\"2026-01-24-005-mno.3\".to_string()));\n    }\n\n    #[test]\n    fn test_auto_complete_driver_not_member_spec() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // A non-member spec should not trigger auto-completion\n        let driver_spec = Spec::parse(\n            \"2026-01-24-006-pqr\",\n            r#\"---\nstatus: in_progress\n---\n# Driver spec\n\"#,\n        )\n        .unwrap();\n\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-006-pqr\", \u0026[driver_spec], specs_dir).unwrap();\n        assert!(\n            !result,\n            \"Non-member spec should not trigger auto-completion\"\n        );\n    }\n\n    #[test]\n    fn test_auto_complete_driver_driver_not_in_progress() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that is pending (not in_progress)\n        let driver_spec = Spec::parse(\n            \"2026-01-24-007-stu\",\n            r#\"---\nstatus: pending\n---\n# Driver spec\n\"#,\n        )\n        .unwrap();\n\n        let member_spec = Spec::parse(\n            \"2026-01-24-007-stu.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![driver_spec, member_spec];\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-007-stu.1\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            !result,\n            \"Driver not in progress should not be auto-completed\"\n        );\n    }\n\n    #[test]\n    fn test_auto_complete_driver_incomplete_members() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that is in_progress\n        let driver_spec = Spec {\n            id: \"2026-01-24-008-vwx\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::InProgress,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"# Driver\\n\\nBody.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-008-vwx.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Create member specs where not all are completed\n        let member1 = Spec::parse(\n            \"2026-01-24-008-vwx.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let member2 = Spec::parse(\n            \"2026-01-24-008-vwx.2\",\n            r#\"---\nstatus: in_progress\n---\n# Member 2\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![driver_spec, member1, member2];\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-008-vwx.1\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            !result,\n            \"Driver should not complete when members are incomplete\"\n        );\n    }\n\n    #[test]\n    fn test_auto_complete_driver_success() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that is in_progress\n        let driver_spec = Spec {\n            id: \"2026-01-24-009-yz0\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::InProgress,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"# Driver\\n\\nBody.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-009-yz0.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Create member specs where all are completed\n        let member1 = Spec::parse(\n            \"2026-01-24-009-yz0.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let member2 = Spec::parse(\n            \"2026-01-24-009-yz0.2\",\n            r#\"---\nstatus: completed\n---\n# Member 2\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![driver_spec, member1, member2];\n\n        // Auto-complete should succeed\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-009-yz0.2\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            result,\n            \"Driver should be auto-completed when all members are completed\"\n        );\n\n        // Verify driver was updated\n        let updated_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(updated_driver.frontmatter.status, SpecStatus::Completed);\n        assert_eq!(\n            updated_driver.frontmatter.model,\n            Some(\"auto-completed\".to_string())\n        );\n        assert!(updated_driver.frontmatter.completed_at.is_some());\n    }\n\n    #[test]\n    fn test_auto_complete_driver_nonexistent_driver() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Try to auto-complete when driver doesn't exist\n        let all_specs = vec![];\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-010-abc.1\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            !result,\n            \"Should return false when driver spec doesn't exist\"\n        );\n    }\n\n    #[test]\n    fn test_auto_complete_driver_single_member() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Driver with single member\n        let driver_spec = Spec {\n            id: \"2026-01-24-011-def\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::InProgress,\n                ..Default::default()\n            },\n            title: Some(\"Driver\".to_string()),\n            body: \"# Driver\\n\\nBody.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-011-def.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Single member\n        let member = Spec::parse(\n            \"2026-01-24-011-def.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![driver_spec, member];\n\n        // Auto-complete should succeed\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-011-def.1\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            result,\n            \"Driver should be auto-completed when single member completes\"\n        );\n\n        // Verify driver was updated\n        let updated_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(updated_driver.frontmatter.status, SpecStatus::Completed);\n        assert_eq!(\n            updated_driver.frontmatter.model,\n            Some(\"auto-completed\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_member_numeric_sort() {\n        use std::cmp::Ordering;\n\n        // Test numeric sorting for member specs\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.2\", \"2026-01-25-00y-abc.10\"),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.10\", \"2026-01-25-00y-abc.2\"),\n            Ordering::Greater\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.1\", \"2026-01-25-00y-abc.1\"),\n            Ordering::Equal\n        );\n\n        // Test with larger numbers\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.99\", \"2026-01-25-00y-abc.100\"),\n            Ordering::Less\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_different_drivers() {\n        use std::cmp::Ordering;\n\n        // Different driver IDs should use lexicographic comparison\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.1\", \"2026-01-25-00y-def.1\"),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-def.1\", \"2026-01-25-00y-abc.1\"),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_non_member_specs() {\n        use std::cmp::Ordering;\n\n        // Non-member specs should use lexicographic comparison\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc\", \"2026-01-25-00y-def\"),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-def\", \"2026-01-25-00y-abc\"),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_driver_vs_member() {\n        use std::cmp::Ordering;\n\n        // Driver should come before its members\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc\", \"2026-01-25-00y-abc.1\"),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00y-abc.1\", \"2026-01-25-00y-abc\"),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_sorting_list() {\n        // Test sorting a list of specs with mixed member numbers\n        let mut ids = vec![\n            \"2026-01-25-00y-abc.10\",\n            \"2026-01-25-00y-abc.2\",\n            \"2026-01-25-00y-abc.1\",\n            \"2026-01-25-00y-abc\",\n            \"2026-01-25-00y-abc.3\",\n        ];\n\n        ids.sort_by(|a, b| compare_spec_ids(a, b));\n\n        assert_eq!(\n            ids,\n            vec![\n                \"2026-01-25-00y-abc\",\n                \"2026-01-25-00y-abc.1\",\n                \"2026-01-25-00y-abc.2\",\n                \"2026-01-25-00y-abc.3\",\n                \"2026-01-25-00y-abc.10\",\n            ]\n        );\n    }\n\n    #[test]\n    fn test_compare_spec_ids_base36_sequence_rollover() {\n        use std::cmp::Ordering;\n\n        // Test that base36 sequence 010 (decimal 36) sorts after 00z (decimal 35)\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-010-xxx\", \"2026-01-25-00z-yyy\"),\n            Ordering::Greater\n        );\n        assert_eq!(\n            compare_spec_ids(\"2026-01-25-00z-yyy\", \"2026-01-25-010-xxx\"),\n            Ordering::Less\n        );\n\n        // Test sorting a list with base36 rollover\n        let mut ids = vec![\n            \"2026-01-25-010-aaa\",\n            \"2026-01-25-00a-bbb\",\n            \"2026-01-25-00z-ccc\",\n            \"2026-01-25-001-ddd\",\n            \"2026-01-25-011-eee\",\n        ];\n\n        ids.sort_by(|a, b| compare_spec_ids(a, b));\n\n        assert_eq!(\n            ids,\n            vec![\n                \"2026-01-25-001-ddd\", // 1\n                \"2026-01-25-00a-bbb\", // 10\n                \"2026-01-25-00z-ccc\", // 35\n                \"2026-01-25-010-aaa\", // 36\n                \"2026-01-25-011-eee\", // 37\n            ]\n        );\n    }\n\n    #[test]\n    fn test_driver_auto_completion_with_two_members() {\n        use tempfile::TempDir;\n\n        let temp_dir = TempDir::new().unwrap();\n        let specs_dir = temp_dir.path();\n\n        // Create a driver spec that starts as pending\n        let driver_spec = Spec {\n            id: \"2026-01-24-012-ghi\".to_string(),\n            frontmatter: crate::spec::SpecFrontmatter {\n                status: SpecStatus::Pending,\n                ..Default::default()\n            },\n            title: Some(\"Driver spec with 2 members\".to_string()),\n            body: \"# Driver\\n\\nBody.\".to_string(),\n        };\n\n        let driver_path = specs_dir.join(\"2026-01-24-012-ghi.md\");\n        driver_spec.save(\u0026driver_path).unwrap();\n\n        // Create first member (initially pending)\n        let _member1 = Spec::parse(\n            \"2026-01-24-012-ghi.1\",\n            r#\"---\nstatus: pending\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        // Create second member (initially pending)\n        let member2 = Spec::parse(\n            \"2026-01-24-012-ghi.2\",\n            r#\"---\nstatus: pending\n---\n# Member 2\n\"#,\n        )\n        .unwrap();\n\n        // Step 1: First member starts - should mark driver as in_progress\n        mark_driver_in_progress(specs_dir, \"2026-01-24-012-ghi.1\").unwrap();\n\n        let updated_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(\n            updated_driver.frontmatter.status,\n            SpecStatus::InProgress,\n            \"Driver should be in_progress after first member starts\"\n        );\n\n        // Step 2: First member completes - driver should NOT complete yet\n        let member1_completed = Spec::parse(\n            \"2026-01-24-012-ghi.1\",\n            r#\"---\nstatus: completed\n---\n# Member 1\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![\n            updated_driver.clone(),\n            member1_completed.clone(),\n            member2.clone(),\n        ];\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-012-ghi.1\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            !result,\n            \"Driver should NOT auto-complete when first member is done but second is pending\"\n        );\n\n        let still_in_progress = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(\n            still_in_progress.frontmatter.status,\n            SpecStatus::InProgress,\n            \"Driver should still be in_progress\"\n        );\n\n        // Step 3: Second member completes - driver SHOULD auto-complete\n        let member2_completed = Spec::parse(\n            \"2026-01-24-012-ghi.2\",\n            r#\"---\nstatus: completed\n---\n# Member 2\n\"#,\n        )\n        .unwrap();\n\n        let all_specs = vec![\n            still_in_progress.clone(),\n            member1_completed.clone(),\n            member2_completed.clone(),\n        ];\n        let result =\n            auto_complete_driver_if_ready(\"2026-01-24-012-ghi.2\", \u0026all_specs, specs_dir).unwrap();\n        assert!(\n            result,\n            \"Driver should auto-complete when all members are completed\"\n        );\n\n        let final_driver = Spec::load(\u0026driver_path).unwrap();\n        assert_eq!(\n            final_driver.frontmatter.status,\n            SpecStatus::Completed,\n            \"Driver should be completed after all members complete\"\n        );\n        assert_eq!(\n            final_driver.frontmatter.model,\n            Some(\"auto-completed\".to_string()),\n            \"Driver should have auto-completed model\"\n        );\n        assert!(\n            final_driver.frontmatter.completed_at.is_some(),\n            \"Driver should have completed_at timestamp\"\n        );\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":164}},{"line":26,"address":[],"length":0,"stats":{"Line":328}},{"line":27,"address":[],"length":0,"stats":{"Line":33}},{"line":30,"address":[],"length":0,"stats":{"Line":393}},{"line":31,"address":[],"length":0,"stats":{"Line":326}},{"line":49,"address":[],"length":0,"stats":{"Line":31}},{"line":50,"address":[],"length":0,"stats":{"Line":31}},{"line":52,"address":[],"length":0,"stats":{"Line":274}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":75,"address":[],"length":0,"stats":{"Line":28}},{"line":76,"address":[],"length":0,"stats":{"Line":14}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":29}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":9}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":7}},{"line":123,"address":[],"length":0,"stats":{"Line":321}},{"line":125,"address":[],"length":0,"stats":{"Line":376}},{"line":126,"address":[],"length":0,"stats":{"Line":220}},{"line":128,"address":[],"length":0,"stats":{"Line":55}},{"line":129,"address":[],"length":0,"stats":{"Line":55}},{"line":130,"address":[],"length":0,"stats":{"Line":55}},{"line":131,"address":[],"length":0,"stats":{"Line":55}},{"line":132,"address":[],"length":0,"stats":{"Line":165}},{"line":134,"address":[],"length":0,"stats":{"Line":54}},{"line":137,"address":[],"length":0,"stats":{"Line":267}},{"line":155,"address":[],"length":0,"stats":{"Line":44}},{"line":156,"address":[],"length":0,"stats":{"Line":87}},{"line":157,"address":[],"length":0,"stats":{"Line":86}},{"line":159,"address":[],"length":0,"stats":{"Line":364}},{"line":160,"address":[],"length":0,"stats":{"Line":43}},{"line":161,"address":[],"length":0,"stats":{"Line":84}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":125}},{"line":195,"address":[],"length":0,"stats":{"Line":375}},{"line":196,"address":[],"length":0,"stats":{"Line":375}},{"line":198,"address":[],"length":0,"stats":{"Line":250}},{"line":199,"address":[],"length":0,"stats":{"Line":22}},{"line":202,"address":[],"length":0,"stats":{"Line":22}},{"line":205,"address":[],"length":0,"stats":{"Line":36}},{"line":206,"address":[],"length":0,"stats":{"Line":36}},{"line":207,"address":[],"length":0,"stats":{"Line":27}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":327}},{"line":247,"address":[],"length":0,"stats":{"Line":125}},{"line":251,"address":[],"length":0,"stats":{"Line":375}},{"line":252,"address":[],"length":0,"stats":{"Line":375}},{"line":254,"address":[],"length":0,"stats":{"Line":250}},{"line":255,"address":[],"length":0,"stats":{"Line":750}},{"line":257,"address":[],"length":0,"stats":{"Line":250}},{"line":260,"address":[],"length":0,"stats":{"Line":250}},{"line":263,"address":[],"length":0,"stats":{"Line":318}},{"line":265,"address":[],"length":0,"stats":{"Line":38}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":250}},{"line":279,"address":[],"length":0,"stats":{"Line":1250}},{"line":282,"address":[],"length":0,"stats":{"Line":250}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":500}},{"line":290,"address":[],"length":0,"stats":{"Line":750}},{"line":293,"address":[],"length":0,"stats":{"Line":500}},{"line":295,"address":[],"length":0,"stats":{"Line":500}},{"line":315,"address":[],"length":0,"stats":{"Line":25}},{"line":317,"address":[],"length":0,"stats":{"Line":147}},{"line":319,"address":[],"length":0,"stats":{"Line":46}},{"line":320,"address":[],"length":0,"stats":{"Line":8}},{"line":325,"address":[],"length":0,"stats":{"Line":21}},{"line":326,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":9}},{"line":329,"address":[],"length":0,"stats":{"Line":10}},{"line":330,"address":[],"length":0,"stats":{"Line":29}},{"line":331,"address":[],"length":0,"stats":{"Line":9}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":13}},{"line":367,"address":[],"length":0,"stats":{"Line":8}},{"line":368,"address":[],"length":0,"stats":{"Line":12}},{"line":370,"address":[],"length":0,"stats":{"Line":16}},{"line":371,"address":[],"length":0,"stats":{"Line":4}},{"line":372,"address":[],"length":0,"stats":{"Line":9}},{"line":373,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":407,"address":[],"length":0,"stats":{"Line":10}},{"line":413,"address":[],"length":0,"stats":{"Line":19}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":42}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":8}},{"line":424,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":14}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":20}},{"line":434,"address":[],"length":0,"stats":{"Line":15}},{"line":436,"address":[],"length":0,"stats":{"Line":5}},{"line":437,"address":[],"length":0,"stats":{"Line":10}},{"line":438,"address":[],"length":0,"stats":{"Line":10}},{"line":439,"address":[],"length":0,"stats":{"Line":5}},{"line":440,"address":[],"length":0,"stats":{"Line":5}},{"line":442,"address":[],"length":0,"stats":{"Line":10}},{"line":444,"address":[],"length":0,"stats":{"Line":15}},{"line":446,"address":[],"length":0,"stats":{"Line":5}}],"covered":110,"coverable":116},{"path":["/","Users","alex","Documents","checkouts","chant","src","spec_template.rs"],"content":"//! Spec template system for creating specs from reusable templates.\n//!\n//! Templates are markdown files with YAML frontmatter containing variable definitions.\n//! They can be stored in `.chant/templates/` (project) or `~/.config/chant/templates/` (global).\n//!\n//! # Template Format\n//!\n//! ```markdown\n//! ---\n//! name: add-feature\n//! description: Add a new feature with tests\n//! variables:\n//!   - name: feature_name\n//!     description: Name of the feature\n//!     required: true\n//!   - name: module\n//!     description: Target module\n//!     default: core\n//! type: code\n//! labels:\n//!   - feature\n//! ---\n//!\n//! # Add {{feature_name}} feature\n//!\n//! ## Problem\n//!\n//! The {{module}} module needs {{feature_name}} functionality.\n//! ```\n\nuse anyhow::{Context, Result};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Directory name for templates within .chant/\npub const PROJECT_TEMPLATES_DIR: \u0026str = \".chant/templates\";\n\n/// Directory name for global templates\npub const GLOBAL_TEMPLATES_DIR: \u0026str = \"templates\";\n\n/// A variable definition within a template\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateVariable {\n    /// Name of the variable (used in {{name}} placeholders)\n    pub name: String,\n    /// Description of what this variable is for\n    #[serde(default)]\n    pub description: String,\n    /// Whether this variable must be provided (no default)\n    #[serde(default)]\n    pub required: bool,\n    /// Default value if not provided\n    #[serde(default)]\n    pub default: Option\u003cString\u003e,\n}\n\n/// Template frontmatter containing metadata and variable definitions\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateFrontmatter {\n    /// Template name (identifier)\n    pub name: String,\n    /// Human-readable description\n    #[serde(default)]\n    pub description: String,\n    /// Variable definitions\n    #[serde(default)]\n    pub variables: Vec\u003cTemplateVariable\u003e,\n    /// Default spec type to use\n    #[serde(default)]\n    pub r#type: Option\u003cString\u003e,\n    /// Default labels to apply\n    #[serde(default)]\n    pub labels: Option\u003cVec\u003cString\u003e\u003e,\n    /// Default target files\n    #[serde(default)]\n    pub target_files: Option\u003cVec\u003cString\u003e\u003e,\n    /// Default context files\n    #[serde(default)]\n    pub context: Option\u003cVec\u003cString\u003e\u003e,\n    /// Default prompt to use\n    #[serde(default)]\n    pub prompt: Option\u003cString\u003e,\n}\n\n/// A spec template with its metadata and content\n#[derive(Debug, Clone)]\npub struct SpecTemplate {\n    /// Template name\n    pub name: String,\n    /// Parsed frontmatter\n    pub frontmatter: TemplateFrontmatter,\n    /// Template body (with {{variable}} placeholders)\n    pub body: String,\n    /// Source location (project or global)\n    pub source: TemplateSource,\n    /// File path where template was loaded from\n    pub path: PathBuf,\n}\n\n/// Where a template was loaded from\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum TemplateSource {\n    /// From project's .chant/templates/\n    Project,\n    /// From ~/.config/chant/templates/\n    Global,\n}\n\nimpl std::fmt::Display for TemplateSource {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            TemplateSource::Project =\u003e write!(f, \"project\"),\n            TemplateSource::Global =\u003e write!(f, \"global\"),\n        }\n    }\n}\n\nimpl SpecTemplate {\n    /// Parse a template from file content.\n    pub fn parse(content: \u0026str, path: \u0026Path, source: TemplateSource) -\u003e Result\u003cSelf\u003e {\n        let (frontmatter_str, body) = split_frontmatter(content);\n\n        let frontmatter: TemplateFrontmatter = if let Some(fm) = frontmatter_str {\n            serde_yaml::from_str(\u0026fm).context(\"Failed to parse template frontmatter\")?\n        } else {\n            anyhow::bail!(\"Template must have YAML frontmatter with 'name' field\");\n        };\n\n        if frontmatter.name.is_empty() {\n            anyhow::bail!(\"Template 'name' field is required and cannot be empty\");\n        }\n\n        Ok(Self {\n            name: frontmatter.name.clone(),\n            frontmatter,\n            body: body.to_string(),\n            source,\n            path: path.to_path_buf(),\n        })\n    }\n\n    /// Load a template from a file path.\n    pub fn load(path: \u0026Path, source: TemplateSource) -\u003e Result\u003cSelf\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read template from {}\", path.display()))?;\n        Self::parse(\u0026content, path, source)\n    }\n\n    /// Get list of required variables that don't have defaults\n    pub fn required_variables(\u0026self) -\u003e Vec\u003c\u0026TemplateVariable\u003e {\n        self.frontmatter\n            .variables\n            .iter()\n            .filter(|v| v.required \u0026\u0026 v.default.is_none())\n            .collect()\n    }\n\n    /// Check if all required variables are provided\n    pub fn validate_variables(\u0026self, provided: \u0026HashMap\u003cString, String\u003e) -\u003e Result\u003c()\u003e {\n        let missing: Vec\u003c_\u003e = self\n            .required_variables()\n            .iter()\n            .filter(|v| !provided.contains_key(\u0026v.name))\n            .map(|v| v.name.as_str())\n            .collect();\n\n        if !missing.is_empty() {\n            anyhow::bail!(\"Missing required variable(s): {}\", missing.join(\", \"));\n        }\n\n        Ok(())\n    }\n\n    /// Substitute variables in a string using {{variable}} syntax\n    pub fn substitute(\u0026self, text: \u0026str, variables: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n        let re = Regex::new(r\"\\{\\{(\\w+)\\}\\}\").unwrap();\n\n        re.replace_all(text, |caps: \u0026regex::Captures| {\n            let var_name = \u0026caps[1];\n\n            // First check provided variables\n            if let Some(value) = variables.get(var_name) {\n                return value.clone();\n            }\n\n            // Then check for defaults in template definition\n            if let Some(var_def) = self\n                .frontmatter\n                .variables\n                .iter()\n                .find(|v| v.name == var_name)\n            {\n                if let Some(ref default) = var_def.default {\n                    return default.clone();\n                }\n            }\n\n            // Keep the placeholder if no value found\n            caps[0].to_string()\n        })\n        .to_string()\n    }\n\n    /// Generate spec content from this template with the given variables\n    pub fn render(\u0026self, variables: \u0026HashMap\u003cString, String\u003e) -\u003e Result\u003cString\u003e {\n        // Validate required variables are present\n        self.validate_variables(variables)?;\n\n        // Build frontmatter for the spec\n        let mut fm_lines = vec![\"---\".to_string()];\n\n        // Type (from template or default to 'code')\n        let spec_type = self.frontmatter.r#type.as_deref().unwrap_or(\"code\");\n        fm_lines.push(format!(\"type: {}\", spec_type));\n        fm_lines.push(\"status: pending\".to_string());\n\n        // Labels\n        if let Some(ref labels) = self.frontmatter.labels {\n            if !labels.is_empty() {\n                fm_lines.push(\"labels:\".to_string());\n                for label in labels {\n                    let substituted = self.substitute(label, variables);\n                    fm_lines.push(format!(\"  - {}\", substituted));\n                }\n            }\n        }\n\n        // Target files\n        if let Some(ref target_files) = self.frontmatter.target_files {\n            if !target_files.is_empty() {\n                fm_lines.push(\"target_files:\".to_string());\n                for file in target_files {\n                    let substituted = self.substitute(file, variables);\n                    fm_lines.push(format!(\"  - {}\", substituted));\n                }\n            }\n        }\n\n        // Context\n        if let Some(ref context) = self.frontmatter.context {\n            if !context.is_empty() {\n                fm_lines.push(\"context:\".to_string());\n                for ctx in context {\n                    let substituted = self.substitute(ctx, variables);\n                    fm_lines.push(format!(\"  - {}\", substituted));\n                }\n            }\n        }\n\n        // Prompt\n        if let Some(ref prompt) = self.frontmatter.prompt {\n            fm_lines.push(format!(\"prompt: {}\", prompt));\n        }\n\n        fm_lines.push(\"---\".to_string());\n        fm_lines.push(String::new());\n\n        let frontmatter = fm_lines.join(\"\\n\");\n\n        // Substitute variables in body\n        let body = self.substitute(\u0026self.body, variables);\n\n        Ok(format!(\"{}{}\", frontmatter, body))\n    }\n}\n\n/// Split content into frontmatter and body.\n/// Returns (Some(frontmatter), body) if frontmatter exists, otherwise (None, full_content).\nfn split_frontmatter(content: \u0026str) -\u003e (Option\u003cString\u003e, \u0026str) {\n    let content = content.trim_start();\n\n    if !content.starts_with(\"---\") {\n        return (None, content);\n    }\n\n    // Find the closing ---\n    let after_first = \u0026content[3..];\n    if let Some(end_pos) = after_first.find(\"\\n---\") {\n        let frontmatter = after_first[..end_pos].trim();\n        let body_start = 3 + end_pos + 4; // \"---\" + frontmatter + \"\\n---\"\n        let body = if body_start \u003c content.len() {\n            content[body_start..].trim_start_matches('\\n')\n        } else {\n            \"\"\n        };\n        (Some(frontmatter.to_string()), body)\n    } else {\n        (None, content)\n    }\n}\n\n/// Get the path to the project templates directory\npub fn project_templates_dir() -\u003e PathBuf {\n    PathBuf::from(PROJECT_TEMPLATES_DIR)\n}\n\n/// Get the path to the global templates directory\npub fn global_templates_dir() -\u003e Option\u003cPathBuf\u003e {\n    dirs::config_dir().map(|p| p.join(\"chant\").join(GLOBAL_TEMPLATES_DIR))\n}\n\n/// Load all templates from a directory\nfn load_templates_from_dir(dir: \u0026Path, source: TemplateSource) -\u003e Vec\u003cSpecTemplate\u003e {\n    let mut templates = Vec::new();\n\n    if !dir.exists() {\n        return templates;\n    }\n\n    if let Ok(entries) = fs::read_dir(dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_file() \u0026\u0026 path.extension().is_some_and(|ext| ext == \"md\") {\n                match SpecTemplate::load(\u0026path, source.clone()) {\n                    Ok(template) =\u003e templates.push(template),\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: Failed to load template {}: {}\", path.display(), e);\n                    }\n                }\n            }\n        }\n    }\n\n    templates\n}\n\n/// Load all available templates (project templates override global ones with the same name)\npub fn load_all_templates() -\u003e Vec\u003cSpecTemplate\u003e {\n    let mut templates_by_name: HashMap\u003cString, SpecTemplate\u003e = HashMap::new();\n\n    // First load global templates\n    if let Some(global_dir) = global_templates_dir() {\n        for template in load_templates_from_dir(\u0026global_dir, TemplateSource::Global) {\n            templates_by_name.insert(template.name.clone(), template);\n        }\n    }\n\n    // Then load project templates (overriding global ones with same name)\n    let project_dir = project_templates_dir();\n    for template in load_templates_from_dir(\u0026project_dir, TemplateSource::Project) {\n        templates_by_name.insert(template.name.clone(), template);\n    }\n\n    let mut templates: Vec\u003c_\u003e = templates_by_name.into_values().collect();\n    templates.sort_by(|a, b| a.name.cmp(\u0026b.name));\n    templates\n}\n\n/// Find a template by name (project templates take precedence)\npub fn find_template(name: \u0026str) -\u003e Result\u003cSpecTemplate\u003e {\n    // Check project templates first\n    let project_dir = project_templates_dir();\n    let project_path = project_dir.join(format!(\"{}.md\", name));\n    if project_path.exists() {\n        return SpecTemplate::load(\u0026project_path, TemplateSource::Project);\n    }\n\n    // Check global templates\n    if let Some(global_dir) = global_templates_dir() {\n        let global_path = global_dir.join(format!(\"{}.md\", name));\n        if global_path.exists() {\n            return SpecTemplate::load(\u0026global_path, TemplateSource::Global);\n        }\n    }\n\n    anyhow::bail!(\n        \"Template '{}' not found.\\n\\\n         Searched in:\\n  \\\n         - {}\\n  \\\n         - {}\",\n        name,\n        project_path.display(),\n        global_templates_dir()\n            .map(|p| p.join(format!(\"{}.md\", name)).display().to_string())\n            .unwrap_or_else(|| \"~/.config/chant/templates/\".to_string())\n    );\n}\n\n/// Parse a list of \"key=value\" strings into a HashMap\npub fn parse_var_args(var_args: \u0026[String]) -\u003e Result\u003cHashMap\u003cString, String\u003e\u003e {\n    let mut vars = HashMap::new();\n\n    for arg in var_args {\n        let parts: Vec\u003c\u0026str\u003e = arg.splitn(2, '=').collect();\n        if parts.len() != 2 {\n            anyhow::bail!(\"Invalid variable format '{}'. Expected 'key=value'.\", arg);\n        }\n        vars.insert(parts[0].to_string(), parts[1].to_string());\n    }\n\n    Ok(vars)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_split_frontmatter() {\n        let content = \"---\\nname: test\\n---\\n\\n# Body\\n\";\n        let (fm, body) = split_frontmatter(content);\n        assert!(fm.is_some());\n        assert_eq!(fm.unwrap(), \"name: test\");\n        assert_eq!(body, \"# Body\\n\");\n    }\n\n    #[test]\n    fn test_split_frontmatter_no_frontmatter() {\n        let content = \"# Just body\\n\";\n        let (fm, body) = split_frontmatter(content);\n        assert!(fm.is_none());\n        assert_eq!(body, \"# Just body\\n\");\n    }\n\n    #[test]\n    fn test_parse_template() {\n        let content = r#\"---\nname: test-template\ndescription: A test template\nvariables:\n  - name: feature\n    description: Feature name\n    required: true\n  - name: module\n    description: Module name\n    default: core\ntype: code\nlabels:\n  - feature\n---\n\n# Add {{feature}} to {{module}}\n\n## Problem\n\nNeed to add {{feature}}.\n\"#;\n\n        let template = SpecTemplate::parse(content, Path::new(\"test.md\"), TemplateSource::Project)\n            .expect(\"Should parse\");\n        assert_eq!(template.name, \"test-template\");\n        assert_eq!(template.frontmatter.description, \"A test template\");\n        assert_eq!(template.frontmatter.variables.len(), 2);\n        assert!(template.frontmatter.variables[0].required);\n        assert_eq!(\n            template.frontmatter.variables[1].default,\n            Some(\"core\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_substitute_variables() {\n        let content = r#\"---\nname: test\nvariables:\n  - name: x\n    required: true\n  - name: y\n    default: default_y\n---\n\nText with {{x}} and {{y}}.\n\"#;\n\n        let template = SpecTemplate::parse(content, Path::new(\"test.md\"), TemplateSource::Project)\n            .expect(\"Should parse\");\n\n        let mut vars = HashMap::new();\n        vars.insert(\"x\".to_string(), \"value_x\".to_string());\n\n        let result = template.substitute(\"{{x}} and {{y}}\", \u0026vars);\n        assert_eq!(result, \"value_x and default_y\");\n    }\n\n    #[test]\n    fn test_validate_variables() {\n        let content = r#\"---\nname: test\nvariables:\n  - name: required_var\n    required: true\n  - name: optional_var\n    default: optional\n---\n\nBody\n\"#;\n\n        let template = SpecTemplate::parse(content, Path::new(\"test.md\"), TemplateSource::Project)\n            .expect(\"Should parse\");\n\n        // Missing required variable\n        let vars = HashMap::new();\n        assert!(template.validate_variables(\u0026vars).is_err());\n\n        // With required variable\n        let mut vars = HashMap::new();\n        vars.insert(\"required_var\".to_string(), \"value\".to_string());\n        assert!(template.validate_variables(\u0026vars).is_ok());\n    }\n\n    #[test]\n    fn test_render_template() {\n        let content = r#\"---\nname: feature\ndescription: Add a feature\nvariables:\n  - name: feature_name\n    required: true\n  - name: module\n    default: core\ntype: code\nlabels:\n  - feature\n  - \"{{module}}\"\n---\n\n# Add {{feature_name}}\n\nImplement {{feature_name}} in {{module}}.\n\"#;\n\n        let template = SpecTemplate::parse(content, Path::new(\"test.md\"), TemplateSource::Project)\n            .expect(\"Should parse\");\n\n        let mut vars = HashMap::new();\n        vars.insert(\"feature_name\".to_string(), \"logging\".to_string());\n\n        let rendered = template.render(\u0026vars).expect(\"Should render\");\n\n        assert!(rendered.contains(\"type: code\"));\n        assert!(rendered.contains(\"status: pending\"));\n        assert!(rendered.contains(\"# Add logging\"));\n        assert!(rendered.contains(\"Implement logging in core.\"));\n        assert!(rendered.contains(\"labels:\"));\n        assert!(rendered.contains(\"  - feature\"));\n        assert!(rendered.contains(\"  - core\"));\n    }\n\n    #[test]\n    fn test_parse_var_args() {\n        let args = vec![\"key1=value1\".to_string(), \"key2=value2\".to_string()];\n        let vars = parse_var_args(\u0026args).expect(\"Should parse\");\n        assert_eq!(vars.get(\"key1\"), Some(\u0026\"value1\".to_string()));\n        assert_eq!(vars.get(\"key2\"), Some(\u0026\"value2\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_var_args_with_equals_in_value() {\n        let args = vec![\"key=value=with=equals\".to_string()];\n        let vars = parse_var_args(\u0026args).expect(\"Should parse\");\n        assert_eq!(vars.get(\"key\"), Some(\u0026\"value=with=equals\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_var_args_invalid() {\n        let args = vec![\"no_equals_sign\".to_string()];\n        assert!(parse_var_args(\u0026args).is_err());\n    }\n\n    #[test]\n    fn test_required_variables() {\n        let content = r#\"---\nname: test\nvariables:\n  - name: req1\n    required: true\n  - name: req2\n    required: true\n    default: has_default\n  - name: opt1\n    required: false\n---\n\nBody\n\"#;\n\n        let template = SpecTemplate::parse(content, Path::new(\"test.md\"), TemplateSource::Project)\n            .expect(\"Should parse\");\n\n        let required = template.required_variables();\n        // req1 is required with no default\n        // req2 has required: true but also has a default, so it shouldn't count\n        // opt1 is not required\n        assert_eq!(required.len(), 1);\n        assert_eq!(required[0].name, \"req1\");\n    }\n}\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":5}},{"line":124,"address":[],"length":0,"stats":{"Line":15}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":15}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":10}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":15}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":140,"address":[],"length":0,"stats":{"Line":10}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":23}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":163,"address":[],"length":0,"stats":{"Line":9}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":16}},{"line":181,"address":[],"length":0,"stats":{"Line":18}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":185,"address":[],"length":0,"stats":{"Line":15}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":190,"address":[],"length":0,"stats":{"Line":6}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":6}},{"line":197,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":224,"address":[],"length":0,"stats":{"Line":5}},{"line":225,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":7}},{"line":273,"address":[],"length":0,"stats":{"Line":21}},{"line":275,"address":[],"length":0,"stats":{"Line":7}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":12}},{"line":281,"address":[],"length":0,"stats":{"Line":12}},{"line":282,"address":[],"length":0,"stats":{"Line":18}},{"line":283,"address":[],"length":0,"stats":{"Line":12}},{"line":284,"address":[],"length":0,"stats":{"Line":18}},{"line":285,"address":[],"length":0,"stats":{"Line":12}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":6}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":3}},{"line":384,"address":[],"length":0,"stats":{"Line":6}},{"line":386,"address":[],"length":0,"stats":{"Line":7}},{"line":387,"address":[],"length":0,"stats":{"Line":16}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":18}},{"line":394,"address":[],"length":0,"stats":{"Line":2}}],"covered":74,"coverable":140},{"path":["/","Users","alex","Documents","checkouts","chant","src","status.rs"],"content":"//! Status data aggregation for specs\n//!\n//! Provides functionality to aggregate status information across all specs,\n//! including counts by status, today's activity, attention items, and ready queue.\n\nuse anyhow::Result;\nuse chrono::{DateTime, Duration, Local};\nuse serde_json::json;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse crate::spec::{self, SpecStatus};\n\n/// Activity data for today (last 24 hours)\n#[derive(Debug, Clone, Default)]\npub struct TodayActivity {\n    /// Number of specs completed today\n    pub completed: usize,\n    /// Number of specs started (moved to in_progress) today\n    pub started: usize,\n    /// Number of specs created today\n    pub created: usize,\n}\n\n/// A spec requiring attention (failed or blocked)\n#[derive(Debug, Clone)]\npub struct AttentionItem {\n    /// Spec ID\n    pub id: String,\n    /// Spec title\n    pub title: Option\u003cString\u003e,\n    /// Current status\n    pub status: SpecStatus,\n    /// How long ago the status changed (e.g., \"2h ago\", \"3d ago\")\n    pub ago: String,\n}\n\n/// A spec currently in progress\n#[derive(Debug, Clone)]\npub struct InProgressItem {\n    /// Spec ID\n    pub id: String,\n    /// Spec title\n    pub title: Option\u003cString\u003e,\n    /// Elapsed time in minutes since status changed to in_progress\n    pub elapsed_minutes: i64,\n}\n\n/// A spec in the ready queue\n#[derive(Debug, Clone)]\npub struct ReadyItem {\n    /// Spec ID\n    pub id: String,\n    /// Spec title\n    pub title: Option\u003cString\u003e,\n}\n\n/// Aggregated status data for all specs\n#[derive(Debug, Clone, Default)]\npub struct StatusData {\n    /// Counts by status\n    pub counts: HashMap\u003cString, usize\u003e,\n    /// Today's activity\n    pub today: TodayActivity,\n    /// Items requiring attention\n    pub attention: Vec\u003cAttentionItem\u003e,\n    /// In-progress items\n    pub in_progress: Vec\u003cInProgressItem\u003e,\n    /// Ready queue items (first 5)\n    pub ready: Vec\u003cReadyItem\u003e,\n    /// Total count of ready items\n    pub ready_count: usize,\n}\n\n/// Format a duration as a relative time string (e.g., \"2h ago\", \"3d ago\")\nfn format_ago(datetime: DateTime\u003cLocal\u003e) -\u003e String {\n    let now = Local::now();\n    let duration = now.signed_duration_since(datetime);\n\n    let time_str = if duration.num_minutes() \u003c 1 {\n        \"now\".to_string()\n    } else if duration.num_minutes() \u003c 60 {\n        format!(\"{}m\", duration.num_minutes())\n    } else if duration.num_hours() \u003c 24 {\n        format!(\"{}h\", duration.num_hours())\n    } else if duration.num_days() \u003c 7 {\n        format!(\"{}d\", duration.num_days())\n    } else if duration.num_weeks() \u003c 4 {\n        format!(\"{}w\", duration.num_weeks())\n    } else {\n        format!(\"{}mo\", duration.num_days() / 30)\n    };\n\n    format!(\"{} ago\", time_str)\n}\n\n/// Parse an ISO 8601 timestamp string to Local datetime\nfn parse_timestamp(timestamp: \u0026str) -\u003e Option\u003cDateTime\u003cLocal\u003e\u003e {\n    DateTime::parse_from_rfc3339(timestamp)\n        .ok()\n        .map(|dt| dt.with_timezone(\u0026Local))\n}\n\n/// Get the last modification time of a file\nfn get_file_modified_time(path: \u0026Path) -\u003e Option\u003cDateTime\u003cLocal\u003e\u003e {\n    fs::metadata(path)\n        .ok()\n        .and_then(|metadata| metadata.modified().ok().map(DateTime::\u003cLocal\u003e::from))\n}\n\n/// Aggregate status data from all specs in the specs directory\npub fn aggregate_status(specs_dir: \u0026Path) -\u003e Result\u003cStatusData\u003e {\n    let mut data = StatusData::default();\n\n    // Initialize all status counts to 0\n    data.counts.insert(\"pending\".to_string(), 0);\n    data.counts.insert(\"in_progress\".to_string(), 0);\n    data.counts.insert(\"paused\".to_string(), 0);\n    data.counts.insert(\"completed\".to_string(), 0);\n    data.counts.insert(\"failed\".to_string(), 0);\n    data.counts.insert(\"blocked\".to_string(), 0);\n    data.counts.insert(\"ready\".to_string(), 0);\n\n    // Empty specs directory - return early\n    if !specs_dir.exists() {\n        return Ok(data);\n    }\n\n    // Load all specs\n    let specs = match spec::load_all_specs(specs_dir) {\n        Ok(specs) =\u003e specs,\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Failed to load specs: {}\", e);\n            return Ok(data);\n        }\n    };\n\n    // Calculate today's cutoff (24 hours ago)\n    let today_cutoff = Local::now() - Duration::hours(24);\n\n    // Track which specs are ready (for ready queue)\n    let mut ready_specs = Vec::new();\n\n    for spec in \u0026specs {\n        // Skip cancelled specs\n        if spec.frontmatter.status == SpecStatus::Cancelled {\n            continue;\n        }\n\n        // Count by status\n        let status_key = match spec.frontmatter.status {\n            SpecStatus::Pending =\u003e \"pending\",\n            SpecStatus::InProgress =\u003e \"in_progress\",\n            SpecStatus::Paused =\u003e \"paused\",\n            SpecStatus::Completed =\u003e \"completed\",\n            SpecStatus::Failed | SpecStatus::NeedsAttention =\u003e \"failed\",\n            SpecStatus::Blocked =\u003e \"blocked\",\n            SpecStatus::Ready =\u003e \"ready\",\n            SpecStatus::Cancelled =\u003e continue, // Already filtered above\n        };\n\n        if let Some(count) = data.counts.get_mut(status_key) {\n            *count += 1;\n        }\n\n        // Track ready specs\n        if spec.is_ready(\u0026specs) {\n            ready_specs.push(spec);\n        }\n\n        // Today's activity - completed specs\n        if spec.frontmatter.status == SpecStatus::Completed {\n            if let Some(ref completed_at) = spec.frontmatter.completed_at {\n                if let Some(completed_time) = parse_timestamp(completed_at) {\n                    if completed_time \u003e= today_cutoff {\n                        data.today.completed += 1;\n                    }\n                }\n            }\n        }\n\n        // Today's activity - started specs (moved to in_progress)\n        // We approximate this using file modification time since we don't track status change history\n        if spec.frontmatter.status == SpecStatus::InProgress {\n            let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n            if let Some(modified_time) = get_file_modified_time(\u0026spec_path) {\n                if modified_time \u003e= today_cutoff {\n                    data.today.started += 1;\n                }\n            }\n        }\n\n        // Today's activity - created specs\n        // Use file creation time as proxy for spec creation\n        let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n        if let Some(created_time) = get_file_modified_time(\u0026spec_path) {\n            if created_time \u003e= today_cutoff {\n                data.today.created += 1;\n            }\n        }\n\n        // Attention items (failed or blocked)\n        if matches!(\n            spec.frontmatter.status,\n            SpecStatus::Failed | SpecStatus::NeedsAttention | SpecStatus::Blocked\n        ) {\n            let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n            if let Some(modified_time) = get_file_modified_time(\u0026spec_path) {\n                data.attention.push(AttentionItem {\n                    id: spec.id.clone(),\n                    title: spec.title.clone(),\n                    status: spec.frontmatter.status.clone(),\n                    ago: format_ago(modified_time),\n                });\n            }\n        }\n\n        // In-progress items\n        if spec.frontmatter.status == SpecStatus::InProgress {\n            let spec_path = specs_dir.join(format!(\"{}.md\", spec.id));\n            if let Some(modified_time) = get_file_modified_time(\u0026spec_path) {\n                let elapsed = Local::now()\n                    .signed_duration_since(modified_time)\n                    .num_minutes();\n                data.in_progress.push(InProgressItem {\n                    id: spec.id.clone(),\n                    title: spec.title.clone(),\n                    elapsed_minutes: elapsed,\n                });\n            }\n        }\n    }\n\n    // Update ready count\n    data.ready_count = ready_specs.len();\n    *data.counts.get_mut(\"ready\").unwrap() = ready_specs.len();\n\n    // Ready queue (first 5)\n    data.ready = ready_specs\n        .iter()\n        .take(5)\n        .map(|spec| ReadyItem {\n            id: spec.id.clone(),\n            title: spec.title.clone(),\n        })\n        .collect();\n\n    Ok(data)\n}\n\n/// Format StatusData as pretty-printed JSON\npub fn format_status_as_json(data: \u0026StatusData) -\u003e Result\u003cString\u003e {\n    // Build JSON structure matching the spec requirements\n    let json_value = json!({\n        \"counts\": data.counts,\n        \"today\": {\n            \"completed\": data.today.completed,\n            \"started\": data.today.started,\n            \"created\": data.today.created,\n        },\n        \"attention\": data.attention.iter().map(|item| {\n            json!({\n                \"id\": item.id,\n                \"title\": item.title,\n                \"status\": match item.status {\n                    SpecStatus::Failed =\u003e \"failed\",\n                    SpecStatus::NeedsAttention =\u003e \"needs_attention\",\n                    SpecStatus::Blocked =\u003e \"blocked\",\n                    _ =\u003e \"unknown\",\n                },\n                \"ago\": item.ago,\n            })\n        }).collect::\u003cVec\u003c_\u003e\u003e(),\n        \"in_progress\": data.in_progress.iter().map(|item| {\n            json!({\n                \"id\": item.id,\n                \"title\": item.title,\n                \"elapsed_minutes\": item.elapsed_minutes,\n            })\n        }).collect::\u003cVec\u003c_\u003e\u003e(),\n        \"ready\": data.ready.iter().map(|item| {\n            json!({\n                \"id\": item.id,\n                \"title\": item.title,\n            })\n        }).collect::\u003cVec\u003c_\u003e\u003e(),\n        \"ready_count\": data.ready_count,\n    });\n\n    // Pretty-print with 2-space indentation\n    let json_string = serde_json::to_string_pretty(\u0026json_value)?;\n    Ok(json_string)\n}\n\nimpl StatusData {\n    /// Format status data as a brief single-line summary\n    ///\n    /// Output format: \"chant: X done, Y running, Z ready, W failed\"\n    /// Omits sections with 0 count.\n    /// Special case: if all counts are 0, returns \"chant: no specs\"\n    pub fn format_brief(\u0026self) -\u003e String {\n        let completed = *self.counts.get(\"completed\").unwrap_or(\u00260);\n        let in_progress = *self.counts.get(\"in_progress\").unwrap_or(\u00260);\n        let ready = *self.counts.get(\"ready\").unwrap_or(\u00260);\n        let failed = *self.counts.get(\"failed\").unwrap_or(\u00260);\n\n        // Special case: no specs at all\n        if completed == 0 \u0026\u0026 in_progress == 0 \u0026\u0026 ready == 0 \u0026\u0026 failed == 0 {\n            return \"chant: no specs\".to_string();\n        }\n\n        let mut parts = Vec::new();\n\n        if completed \u003e 0 {\n            parts.push(format!(\"{} done\", completed));\n        }\n        if in_progress \u003e 0 {\n            parts.push(format!(\"{} running\", in_progress));\n        }\n        if ready \u003e 0 {\n            parts.push(format!(\"{} ready\", ready));\n        }\n        if failed \u003e 0 {\n            parts.push(format!(\"{} failed\", failed));\n        }\n\n        format!(\"chant: {}\", parts.join(\", \"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_format_ago() {\n        let now = Local::now();\n\n        // Less than a minute\n        let recent = now - Duration::seconds(30);\n        assert_eq!(format_ago(recent), \"now ago\");\n\n        // Minutes\n        let mins = now - Duration::minutes(45);\n        assert_eq!(format_ago(mins), \"45m ago\");\n\n        // Hours\n        let hours = now - Duration::hours(5);\n        assert_eq!(format_ago(hours), \"5h ago\");\n\n        // Days\n        let days = now - Duration::days(3);\n        assert_eq!(format_ago(days), \"3d ago\");\n    }\n\n    #[test]\n    fn test_empty_specs_directory() {\n        let temp_dir = tempfile::tempdir().unwrap();\n        let specs_dir = temp_dir.path().join(\"nonexistent\");\n\n        let result = aggregate_status(\u0026specs_dir).unwrap();\n\n        assert_eq!(*result.counts.get(\"pending\").unwrap(), 0);\n        assert_eq!(*result.counts.get(\"in_progress\").unwrap(), 0);\n        assert_eq!(*result.counts.get(\"completed\").unwrap(), 0);\n        assert_eq!(*result.counts.get(\"failed\").unwrap(), 0);\n        assert_eq!(result.today.completed, 0);\n        assert_eq!(result.today.started, 0);\n        assert_eq!(result.today.created, 0);\n        assert!(result.attention.is_empty());\n        assert!(result.in_progress.is_empty());\n        assert!(result.ready.is_empty());\n        assert_eq!(result.ready_count, 0);\n    }\n\n    #[test]\n    fn test_format_brief_no_specs() {\n        let data = StatusData::default();\n        assert_eq!(data.format_brief(), \"chant: no specs\");\n    }\n\n    #[test]\n    fn test_format_brief_all_statuses() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"completed\".to_string(), 45);\n        data.counts.insert(\"in_progress\".to_string(), 3);\n        data.counts.insert(\"ready\".to_string(), 8);\n        data.counts.insert(\"failed\".to_string(), 1);\n\n        assert_eq!(\n            data.format_brief(),\n            \"chant: 45 done, 3 running, 8 ready, 1 failed\"\n        );\n    }\n\n    #[test]\n    fn test_format_brief_only_completed() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"completed\".to_string(), 10);\n\n        assert_eq!(data.format_brief(), \"chant: 10 done\");\n    }\n\n    #[test]\n    fn test_format_brief_omit_zero_counts() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"completed\".to_string(), 5);\n        data.counts.insert(\"in_progress\".to_string(), 0);\n        data.counts.insert(\"ready\".to_string(), 2);\n        data.counts.insert(\"failed\".to_string(), 0);\n\n        assert_eq!(data.format_brief(), \"chant: 5 done, 2 ready\");\n    }\n\n    #[test]\n    fn test_format_brief_single_line() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"completed\".to_string(), 100);\n        data.counts.insert(\"in_progress\".to_string(), 50);\n\n        let result = data.format_brief();\n        assert!(!result.contains('\\n'));\n    }\n\n    #[test]\n    fn test_format_status_as_json_all_fields() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"pending\".to_string(), 5);\n        data.counts.insert(\"in_progress\".to_string(), 2);\n        data.counts.insert(\"completed\".to_string(), 10);\n        data.counts.insert(\"failed\".to_string(), 1);\n        data.counts.insert(\"blocked\".to_string(), 0);\n        data.counts.insert(\"ready\".to_string(), 3);\n\n        data.today.completed = 2;\n        data.today.started = 1;\n        data.today.created = 3;\n\n        data.attention.push(AttentionItem {\n            id: \"2026-01-30-abc\".to_string(),\n            title: Some(\"Fix bug\".to_string()),\n            status: SpecStatus::Failed,\n            ago: \"2h ago\".to_string(),\n        });\n\n        data.in_progress.push(InProgressItem {\n            id: \"2026-01-30-def\".to_string(),\n            title: Some(\"Add feature\".to_string()),\n            elapsed_minutes: 45,\n        });\n\n        data.ready.push(ReadyItem {\n            id: \"2026-01-30-ghi\".to_string(),\n            title: Some(\"Ready task\".to_string()),\n        });\n        data.ready_count = 3;\n\n        let json_str = format_status_as_json(\u0026data).unwrap();\n\n        // Verify it's valid JSON\n        let parsed: serde_json::Value = serde_json::from_str(\u0026json_str).unwrap();\n\n        // Verify top-level keys\n        assert!(parsed.get(\"counts\").is_some());\n        assert!(parsed.get(\"today\").is_some());\n        assert!(parsed.get(\"attention\").is_some());\n        assert!(parsed.get(\"in_progress\").is_some());\n        assert!(parsed.get(\"ready\").is_some());\n        assert!(parsed.get(\"ready_count\").is_some());\n\n        // Verify counts structure\n        assert_eq!(parsed[\"counts\"][\"pending\"], 5);\n        assert_eq!(parsed[\"counts\"][\"in_progress\"], 2);\n        assert_eq!(parsed[\"counts\"][\"completed\"], 10);\n\n        // Verify today structure\n        assert_eq!(parsed[\"today\"][\"completed\"], 2);\n        assert_eq!(parsed[\"today\"][\"started\"], 1);\n        assert_eq!(parsed[\"today\"][\"created\"], 3);\n\n        // Verify attention array\n        assert!(parsed[\"attention\"].is_array());\n        assert_eq!(parsed[\"attention\"][0][\"id\"], \"2026-01-30-abc\");\n        assert_eq!(parsed[\"attention\"][0][\"status\"], \"failed\");\n        assert_eq!(parsed[\"attention\"][0][\"ago\"], \"2h ago\");\n\n        // Verify in_progress array\n        assert!(parsed[\"in_progress\"].is_array());\n        assert_eq!(parsed[\"in_progress\"][0][\"id\"], \"2026-01-30-def\");\n        assert_eq!(parsed[\"in_progress\"][0][\"elapsed_minutes\"], 45);\n\n        // Verify ready array\n        assert!(parsed[\"ready\"].is_array());\n        assert_eq!(parsed[\"ready\"][0][\"id\"], \"2026-01-30-ghi\");\n\n        // Verify ready_count\n        assert_eq!(parsed[\"ready_count\"], 3);\n    }\n\n    #[test]\n    fn test_format_status_as_json_empty_lists() {\n        let mut data = StatusData::default();\n        data.counts.insert(\"pending\".to_string(), 0);\n        data.counts.insert(\"in_progress\".to_string(), 0);\n\n        let json_str = format_status_as_json(\u0026data).unwrap();\n        let parsed: serde_json::Value = serde_json::from_str(\u0026json_str).unwrap();\n\n        // Empty lists should be empty arrays, not null\n        assert!(parsed[\"attention\"].is_array());\n        assert_eq!(parsed[\"attention\"].as_array().unwrap().len(), 0);\n        assert!(parsed[\"in_progress\"].is_array());\n        assert_eq!(parsed[\"in_progress\"].as_array().unwrap().len(), 0);\n        assert!(parsed[\"ready\"].is_array());\n        assert_eq!(parsed[\"ready\"].as_array().unwrap().len(), 0);\n    }\n\n    #[test]\n    fn test_format_status_as_json_special_characters() {\n        let mut data = StatusData::default();\n        data.ready.push(ReadyItem {\n            id: \"2026-01-30-xyz\".to_string(),\n            title: Some(\"Title with \\\"quotes\\\" and \\\\ backslash\".to_string()),\n        });\n\n        let json_str = format_status_as_json(\u0026data).unwrap();\n\n        // Verify it's valid JSON (should properly escape special chars)\n        let parsed: serde_json::Value = serde_json::from_str(\u0026json_str).unwrap();\n        assert_eq!(\n            parsed[\"ready\"][0][\"title\"],\n            \"Title with \\\"quotes\\\" and \\\\ backslash\"\n        );\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":16}},{"line":81,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":6}},{"line":256,"address":[],"length":0,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":10}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":10}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":11}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":5}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":292,"address":[],"length":0,"stats":{"Line":9}},{"line":293,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":25}},{"line":304,"address":[],"length":0,"stats":{"Line":25}},{"line":305,"address":[],"length":0,"stats":{"Line":25}},{"line":306,"address":[],"length":0,"stats":{"Line":25}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":8}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":6}},{"line":319,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":6}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":5}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":12}}],"covered":69,"coverable":146},{"path":["/","Users","alex","Documents","checkouts","chant","src","takeover.rs"],"content":"//! Takeover command for intervening in running work processes\n//!\n//! Allows users to stop an autonomous agent and continue with manual guidance.\n\nuse anyhow::{Context, Result};\nuse colored::Colorize;\nuse std::fs;\nuse std::path::PathBuf;\n\nuse crate::paths::LOGS_DIR;\nuse crate::pid;\nuse crate::spec::{self, SpecStatus};\n\n/// Result of a takeover operation\npub struct TakeoverResult {\n    pub spec_id: String,\n    pub analysis: String,\n    pub log_tail: String,\n    pub suggestion: String,\n}\n\n/// Takeover a spec that is currently being worked on\npub fn cmd_takeover(id: \u0026str, force: bool) -\u003e Result\u003cTakeoverResult\u003e {\n    let specs_dir = PathBuf::from(crate::paths::SPECS_DIR);\n    if !specs_dir.exists() {\n        anyhow::bail!(\"Not a chant project (no .chant/ directory found)\");\n    }\n\n    // Resolve the spec ID\n    let mut spec = spec::resolve_spec(\u0026specs_dir, id)?;\n    let spec_id = spec.id.clone();\n    let spec_path = specs_dir.join(format!(\"{}.md\", spec_id));\n\n    println!(\"{} Taking over spec {}\", \"â\".cyan(), spec_id.cyan());\n\n    // Pause the work (stops process and sets status to paused)\n    let pid = pid::read_pid_file(\u0026spec_id)?;\n    let was_running = if let Some(pid) = pid {\n        if pid::is_process_running(pid) {\n            println!(\"  {} Stopping running process (PID: {})\", \"â¢\".cyan(), pid);\n            pid::stop_process(pid)?;\n            pid::remove_pid_file(\u0026spec_id)?;\n            println!(\"  {} Process stopped\", \"â\".green());\n            true\n        } else {\n            println!(\"  {} Cleaning up stale PID file\", \"â¢\".cyan());\n            pid::remove_pid_file(\u0026spec_id)?;\n            false\n        }\n    } else {\n        if !force {\n            anyhow::bail!(\n                \"Spec {} is not currently running. Use --force to analyze anyway.\",\n                spec_id\n            );\n        }\n        false\n    };\n\n    // Read and analyze the log\n    let log_path = PathBuf::from(LOGS_DIR).join(format!(\"{}.log\", spec_id));\n    let (log_tail, analysis) = if log_path.exists() {\n        let log_content = fs::read_to_string(\u0026log_path)\n            .with_context(|| format!(\"Failed to read log file: {}\", log_path.display()))?;\n\n        let tail = get_log_tail(\u0026log_content, 50);\n        let analysis = analyze_log(\u0026log_content);\n\n        (tail, analysis)\n    } else {\n        (\n            \"No log file found\".to_string(),\n            \"No execution log available for analysis\".to_string(),\n        )\n    };\n\n    // Generate suggestion based on spec status and analysis\n    let suggestion = generate_suggestion(\u0026spec, \u0026analysis);\n\n    // Update spec status to paused if it was in_progress\n    if spec.frontmatter.status == SpecStatus::InProgress {\n        spec.frontmatter.status = SpecStatus::Paused;\n    }\n\n    // Append takeover analysis to spec body\n    let takeover_section = format!(\n        \"\\n\\n## Takeover Analysis\\n\\n{}\\n\\n### Recent Log Activity\\n\\n```\\n{}\\n```\\n\\n### Recommendation\\n\\n{}\\n\",\n        analysis,\n        log_tail,\n        suggestion\n    );\n\n    spec.body.push_str(\u0026takeover_section);\n    spec.save(\u0026spec_path)?;\n\n    println!(\"{} Updated spec with takeover analysis\", \"â\".green());\n    if was_running {\n        println!(\"  {} Status set to: paused\", \"â¢\".cyan());\n    }\n    println!(\"  {} Analysis appended to spec body\", \"â¢\".cyan());\n\n    Ok(TakeoverResult {\n        spec_id,\n        analysis,\n        log_tail,\n        suggestion,\n    })\n}\n\n/// Get the last N lines from a log\nfn get_log_tail(log_content: \u0026str, lines: usize) -\u003e String {\n    log_content\n        .lines()\n        .rev()\n        .take(lines)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .into_iter()\n        .rev()\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\\n\")\n}\n\n/// Analyze log content to understand what went wrong\nfn analyze_log(log_content: \u0026str) -\u003e String {\n    let lines: Vec\u003c\u0026str\u003e = log_content.lines().collect();\n\n    if lines.is_empty() {\n        return \"Log is empty - no execution activity recorded.\".to_string();\n    }\n\n    let mut analysis = Vec::new();\n\n    // Check for common error patterns\n    let error_indicators = [\"error:\", \"failed:\", \"ERROR\", \"FAIL\", \"exception\", \"panic\"];\n    let errors: Vec\u003c\u0026str\u003e = lines\n        .iter()\n        .filter(|line| {\n            error_indicators\n                .iter()\n                .any(|indicator| line.to_lowercase().contains(indicator))\n        })\n        .copied()\n        .collect();\n\n    if !errors.is_empty() {\n        analysis.push(format!(\"Found {} error indicator(s) in log:\", errors.len()));\n        for error in errors.iter().take(3) {\n            analysis.push(format!(\"  - {}\", error.trim()));\n        }\n        if errors.len() \u003e 3 {\n            analysis.push(format!(\"  ... and {} more\", errors.len() - 3));\n        }\n    }\n\n    // Check for tool usage patterns\n    let tool_indicators = [\n        \"\u003cfunction_calls\u003e\",\n        \"tool_name\",\n        \"Bash\",\n        \"Read\",\n        \"Edit\",\n        \"Write\",\n    ];\n    let tool_uses: Vec\u003c\u0026str\u003e = lines\n        .iter()\n        .filter(|line| {\n            tool_indicators\n                .iter()\n                .any(|indicator| line.contains(indicator))\n        })\n        .copied()\n        .collect();\n\n    if !tool_uses.is_empty() {\n        analysis.push(format!(\"\\nAgent made {} tool call(s)\", tool_uses.len()));\n    }\n\n    // Check for completion indicators\n    let completion_indicators = [\"completed\", \"finished\", \"done\", \"success\"];\n    let has_completion = lines.iter().any(|line| {\n        completion_indicators\n            .iter()\n            .any(|indicator| line.to_lowercase().contains(indicator))\n    });\n\n    if has_completion {\n        analysis.push(\"\\nLog contains completion indicators.\".to_string());\n    }\n\n    // Estimate progress\n    let total_lines = lines.len();\n    analysis.push(format!(\"\\nLog contains {} lines of output.\", total_lines));\n\n    if errors.is_empty() \u0026\u0026 !has_completion {\n        analysis.push(\"\\nNo errors detected, but work appears incomplete.\".to_string());\n    }\n\n    if analysis.is_empty() {\n        \"Agent execution started but no significant activity detected.\".to_string()\n    } else {\n        analysis.join(\"\\n\")\n    }\n}\n\n/// Generate a suggestion based on spec and analysis\nfn generate_suggestion(spec: \u0026spec::Spec, analysis: \u0026str) -\u003e String {\n    let mut suggestions: Vec\u003cString\u003e = Vec::new();\n\n    // Check if there are errors\n    if analysis.to_lowercase().contains(\"error\") {\n        suggestions\n            .push(\"Review the errors in the log and address them before resuming.\".to_string());\n    }\n\n    // Check acceptance criteria\n    let unchecked = spec.count_unchecked_checkboxes();\n    if unchecked \u003e 0 {\n        suggestions.push(format!(\n            \"{} acceptance criteria remain unchecked.\",\n            unchecked\n        ));\n    }\n\n    // General suggestions\n    suggestions.push(\"Continue working on this spec manually or adjust the approach.\".to_string());\n    suggestions\n        .push(\"When ready to resume automated work, use `chant work \u003cspec-id\u003e`.\".to_string());\n\n    suggestions.join(\"\\n\")\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":10}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":20}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":32,"address":[],"length":0,"stats":{"Line":15}},{"line":34,"address":[],"length":0,"stats":{"Line":20}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":9}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":12}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":67,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":16}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":20}},{"line":135,"address":[],"length":0,"stats":{"Line":12}},{"line":137,"address":[],"length":0,"stats":{"Line":20}},{"line":138,"address":[],"length":0,"stats":{"Line":16}},{"line":139,"address":[],"length":0,"stats":{"Line":16}},{"line":140,"address":[],"length":0,"stats":{"Line":304}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":8}},{"line":159,"address":[],"length":0,"stats":{"Line":8}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":20}},{"line":167,"address":[],"length":0,"stats":{"Line":16}},{"line":168,"address":[],"length":0,"stats":{"Line":16}},{"line":169,"address":[],"length":0,"stats":{"Line":280}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":8}},{"line":179,"address":[],"length":0,"stats":{"Line":12}},{"line":180,"address":[],"length":0,"stats":{"Line":28}},{"line":181,"address":[],"length":0,"stats":{"Line":16}},{"line":182,"address":[],"length":0,"stats":{"Line":16}},{"line":183,"address":[],"length":0,"stats":{"Line":208}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":192,"address":[],"length":0,"stats":{"Line":12}},{"line":194,"address":[],"length":0,"stats":{"Line":16}},{"line":195,"address":[],"length":0,"stats":{"Line":12}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":12}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":217,"address":[],"length":0,"stats":{"Line":8}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":16}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":8}}],"covered":94,"coverable":108},{"path":["/","Users","alex","Documents","checkouts","chant","src","templates.rs"],"content":"//! Agent configuration templates for AI providers.\n//!\n//! # Doc Audit\n//! - ignore: internal implementation detail\n\nuse anyhow::{anyhow, Result};\nuse std::fmt;\n\n/// Supported AI provider types for agent configuration\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum AgentProvider {\n    Claude,\n    Cursor,\n    AmazonQ,\n    Generic,\n}\n\nimpl AgentProvider {\n    /// Get the string identifier for this provider\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Claude =\u003e \"claude\",\n            Self::Cursor =\u003e \"cursor\",\n            Self::AmazonQ =\u003e \"amazonq\",\n            Self::Generic =\u003e \"generic\",\n        }\n    }\n\n    /// Get the config file name for this provider\n    pub fn config_filename(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Claude =\u003e \"CLAUDE.md\",\n            Self::Cursor =\u003e \".cursorrules\",\n            Self::AmazonQ =\u003e \".amazonq/rules.md\",\n            Self::Generic =\u003e \".ai-instructions\",\n        }\n    }\n\n    /// Returns true if this provider supports MCP and should generate config.\n    /// Used in tests to verify MCP support; production code uses mcp_config_filename() directly.\n    #[allow(dead_code)]\n    pub fn supports_mcp(\u0026self) -\u003e bool {\n        match self {\n            Self::Claude =\u003e true,\n            Self::Cursor =\u003e true,\n            Self::AmazonQ =\u003e false,\n            Self::Generic =\u003e false,\n        }\n    }\n\n    /// Get MCP config filename if provider supports MCP\n    pub fn mcp_config_filename(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Claude =\u003e Some(\".mcp.json\"),\n            Self::Cursor =\u003e Some(\".cursor/mcp.json\"),\n            _ =\u003e None,\n        }\n    }\n}\n\nimpl fmt::Display for AgentProvider {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\n\n/// Template metadata and content\npub struct AgentTemplate {\n    pub provider: AgentProvider,\n    pub content: \u0026'static str,\n}\n\n/// Embedded templates for each provider\nconst CLAUDE_TEMPLATE: \u0026str = include_str!(\"../templates/agent-claude.md\");\nconst CURSOR_TEMPLATE: \u0026str = include_str!(\"../templates/agent-cursor.md\");\nconst AMAZONQ_TEMPLATE: \u0026str = include_str!(\"../templates/agent-amazonq.md\");\nconst GENERIC_TEMPLATE: \u0026str = include_str!(\"../templates/agent-generic.md\");\n\n/// Compact chant section for injection into existing CLAUDE.md files\nconst CHANT_SECTION: \u0026str = include_str!(\"../templates/chant-section.md\");\n/// Even more compact section when MCP is available (agent discovers commands via tools)\nconst CHANT_SECTION_MCP: \u0026str = include_str!(\"../templates/chant-section-mcp.md\");\n\n/// Markers for the chant section in CLAUDE.md\npub const CHANT_SECTION_BEGIN: \u0026str = \"\u003c!-- chant:begin --\u003e\";\npub const CHANT_SECTION_END: \u0026str = \"\u003c!-- chant:end --\u003e\";\n\n/// Get a template by provider name (case-insensitive)\npub fn get_template(provider_str: \u0026str) -\u003e Result\u003cAgentTemplate\u003e {\n    let provider = match provider_str.to_lowercase().as_str() {\n        \"claude\" =\u003e AgentProvider::Claude,\n        \"cursor\" =\u003e AgentProvider::Cursor,\n        \"amazonq\" =\u003e AgentProvider::AmazonQ,\n        \"generic\" =\u003e AgentProvider::Generic,\n        _ =\u003e {\n            return Err(anyhow!(\n                \"Unknown agent provider '{}'. Valid providers: claude, cursor, amazonq, generic\",\n                provider_str\n            ))\n        }\n    };\n    Ok(get_template_for_provider(provider))\n}\n\n/// Get a template for a specific provider\nfn get_template_for_provider(provider: AgentProvider) -\u003e AgentTemplate {\n    let content = match provider {\n        AgentProvider::Claude =\u003e CLAUDE_TEMPLATE,\n        AgentProvider::Cursor =\u003e CURSOR_TEMPLATE,\n        AgentProvider::AmazonQ =\u003e AMAZONQ_TEMPLATE,\n        AgentProvider::Generic =\u003e GENERIC_TEMPLATE,\n    };\n    AgentTemplate { provider, content }\n}\n\n/// Parse a list of agent provider specifications into a deduplicated, validated list\n///\n/// Supports:\n/// - Single providers: \"claude\", \"cursor\", etc.\n/// - Special keyword \"all\" which expands to all providers\n/// - Case-insensitive matching\n///\n/// Returns a deduplicated sorted list of providers.\npub fn parse_agent_providers(agent_specs: \u0026[String]) -\u003e Result\u003cVec\u003cAgentProvider\u003e\u003e {\n    if agent_specs.is_empty() {\n        return Ok(vec![]);\n    }\n\n    let mut providers = std::collections::HashSet::new();\n\n    for spec in agent_specs {\n        let lower = spec.to_lowercase();\n\n        if lower == \"all\" {\n            // Add all providers\n            providers.insert(AgentProvider::Claude);\n            providers.insert(AgentProvider::Cursor);\n            providers.insert(AgentProvider::AmazonQ);\n            providers.insert(AgentProvider::Generic);\n        } else {\n            // Validate and add single provider\n            let template = get_template(\u0026lower)?;\n            providers.insert(template.provider);\n        }\n    }\n\n    // Convert to sorted vec for consistent ordering\n    let mut result: Vec\u003c_\u003e = providers.into_iter().collect();\n    result.sort_by_key(|p| p.as_str());\n    Ok(result)\n}\n\n/// Get the compact chant section for injection into existing files\n///\n/// # Arguments\n/// * `has_mcp` - If true, returns the even more compact MCP version\npub fn get_chant_section(has_mcp: bool) -\u003e \u0026'static str {\n    if has_mcp {\n        CHANT_SECTION_MCP\n    } else {\n        CHANT_SECTION\n    }\n}\n\n/// Result of injecting the chant section into a file\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InjectionResult {\n    /// Created new file with just the chant section\n    Created(String),\n    /// Appended section to existing file\n    Appended(String),\n    /// Replaced existing section between markers\n    Replaced(String),\n    /// File already has up-to-date section\n    Unchanged,\n}\n\n/// Inject or update the chant section in an existing CLAUDE.md file\n///\n/// # Behavior\n/// - If `existing_content` is None: Returns just the chant section (for new files)\n/// - If content has no markers: Appends chant section at end\n/// - If content has markers: Replaces content between markers\n///\n/// # Arguments\n/// * `existing_content` - The current file content, or None if file doesn't exist\n/// * `has_mcp` - If true, uses the compact MCP-aware template\npub fn inject_chant_section(existing_content: Option\u003c\u0026str\u003e, has_mcp: bool) -\u003e InjectionResult {\n    let section = get_chant_section(has_mcp);\n\n    match existing_content {\n        None =\u003e {\n            // No existing file - create with just the chant section\n            InjectionResult::Created(section.to_string())\n        }\n        Some(content) =\u003e {\n            // Check if markers exist\n            let begin_pos = content.find(CHANT_SECTION_BEGIN);\n            let end_pos = content.find(CHANT_SECTION_END);\n\n            match (begin_pos, end_pos) {\n                (Some(begin), Some(end)) if begin \u003c end =\u003e {\n                    // Both markers found in correct order - replace between them\n                    let end_marker_end = end + CHANT_SECTION_END.len();\n\n                    // Include trailing newline in the section boundary if present\n                    // Handle both Unix (\\n) and Windows (\\r\\n) line endings\n                    let section_end = if content[end_marker_end..].starts_with(\"\\r\\n\") {\n                        end_marker_end + 2\n                    } else if content[end_marker_end..].starts_with('\\n') {\n                        end_marker_end + 1\n                    } else {\n                        end_marker_end\n                    };\n\n                    let before = \u0026content[..begin];\n                    let after = \u0026content[section_end..];\n\n                    // Normalize line endings for comparison (handle CRLF in both template and content)\n                    let existing_section = \u0026content[begin..section_end];\n                    let existing_normalized = existing_section.replace(\"\\r\\n\", \"\\n\");\n                    let section_normalized = section.replace(\"\\r\\n\", \"\\n\");\n                    if existing_normalized == section_normalized {\n                        return InjectionResult::Unchanged;\n                    }\n\n                    let new_content = format!(\"{}{}{}\", before, section, after);\n                    InjectionResult::Replaced(new_content)\n                }\n                _ =\u003e {\n                    // No markers or invalid order - append at end\n                    let new_content = if content.ends_with('\\n') {\n                        format!(\"{}\\n{}\", content, section)\n                    } else {\n                        format!(\"{}\\n\\n{}\", content, section)\n                    };\n                    InjectionResult::Appended(new_content)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_template_case_insensitive() {\n        assert!(get_template(\"claude\").is_ok());\n        assert!(get_template(\"CLAUDE\").is_ok());\n        assert!(get_template(\"Claude\").is_ok());\n        assert!(get_template(\"cursor\").is_ok());\n        assert!(get_template(\"AMAZONQ\").is_ok());\n        assert!(get_template(\"generic\").is_ok());\n    }\n\n    #[test]\n    fn test_get_template_invalid() {\n        assert!(get_template(\"invalid-provider\").is_err());\n        assert!(get_template(\"python\").is_err());\n    }\n\n    #[test]\n    fn test_parse_agent_providers_single() {\n        let specs = vec![\"claude\".to_string()];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 1);\n        assert_eq!(providers[0], AgentProvider::Claude);\n    }\n\n    #[test]\n    fn test_parse_agent_providers_multiple() {\n        let specs = vec![\"claude\".to_string(), \"cursor\".to_string()];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 2);\n        assert!(providers.contains(\u0026AgentProvider::Claude));\n        assert!(providers.contains(\u0026AgentProvider::Cursor));\n    }\n\n    #[test]\n    fn test_parse_agent_providers_all() {\n        let specs = vec![\"all\".to_string()];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 4);\n        assert!(providers.contains(\u0026AgentProvider::Claude));\n        assert!(providers.contains(\u0026AgentProvider::Cursor));\n        assert!(providers.contains(\u0026AgentProvider::AmazonQ));\n        assert!(providers.contains(\u0026AgentProvider::Generic));\n    }\n\n    #[test]\n    fn test_parse_agent_providers_deduplication() {\n        let specs = vec![\n            \"claude\".to_string(),\n            \"claude\".to_string(),\n            \"cursor\".to_string(),\n        ];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 2);\n    }\n\n    #[test]\n    fn test_parse_agent_providers_case_insensitive() {\n        let specs = vec![\"CLAUDE\".to_string(), \"Cursor\".to_string()];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 2);\n        assert!(providers.contains(\u0026AgentProvider::Claude));\n        assert!(providers.contains(\u0026AgentProvider::Cursor));\n    }\n\n    #[test]\n    fn test_parse_agent_providers_empty() {\n        let specs = vec![];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 0);\n    }\n\n    #[test]\n    fn test_parse_agent_providers_invalid() {\n        let specs = vec![\"invalid\".to_string()];\n        assert!(parse_agent_providers(\u0026specs).is_err());\n    }\n\n    #[test]\n    fn test_parse_agent_providers_all_with_individual() {\n        let specs = vec![\"all\".to_string(), \"claude\".to_string()];\n        let providers = parse_agent_providers(\u0026specs).unwrap();\n        assert_eq!(providers.len(), 4); // \"all\" expands to all 4, claude is already included\n    }\n\n    #[test]\n    fn test_get_chant_section_standard() {\n        let section = get_chant_section(false);\n        assert!(section.starts_with(CHANT_SECTION_BEGIN));\n        // Section ends with end marker followed by newline\n        assert!(section.trim_end().ends_with(CHANT_SECTION_END));\n        assert!(section.contains(\"orchestrator\"));\n        assert!(section.contains(\"chant work\"));\n    }\n\n    #[test]\n    fn test_get_chant_section_mcp() {\n        let section = get_chant_section(true);\n        assert!(section.starts_with(CHANT_SECTION_BEGIN));\n        // Section ends with end marker followed by newline\n        assert!(section.trim_end().ends_with(CHANT_SECTION_END));\n        assert!(section.contains(\"orchestrator\"));\n        assert!(section.contains(\"MCP\")); // MCP-specific content\n    }\n\n    #[test]\n    fn test_inject_chant_section_no_existing_file() {\n        let result = inject_chant_section(None, false);\n        match result {\n            InjectionResult::Created(content) =\u003e {\n                assert!(content.starts_with(CHANT_SECTION_BEGIN));\n                // Content ends with end marker followed by newline\n                assert!(content.trim_end().ends_with(CHANT_SECTION_END));\n            }\n            _ =\u003e panic!(\"Expected Created result\"),\n        }\n    }\n\n    #[test]\n    fn test_inject_chant_section_existing_no_markers() {\n        let existing = \"# My Project\\n\\nSome existing content.\\n\";\n        let result = inject_chant_section(Some(existing), false);\n        match result {\n            InjectionResult::Appended(content) =\u003e {\n                // Should preserve original content\n                assert!(content.starts_with(\"# My Project\"));\n                // Should have markers at end\n                assert!(content.contains(CHANT_SECTION_BEGIN));\n                // Content ends with end marker followed by newline\n                assert!(content.trim_end().ends_with(CHANT_SECTION_END));\n            }\n            _ =\u003e panic!(\"Expected Appended result\"),\n        }\n    }\n\n    #[test]\n    fn test_inject_chant_section_existing_with_markers() {\n        let existing = format!(\n            \"# My Project\\n\\n{}\\nOld chant content\\n{}\\n\\n## Other section\",\n            CHANT_SECTION_BEGIN, CHANT_SECTION_END\n        );\n        let result = inject_chant_section(Some(\u0026existing), false);\n        match result {\n            InjectionResult::Replaced(content) =\u003e {\n                // Should preserve content before and after\n                assert!(content.starts_with(\"# My Project\"));\n                assert!(content.contains(\"## Other section\"));\n                // Should NOT have old content\n                assert!(!content.contains(\"Old chant content\"));\n                // Should have new markers\n                assert!(content.contains(CHANT_SECTION_BEGIN));\n                assert!(content.contains(CHANT_SECTION_END));\n            }\n            _ =\u003e panic!(\"Expected Replaced result\"),\n        }\n    }\n\n    #[test]\n    fn test_inject_chant_section_idempotent() {\n        // First injection\n        let result1 = inject_chant_section(None, false);\n        let content1 = match result1 {\n            InjectionResult::Created(c) =\u003e c,\n            _ =\u003e panic!(\"Expected Created\"),\n        };\n\n        // Second injection on same content\n        let result2 = inject_chant_section(Some(\u0026content1), false);\n        assert_eq!(result2, InjectionResult::Unchanged);\n    }\n\n    #[test]\n    fn test_inject_chant_section_preserves_surrounding_content() {\n        let existing = \"# Header\\n\\nIntro paragraph.\\n\\n## Code Style\\n\\nUse TypeScript.\\n\";\n        let result = inject_chant_section(Some(existing), false);\n        match result {\n            InjectionResult::Appended(content) =\u003e {\n                // All original content should be preserved\n                assert!(content.contains(\"# Header\"));\n                assert!(content.contains(\"Intro paragraph.\"));\n                assert!(content.contains(\"## Code Style\"));\n                assert!(content.contains(\"Use TypeScript.\"));\n            }\n            _ =\u003e panic!(\"Expected Appended result\"),\n        }\n    }\n\n    #[test]\n    fn test_inject_chant_section_mcp_variant() {\n        let result = inject_chant_section(None, true);\n        match result {\n            InjectionResult::Created(content) =\u003e {\n                // MCP version should mention MCP tools\n                assert!(content.contains(\"MCP\"));\n                assert!(content.contains(\"chant_\"));\n            }\n            _ =\u003e panic!(\"Expected Created result\"),\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":34}},{"line":21,"address":[],"length":0,"stats":{"Line":34}},{"line":22,"address":[],"length":0,"stats":{"Line":16}},{"line":23,"address":[],"length":0,"stats":{"Line":9}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":7}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":49}},{"line":91,"address":[],"length":0,"stats":{"Line":43}},{"line":92,"address":[],"length":0,"stats":{"Line":13}},{"line":93,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":23}},{"line":106,"address":[],"length":0,"stats":{"Line":23}},{"line":107,"address":[],"length":0,"stats":{"Line":46}},{"line":108,"address":[],"length":0,"stats":{"Line":17}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":52}},{"line":125,"address":[],"length":0,"stats":{"Line":104}},{"line":126,"address":[],"length":0,"stats":{"Line":41}},{"line":129,"address":[],"length":0,"stats":{"Line":22}},{"line":131,"address":[],"length":0,"stats":{"Line":27}},{"line":132,"address":[],"length":0,"stats":{"Line":32}},{"line":134,"address":[],"length":0,"stats":{"Line":18}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":8}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":42}},{"line":143,"address":[],"length":0,"stats":{"Line":39}},{"line":148,"address":[],"length":0,"stats":{"Line":50}},{"line":149,"address":[],"length":0,"stats":{"Line":72}},{"line":150,"address":[],"length":0,"stats":{"Line":10}},{"line":157,"address":[],"length":0,"stats":{"Line":16}},{"line":158,"address":[],"length":0,"stats":{"Line":16}},{"line":159,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":14}},{"line":189,"address":[],"length":0,"stats":{"Line":42}},{"line":191,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":7}},{"line":196,"address":[],"length":0,"stats":{"Line":7}},{"line":198,"address":[],"length":0,"stats":{"Line":21}},{"line":199,"address":[],"length":0,"stats":{"Line":21}},{"line":201,"address":[],"length":0,"stats":{"Line":14}},{"line":202,"address":[],"length":0,"stats":{"Line":20}},{"line":204,"address":[],"length":0,"stats":{"Line":15}},{"line":208,"address":[],"length":0,"stats":{"Line":15}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":15}},{"line":221,"address":[],"length":0,"stats":{"Line":20}},{"line":222,"address":[],"length":0,"stats":{"Line":20}},{"line":223,"address":[],"length":0,"stats":{"Line":5}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":6}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":2}}],"covered":73,"coverable":89},{"path":["/","Users","alex","Documents","checkouts","chant","src","tools.rs"],"content":"//! Tool definitions for ollama-rs function calling integration.\n//!\n//! These tools provide the agent with the ability to read files, write files,\n//! run commands, and list files during spec execution.\n\nuse anyhow::Result;\nuse serde_json::{json, Value};\nuse std::fs;\nuse std::process::Command;\n\n/// Get JSON schema definitions for all available tools.\n/// These schemas are passed to the ollama model to enable function calling.\npub fn get_tool_definitions() -\u003e Vec\u003cValue\u003e {\n    vec![\n        json!({\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"read_file\",\n                \"description\": \"Read the contents of a file at the given path\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"path\": {\n                            \"type\": \"string\",\n                            \"description\": \"File path to read\"\n                        }\n                    },\n                    \"required\": [\"path\"]\n                }\n            }\n        }),\n        json!({\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"write_file\",\n                \"description\": \"Write content to a file, creating or overwriting it\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"path\": {\n                            \"type\": \"string\",\n                            \"description\": \"File path to write to\"\n                        },\n                        \"content\": {\n                            \"type\": \"string\",\n                            \"description\": \"Content to write to the file\"\n                        }\n                    },\n                    \"required\": [\"path\", \"content\"]\n                }\n            }\n        }),\n        json!({\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"run_command\",\n                \"description\": \"Run a shell command and return its output\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"command\": {\n                            \"type\": \"string\",\n                            \"description\": \"Shell command to execute\"\n                        }\n                    },\n                    \"required\": [\"command\"]\n                }\n            }\n        }),\n        json!({\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"list_files\",\n                \"description\": \"List files matching a glob pattern\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"pattern\": {\n                            \"type\": \"string\",\n                            \"description\": \"Glob pattern like 'src/**/*.rs' or '*.txt'\"\n                        }\n                    },\n                    \"required\": [\"pattern\"]\n                }\n            }\n        }),\n        json!({\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"task_complete\",\n                \"description\": \"Signal that the task has been completed successfully\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"summary\": {\n                            \"type\": \"string\",\n                            \"description\": \"Brief summary of what was accomplished\"\n                        }\n                    },\n                    \"required\": [\"summary\"]\n                }\n            }\n        }),\n    ]\n}\n\n/// Execute a tool by name with the given arguments.\n/// Returns the result as a string to be sent back to the model.\npub fn execute_tool(name: \u0026str, args: \u0026Value) -\u003e Result\u003cString, String\u003e {\n    match name {\n        \"read_file\" =\u003e {\n            let path = args[\"path\"]\n                .as_str()\n                .ok_or_else(|| \"missing or invalid 'path' parameter\".to_string())?;\n            read_file(path.to_string()).map_err(|e| format!(\"read_file failed: {}\", e))\n        }\n        \"write_file\" =\u003e {\n            let path = args[\"path\"]\n                .as_str()\n                .ok_or_else(|| \"missing or invalid 'path' parameter\".to_string())?;\n            let content = args[\"content\"]\n                .as_str()\n                .ok_or_else(|| \"missing or invalid 'content' parameter\".to_string())?;\n            write_file(path.to_string(), content.to_string())\n                .map_err(|e| format!(\"write_file failed: {}\", e))\n        }\n        \"run_command\" =\u003e {\n            let command = args[\"command\"]\n                .as_str()\n                .ok_or_else(|| \"missing or invalid 'command' parameter\".to_string())?;\n            run_command(command.to_string()).map_err(|e| format!(\"run_command failed: {}\", e))\n        }\n        \"list_files\" =\u003e {\n            let pattern = args[\"pattern\"]\n                .as_str()\n                .ok_or_else(|| \"missing or invalid 'pattern' parameter\".to_string())?;\n            list_files(pattern.to_string()).map_err(|e| format!(\"list_files failed: {}\", e))\n        }\n        \"task_complete\" =\u003e {\n            let summary = args[\"summary\"].as_str().unwrap_or(\"Task completed\");\n            Ok(format!(\"TASK_COMPLETE: {}\", summary))\n        }\n        _ =\u003e Err(format!(\"Unknown tool: {}\", name)),\n    }\n}\n\n/// Read the contents of a file at the given path.\n/// Use this to understand existing code before making changes.\npub fn read_file(path: String) -\u003e Result\u003cString, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    Ok(fs::read_to_string(\u0026path)?)\n}\n\n/// Write content to a file at the given path.\n/// Creates the file if it doesn't exist, overwrites if it does.\npub fn write_file(\n    path: String,\n    content: String,\n) -\u003e Result\u003cString, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    fs::write(\u0026path, \u0026content)?;\n    Ok(format!(\"Wrote {} bytes to {}\", content.len(), path))\n}\n\n/// Run a shell command and return its output.\n/// Use for: git operations, cargo build/test, file operations.\npub fn run_command(command: String) -\u003e Result\u003cString, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    let output = Command::new(\"sh\").arg(\"-c\").arg(\u0026command).output()?;\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n\n    if output.status.success() {\n        Ok(stdout.to_string())\n    } else {\n        Ok(format!(\n            \"Command failed:\\nstdout: {}\\nstderr: {}\",\n            stdout, stderr\n        ))\n    }\n}\n\n/// List files matching a glob pattern.\n/// Example: list_files(\"src/**/*.rs\") returns all Rust files in src/\npub fn list_files(pattern: String) -\u003e Result\u003cString, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    use glob::glob;\n\n    let paths: Vec\u003c_\u003e = glob(\u0026pattern)?\n        .filter_map(Result::ok)\n        .map(|p| p.display().to_string())\n        .collect();\n    Ok(paths.join(\"\\n\"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_write_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"test.txt\");\n        let path_str = file_path.to_string_lossy().to_string();\n\n        let result = write_file(path_str.clone(), \"test content\".to_string()).unwrap();\n        assert!(result.contains(\"12 bytes\"));\n\n        let content = fs::read_to_string(\u0026file_path).unwrap();\n        assert_eq!(content, \"test content\");\n    }\n\n    #[test]\n    fn test_read_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"test content\").unwrap();\n\n        let path_str = file_path.to_string_lossy().to_string();\n        let content = read_file(path_str).unwrap();\n        assert_eq!(content, \"test content\");\n    }\n\n    #[test]\n    fn test_run_command() {\n        let result = run_command(\"echo 'test output'\".to_string()).unwrap();\n        assert!(result.contains(\"test output\"));\n    }\n\n    #[test]\n    fn test_list_files() {\n        let dir = tempdir().unwrap();\n        let _file1 = fs::File::create(dir.path().join(\"file1.txt\")).unwrap();\n        let _file2 = fs::File::create(dir.path().join(\"file2.txt\")).unwrap();\n\n        let pattern = format!(\"{}/*.txt\", dir.path().display());\n        let result = list_files(pattern).unwrap();\n\n        assert!(result.contains(\"file1.txt\"));\n        assert!(result.contains(\"file2.txt\"));\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":2}}],"covered":16,"coverable":109},{"path":["/","Users","alex","Documents","checkouts","chant","src","ui.rs"],"content":"//! Centralized UI formatting and color utilities\n//!\n//! This module provides a unified interface for status colors, icons, and\n//! formatting patterns used throughout the chant CLI.\n\nuse colored::{ColoredString, Colorize};\n\nuse crate::spec::SpecStatus;\n\n/// Check if quiet mode is enabled via environment variable, --quiet flag, or silent mode\npub fn is_quiet() -\u003e bool {\n    // Check CHANT_QUIET env var (deprecated, for backwards compatibility)\n    if std::env::var(\"CHANT_QUIET\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false)\n    {\n        return true;\n    }\n\n    // Check if silent mode is enabled in config\n    is_silent_mode()\n}\n\n/// Check if silent mode is enabled in project or global config\npub fn is_silent_mode() -\u003e bool {\n    // Try to load config and check silent flag\n    crate::config::Config::load()\n        .ok()\n        .map(|config| config.project.silent)\n        .unwrap_or(false)\n}\n\n/// Returns a colored status icon for the given spec status.\n///\n/// Icons:\n/// - Pending: â (white)\n/// - InProgress: â (yellow)\n/// - Completed: â (green)\n/// - Failed: â (red)\n/// - NeedsAttention: â  (yellow)\n/// - Ready: â (cyan)\n/// - Blocked: â (red)\n/// - Cancelled: â (dimmed)\npub fn status_icon(status: \u0026SpecStatus) -\u003e ColoredString {\n    match status {\n        SpecStatus::Pending =\u003e \"â\".white(),\n        SpecStatus::InProgress =\u003e \"â\".yellow(),\n        SpecStatus::Paused =\u003e \"â\".cyan(),\n        SpecStatus::Completed =\u003e \"â\".green(),\n        SpecStatus::Failed =\u003e \"â\".red(),\n        SpecStatus::NeedsAttention =\u003e \"â \".yellow(),\n        SpecStatus::Ready =\u003e \"â\".cyan(),\n        SpecStatus::Blocked =\u003e \"â\".red(),\n        SpecStatus::Cancelled =\u003e \"â\".dimmed(),\n    }\n}\n\n/// Returns a colored status symbol for attention items (failed/blocked).\n///\n/// Symbols:\n/// - Failed/NeedsAttention: â (red)\n/// - Blocked: â (yellow)\n/// - Other: ? (normal)\npub fn attention_symbol(status: \u0026SpecStatus) -\u003e ColoredString {\n    match status {\n        SpecStatus::Failed | SpecStatus::NeedsAttention =\u003e \"â\".red(),\n        SpecStatus::Blocked =\u003e \"â\".yellow(),\n        _ =\u003e \"?\".normal(),\n    }\n}\n\n/// Color scheme for status-related text output\npub mod colors {\n    use colored::{Color, ColoredString, Colorize};\n\n    /// Green for success/completion\n    pub fn success(text: \u0026str) -\u003e ColoredString {\n        text.green()\n    }\n\n    /// Yellow for in-progress/warnings\n    pub fn warning(text: \u0026str) -\u003e ColoredString {\n        text.yellow()\n    }\n\n    /// Red for errors/failures\n    pub fn error(text: \u0026str) -\u003e ColoredString {\n        text.red()\n    }\n\n    /// Cyan for identifiers (spec IDs, etc.)\n    pub fn identifier(text: \u0026str) -\u003e ColoredString {\n        text.cyan()\n    }\n\n    /// Blue for informational text\n    pub fn info(text: \u0026str) -\u003e ColoredString {\n        text.blue()\n    }\n\n    /// Dimmed for secondary text\n    pub fn secondary(text: \u0026str) -\u003e ColoredString {\n        text.dimmed()\n    }\n\n    /// Bold for headings\n    pub fn heading(text: \u0026str) -\u003e ColoredString {\n        text.bold()\n    }\n\n    /// Color for markdown heading levels\n    pub fn markdown_heading(text: \u0026str, level: usize) -\u003e ColoredString {\n        match level {\n            1 =\u003e text.bold(),\n            2 =\u003e text.bold().cyan(),\n            3 =\u003e text.bold().blue(),\n            4 =\u003e text.bold().magenta(),\n            _ =\u003e text.bold(),\n        }\n    }\n\n    /// Generic colored text\n    pub fn colored(text: \u0026str, color: Color) -\u003e ColoredString {\n        text.color(color)\n    }\n}\n\n/// Common text formatting patterns\npub mod format {\n    /// Truncate a title to fit terminal width\n    pub fn truncate_title(title: \u0026str, max_len: usize) -\u003e String {\n        if title.len() \u003c= max_len {\n            title.to_string()\n        } else {\n            format!(\"{}...\", \u0026title[..max_len.saturating_sub(3)])\n        }\n    }\n\n    /// Format elapsed time in minutes to human-readable string\n    pub fn elapsed_minutes(minutes: i64) -\u003e String {\n        if minutes \u003c 1 {\n            \"just now\".to_string()\n        } else if minutes \u003c 60 {\n            format!(\"{}m\", minutes)\n        } else if minutes \u003c 1440 {\n            // Less than 24 hours\n            let hours = minutes / 60;\n            let mins = minutes % 60;\n            if mins == 0 {\n                format!(\"{}h\", hours)\n            } else {\n                format!(\"{}h {}m\", hours, mins)\n            }\n        } else {\n            // 24 hours or more\n            let days = minutes / 1440;\n            format!(\"{}d\", days)\n        }\n    }\n\n    /// Format a separator line for sections\n    pub fn separator(width: usize) -\u003e String {\n        \"â\".repeat(width)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_status_icon_all_statuses() {\n        status_icon(\u0026SpecStatus::Pending);\n        status_icon(\u0026SpecStatus::InProgress);\n        status_icon(\u0026SpecStatus::Completed);\n        status_icon(\u0026SpecStatus::Failed);\n        status_icon(\u0026SpecStatus::NeedsAttention);\n        status_icon(\u0026SpecStatus::Ready);\n        status_icon(\u0026SpecStatus::Blocked);\n        status_icon(\u0026SpecStatus::Cancelled);\n    }\n\n    #[test]\n    fn test_attention_symbol() {\n        attention_symbol(\u0026SpecStatus::Failed);\n        attention_symbol(\u0026SpecStatus::NeedsAttention);\n        attention_symbol(\u0026SpecStatus::Blocked);\n        attention_symbol(\u0026SpecStatus::Pending);\n    }\n\n    #[test]\n    fn test_truncate_title() {\n        assert_eq!(format::truncate_title(\"short\", 10), \"short\");\n        assert_eq!(format::truncate_title(\"exactly ten\", 11), \"exactly ten\");\n        assert_eq!(\n            format::truncate_title(\"this is a very long title\", 10),\n            \"this is...\"\n        );\n    }\n\n    #[test]\n    fn test_elapsed_minutes() {\n        assert_eq!(format::elapsed_minutes(0), \"just now\");\n        assert_eq!(format::elapsed_minutes(30), \"30m\");\n        assert_eq!(format::elapsed_minutes(60), \"1h\");\n        assert_eq!(format::elapsed_minutes(90), \"1h 30m\");\n        assert_eq!(format::elapsed_minutes(120), \"2h\");\n        assert_eq!(format::elapsed_minutes(1440), \"1d\");\n        assert_eq!(format::elapsed_minutes(2880), \"2d\");\n    }\n\n    #[test]\n    fn test_separator() {\n        assert_eq!(format::separator(5), \"âââââ\");\n        assert_eq!(format::separator(10), \"ââââââââââ\");\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":49}},{"line":13,"address":[],"length":0,"stats":{"Line":49}},{"line":14,"address":[],"length":0,"stats":{"Line":49}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":49}},{"line":25,"address":[],"length":0,"stats":{"Line":49}},{"line":27,"address":[],"length":0,"stats":{"Line":49}},{"line":29,"address":[],"length":0,"stats":{"Line":49}},{"line":44,"address":[],"length":0,"stats":{"Line":48}},{"line":45,"address":[],"length":0,"stats":{"Line":48}},{"line":46,"address":[],"length":0,"stats":{"Line":28}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":34}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":12}}],"covered":51,"coverable":66},{"path":["/","Users","alex","Documents","checkouts","chant","src","validation.rs"],"content":"//! Output schema validation for spec agent outputs.\n//!\n//! This module provides JSON Schema validation for agent outputs when specs\n//! define an `output_schema` field in their frontmatter.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-29\n//! - docs: reference/schema.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\n\n/// Result of validating agent output against a JSON schema\n#[derive(Debug)]\npub struct ValidationResult {\n    /// Whether the validation passed\n    pub is_valid: bool,\n    /// List of validation errors (empty if valid)\n    pub errors: Vec\u003cString\u003e,\n    /// The JSON that was extracted and validated (if any)\n    pub extracted_json: Option\u003cserde_json::Value\u003e,\n}\n\n/// Extract JSON from agent output text.\n///\n/// Tries multiple strategies:\n/// 1. Look for ```json code blocks\n/// 2. Look for bare ``` code blocks that contain JSON\n/// 3. Try parsing the entire output as JSON\n/// 4. Find JSON object/array patterns in the text\npub fn extract_json_from_output(output: \u0026str) -\u003e Option\u003cserde_json::Value\u003e {\n    // Strategy 1: Look for ```json code blocks\n    if let Some(json) = extract_json_code_block(output, \"json\") {\n        return Some(json);\n    }\n\n    // Strategy 2: Look for bare ``` code blocks\n    if let Some(json) = extract_json_code_block(output, \"\") {\n        return Some(json);\n    }\n\n    // Strategy 3: Try parsing the entire output as JSON\n    if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(output.trim()) {\n        return Some(json);\n    }\n\n    // Strategy 4: Find JSON object/array patterns\n    if let Some(json) = find_json_in_text(output) {\n        return Some(json);\n    }\n\n    None\n}\n\n/// Extract JSON from a fenced code block with optional language specifier\nfn extract_json_code_block(output: \u0026str, lang: \u0026str) -\u003e Option\u003cserde_json::Value\u003e {\n    let mut in_fence = false;\n    let mut fence_content = String::new();\n    let mut fence_lang = String::new();\n\n    for line in output.lines() {\n        let trimmed = line.trim_start();\n        if let Some(after_fence) = trimmed.strip_prefix(\"```\") {\n            if in_fence {\n                // End of fence\n                in_fence = false;\n                // Check if this is the right language (or any if lang is empty)\n                if lang.is_empty()\n                    || fence_lang.is_empty()\n                    || fence_lang.to_lowercase() == lang.to_lowercase()\n                {\n                    if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026fence_content) {\n                        return Some(json);\n                    }\n                }\n                fence_content.clear();\n                fence_lang.clear();\n            } else {\n                // Start of fence\n                in_fence = true;\n                fence_lang = after_fence.trim().to_string();\n            }\n        } else if in_fence {\n            if !fence_content.is_empty() {\n                fence_content.push('\\n');\n            }\n            fence_content.push_str(line);\n        }\n    }\n\n    // Handle unclosed fence (try what we have)\n    if in_fence\n        \u0026\u0026 !fence_content.is_empty()\n        \u0026\u0026 (lang.is_empty()\n            || fence_lang.is_empty()\n            || fence_lang.to_lowercase() == lang.to_lowercase())\n    {\n        if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026fence_content) {\n            return Some(json);\n        }\n    }\n\n    None\n}\n\n/// Find JSON object or array patterns in text\nfn find_json_in_text(text: \u0026str) -\u003e Option\u003cserde_json::Value\u003e {\n    // Look for { ... } patterns (objects)\n    let mut brace_depth = 0;\n    let mut start_idx = None;\n\n    for (idx, ch) in text.char_indices() {\n        match ch {\n            '{' =\u003e {\n                if brace_depth == 0 {\n                    start_idx = Some(idx);\n                }\n                brace_depth += 1;\n            }\n            '}' =\u003e {\n                brace_depth -= 1;\n                if brace_depth == 0 {\n                    if let Some(start) = start_idx {\n                        let candidate = \u0026text[start..=idx];\n                        if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(candidate) {\n                            return Some(json);\n                        }\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    // Look for [ ... ] patterns (arrays)\n    let mut bracket_depth = 0;\n    start_idx = None;\n\n    for (idx, ch) in text.char_indices() {\n        match ch {\n            '[' =\u003e {\n                if bracket_depth == 0 {\n                    start_idx = Some(idx);\n                }\n                bracket_depth += 1;\n            }\n            ']' =\u003e {\n                bracket_depth -= 1;\n                if bracket_depth == 0 {\n                    if let Some(start) = start_idx {\n                        let candidate = \u0026text[start..=idx];\n                        if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(candidate) {\n                            return Some(json);\n                        }\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    None\n}\n\n/// Load and compile a JSON schema from a file path\npub fn load_schema(schema_path: \u0026Path) -\u003e Result\u003cjsonschema::Validator\u003e {\n    let schema_content = fs::read_to_string(schema_path)\n        .with_context(|| format!(\"Failed to read schema file: {}\", schema_path.display()))?;\n\n    let schema: serde_json::Value = serde_json::from_str(\u0026schema_content)\n        .with_context(|| format!(\"Failed to parse schema as JSON: {}\", schema_path.display()))?;\n\n    jsonschema::validator_for(\u0026schema)\n        .map_err(|e| anyhow::anyhow!(\"Failed to compile JSON schema: {}\", e))\n}\n\n/// Validate agent output against a JSON schema file.\n///\n/// # Arguments\n/// * `spec_id` - The spec ID (for error messages)\n/// * `schema_path` - Path to the JSON schema file\n/// * `agent_output` - The raw output from the agent\n///\n/// # Returns\n/// * `ValidationResult` with validation status and any errors\npub fn validate_agent_output(\n    spec_id: \u0026str,\n    schema_path: \u0026Path,\n    agent_output: \u0026str,\n) -\u003e Result\u003cValidationResult\u003e {\n    // Load and compile the schema\n    let validator = load_schema(schema_path)?;\n\n    // Extract JSON from the agent output\n    let extracted_json = match extract_json_from_output(agent_output) {\n        Some(json) =\u003e json,\n        None =\u003e {\n            return Ok(ValidationResult {\n                is_valid: false,\n                errors: vec![format!(\n                    \"No JSON found in agent output for spec '{}'\",\n                    spec_id\n                )],\n                extracted_json: None,\n            });\n        }\n    };\n\n    // Validate the extracted JSON against the schema using iter_errors\n    // to collect all validation errors\n    let error_iter = validator.iter_errors(\u0026extracted_json);\n    let error_messages: Vec\u003cString\u003e = error_iter\n        .map(|e| {\n            let path = e.instance_path.to_string();\n            if path.is_empty() {\n                e.to_string()\n            } else {\n                format!(\"at '{}': {}\", path, e)\n            }\n        })\n        .collect();\n\n    if error_messages.is_empty() {\n        Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n            extracted_json: Some(extracted_json),\n        })\n    } else {\n        Ok(ValidationResult {\n            is_valid: false,\n            errors: error_messages,\n            extracted_json: Some(extracted_json),\n        })\n    }\n}\n\n/// Read the agent log file for a spec and validate its output against the schema.\n///\n/// This is useful for batch validation (e.g., in `chant lint`).\n///\n/// # Arguments\n/// * `spec_id` - The spec ID\n/// * `schema_path` - Path to the JSON schema file\n/// * `logs_dir` - Path to the logs directory (typically `.chant/logs`)\n///\n/// # Returns\n/// * `Ok(Some(ValidationResult))` if log exists and validation was attempted\n/// * `Ok(None)` if no log file exists for this spec\n/// * `Err` if there was an error reading the log or schema\npub fn validate_spec_output_from_log(\n    spec_id: \u0026str,\n    schema_path: \u0026Path,\n    logs_dir: \u0026Path,\n) -\u003e Result\u003cOption\u003cValidationResult\u003e\u003e {\n    let log_path = logs_dir.join(format!(\"{}.log\", spec_id));\n\n    if !log_path.exists() {\n        return Ok(None);\n    }\n\n    let log_content = fs::read_to_string(\u0026log_path)\n        .with_context(|| format!(\"Failed to read log file: {}\", log_path.display()))?;\n\n    let result = validate_agent_output(spec_id, schema_path, \u0026log_content)?;\n    Ok(Some(result))\n}\n\n/// Generate an \"Output Format\" prompt section from a JSON schema.\n///\n/// This is injected into agent prompts when a spec has an `output_schema` field.\npub fn generate_schema_prompt_section(schema_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let schema_content = fs::read_to_string(schema_path)\n        .with_context(|| format!(\"Failed to read schema file: {}\", schema_path.display()))?;\n\n    let schema: serde_json::Value = serde_json::from_str(\u0026schema_content)\n        .with_context(|| format!(\"Failed to parse schema as JSON: {}\", schema_path.display()))?;\n\n    let mut section = String::new();\n    section.push_str(\"\\n## Output Format\\n\\n\");\n    section.push_str(\"Your output MUST include valid JSON matching this schema:\\n\\n\");\n    section.push_str(\"```json\\n\");\n    section.push_str(\u0026serde_json::to_string_pretty(\u0026schema)?);\n    section.push_str(\"\\n```\\n\\n\");\n\n    // Extract required fields if present\n    if let Some(required) = schema.get(\"required\").and_then(|r| r.as_array()) {\n        let required_fields: Vec\u003c\u0026str\u003e = required.iter().filter_map(|v| v.as_str()).collect();\n        if !required_fields.is_empty() {\n            section.push_str(\u0026format!(\n                \"**Required fields:** {}\\n\\n\",\n                required_fields.join(\", \")\n            ));\n        }\n    }\n\n    // Generate an example if properties are defined\n    if let Some(properties) = schema.get(\"properties\").and_then(|p| p.as_object()) {\n        section.push_str(\"**Example:**\\n\\n```json\\n\");\n        let example = generate_example_from_properties(properties, \u0026schema);\n        section.push_str(\u0026serde_json::to_string_pretty(\u0026example)?);\n        section.push_str(\"\\n```\\n\");\n    }\n\n    Ok(section)\n}\n\n/// Generate an example JSON object from schema properties\nfn generate_example_from_properties(\n    properties: \u0026serde_json::Map\u003cString, serde_json::Value\u003e,\n    schema: \u0026serde_json::Value,\n) -\u003e serde_json::Value {\n    let required: Vec\u003c\u0026str\u003e = schema\n        .get(\"required\")\n        .and_then(|r| r.as_array())\n        .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect())\n        .unwrap_or_default();\n\n    let mut example = serde_json::Map::new();\n\n    for (key, prop_schema) in properties {\n        // Only include required fields in example, or first 3 properties\n        if !required.contains(\u0026key.as_str()) \u0026\u0026 example.len() \u003e= 3 {\n            continue;\n        }\n\n        let value = generate_example_value(prop_schema);\n        example.insert(key.clone(), value);\n    }\n\n    serde_json::Value::Object(example)\n}\n\n/// Generate an example value for a schema property\nfn generate_example_value(prop_schema: \u0026serde_json::Value) -\u003e serde_json::Value {\n    let prop_type = prop_schema.get(\"type\").and_then(|t| t.as_str());\n\n    match prop_type {\n        Some(\"string\") =\u003e {\n            // Check for pattern or enum\n            if let Some(enum_values) = prop_schema.get(\"enum\").and_then(|e| e.as_array()) {\n                if let Some(first) = enum_values.first() {\n                    return first.clone();\n                }\n            }\n            serde_json::Value::String(\"...\".to_string())\n        }\n        Some(\"number\") | Some(\"integer\") =\u003e serde_json::Value::Number(0.into()),\n        Some(\"boolean\") =\u003e serde_json::Value::Bool(true),\n        Some(\"array\") =\u003e {\n            let items_schema = prop_schema.get(\"items\");\n            let item_example = items_schema\n                .map(generate_example_value)\n                .unwrap_or(serde_json::Value::String(\"...\".to_string()));\n            serde_json::Value::Array(vec![item_example])\n        }\n        Some(\"object\") =\u003e {\n            if let Some(props) = prop_schema.get(\"properties\").and_then(|p| p.as_object()) {\n                generate_example_from_properties(props, prop_schema)\n            } else {\n                serde_json::Value::Object(serde_json::Map::new())\n            }\n        }\n        _ =\u003e serde_json::Value::Null,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_extract_json_from_code_block() {\n        let output = r#\"\nHere is the analysis:\n\n```json\n{\n  \"spec_id\": \"C.1.1\",\n  \"findings\": [\"Found issue A\", \"Found issue B\"],\n  \"recommendation\": \"Fix the bug\"\n}\n```\n\nThat's my report.\n\"#;\n\n        let json = extract_json_from_output(output).unwrap();\n        assert_eq!(json[\"spec_id\"], \"C.1.1\");\n        assert!(json[\"findings\"].is_array());\n    }\n\n    #[test]\n    fn test_extract_json_bare_output() {\n        let output = r#\"{\"spec_id\": \"test\", \"value\": 42}\"#;\n\n        let json = extract_json_from_output(output).unwrap();\n        assert_eq!(json[\"spec_id\"], \"test\");\n        assert_eq!(json[\"value\"], 42);\n    }\n\n    #[test]\n    fn test_extract_json_embedded_in_text() {\n        let output = r#\"\nThe analysis shows that the result is:\n{\"status\": \"success\", \"count\": 5}\nEnd of report.\n\"#;\n\n        let json = extract_json_from_output(output).unwrap();\n        assert_eq!(json[\"status\"], \"success\");\n        assert_eq!(json[\"count\"], 5);\n    }\n\n    #[test]\n    fn test_extract_json_no_json() {\n        let output = \"This is just plain text without any JSON content.\";\n        assert!(extract_json_from_output(output).is_none());\n    }\n\n    #[test]\n    fn test_validate_valid_output() {\n        let tmp = TempDir::new().unwrap();\n        let schema_path = tmp.path().join(\"schema.json\");\n\n        let schema = r#\"{\n            \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n            \"type\": \"object\",\n            \"required\": [\"spec_id\", \"status\"],\n            \"properties\": {\n                \"spec_id\": {\"type\": \"string\"},\n                \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"failure\"]}\n            }\n        }\"#;\n        fs::write(\u0026schema_path, schema).unwrap();\n\n        let agent_output = r#\"\nHere is my report:\n```json\n{\"spec_id\": \"test-001\", \"status\": \"success\"}\n```\n\"#;\n\n        let result = validate_agent_output(\"test-001\", \u0026schema_path, agent_output).unwrap();\n        assert!(result.is_valid);\n        assert!(result.errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_invalid_output() {\n        let tmp = TempDir::new().unwrap();\n        let schema_path = tmp.path().join(\"schema.json\");\n\n        let schema = r#\"{\n            \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n            \"type\": \"object\",\n            \"required\": [\"spec_id\"],\n            \"properties\": {\n                \"spec_id\": {\"type\": \"string\"}\n            }\n        }\"#;\n        fs::write(\u0026schema_path, schema).unwrap();\n\n        // Missing required field\n        let agent_output = r#\"{\"status\": \"done\"}\"#;\n\n        let result = validate_agent_output(\"test-001\", \u0026schema_path, agent_output).unwrap();\n        assert!(!result.is_valid);\n        assert!(!result.errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_no_json_in_output() {\n        let tmp = TempDir::new().unwrap();\n        let schema_path = tmp.path().join(\"schema.json\");\n\n        let schema = r#\"{\n            \"type\": \"object\",\n            \"properties\": {\"x\": {\"type\": \"string\"}}\n        }\"#;\n        fs::write(\u0026schema_path, schema).unwrap();\n\n        let agent_output = \"Just some plain text, no JSON here.\";\n\n        let result = validate_agent_output(\"test-001\", \u0026schema_path, agent_output).unwrap();\n        assert!(!result.is_valid);\n        assert!(result.errors[0].contains(\"No JSON found\"));\n    }\n\n    #[test]\n    fn test_generate_schema_prompt_section() {\n        let tmp = TempDir::new().unwrap();\n        let schema_path = tmp.path().join(\"schema.json\");\n\n        let schema = r#\"{\n            \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n            \"type\": \"object\",\n            \"required\": [\"spec_id\", \"findings\"],\n            \"properties\": {\n                \"spec_id\": {\"type\": \"string\"},\n                \"findings\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n            }\n        }\"#;\n        fs::write(\u0026schema_path, schema).unwrap();\n\n        let section = generate_schema_prompt_section(\u0026schema_path).unwrap();\n\n        assert!(section.contains(\"## Output Format\"));\n        assert!(section.contains(\"spec_id\"));\n        assert!(section.contains(\"Required fields\"));\n        assert!(section.contains(\"Example\"));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":23}},{"line":35,"address":[],"length":0,"stats":{"Line":56}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":26}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":32}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":36}},{"line":59,"address":[],"length":0,"stats":{"Line":72}},{"line":60,"address":[],"length":0,"stats":{"Line":72}},{"line":61,"address":[],"length":0,"stats":{"Line":72}},{"line":63,"address":[],"length":0,"stats":{"Line":177}},{"line":64,"address":[],"length":0,"stats":{"Line":315}},{"line":65,"address":[],"length":0,"stats":{"Line":125}},{"line":66,"address":[],"length":0,"stats":{"Line":20}},{"line":68,"address":[],"length":0,"stats":{"Line":10}},{"line":70,"address":[],"length":0,"stats":{"Line":20}},{"line":71,"address":[],"length":0,"stats":{"Line":20}},{"line":72,"address":[],"length":0,"stats":{"Line":20}},{"line":74,"address":[],"length":0,"stats":{"Line":20}},{"line":75,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":20}},{"line":83,"address":[],"length":0,"stats":{"Line":20}},{"line":85,"address":[],"length":0,"stats":{"Line":85}},{"line":86,"address":[],"length":0,"stats":{"Line":30}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":89,"address":[],"length":0,"stats":{"Line":60}},{"line":94,"address":[],"length":0,"stats":{"Line":26}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":26}},{"line":109,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":14}},{"line":112,"address":[],"length":0,"stats":{"Line":14}},{"line":114,"address":[],"length":0,"stats":{"Line":684}},{"line":115,"address":[],"length":0,"stats":{"Line":335}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":329}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":328}},{"line":142,"address":[],"length":0,"stats":{"Line":160}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":160}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":13}},{"line":169,"address":[],"length":0,"stats":{"Line":39}},{"line":170,"address":[],"length":0,"stats":{"Line":13}},{"line":172,"address":[],"length":0,"stats":{"Line":52}},{"line":173,"address":[],"length":0,"stats":{"Line":13}},{"line":175,"address":[],"length":0,"stats":{"Line":26}},{"line":176,"address":[],"length":0,"stats":{"Line":13}},{"line":188,"address":[],"length":0,"stats":{"Line":13}},{"line":194,"address":[],"length":0,"stats":{"Line":39}},{"line":197,"address":[],"length":0,"stats":{"Line":23}},{"line":198,"address":[],"length":0,"stats":{"Line":20}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":40}},{"line":214,"address":[],"length":0,"stats":{"Line":30}},{"line":215,"address":[],"length":0,"stats":{"Line":15}},{"line":216,"address":[],"length":0,"stats":{"Line":15}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":218,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":20}},{"line":226,"address":[],"length":0,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":5}},{"line":228,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":234,"address":[],"length":0,"stats":{"Line":5}},{"line":235,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":9}},{"line":276,"address":[],"length":0,"stats":{"Line":3}},{"line":278,"address":[],"length":0,"stats":{"Line":12}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":9}},{"line":283,"address":[],"length":0,"stats":{"Line":9}},{"line":284,"address":[],"length":0,"stats":{"Line":9}},{"line":285,"address":[],"length":0,"stats":{"Line":12}},{"line":286,"address":[],"length":0,"stats":{"Line":9}},{"line":289,"address":[],"length":0,"stats":{"Line":18}},{"line":290,"address":[],"length":0,"stats":{"Line":27}},{"line":291,"address":[],"length":0,"stats":{"Line":6}},{"line":292,"address":[],"length":0,"stats":{"Line":12}},{"line":293,"address":[],"length":0,"stats":{"Line":3}},{"line":294,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":18}},{"line":301,"address":[],"length":0,"stats":{"Line":9}},{"line":302,"address":[],"length":0,"stats":{"Line":12}},{"line":303,"address":[],"length":0,"stats":{"Line":12}},{"line":304,"address":[],"length":0,"stats":{"Line":9}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":9}},{"line":317,"address":[],"length":0,"stats":{"Line":9}},{"line":318,"address":[],"length":0,"stats":{"Line":24}},{"line":321,"address":[],"length":0,"stats":{"Line":6}},{"line":323,"address":[],"length":0,"stats":{"Line":15}},{"line":325,"address":[],"length":0,"stats":{"Line":18}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":18}},{"line":330,"address":[],"length":0,"stats":{"Line":30}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":9}},{"line":338,"address":[],"length":0,"stats":{"Line":54}},{"line":340,"address":[],"length":0,"stats":{"Line":9}},{"line":341,"address":[],"length":0,"stats":{"Line":9}},{"line":343,"address":[],"length":0,"stats":{"Line":18}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":6}},{"line":351,"address":[],"length":0,"stats":{"Line":3}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":9}},{"line":354,"address":[],"length":0,"stats":{"Line":6}},{"line":355,"address":[],"length":0,"stats":{"Line":3}},{"line":356,"address":[],"length":0,"stats":{"Line":6}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}}],"covered":131,"coverable":166},{"path":["/","Users","alex","Documents","checkouts","chant","src","worktree.rs"],"content":"//! Low-level git worktree operations.\n//!\n//! Provides utilities for creating, managing, and removing git worktrees.\n//! These functions handle the mechanics of worktree lifecycle management.\n//!\n//! # Doc Audit\n//! - audited: 2026-01-25\n//! - docs: scale/isolation.md\n//! - ignore: false\n\nuse anyhow::{Context, Result};\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\n/// Returns the worktree path for a given spec ID.\n///\n/// This does not check whether the worktree exists.\npub fn worktree_path_for_spec(spec_id: \u0026str) -\u003e PathBuf {\n    PathBuf::from(format!(\"/tmp/chant-{}\", spec_id))\n}\n\n/// Returns the worktree path for a spec if an active worktree exists.\n///\n/// Returns Some(path) if the worktree directory exists, None otherwise.\npub fn get_active_worktree(spec_id: \u0026str) -\u003e Option\u003cPathBuf\u003e {\n    let path = worktree_path_for_spec(spec_id);\n    if path.exists() \u0026\u0026 path.is_dir() {\n        Some(path)\n    } else {\n        None\n    }\n}\n\n/// Commits changes in a worktree.\n///\n/// # Arguments\n///\n/// * `worktree_path` - Path to the worktree\n/// * `message` - Commit message\n///\n/// # Returns\n///\n/// Ok(commit_hash) if commit was successful, Err if failed.\npub fn commit_in_worktree(worktree_path: \u0026Path, message: \u0026str) -\u003e Result\u003cString\u003e {\n    // Stage all changes\n    let output = Command::new(\"git\")\n        .args([\"add\", \"-A\"])\n        .current_dir(worktree_path)\n        .output()\n        .context(\"Failed to stage changes in worktree\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to stage changes: {}\", stderr);\n    }\n\n    // Check if there are any changes to commit\n    let output = Command::new(\"git\")\n        .args([\"status\", \"--porcelain\"])\n        .current_dir(worktree_path)\n        .output()\n        .context(\"Failed to check git status in worktree\")?;\n\n    let status_output = String::from_utf8_lossy(\u0026output.stdout);\n    if status_output.trim().is_empty() {\n        // No changes to commit, return the current HEAD\n        let output = Command::new(\"git\")\n            .args([\"rev-parse\", \"HEAD\"])\n            .current_dir(worktree_path)\n            .output()\n            .context(\"Failed to get HEAD commit\")?;\n\n        let hash = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n        return Ok(hash);\n    }\n\n    // Commit the changes\n    let output = Command::new(\"git\")\n        .args([\"commit\", \"-m\", message])\n        .current_dir(worktree_path)\n        .output()\n        .context(\"Failed to commit changes in worktree\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to commit: {}\", stderr);\n    }\n\n    // Get the commit hash\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", \"HEAD\"])\n        .current_dir(worktree_path)\n        .output()\n        .context(\"Failed to get commit hash\")?;\n\n    let hash = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    Ok(hash)\n}\n\n/// Creates a new git worktree for the given spec.\n///\n/// # Arguments\n///\n/// * `spec_id` - The specification ID (used to create unique worktree paths)\n/// * `branch` - The branch name to create in the worktree\n///\n/// # Returns\n///\n/// The absolute path to the created worktree directory.\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - The branch already exists\n/// - Git worktree creation fails (e.g., corrupted repo)\n/// - Directory creation fails\npub fn create_worktree(spec_id: \u0026str, branch: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n    let worktree_path = PathBuf::from(format!(\"/tmp/chant-{}\", spec_id));\n\n    // Check if branch already exists\n    let output = Command::new(\"git\")\n        .args([\"rev-parse\", \"--verify\", branch])\n        .output()\n        .context(\"Failed to check if branch exists\")?;\n\n    if output.status.success() {\n        anyhow::bail!(\"Branch '{}' already exists\", branch);\n    }\n\n    // Create the worktree with the new branch\n    let output = Command::new(\"git\")\n        .args([\n            \"worktree\",\n            \"add\",\n            \"-b\",\n            branch,\n            \u0026worktree_path.to_string_lossy(),\n        ])\n        .output()\n        .context(\"Failed to create git worktree\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to create worktree: {}\", stderr);\n    }\n\n    Ok(worktree_path)\n}\n\n/// Copies the spec file from the main working directory to a worktree.\n///\n/// This ensures the worktree has the current spec state (e.g., in_progress status)\n/// even when the change hasn't been committed to main yet.\n///\n/// # Arguments\n///\n/// * `spec_id` - The specification ID\n/// * `worktree_path` - The path to the worktree\n///\n/// # Returns\n///\n/// Ok(()) if the spec file was successfully copied and committed.\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - The spec file doesn't exist in the main working directory\n/// - The copy operation fails\n/// - The commit fails\npub fn copy_spec_to_worktree(spec_id: \u0026str, worktree_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    // Use absolute path from git root to avoid issues when current directory changes\n    let git_root = std::env::current_dir().context(\"Failed to get current directory\")?;\n    let main_spec_path = git_root\n        .join(\".chant/specs\")\n        .join(format!(\"{}.md\", spec_id));\n    let worktree_specs_dir = worktree_path.join(\".chant/specs\");\n    let worktree_spec_path = worktree_specs_dir.join(format!(\"{}.md\", spec_id));\n\n    // Ensure the .chant/specs directory exists in the worktree\n    std::fs::create_dir_all(\u0026worktree_specs_dir).context(format!(\n        \"Failed to create specs directory in worktree: {:?}\",\n        worktree_specs_dir\n    ))?;\n\n    // Copy the spec file from main to worktree\n    std::fs::copy(\u0026main_spec_path, \u0026worktree_spec_path).context(format!(\n        \"Failed to copy spec file to worktree: {:?}\",\n        worktree_spec_path\n    ))?;\n\n    // Commit the updated spec in the worktree\n    commit_in_worktree(\n        worktree_path,\n        \u0026format!(\"chant({}): update spec status to in_progress\", spec_id),\n    )?;\n\n    Ok(())\n}\n\n/// Removes a git worktree and cleans up its directory.\n///\n/// This function is idempotent - it does not error if the worktree is already gone.\n///\n/// # Arguments\n///\n/// * `path` - The path to the worktree to remove\n///\n/// # Returns\n///\n/// Ok(()) if the worktree was successfully removed or didn't exist.\npub fn remove_worktree(path: \u0026Path) -\u003e Result\u003c()\u003e {\n    // Try to remove the git worktree entry\n    let _output = Command::new(\"git\")\n        .args([\"worktree\", \"remove\", \u0026path.to_string_lossy()])\n        .output()\n        .context(\"Failed to run git worktree remove\")?;\n\n    // Even if git worktree remove fails, try to clean up the directory\n    if path.exists() {\n        std::fs::remove_dir_all(path)\n            .context(format!(\"Failed to remove worktree directory at {:?}\", path))?;\n    }\n\n    Ok(())\n}\n\n/// Result of a merge operation\n#[derive(Debug, Clone)]\npub struct MergeCleanupResult {\n    pub success: bool,\n    pub has_conflict: bool,\n    pub error: Option\u003cString\u003e,\n}\n\n/// Checks if a branch is behind main (main has commits not in branch).\n///\n/// # Arguments\n///\n/// * `branch` - The branch name to check\n/// * `work_dir` - Optional working directory for the git command\n///\n/// # Returns\n///\n/// Ok(true) if main has commits not in branch, Ok(false) otherwise.\nfn branch_is_behind_main(branch: \u0026str, work_dir: Option\u003c\u0026Path\u003e) -\u003e Result\u003cbool\u003e {\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"rev-list\", \"--count\", \u0026format!(\"{}..main\", branch)]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = cmd\n        .output()\n        .context(\"Failed to check if branch is behind main\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to check branch status: {}\", stderr);\n    }\n\n    let count_str = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n    let count: i32 = count_str\n        .parse()\n        .context(format!(\"Failed to parse commit count: {}\", count_str))?;\n    Ok(count \u003e 0)\n}\n\n/// Rebases a branch onto main.\n///\n/// # Arguments\n///\n/// * `branch` - The branch name to rebase\n/// * `work_dir` - Optional working directory for the git command\n///\n/// # Returns\n///\n/// Ok(()) if rebase succeeded, Err if rebase had conflicts or failed.\nfn rebase_branch_onto_main(branch: \u0026str, work_dir: Option\u003c\u0026Path\u003e) -\u003e Result\u003c()\u003e {\n    // Checkout the branch\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"checkout\", branch]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = cmd\n        .output()\n        .context(\"Failed to checkout branch for rebase\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to checkout branch: {}\", stderr);\n    }\n\n    // Rebase onto main\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"rebase\", \"main\"]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = cmd.output().context(\"Failed to rebase onto main\")?;\n\n    if !output.status.success() {\n        anyhow::bail!(\"Rebase had conflicts\");\n    }\n\n    // Return to main branch\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"checkout\", \"main\"]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = cmd\n        .output()\n        .context(\"Failed to checkout main after rebase\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"Failed to checkout main: {}\", stderr);\n    }\n\n    Ok(())\n}\n\n/// Aborts a rebase in progress and returns to main branch.\n///\n/// # Arguments\n///\n/// * `work_dir` - Optional working directory for the git command\n///\n/// This function is best-effort and does not return errors.\nfn abort_rebase(work_dir: Option\u003c\u0026Path\u003e) {\n    // Abort the rebase\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"rebase\", \"--abort\"]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let _ = cmd.output();\n\n    // Try to ensure we're on main branch\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"checkout\", \"main\"]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let _ = cmd.output();\n}\n\n/// Merges a branch to main and cleans up.\n///\n/// # Arguments\n///\n/// * `branch` - The branch name to merge\n/// * `no_rebase` - If true, skip automatic rebase even if branch is behind\n///\n/// # Returns\n///\n/// Returns a MergeCleanupResult indicating:\n/// - success: true if merge succeeded and branch was deleted\n/// - has_conflict: true if merge failed due to conflicts\n/// - error: optional error message\n///\n/// If there are merge conflicts, the branch is preserved for manual resolution.\npub fn merge_and_cleanup(branch: \u0026str, no_rebase: bool) -\u003e MergeCleanupResult {\n    merge_and_cleanup_in_dir(branch, None, no_rebase)\n}\n\n/// Internal function that merges a branch to main with optional working directory.\nfn merge_and_cleanup_in_dir(\n    branch: \u0026str,\n    work_dir: Option\u003c\u0026Path\u003e,\n    no_rebase: bool,\n) -\u003e MergeCleanupResult {\n    // Checkout main branch\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"checkout\", \"main\"]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = match cmd.output() {\n        Ok(o) =\u003e o,\n        Err(e) =\u003e {\n            return MergeCleanupResult {\n                success: false,\n                has_conflict: false,\n                error: Some(format!(\"Failed to checkout main: {}\", e)),\n            };\n        }\n    };\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        // Try to ensure we're on main branch before returning error\n        let _ = crate::git::ensure_on_main_branch(\"main\");\n        return MergeCleanupResult {\n            success: false,\n            has_conflict: false,\n            error: Some(format!(\"Failed to checkout main: {}\", stderr)),\n        };\n    }\n\n    // Check if branch needs rebase (is behind main) and attempt rebase if needed\n    if !no_rebase {\n        match branch_is_behind_main(branch, work_dir) {\n            Ok(true) =\u003e {\n                // Branch is behind main, attempt automatic rebase\n                println!(\n                    \"Branch '{}' is behind main, attempting automatic rebase...\",\n                    branch\n                );\n                match rebase_branch_onto_main(branch, work_dir) {\n                    Ok(()) =\u003e {\n                        println!(\"Rebase succeeded, proceeding with merge...\");\n                    }\n                    Err(e) =\u003e {\n                        // Rebase failed (conflicts), abort and preserve branch\n                        abort_rebase(work_dir);\n                        return MergeCleanupResult {\n                            success: false,\n                            has_conflict: true,\n                            error: Some(format!(\"Auto-rebase failed due to conflicts: {}\", e)),\n                        };\n                    }\n                }\n            }\n            Ok(false) =\u003e {\n                // Branch is not behind main, proceed normally\n            }\n            Err(e) =\u003e {\n                // Failed to check if branch is behind, log warning and proceed\n                eprintln!(\"Warning: Failed to check if branch is behind main: {}\", e);\n            }\n        }\n    }\n\n    // Perform fast-forward merge\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"merge\", \"--ff-only\", branch]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = match cmd.output() {\n        Ok(o) =\u003e o,\n        Err(e) =\u003e {\n            return MergeCleanupResult {\n                success: false,\n                has_conflict: false,\n                error: Some(format!(\"Failed to perform merge: {}\", e)),\n            };\n        }\n    };\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        // Check if this was a conflict\n        let has_conflict = stderr.contains(\"CONFLICT\") || stderr.contains(\"merge conflict\");\n\n        // Abort merge if there was a conflict to preserve the branch\n        if has_conflict {\n            let mut cmd = Command::new(\"git\");\n            cmd.args([\"merge\", \"--abort\"]);\n            if let Some(dir) = work_dir {\n                cmd.current_dir(dir);\n            }\n            let _ = cmd.output();\n        }\n\n        // Extract spec_id from branch name (strip \"chant/\" prefix if present)\n        let spec_id = branch.trim_start_matches(\"chant/\");\n        let error_msg = if has_conflict {\n            crate::merge_errors::merge_conflict(spec_id, branch, \"main\")\n        } else {\n            crate::merge_errors::fast_forward_conflict(spec_id, branch, \"main\", \u0026stderr)\n        };\n        // Try to ensure we're on main branch before returning error\n        let _ = crate::git::ensure_on_main_branch(\"main\");\n        return MergeCleanupResult {\n            success: false,\n            has_conflict,\n            error: Some(error_msg),\n        };\n    }\n\n    // Delete the local branch after successful merge\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"branch\", \"-d\", branch]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    let output = match cmd.output() {\n        Ok(o) =\u003e o,\n        Err(e) =\u003e {\n            return MergeCleanupResult {\n                success: false,\n                has_conflict: false,\n                error: Some(format!(\"Failed to delete branch: {}\", e)),\n            };\n        }\n    };\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        return MergeCleanupResult {\n            success: false,\n            has_conflict: false,\n            error: Some(format!(\"Failed to delete branch '{}': {}\", branch, stderr)),\n        };\n    }\n\n    // Delete the remote branch (best-effort, don't fail if it doesn't exist)\n    let mut cmd = Command::new(\"git\");\n    cmd.args([\"push\", \"origin\", \"--delete\", branch]);\n    if let Some(dir) = work_dir {\n        cmd.current_dir(dir);\n    }\n    // Ignore errors - remote branch may not exist or remote may be unavailable\n    let _ = cmd.output();\n\n    MergeCleanupResult {\n        success: true,\n        has_conflict: false,\n        error: None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::process::Command as StdCommand;\n\n    /// Helper to initialize a temporary git repo for testing.\n    fn setup_test_repo(repo_dir: \u0026Path) -\u003e Result\u003c()\u003e {\n        fs::create_dir_all(repo_dir)?;\n\n        let output = StdCommand::new(\"git\")\n            .args([\"init\", \"-b\", \"main\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to run git init\")?;\n        anyhow::ensure!(\n            output.status.success(),\n            \"git init failed: {}\",\n            String::from_utf8_lossy(\u0026output.stderr)\n        );\n\n        let output = StdCommand::new(\"git\")\n            .args([\"config\", \"user.email\", \"test@example.com\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to run git config\")?;\n        anyhow::ensure!(\n            output.status.success(),\n            \"git config email failed: {}\",\n            String::from_utf8_lossy(\u0026output.stderr)\n        );\n\n        let output = StdCommand::new(\"git\")\n            .args([\"config\", \"user.name\", \"Test User\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to run git config\")?;\n        anyhow::ensure!(\n            output.status.success(),\n            \"git config name failed: {}\",\n            String::from_utf8_lossy(\u0026output.stderr)\n        );\n\n        // Create an initial commit\n        fs::write(repo_dir.join(\"README.md\"), \"# Test\")?;\n\n        let output = StdCommand::new(\"git\")\n            .args([\"add\", \".\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to run git add\")?;\n        anyhow::ensure!(\n            output.status.success(),\n            \"git add failed: {}\",\n            String::from_utf8_lossy(\u0026output.stderr)\n        );\n\n        let output = StdCommand::new(\"git\")\n            .args([\"commit\", \"-m\", \"Initial commit\"])\n            .current_dir(repo_dir)\n            .output()\n            .context(\"Failed to run git commit\")?;\n        anyhow::ensure!(\n            output.status.success(),\n            \"git commit failed: {}\",\n            String::from_utf8_lossy(\u0026output.stderr)\n        );\n\n        Ok(())\n    }\n\n    /// Helper to clean up test repos.\n    fn cleanup_test_repo(repo_dir: \u0026Path) -\u003e Result\u003c()\u003e {\n        if repo_dir.exists() {\n            fs::remove_dir_all(repo_dir)?;\n        }\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_create_worktree_branch_already_exists() -\u003e Result\u003c()\u003e {\n        let repo_dir = PathBuf::from(\"/tmp/test-chant-repo-branch-exists\");\n        cleanup_test_repo(\u0026repo_dir)?;\n        setup_test_repo(\u0026repo_dir)?;\n\n        let original_dir = std::env::current_dir()?;\n\n        let result = {\n            std::env::set_current_dir(\u0026repo_dir).context(\"Failed to change to repo directory\")?;\n\n            let spec_id = \"test-spec-branch-exists\";\n            let branch = \"spec/test-spec-branch-exists\";\n\n            // Create the branch first\n            let output = StdCommand::new(\"git\")\n                .args([\"branch\", branch])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git branch failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            create_worktree(spec_id, branch)\n        };\n\n        // Always restore original directory\n        std::env::set_current_dir(\u0026original_dir).context(\"Failed to restore original directory\")?;\n        cleanup_test_repo(\u0026repo_dir)?;\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"already exists\"));\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_and_cleanup_with_conflict_preserves_branch() -\u003e Result\u003c()\u003e {\n        let repo_dir = PathBuf::from(\"/tmp/test-chant-repo-conflict-preserve\");\n        cleanup_test_repo(\u0026repo_dir)?;\n        setup_test_repo(\u0026repo_dir)?;\n\n        let original_dir = std::env::current_dir()?;\n\n        let result = {\n            std::env::set_current_dir(\u0026repo_dir).context(\"Failed to change to repo directory\")?;\n\n            let branch = \"feature/conflict-test\";\n\n            // Create a feature branch that conflicts with main\n            let output = StdCommand::new(\"git\")\n                .args([\"branch\", branch])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git branch failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            let output = StdCommand::new(\"git\")\n                .args([\"checkout\", branch])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git checkout branch failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            fs::write(repo_dir.join(\"README.md\"), \"feature version\")?;\n\n            let output = StdCommand::new(\"git\")\n                .args([\"add\", \".\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git add failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            let output = StdCommand::new(\"git\")\n                .args([\"commit\", \"-m\", \"Modify README on feature\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git commit feature failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            // Modify README on main differently\n            let output = StdCommand::new(\"git\")\n                .args([\"checkout\", \"main\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git checkout main failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            fs::write(repo_dir.join(\"README.md\"), \"main version\")?;\n\n            let output = StdCommand::new(\"git\")\n                .args([\"add\", \".\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git add main failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            let output = StdCommand::new(\"git\")\n                .args([\"commit\", \"-m\", \"Modify README on main\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git commit main failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            // Now call merge_and_cleanup with explicit repo directory\n            merge_and_cleanup_in_dir(branch, Some(\u0026repo_dir), false)\n        };\n\n        // Always restore original directory\n        std::env::set_current_dir(\u0026original_dir).context(\"Failed to restore original directory\")?;\n\n        // Check that branch still exists (wasn't deleted)\n        let branch_check = StdCommand::new(\"git\")\n            .args([\"rev-parse\", \"--verify\", \"feature/conflict-test\"])\n            .current_dir(\u0026repo_dir)\n            .output()?;\n\n        cleanup_test_repo(\u0026repo_dir)?;\n\n        // Merge should fail (either due to conflict or non-ff situation)\n        assert!(!result.success);\n        // Branch should still exist\n        assert!(branch_check.status.success());\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_merge_and_cleanup_successful_merge() -\u003e Result\u003c()\u003e {\n        let repo_dir = PathBuf::from(\"/tmp/test-chant-repo-merge-success\");\n        cleanup_test_repo(\u0026repo_dir)?;\n        setup_test_repo(\u0026repo_dir)?;\n\n        let original_dir = std::env::current_dir()?;\n\n        let result = {\n            std::env::set_current_dir(\u0026repo_dir).context(\"Failed to change to repo directory\")?;\n\n            let branch = \"feature/new-feature\";\n\n            // Create a fast-forwardable feature branch\n            let output = StdCommand::new(\"git\")\n                .args([\"branch\", branch])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git branch failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            let output = StdCommand::new(\"git\")\n                .args([\"checkout\", branch])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git checkout failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            fs::write(repo_dir.join(\"feature.txt\"), \"feature content\")?;\n\n            let output = StdCommand::new(\"git\")\n                .args([\"add\", \".\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git add failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            let output = StdCommand::new(\"git\")\n                .args([\"commit\", \"-m\", \"Add feature\"])\n                .current_dir(\u0026repo_dir)\n                .output()?;\n            anyhow::ensure!(\n                output.status.success(),\n                \"git commit failed: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            );\n\n            // Merge the branch with explicit repo directory\n            merge_and_cleanup_in_dir(branch, Some(\u0026repo_dir), false)\n        };\n\n        // Always restore original directory\n        std::env::set_current_dir(\u0026original_dir).context(\"Failed to restore original directory\")?;\n\n        // Check that branch no longer exists\n        let branch_check = StdCommand::new(\"git\")\n            .args([\"rev-parse\", \"--verify\", \"feature/new-feature\"])\n            .current_dir(\u0026repo_dir)\n            .output()?;\n\n        cleanup_test_repo(\u0026repo_dir)?;\n\n        assert!(\n            result.success \u0026\u0026 result.error.is_none(),\n            \"Merge result: {:?}\",\n            result\n        );\n        // Branch should be deleted after merge\n        assert!(!branch_check.status.success());\n        Ok(())\n    }\n\n    #[test]\n    fn test_remove_worktree_idempotent() -\u003e Result\u003c()\u003e {\n        let path = PathBuf::from(\"/tmp/nonexistent-worktree-12345\");\n\n        // Try to remove a non-existent worktree - should succeed\n        let result = remove_worktree(\u0026path);\n\n        assert!(result.is_ok());\n        Ok(())\n    }\n\n    #[test]\n    fn test_worktree_path_for_spec() {\n        let path = worktree_path_for_spec(\"2026-01-27-001-abc\");\n        assert_eq!(path, PathBuf::from(\"/tmp/chant-2026-01-27-001-abc\"));\n    }\n\n    #[test]\n    fn test_get_active_worktree_nonexistent() {\n        // Test with a spec ID that definitely doesn't have a worktree\n        let result = get_active_worktree(\"nonexistent-spec-12345\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_in_worktree() -\u003e Result\u003c()\u003e {\n        let repo_dir = PathBuf::from(\"/tmp/test-chant-commit-in-worktree\");\n        cleanup_test_repo(\u0026repo_dir)?;\n        setup_test_repo(\u0026repo_dir)?;\n\n        // Create a new file\n        fs::write(repo_dir.join(\"new_file.txt\"), \"content\")?;\n\n        // Commit the changes\n        let result = commit_in_worktree(\u0026repo_dir, \"Test commit message\");\n\n        cleanup_test_repo(\u0026repo_dir)?;\n\n        assert!(result.is_ok());\n        let hash = result.unwrap();\n        // Commit hash should be a 40-character hex string\n        assert_eq!(hash.len(), 40);\n        assert!(hash.chars().all(|c| c.is_ascii_hexdigit()));\n\n        Ok(())\n    }\n\n    #[test]\n    #[serial_test::serial]\n    fn test_commit_in_worktree_no_changes() -\u003e Result\u003c()\u003e {\n        let repo_dir = PathBuf::from(\"/tmp/test-chant-commit-no-changes\");\n        cleanup_test_repo(\u0026repo_dir)?;\n        setup_test_repo(\u0026repo_dir)?;\n\n        // Don't make any changes, just try to commit\n        let result = commit_in_worktree(\u0026repo_dir, \"Empty commit\");\n\n        cleanup_test_repo(\u0026repo_dir)?;\n\n        // Should still succeed (returns HEAD)\n        assert!(result.is_ok());\n        let hash = result.unwrap();\n        assert_eq!(hash.len(), 40);\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":5}},{"line":19,"address":[],"length":0,"stats":{"Line":10}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":24}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":24}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":18}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":15}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":84,"address":[],"length":0,"stats":{"Line":5}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":20}},{"line":91,"address":[],"length":0,"stats":{"Line":10}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":15}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":5}},{"line":118,"address":[],"length":0,"stats":{"Line":15}},{"line":121,"address":[],"length":0,"stats":{"Line":15}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":10}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":12}},{"line":132,"address":[],"length":0,"stats":{"Line":8}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":173,"address":[],"length":0,"stats":{"Line":12}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":12}},{"line":177,"address":[],"length":0,"stats":{"Line":12}},{"line":180,"address":[],"length":0,"stats":{"Line":16}},{"line":186,"address":[],"length":0,"stats":{"Line":20}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":9}},{"line":214,"address":[],"length":0,"stats":{"Line":9}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":248,"address":[],"length":0,"stats":{"Line":6}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":295,"address":[],"length":0,"stats":{"Line":3}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":301,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":345,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":4}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":376,"address":[],"length":0,"stats":{"Line":6}},{"line":377,"address":[],"length":0,"stats":{"Line":4}},{"line":379,"address":[],"length":0,"stats":{"Line":4}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":2}},{"line":417,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":3}},{"line":438,"address":[],"length":0,"stats":{"Line":3}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":3}},{"line":486,"address":[],"length":0,"stats":{"Line":3}},{"line":487,"address":[],"length":0,"stats":{"Line":2}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":1}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":4}},{"line":512,"address":[],"length":0,"stats":{"Line":3}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":1}}],"covered":135,"coverable":206}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, 'ð'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = 'ð';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = 'âï¸';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = 'ð';
    }
  });
})();
</script>
</body>
</html>