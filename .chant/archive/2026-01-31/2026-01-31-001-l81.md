---
type: code
status: completed
target_files:
- src/cmd/cleanup.rs
- src/worktree.rs
commits:
- ddf2926
completed_at: 2026-01-31T22:49:42Z
model: sonnet
---
# Fix cleanup not finding worktrees that worktree status marks as prunable

## Problem

`chant worktree status` and `chant cleanup` use different logic to identify orphan worktrees:

```
% chant worktree status
Found 1 chant worktree:

  /private/tmp/chant-2026-01-27-00n-0td [prunable]
    Branch: chant/2026-01-27-00n-0td
    Spec:   2026-01-27-00n-0td
    Status: unknown (spec not found)
    Reason: gitdir file points to non-existent location

âš  1 prunable worktree (run chant cleanup to clean up)

% chant cleanup
No orphan worktrees found.
```

The `worktree status` command correctly identifies the worktree as prunable, but `cleanup` doesn't find it.

## Root Cause

Likely the commands use different discovery methods:
- `worktree status` may use `git worktree list` or scan `/tmp/chant-*`
- `cleanup` may only look for worktrees with active specs or different path patterns

## Solution

Unify the worktree discovery logic so both commands find the same worktrees.

## Acceptance Criteria

- [x] `chant cleanup` finds and removes worktrees that `worktree status` marks as prunable
- [x] Both commands use shared worktree discovery logic
- [x] Worktrees with "gitdir file points to non-existent location" are cleaned up

## Agent Output

2026-01-31T22:49:42Z

```
I'll investigate and fix the worktree discovery inconsistency between `chant worktree status` and `chant cleanup`.
Found the issue. The `worktree status` command uses `git worktree list --porcelain` to find all worktrees, including prunable ones. The `cleanup` command scans `/tmp/chant-*` directories and checks for `.git` file existence to determine if they're orphans.

A worktree marked as prunable by git (like "gitdir file points to non-existent location") will still have a `.git` file present in the directory, so `is_valid_worktree()` returns true and it's filtered out.

The fix: use `git worktree list --porcelain` in cleanup to find prunable worktrees, instead of just checking for `.git` file existence.
Tests pass. Now verifying the fix works as expected. Let me check if there's an actual prunable worktree to test with:
Perfect! The prunable worktree exists. Now testing the cleanup command:
The issue still exists. The problem is that the prunable worktree has size 0 and doesn't exist on disk, but cleanup scans `/tmp` directories. Let me trace through the logic:
Ah! The worktree directory doesn't exist. The cleanup code scans `/tmp` for existing directories, so it won't find this one. The fix needs to also include worktrees from git's list even if they don't exist on disk:
Excellent! Now cleanup finds the prunable worktree. Let me verify it actually cleans it up:
The worktree doesn't exist on disk, so `fs::remove_dir_all` fails. But `git worktree prune` should handle it. Let me update the logic to handle this case gracefully:
Good! The previous cleanup removed it. Let me verify both commands now show consistent behavior:
Perfect! Both commands are now consistent. Let me update the acceptance criteria:
## Summary

Modified src/cmd/cleanup.rs to use `git worktree list --porcelain` for discovering prunable worktrees, unifying the logic with `chant worktree status`.

- Added `get_prunable_worktrees()` to parse git's prunable worktree list
- Updated `find_orphan_worktrees()` to include prunable worktrees even when they don't exist on disk
- Fixed removal logic to handle non-existent directories without errors
- Both commands now consistently identify and handle the same set of worktrees```
