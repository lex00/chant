---
type: code
status: completed
target_files:
- src/git.rs
- src/cmd/work.rs
- src/worktree.rs
commits:
- b400a0e
completed_at: 2026-01-31T10:21:15Z
model: sonnet
---
# Add ensure_on_main_branch safeguard to chant commands

## Problem

The main repo can get "flipped" off the main branch during various chant operations:

1. **`merge_and_cleanup`** (worktree.rs:199) - calls `git checkout main` in main repo, but if it fails mid-operation, state is unclear
2. **`create_or_switch_branch`** (git_ops.rs:11) - switches main repo to spec branch for single-spec branch mode
3. **Failed operations** - any interruption can leave main on wrong branch

Users expect the main repo to always be on `main` branch. Worktrees handle isolation; main should stay stable.

## Solution

Add an `ensure_on_main_branch()` helper that snaps the main repo back to main, and call it:

1. At the **start** of significant commands (work, merge, finalize)
2. At the **end** of commands (success or failure)
3. In error recovery paths

## Implementation

### Add helper to src/git.rs

```rust
/// Ensure the main repo is on the main branch.
///
/// Call this at command boundaries to prevent branch drift.
/// Uses config's main_branch setting (defaults to "main").
pub fn ensure_on_main_branch(main_branch: &str) -> Result<()> {
    let output = Command::new("git")
        .args(["branch", "--show-current"])
        .output()
        .context("Failed to get current branch")?;

    let current = String::from_utf8_lossy(&output.stdout).trim().to_string();

    if current != main_branch {
        let output = Command::new("git")
            .args(["checkout", main_branch])
            .output()
            .context("Failed to checkout main branch")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            // Don't fail hard - just warn
            eprintln!("Warning: Could not return to {}: {}", main_branch, stderr);
        }
    }

    Ok(())
}
```

### Call sites

1. **cmd_work** - at end of single-spec execution
2. **cmd_work_parallel** - after merge phase completes
3. **merge_and_cleanup** - in error paths
4. **cmd_merge** - at start and end

### Config integration

Use `config.defaults.main_branch` (defaults to "main") to support repos with different default branches.

## Acceptance Criteria

- [x] Add `ensure_on_main_branch(main_branch: &str)` to src/git.rs
- [x] Call at end of `cmd_work` (single spec mode)
- [x] Call at end of `cmd_work_parallel` (after merge phase)
- [x] Call in `merge_and_cleanup` error recovery
- [x] Warn but don't fail if checkout fails (dirty worktree, etc.)
- [x] Use config's main_branch setting
- [x] Add test for ensure_on_main_branch

## Agent Output

2026-01-31T10:21:15Z

```
I'll implement the `ensure_on_main_branch` safeguard for chant commands. Let me start by creating a todo list and then reading the relevant code.
Now let me read the relevant code files to understand the current implementation.
Let me find the correct paths for these files.
Now let me read the relevant files.
Let me search for the specific functions mentioned in the spec.
Let me grep for the specific function signatures with context to understand them better.
Now let me read specific sections of these files to understand the context better. Let me also check the Config structure to see how main_branch is configured.
Perfect! Now I can see that `config.defaults.main_branch` is the field I need to use. Let me update the todo list and move on to planning the implementation.
Now let me plan the implementation approach based on what I've learned:

## Implementation Plan

1. **Add `ensure_on_main_branch` function to src/git.rs**:
   - This function will check the current branch and switch back to main if needed
   - It should warn but not fail if checkout fails (dirty worktree, etc.)
   - It uses `config.defaults.main_branch` setting

2. **Call sites** (based on spec and code analysis):
   - **cmd_work** (src/cmd/work.rs:255) - at the end of single-spec execution
   - **cmd_work_parallel** (src/cmd/work.rs:1654) - after merge phase completes
   - **merge_and_cleanup** (src/worktree.rs:199) - in error recovery paths
   - **cmd_merge** (src/cmd/lifecycle.rs:1655) - at start and end

3. **Testing**: Add a test to src/git.rs to verify the function works correctly

Let me now read the relevant sections of these files to understand the exact placement.
Now let me implement the `ensure_on_main_branch` function in src/git.rs. I'll add it after the `get_current_branch` function.
Now let me add a test for this function in the tests module at the end of src/git.rs.
Now let me add a test for the `ensure_on_main_branch` function.
Now I need to add calls to `ensure_on_main_branch` in the various command functions. Let me start by finding the end of `cmd_work` function to understand where to place the call.
Let me continue reading to find the end of the function.
Let me read the saved file to see the full function.
Let me use a different approach - let me search for the end of the cmd_work function by looking for where it returns.
Let me read around line 839 to see if that's the end of cmd_work.
Perfect! Now I can see that line 838-839 is the end of `cmd_work`. I need to add the call to `ensure_on_main_branch` right before the `Ok(())`. Let me add it.
Now let me find the end of `cmd_work_parallel` function. Let me search for it.
Let me continue reading to find the end of the function.
Let me continue reading to find the end of the function where the merge phase completes.
Let me continue reading to find the end of the function.
Let me continue to find the end of the function.
Perfect! Now I found the end of `cmd_work_parallel` at line 2462. I need to add the call to `ensure_on_main_branch` right before `Ok(())`. Let me update the todo list and add the call.
Now let me add the call to `ensure_on_main_branch` in the `merge_and_cleanup` function. Let me read the function first.
Let me continue reading to find the end of the function.
I can see that `merge_and_cleanup_in_dir` has multiple error paths. According to the spec, I need to add calls in error recovery paths. However, I notice that this function doesn't have access to the config, so I need to think about how to handle this. Looking at the spec again, it mentions calling `ensure_on_main_branch` in error recovery paths. 

Looking at the function more carefully, I see that it's already calling `git checkout main` at the beginning (line 206-207), and the errors happen after that. So if checkout main fails, we're still on the wrong branch. Let me add the ensure call in the error paths. But since this function doesn't have access to config, I'll need to pass in the main_branch parameter or hardcode "main" for now.

Actually, looking at the function signature and how it's called from cmd_work_parallel, I think the best approach is to not modify this function directly but instead ensure the main branch is correct in the calling code. The spec says to call it in error recovery paths of merge_and_cleanup, but since that function is already trying to checkout main, the better place might be to ensure we're on main after calling this function from the higher-level code.

Let me check how this function is being used and whether we should modify it or just ensure the branch is correct in the callers. Looking at the spec again, I see it mentions "In error recovery paths" - but all the error paths in this function already try to return early. The most sensible thing is to add a call at the end of the success path, or to ensure the calling code handles this.

Actually, re-reading the spec more carefully:
- "3. In error recovery paths" for merge_and_cleanup

Let me modify the error paths to

... (output truncated, 9412 chars total)```
