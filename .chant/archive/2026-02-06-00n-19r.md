---
type: code
status: completed
commits:
- 241b1cc
completed_at: 2026-02-06T23:47:33Z
model: sonnet
---
# Add lifecycle integration test that exercises SpecStateMachine through full multi-transition sequences. Test cases: (1) Happy path: Pending→InProgress→Completed with all preconditions (clean tree, criteria checked, commits exist). (2) Retry flow: Pending→InProgress→Failed→Pending→InProgress→Completed. (3) Blocked flow: create spec with unmet dependency, verify Blocked status, resolve dep, verify transition to Pending. (4) Precondition errors: verify DirtyWorktree, UnmetDependencies, NoCommits, UncheckedCriteria are raised when conditions not met. (5) Force bypass: verify .force() allows invalid transitions and skips all preconditions. Put tests in tests/test_state_machine_lifecycle.rs. Use TransitionBuilder directly (not CLI commands) so the state machine module is exercised as a unit. Create realistic Spec structs with frontmatter for each test.

## Agent Output

2026-02-06T23:47:33Z

```
I'll implement the lifecycle integration test for SpecStateMachine. Let me start by reading the relevant code to understand the existing structure.
Now I'll create the lifecycle integration test file:
The tests reveal that the `require_commits_exist()` precondition checks for commits in **all** branches using `--all`, but our test commits are only on the `main` branch. Let me look at the error more carefully and fix the test setup:
The issue is that `has_commits` checks all branches with `--all`. The test commits are being made on main. The test setup needs to ensure the commits are visible to the check. Let me also check the dependency resolution issue:
The commits exist, but they don't match the pattern. Looking back at my test - I see that `make_spec_commit` creates commits with the pattern `chant(spec_id): Complete work`, so the commits should be found. Let me debug this more carefully:
The commit exists! But the test is still failing. Let me check what directory the test is running in. The issue is that the `has_commits` function runs git commands in the **current directory**, not in the test repo directory. The tests need to change the working directory:
Good progress - 3 tests are passing. The two failing tests have `DirtyWorktree` errors, which means the spec files are being modified but not committed. Let me fix this by committing after each status change:
Almost there! Let me check what's going on with the happy path test. Let me run it with more debugging:
The worktree is clean and commits exist. Let me add more detailed error output:
Interesting - it's saying `NoCommits` even though the commits exist. The issue is that `has_commits` is being called from the chant working directory, not the test repo directory. The function uses `Command::new("git")` without setting `current_dir`. Since we changed the current directory with `std::env::set_current_dir`, the git commands should work, but there might be an issue with how the state machine module runs git commands.

Let me look more closely at the `has_commits` function and check if it respects the current directory:
The command works when we explicitly cd. The issue is that the test changes `std::env::current_dir()`, but the `Command::new("git")` in `has_commits` doesn't inherit this change in some cases. Actually wait - `Command` should inherit the process's current directory. Let me trace this more carefully.

Actually, looking at the code again, `has_commits` runs git commands WITHOUT setting `current_dir()`, which means they run in the current process directory. Since we use `std::env::set_current_dir(&repo_dir)`, it should work. But let me verify this is actually working:
Let me add debugging to see what's happening. Actually, let me check if the parallel test execution is causing issues. The tests use `#[serial]` but maybe the directory changes are interfering:
Let me check if there's a timing issue - maybe the commits aren't being created properly. Let me check the actual commit message format more carefully:
The commit message format is correct: `chant(test-happy-001): Complete work`. Let me check if the commit is actually created:
Perfect! The commit is there. So why is `has_commits` returning false? Let me check the current directory inside the test at the point where the transition is called. Actually, I think I see the issue - the `is_clean` function checks if there's a worktree at `/tmp/chant-{spec_id}`, and if not, it checks the current directory. But `has_commits` doesn't have any directory logic - it just runs `git log --all`.

Wait, let me re-read the error more carefully. The issue is that when `TransitionBuilder` calls `has_commits`, it's doing so from within the state_machine module, which runs `git log --all` in whatever the current directory is at that moment. Since we used `std::env::set_current_dir(&repo_dir)`, that should work... unless something is resetting it.

Actually, I think I found it! The `Command::new("git")` calls in our test helper functions like `create_test_spec` and `make_spec_commit` use `.current_dir(repo_dir)`, which sets the directory for THAT command only. But we also need to ensure the current_dir is set when we call the TransitionBuilder. Let me verify the current directory is actually set:
Aha! There's the problem! The current directory is back to the chant checkout directory, not the test repo. The `std::env::set_current_dir` isn't persisting or something is resetting it. Let me check if `Spec::load` is changing the directory:
Actually, I think the issue is that changing `std::env::current_dir()` doesn't work properly across different parts of the program. Let me try a different approach - instead of testing with directory changes, I should make the tests work within a directory structure that the state machine expects. Or better yet, I can verify that the commit check is working properly by not using `require_commits_exist` for now, or by ensuring the test directory is in the right place.

Actually, 

... (output truncated, 7332 chars total)```
