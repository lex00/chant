---
type: code
status: completed
target_files:
- src/main.rs
model: claude-haiku-4-5-20251001
---
# Add chant split command to break specs into ordered subtasks

Split a monolithic spec into multiple ordered subtasks, each leaving code in a compilable state.

## Usage

```bash
chant split <spec-id>
```

## Behavior

1. Read the spec and its acceptance criteria
2. Analyze target files to understand code dependencies
3. Create subtask specs with `depends_on` relationships
4. Mark original spec as a "group" (parent)

## Example

**Before:**
```
01b-chy.md  # Monolithic spec with 6 acceptance criteria
```

**After `chant split 01b`:**
```
01b-chy.md      # Parent (type: group, status: pending)
01b-chy.1.md    # Subtask 1: Add commits field alongside commit
01b-chy.2.md    # Subtask 2: Update detection to populate both
  depends_on: [01b-chy.1]
01b-chy.3.md    # Subtask 3: Update display/MCP
  depends_on: [01b-chy.2]
01b-chy.4.md    # Subtask 4: Migrate existing specs
  depends_on: [01b-chy.3]
01b-chy.5.md    # Subtask 5: Remove old commit field
  depends_on: [01b-chy.4]
```

## Splitting Strategy

The agent should analyze the spec and create subtasks that:

1. **Each subtask leaves code compilable** - No broken intermediate states
2. **Minimal dependency chain** - Parallelize where possible
3. **Atomic units** - Each subtask is independently testable
4. **Preserve intent** - Subtasks together achieve the original goal

For code changes, common patterns:
- Add new alongside old → update callers → remove old
- Schema first → logic second → migration last
- Core change → peripheral updates

## Acceptance Criteria

- [x] Add `Split` subcommand to CLI
- [x] Split invokes agent to analyze spec and create subtasks
- [x] Subtasks use `{parent-id}.N` naming convention
- [x] Subtasks have appropriate `depends_on` relationships
- [x] Parent spec type changes to `group` after split
- [x] Parent marked complete when all subtasks complete
- [x] `chant list` shows subtask hierarchy

## Implementation Notes

The split operation itself uses an agent (claude) to:
1. Read the parent spec
2. Read target files to understand dependencies
3. Propose a split with ordering rationale
4. Create the subtask spec files

This is similar to `chant work` but the output is specs, not code.