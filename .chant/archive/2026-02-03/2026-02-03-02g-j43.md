---
type: code
status: completed
commits:
- 812e667
completed_at: 2026-02-03T22:23:56Z
model: sonnet
---
# Investigate chain mode leaving multiple specs in_progress simultaneously

## Problem

When running `chant work --chain`, the user observes 3 specs showing as `in_progress` simultaneously. Chain mode should only have 1 spec in_progress at a time (sequential execution).

## Expected behavior

- Chain mode processes specs sequentially
- Only 1 spec should be `in_progress` at any time
- Previous spec should be `completed` before next starts

## Investigation tasks

1. Search for where chain mode sets spec status to `in_progress`
2. Check if status is properly updated to `completed` before moving to next spec
3. Look for race conditions in status file writes
4. Check if MCP status queries show stale data
5. Review takeover logic - does it properly clean up previous in_progress specs?

## Likely locations

- `src/cmd/work/` - Chain execution logic
- `src/spec.rs` - Status transitions
- `src/cmd/takeover.rs` - Process handoff

## Acceptance criteria

- [x] Root cause identified
- [x] Fix implemented if bug confirmed
- [x] Add test to prevent regression
- [x] `chant work --chain` only shows 1 in_progress spec at a time

## Agent Output

2026-02-03T22:23:56Z

```
I'll investigate the chain mode issue where multiple specs appear as `in_progress` simultaneously.
Found the issue. In `execute_single_spec_in_chain` at src/cmd/work/chain.rs:220-221, the spec status is set to `InProgress` and saved. However, when `finalize_spec` is called (line 304-311), if it succeeds, the spec status is updated to `Completed` inside `finalize_spec`. But if there's any delay or if the next iteration starts before finalization completes, multiple specs can be in_progress.

The key issue is the status transition happens in two places and there's no atomic operation ensuring the previous spec is completed before the next one starts.
I can see the flow:
1. Chain sets spec to `InProgress` (chain.rs:220)
2. Agent runs
3. `finalize_spec` sets spec to `Completed` (finalize.rs:70) and saves it (finalize.rs:97)
4. Control returns to chain loop

The issue might be that chain starts the next spec before the previous finalization is complete, or MCP queries show stale cached data. Let me check if there's any caching in the MCP handlers.
Now I understand the issue. MCP handlers call `load_all_specs` which reads from disk each time - there's no caching issue. The problem must be in the chain execution itself.

Looking back at chain.rs, I notice that after finalization completes (line 311), the code immediately continues to the next iteration. The loop in `cmd_work_chain_all_ready` (line 582) doesn't reload specs or verify the previous spec is completed before starting the next one.

Let me trace through the exact flow:

1. Line 623: `execute_single_spec_in_chain` is called for spec A
2. Line 220: Spec A set to `InProgress` 
3. Line 304-311: `finalize_spec` is called - should set to `Completed`
4. Line 330: Function returns Ok
5. Line 635: Success branch - completed counter incremented
6. **No reload of specs here**
7. Loop continues to line 600: `find_next_ready_spec` is called
8. Line 62: This calls `load_all_specs` - should see spec A as Completed
9. BUT - if spec A is still being processed by finalize_spec, it might still be InProgress

Wait, let me reread more carefully. The finalize happens synchronously at line 304-311, so by the time it returns at line 330, the spec should be completed and saved.

Let me check if there's an issue with the save operation or if finalize_spec can fail silently.
Interesting! This fix shows that specs need to be looked up from the refreshed `all_specs` to get their current status. The code in chain.rs DOES reload all_specs after each completion (line 496 in chain.rs), but I notice there's a subtle issue.

Let me check the specific-IDs path more carefully:
Perfect! I can see the code DOES reload `all_specs` at line 496 after successful completion. Now let me check the "all ready" path:
Found it! In `cmd_work_chain_all_ready`, after successfully completing a spec (line 635-644), there's NO reload of specs. Compare:

- **Specific IDs path** (line 496): `all_specs = spec::load_all_specs(specs_dir)?;` ✓
- **All ready path** (line 644): NO reload! ✗

This means in the "all ready" path:
1. Spec A completes and is marked as Completed
2. Loop continues immediately
3. `find_next_ready_spec` at line 600 does call `load_all_specs` internally
4. So it SHOULD see the updated status...

Wait, let me check `find_next_ready_spec` again:
OK so `find_next_ready_spec` DOES reload specs at line 62. So theoretically the completed spec should show as completed.

But wait - I just realized the issue! The `is_ready` check at line 71 only checks if dependencies are satisfied. It doesn't exclude specs that are already **InProgress** or **Completed**! 

Looking at line 69-71:
- Excludes Cancelled ✓
- Checks `is_ready` (dependencies) ✓  
- But doesn't check status != InProgress ✗
- Doesn't check status != Completed ✗

So if somehow a spec is still in `InProgress` status when the loop continues, `find_next_ready_spec` could return it again OR return another spec that also gets set to InProgress.

Actually wait, let me reconsider. The spec that just completed SHOULD be marked `Completed` by `finalize_spec`. So it wouldn't be selected again. But could multiple NEW specs be started?

Let me check what `is_ready` does:
Perfect! Line 394-396: `is_ready` returns `false` if status != Pending. So completed and in_progress specs won't be selected by `find_next_ready_spec`.

So the theory that multiple specs are being selected doesn't hold. The issue must be something else.

Let me think about this differently. What if the issue is not with chain selecting multiple specs, but with how status is being reported? Perhaps:

1. Spec A starts, marked InProgress
2. Spec A completes, BUT finalize_spec fails silently or partially?
3. Spec B starts, marked InProgress
4. Now both show as InProgress

Let me check if finalize_spec could fail without raising an error:
Excellent! `finalize_spec` has extensive validation (lines 107-146) and will error if:
- Status isn't Completed
- completed_at isn't set
- The 

... (output truncated, 16071 chars total)```
