---
type: code
status: completed
commits:
- 6670ac9
completed_at: 2026-02-06T20:33:17Z
model: sonnet
---
# Research: Dirty working tree from failed agent runs blocks subsequent work — failed runs leave unstaged changes in the main repo, causing git worktree add to fail silently on next attempt. Investigate: should chant clean up on failure? Should work startup detect and report dirty state? Look at src/cmd/work/single.rs error paths, src/worktree/git_ops.rs create_worktree, and what happens when an agent is killed mid-merge.

## Findings

### Git Worktree Behavior
- `git worktree add` **succeeds** even when main repo has dirty state (unstaged/untracked files)
- Worktrees are created from HEAD commit, not working directory state
- The worktree itself starts clean regardless of main repo state

### Current Code Flow (src/cmd/work/single.rs)

**Worktree Creation** (line 549):
```rust
let worktree_path = worktree::create_worktree(&spec.id, &branch_name, project_name)?;
```

**On Agent Failure** (line 862-889):
1. Writes `.chant-status-{spec_id}.json` with `Failed` status
2. Updates spec to `SpecStatus::Failed`
3. Saves spec and returns error
4. **Does NOT clean up worktree**
5. **Does NOT ensure main branch checkout**

**Worktree Cleanup** (src/worktree/git_ops.rs line 149-164):
- `create_worktree` auto-removes existing worktree if present
- Uses `git worktree remove --force`
- Forcibly deletes directory if git command fails

### The Real Issue: Confirmed Bug

The problem is **NOT** that dirty main repo blocks worktree creation. Git worktree creation succeeds even with dirty main repo.

**The actual bug**: `ensure_on_main_branch` is unreachable on failure path.

src/cmd/work/single.rs lines 862-895:
```rust
Err(e) => {
    // Write agent status file: failed (line 863-880)
    // Update spec to failed (line 882-885)
    println!("\n{} Spec failed: {}", "✗".red(), e);
    return Err(e);  // ❌ Line 888: Returns early
}

// Line 892-894: UNREACHABLE on failure!
let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);

Ok(())
```

### Impact

When an agent fails:
1. ✅ Status file written correctly
2. ✅ Spec marked as `Failed`
3. ❌ **Main repo left on wrong branch**
4. ❌ **Worktree NOT cleaned up** (will be force-removed on next `create_worktree` for same spec)
5. ❌ **If main repo has in-progress merge**: Abandoned, blocking future operations

### What Actually Blocks Subsequent Work

Not dirty state itself, but:
- **Wrong branch**: Main repo stuck on `chant/spec-id` branch instead of `main`
- **In-progress merge**: Unaborted merge state from failed merge attempts
- **Lock files**: `.git/index.lock` or merge conflict markers

### Worktree Cleanup Behavior

src/worktree/git_ops.rs lines 149-164 in `create_worktree()`:
```rust
// Check if worktree already exists
if worktree_path.exists() {
    // Clean up existing worktree
    let _ = Command::new("git")
        .args(["worktree", "remove", "--force", &worktree_path.to_string_lossy()])
        .output();

    // Force remove directory if still present
    if worktree_path.exists() {
        let _ = std::fs::remove_dir_all(&worktree_path);
    }
}
```

**Auto-recovery**: Next `create_worktree` call force-removes old worktree. So worktree accumulation is not an issue.

## Root Cause Summary

**Single point of failure**: Early return at line 888 bypasses cleanup code at line 893.

## Recommended Fixes

### Fix 1: Move cleanup before error return (Minimal)
```rust
Err(e) => {
    // Write status, update spec...

    // Ensure cleanup before returning error
    let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);

    println!("\n{} Spec failed: {}", "✗".red(), e);
    return Err(e);
}
```

### Fix 2: Use defer-like pattern (Better)
```rust
// At function start
let _cleanup_guard = CleanupGuard::new(|| {
    let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);
});
```

### Fix 3: Detect dirty state at startup (Defense in depth)
Before line 549 (`create_worktree`):
```rust
// Check if main repo has uncommitted changes or wrong branch
if let Ok(current_branch) = git::get_current_branch() {
    if current_branch != config.defaults.main_branch {
        eprintln!("Warning: Main repo is on '{}', not '{}'. Did previous run fail?",
                  current_branch, config.defaults.main_branch);
        // Offer to checkout main or abort
    }
}
```

## Acceptance Criteria

None - this is a research task. Findings documented above.

## Agent Output

2026-02-06T20:33:17Z

```
I'll investigate the dirty working tree issue by examining the relevant code paths.
Now I need to look at how worktree cleanup happens on failure and what state gets left behind.
Now let me check how the main repo's dirty state is checked on work startup:
Let me create a test to reproduce the issue:
Interesting - `git worktree add` doesn't actually fail when the main repo has untracked files. Let me test with staged/uncommitted changes:
Good - so git worktree add succeeds even with unstaged changes in the main repo. The worktree is created clean. Let me now understand the actual problem - what happens when an agent fails mid-work:
Now let me verify this finding by checking the actual code flow more carefully:
Perfect! I confirmed the issue. Line 888 does `return Err(e)` which means line 893's `ensure_on_main_branch` is **never reached** on the failure path. Let me update the spec with complete findings:
## Summary

Research completed. Root cause identified:

**Bug**: `ensure_on_main_branch()` at line 893 is unreachable when agent fails because line 888 returns early with error.

**Impact**: Failed agent runs leave main repo on wrong branch, blocking subsequent operations.

**Fix**: Move cleanup code before error return in failure path.

Key findings documented in spec file with:
- Confirmed git worktree behavior 
- Identified unreachable cleanup code
- Traced actual failure path
- Recommended 3 fix strategies```
