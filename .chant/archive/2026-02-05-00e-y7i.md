---
type: code
status: completed
branch: chant/2026-02-05-00e-y7i
commits:
- 33860d9
completed_at: 2026-02-05T20:02:33Z
model: sonnet
---
# Fix watch false positive: Watch log reports "Spec is completed" and "failed to finalize" while workers are still actively running. Watch incorrectly detects completion status when checking in-progress specs in worktrees.

## Acceptance Criteria

- [x] `is_completed()` reads spec from worktree when active worktree exists
- [x] `is_failed()` reads spec from worktree when active worktree exists
- [x] Code compiles without errors
- [x] Clippy passes with no warnings

## Agent Output

2026-02-05T20:02:33Z

```
I'll implement this fix by first understanding the watch mechanism and how it incorrectly detects completion status for in-progress specs in worktrees.
Now I understand the issue. The watch command in `src/cmd/watch.rs` calls `is_completed()` and `is_failed()` on in-progress specs around lines 629 and 660. However, these functions load the spec from the **main repository** (`.chant/specs`), not from the worktree where the agent is actively working.

When an agent in a worktree checks off acceptance criteria and commits its work, those changes exist only in the worktree branch, not in the main repo. The watch command therefore sees the stale, unmodified spec in the main repo and incorrectly concludes the spec is completed (if all old criteria were already checked) or fails to detect completion.

The fix is to modify `is_completed()` and `is_failed()` to load the spec from the worktree when checking in-progress specs.
Perfect! I can see that `get_active_worktree()` is available at line 25 to check if a worktree exists for a spec. Now I'll modify the `is_completed()` and `is_failed()` functions to load specs from the worktree when available.
Now I need to add the helper function `load_spec_from_worktree_or_main()`:
Now let's run `cargo fmt` and `cargo clippy` to ensure the code is properly formatted and has no lint errors:
Good! Now let's run the tests to make sure nothing broke:
Let's check the spec file to see what acceptance criteria need to be checked off:
The spec file seems incomplete. Let me check for the full spec:
The spec file appears to be missing its body. Let me look for the acceptance criteria or create appropriate ones based on the task:
The spec doesn't have acceptance criteria yet. Let me add them to properly track this work:
Now let's commit the changes:
Let me check git status:
There are changes to `src/mcp/handlers.rs` that aren't part of this spec. Let me stage only the files related to this fix:
The `.chant` directory is in gitignore. Let me commit just the source file:
It seems `src/spec/lifecycle.rs` was already committed. Let me check the git log:
Let me check if my changes are already present in a different location or if they were auto-committed:
No uncommitted changes. Let me check if my changes are in the HEAD commit:
The changes are already in HEAD but there's no commit with the spec ID. Let me check when these changes were made:
No commits with this spec ID exist. Let me check the git log to see which commit contains my changes:
Let me check the actual git history for this file:
Let me check that commit:
Let me look more carefully - maybe my edits weren't saved to disk. Let me re-check the current state of the file:
The function is in the file. Let me check the actual committed version vs working directory:
So the file has no uncommitted changes. The function is already in HEAD. It appears the changes were auto-committed somehow. Let me verify that the fix is actually present by reading the committed version:
Perfect! The fix is already in place. It seems the changes were auto-saved and maybe auto-committed. Let me look at how they got committed - check if there was an amend or something:
Interesting! The changes are already in commit `89845da`. Let me check if that commit actually matches our spec ID or if there was some confusion. Let me see the full commit message again:
That commit is for a different spec (`00h-uzs`). Let me check if perhaps the commit was amended or if this is a rebase situation. Let me see what the parent commit has:
Aha! So commit `cb26a5c` has the old version, and commit `89845da` has my new version. This means my changes were included in commit `89845da` which is for a different spec. That commit must have been amended or the changes were part of a batch. 

Since the fix is already committed (albeit under a different spec ID), I need to create a new commit just for this spec to properly track it:
Now let's verify git status is clean:
There are still some unrelated changes in `src/mcp/handlers.rs` and `src/mcp/mod.rs`. These aren't part of this spec, so I'll leave them uncommitted. The spec work is complete and committed.

## Summary

Fixed watch false positive by modifying `is_completed()` and `is_failed()` in `src/spec/lifecycle.rs` to read spec state from active worktrees instead of only from the main repository.

- Added `load_spec_from_worktree_or_main()` helper function that checks for active worktree and loads spec from there first, falling back to main repo
- Updated `is_completed()` to use the new helper
- Updated `is_failed()` to use the new helper

This prevents watch from incorrectly reporting completion status when checking in-progress specs, since it now sees the current state in the worktree where the agent is actively working.```
