---
type: code
status: completed
depends_on:
- 2026-01-30-00e-y44.4
target_files:
- src/score/splittability.rs
commits:
- f85841b
completed_at: 2026-01-31T17:21:24Z
model: sonnet
---
# Splittability Scoring Implementation

Implement scoring to determine if a spec can be effectively decomposed.

### Acceptance Criteria

- [x] Implement `calculate_splittability(spec: &Spec) -> SplittabilityGrade` function
- [x] Grade A: Clear subsections (3+ headers), multiple target files (3+), independent tasks
- [x] Grade B: Some structure (1-2 headers), 2 target files
- [x] Grade C: Single concern, 1 target file, minimal structure
- [x] Grade D: Tightly coupled indicators (many cross-references, shared state mentioned)
- [x] Detect subsections by counting markdown headers in body

### Edge Cases

- Specs already part of a group (has parent_id) should be Grade C (already split)
- Specs with 1 criterion should be Grade C (atomic)
- Detection of coupling keywords: "shared", "depends on each other", "tightly coupled"

### Example Test Cases

- Spec with 4 headers, 5 files, 8 criteria → Grade A
- Spec with 1 header, 2 files, 3 criteria → Grade B
- Spec with 0 headers, 1 file, 1 criterion → Grade C
- Spec mentioning "tightly coupled components" → Grade D

### Provides

- `calculate_splittability(spec: &Spec) -> SplittabilityGrade` - Returns grade based on decomposability

## Agent Output

2026-01-31T17:21:24Z

```
I'll implement the splittability scoring functionality for chant. Let me start by reading the relevant code to understand the existing structure.
Let me first check what existing scoring implementations look like in the codebase.
Now let me read the existing scoring implementation and the Spec structure to understand the patterns.
Let me read the spec structure in smaller portions and check the existing scoring module structure.
Now let me check the mod.rs file and look for references to parent_id in the Spec structure.
Let me check if there's a parent_id field in the Spec structure and understand how to count headers.
Good! Now let me understand how to count markdown headers and check the vague patterns list. Let me update the todo list and plan the implementation.
Now let me plan the implementation:

**Implementation Plan:**

1. Create `src/score/splittability.rs` file
2. Implement helper functions:
   - `count_markdown_headers(body: &str) -> usize` - counts `##` headers (not `#` or in code blocks)
   - `count_target_files(spec: &Spec) -> usize` - gets target files count
   - `count_criteria(spec: &Spec) -> usize` - uses existing `count_total_checkboxes()`
   - `has_coupling_keywords(body: &str) -> bool` - checks for coupling indicators
   - `is_part_of_group(spec_id: &str) -> bool` - checks if ID has `.N` pattern

3. Implement main function `calculate_splittability(spec: &Spec) -> SplittabilityGrade`:
   - Check edge cases first (D grade for coupling, C for group members/atomic)
   - Then grade A, B, C based on headers/files/criteria

4. Add comprehensive tests covering all example test cases and edge cases
5. Update `src/score/mod.rs` to export the new module

Let me start implementing:
Now I need to update the mod.rs file to export the new module.
Now let's run cargo fmt and cargo clippy.
Let me fix the clippy warning.
Now let's run clippy again.
Great! Now let's run the tests.
Let me check the full test output to see if there are any failures.
Let me check the end of the file to see the test summary.
Perfect! All tests passed. Now let me verify all acceptance criteria are met and check them off in the spec file.
Let me verify all acceptance criteria:

1. ✅ Implemented `calculate_splittability(spec: &Spec) -> SplittabilityGrade` function
2. ✅ Grade A: Clear subsections (3+ headers), multiple target files (3+), independent tasks
3. ✅ Grade B: Some structure (1-2 headers), 2 target files  
4. ✅ Grade C: Single concern, 1 target file, minimal structure
5. ✅ Grade D: Tightly coupled indicators (many cross-references, shared state mentioned)
6. ✅ Detect subsections by counting markdown headers in body

All criteria are met! Now let me check them off in the spec file.
Now let me commit the changes with the proper message.
I notice there's an unrelated spec file (2026-01-31-007-r93.md) that got added. Let me unstage that and commit only the splittability implementation changes.
Perfect! Now let me verify git status is clean.
Good! The git status shows only the untracked file which is not part of this spec. Let me mark the final todo as completed.
Perfect! I've successfully implemented the splittability scoring feature for chant. Here's a summary of what was completed:

## Implementation Summary

**Created:** `src/score/splittability.rs`

**Key Features:**
1. `calculate_splittability(spec: &Spec) -> SplittabilityGrade` - Main scoring function
2. Grade A: Clear subsections (3+ headers), multiple target files (3+), independent tasks
3. Grade B: Some structure (1-2 headers), 2 target files
4. Grade C: Single concern, 1 target file, minimal structure
5. Grade D: Tightly coupled indicators (coupling keywords detected)

**Edge Cases Handled:**
- Specs already part of a group (has `.N` pattern in ID) → Grade C (already split)
- Specs with 1 criterion → Grade C (atomic)
- Coupling keywords ("shared", "depends on each other", "tightly coupled") → Grade D

**Helper Functions:**
- `count_markdown_headers()` - Counts `##` headers outside code blocks
- `count_target_files()` - Gets target file count from frontmatter
- `has_coupling_keywords()` - Detects coupling indicators (case-insensitive)
- `is_part_of_group()` - Checks if spec ID indicates group membership

**Testing:**
- 17 comprehensive tests covering all grading scenarios and edge cases
- All tests passing
- Code formatted with `cargo fmt`
- No clippy warnings

**Changes Committed:**
- Created `src/score/splittability.rs` (506 lines)
- Updated `src/score/mod.rs` to export new module
- All acceptance criteria checked off in spec file

The implementation follows the same patterns as the existing `confidence.rs` scoring module and integrates seamlessly with the chant scoring system.```
