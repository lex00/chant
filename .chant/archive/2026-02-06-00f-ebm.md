---
type: code
status: completed
branch: chant/2026-02-06-00f-ebm
commits:
- 48dc452
completed_at: 2026-02-06T22:56:23Z
model: sonnet
---
# Research: Internal state machine for spec lifecycle enforcement — currently chant enforces lifecycle rules at the edges (CLI entry points, prompts, finalization checks) but nothing centrally guarantees invariants between states. Investigate whether chant needs a formal state machine that: validates all transitions (pending→in_progress→completed/failed), enforces preconditions per transition (clean tree, criteria checked, no locks), prevents invalid states (in_progress without worktree, completed without commits), and provides a single place to add cross-cutting concerns (logging, cleanup, notifications). Consider tradeoffs: added complexity vs current "everything is a prompt" simplicity. Look at how status transitions happen across single.rs, parallel.rs, watch.rs, finalize.rs, and the MCP tools.

## Findings

### Current State Architecture

Chant follows a **decentralized, edge-based** lifecycle model:

1. **Status Enum** (`src/spec/frontmatter.rs`):
   - `Pending`, `InProgress`, `Paused`, `Completed`, `Failed`, `NeedsAttention`, `Blocked`, `Cancelled`, `Ready`
   - No transition logic encoded in the enum itself
   - Status is a simple field in `SpecFrontmatter`

2. **Transition Points** (where status changes happen):
   - **single.rs:569**: `pending → in_progress` when work starts
   - **single.rs:685/884**: `in_progress → failed` when agent errors
   - **single.rs:569** via finalize: `in_progress → completed` after validation
   - **parallel.rs:504**: `pending → in_progress` in parallel mode
   - **parallel.rs:779/838**: `in_progress → failed/needs_attention` on error
   - **watch.rs:446**: `working → failed` for stale worktrees
   - **finalize.rs:83**: `in_progress → completed` with validation
   - **takeover.rs:82**: `in_progress → paused` during takeover
   - **lifecycle.rs:28-49**: `pending ⟷ blocked` based on dependencies

3. **Precondition Checks** (scattered):
   - **single.rs:251-253**: Lint validation before work
   - **single.rs:902-926**: Status preconditions in `validate_work_preconditions`
   - **finalize.rs:38-46**: Uncommitted changes check
   - **finalize.rs:49-56**: Incomplete members check for drivers
   - **lifecycle.rs:214-237**: Completion criteria (in_progress, all AC checked, commits exist, clean tree)
   - **lifecycle.rs:283-313**: Failure criteria (in_progress, no lock, incomplete AC, no commits)

4. **Invariant Enforcement**:
   - **No central validation** - each transition site checks what it needs
   - **finalize.rs:120-176**: Post-save validation (reload from disk to verify)
   - **lifecycle.rs:14-50**: Dependency-based blocked status applied during load
   - **Edge-based checks**: Each command validates preconditions before acting

### Transition Patterns Found

**Valid transitions observed:**
- `pending → in_progress` (work starts)
- `pending → blocked` (dependencies unmet)
- `blocked → pending` (dependencies resolved)
- `in_progress → completed` (finalization)
- `in_progress → failed` (agent error)
- `in_progress → needs_attention` (validation failure)
- `in_progress → paused` (takeover)
- `failed → pending` (reset for retry)

**Preconditions per transition:**
- `→ in_progress`: Must be pending/failed/blocked/paused, not completed/cancelled, dependencies met (unless --skip-deps), lint passes
- `→ completed`: Must be in_progress, all AC checked, commits exist, worktree clean, no incomplete members (for drivers)
- `→ failed`: Agent exited, incomplete AC, no success signals
- `→ blocked`: Has unmet dependencies, currently pending/blocked

### Evidence of Problems

**Current approach has revealed issues:**
1. **Race conditions** (parallel.rs:723-748): Comment describes finalization race where specs show completed on feature branch but not main
2. **Invalid states possible**: No central enforcement prevents `in_progress` without worktree or `completed` without commits
3. **Scattered validation**: 5+ files contain status transition logic with duplicated checks
4. **Post-facto verification** (finalize.rs:120-176): Need to reload and verify after save because no transactional guarantees
5. **Watch complexity** (watch.rs:214-236): Checks `is_completed` and `is_failed` which duplicate finalize logic

### Tradeoffs Analysis

**Benefits of formal state machine:**
- ✅ Single source of truth for transitions
- ✅ Centralized precondition validation
- ✅ Prevents impossible states
- ✅ Easier to add cross-cutting concerns (logging, hooks, metrics)
- ✅ Self-documenting lifecycle
- ✅ Atomic transitions with validation

**Costs of formal state machine:**
- ❌ Additional abstraction layer
- ❌ All transition sites must use the API (refactor burden)
- ❌ May reduce flexibility for edge cases
- ❌ Requires careful design of precondition system
- ❌ Could add runtime overhead for validation

**Current "edge-based" benefits:**
- ✅ Simple - just set `spec.frontmatter.status = X`
- ✅ Flexible - can handle special cases locally
- ✅ No abstraction overhead
- ✅ Easy to understand for small changes

**Current "edge-based" costs:**
- ❌ No transition guarantees
- ❌ Duplicated validation logic
- ❌ Easy to forget checks
- ❌ Hard to audit all transitions
- ❌ No protection against invalid states

## Recommendation

**Implement a hybrid approach:**

1. **Create a `SpecStateMachine` module** in `src/spec/state_machine.rs`:
   - Encode valid transitions with builder pattern
   - Validate preconditions before transition
   - Return `Result<(), TransitionError>` with clear errors
   - Allow "escape hatch" for special cases with explicit bypass

2. **Transition sites should use the state machine:**
   ```rust
   // Instead of: spec.frontmatter.status = SpecStatus::InProgress;
   SpecStateMachine::new(&mut spec)
       .require_clean_tree()
       .require_dependencies_met(&all_specs)
       .transition_to(SpecStatus::InProgress)?;
   ```

3. **Keep edge-based checks for read-only queries:**
   - `is_completed`, `is_failed`, etc. can remain in lifecycle.rs
   - State machine handles mutations only

4. **Phase the rollout:**
   - Phase 1: Create state machine alongside existing code
   - Phase 2: Migrate high-value transitions (work start, finalization)
   - Phase 3: Full migration, deprecate direct status assignment

5. **Design principles:**
   - State machine is optional, not mandatory (backwards compatible)
   - Provides convenience + safety, not rigid enforcement
   - Clear error messages guide developers to correct usage
   - Escape hatch available for truly exceptional cases

## Acceptance Criteria

- [x] Identify all status transition points in codebase
- [x] Document current preconditions and validation approach
- [x] Analyze tradeoffs of centralized vs edge-based validation
- [x] Provide concrete recommendation with migration path

## Agent Output

2026-02-06T22:56:23Z

```
I'll research the spec lifecycle state machine question by examining the current codebase.
Now I have enough information. Let me write the research findings to the spec.
## Summary

Researched spec lifecycle state machine architecture in chant.

### Current Architecture (Edge-Based)

- **9 status states** with no transition logic in enum
- **Status changes scattered** across 8+ files (single.rs, parallel.rs, watch.rs, finalize.rs, takeover.rs, lifecycle.rs, MCP handlers)
- **Preconditions validated locally** at each transition site
- **No central enforcement** preventing invalid states

### Key Findings

**Transition points identified:**
- Work start: pending → in_progress (single.rs:569, parallel.rs:504)
- Finalization: in_progress → completed (finalize.rs:83)
- Failure: in_progress → failed/needs_attention (scattered)
- Dependencies: pending ⟷ blocked (lifecycle.rs:28-49)
- Takeover: in_progress → paused (takeover.rs:82)

**Evidence of problems:**
- Race condition comments in parallel.rs about finalization ordering
- Post-facto verification needed in finalize.rs (reload to verify save)
- Duplicated validation logic across 5+ files
- No protection against in_progress without worktree or completed without commits

### Recommendation

**Hybrid approach** with phased migration:
- Create `SpecStateMachine` module with builder pattern
- Validate preconditions before transitions
- Optional, not mandatory (backwards compatible)
- Provide escape hatch for exceptional cases
- Migrate high-value transitions first (work start, finalization)

Commit: 48dc452```
