---
type: code
status: in_progress
target_files:
- src/spec.rs
- src/cmd/spec/list.rs
- src/cmd/spec/show.rs
---
# Smart spec resolution - read in_progress specs from their working branch

## Problem

When specs are worked in worktrees/branches:
- Checkbox progress happens on the branch (`- [ ]` becomes `- [x]`)
- Main branch doesn't see this progress until merge
- `chant list` and `chant show` read from main, showing stale state
- User has no visibility into work progress without checking branches manually

## Solution

For `in_progress` specs, check if a working branch exists and read the spec file from that branch using `git show`. Display the "live" state from the branch.

This is read-only - no checkouts, no commits on main, just visibility.

## Implementation

### Add branch-aware spec loading

```rust
/// Load a spec, optionally resolving from its working branch.
///
/// If the spec is in_progress and has a branch (frontmatter.branch or chant/{id}),
/// attempt to read the spec content from that branch for live progress.
pub fn load_with_branch_resolution(spec_path: &Path) -> Result<Spec> {
    let spec = Spec::load(spec_path)?;

    // Only resolve for in_progress specs
    if spec.frontmatter.status != SpecStatus::InProgress {
        return Ok(spec);
    }

    // Try to find the working branch
    let branch_name = spec.frontmatter.branch
        .clone()
        .unwrap_or_else(|| format!("chant/{}", spec.id));

    // Check if branch exists
    if !branch_exists(&branch_name)? {
        return Ok(spec);
    }

    // Read spec from branch
    match read_spec_from_branch(&spec.id, &branch_name) {
        Ok(branch_spec) => Ok(branch_spec),
        Err(_) => Ok(spec), // Fall back to main version
    }
}

fn branch_exists(branch: &str) -> Result<bool> {
    let output = Command::new("git")
        .args(["rev-parse", "--verify", branch])
        .output()?;
    Ok(output.status.success())
}

fn read_spec_from_branch(spec_id: &str, branch: &str) -> Result<Spec> {
    let spec_path = format!(".chant/specs/{}.md", spec_id);
    let output = Command::new("git")
        .args(["show", &format!("{}:{}", branch, spec_path)])
        .output()?;

    if !output.status.success() {
        anyhow::bail!("Spec not found on branch");
    }

    let content = String::from_utf8_lossy(&output.stdout);
    Spec::parse(&content, spec_id)
}
```

### Update list command

In `cmd_list`, use `load_with_branch_resolution` and indicate when showing branch state:

```
[in_progress] 2026-01-31-001-abc - Implement feature (3/5 criteria) [branch]
```

### Update show command

In `cmd_show`, use resolved spec and show header:

```
Spec: 2026-01-31-001-abc (showing state from branch chant/2026-01-31-001-abc)
```

### MCP tools

Update `chant_spec_get` and `chant_spec_list` to use resolution by default.

## Acceptance Criteria

- [x] Add `load_with_branch_resolution` to src/spec.rs
- [x] Add `branch_exists` and `read_spec_from_branch` helpers
- [x] Update `cmd_list` to use branch resolution for in_progress specs
- [x] Show indicator when displaying branch state (e.g., `[branch]` suffix)
- [x] Update `cmd_show` to use branch resolution
- [x] Show header indicating branch source
- [x] Update MCP `chant_spec_get` to use resolution
- [x] Update MCP `chant_spec_list` to use resolution
- [x] Add `--main-only` flag to skip resolution (for debugging)
- [x] Graceful fallback if branch read fails
- [x] Add tests for branch resolution (basic smoke tests; comprehensive tests in 2026-01-31-008-zms)