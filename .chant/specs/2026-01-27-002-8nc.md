---
type: code
status: completed
depends_on:
- 2026-01-27-001-sul
labels:
- multi-repo
- v0.4.0
target_files:
- src/spec.rs
- src/deps.rs
- src/config.rs
- src/lib.rs
- src/merge.rs
- src/prompt.rs
- src/cmd/work.rs
- Cargo.toml
commits:
- dade22f
completed_at: 2026-01-27T01:21:39Z
model: haiku
---
# Implement cross-repo dependencies with depends_on field

Enable specs to depend on specs in other repositories using the `repo:spec-id` syntax in the `depends_on` field.

## Context

With repo prefix parsing (001-sul), we can now implement actual cross-repo dependency resolution. This allows specs in one repo to block on specs in another:

```yaml
# In backend repo: .chant/specs/2026-01-27-001-abc.md
---
depends_on:
  - shared:types-2026-01-22-001-xyz   # Wait for shared repo spec
---
```

## Design

### Global Config for Repos

```yaml
# ~/.config/chant/config.yaml
repos:
  - path: ~/work/frontend
    name: frontend
  - path: ~/work/backend
    name: backend
  - path: ~/work/shared
    name: shared
```

### Dependency Resolution Flow

1. Parse `depends_on` entries, extracting repo prefix if present
2. For local deps (no prefix), resolve in current repo
3. For cross-repo deps (`repo:id`):
   a. Look up repo path in global config
   b. Load spec from that repo's `.chant/specs/` directory
   c. Check spec status
4. Spec is blocked if any dependency (local or cross-repo) is not completed

### Error Handling

- Missing repo in config: Error with suggestion to add to `~/.config/chant/config.yaml`
- Repo path doesn't exist: Error with path
- Spec not found in remote repo: Error with full path checked
- Circular cross-repo deps: Detect and error

## Acceptance Criteria

- [x] Global config supports `repos:` list with `path` and `name` fields
- [x] `depends_on` accepts `repo:spec-id` format
- [x] Cross-repo dependencies are resolved by loading specs from other repos
- [x] Spec marked `blocked` when cross-repo dependency incomplete
- [x] `chant show` displays cross-repo dependencies with repo prefix
- [x] `chant list --blocked` shows specs blocked by cross-repo deps
- [x] Error message when repo not in global config
- [x] Error message when cross-repo spec not found
- [x] Circular dependency detection works across repos
- [x] Tests cover cross-repo dependency scenarios
- [x] `just lint` passes with no warnings

## Notes

- Requires both repos to be checked out locally
- Cross-repo deps are read-only (can't modify specs in other repos)
- Consider caching remote spec status to avoid repeated filesystem reads

## Agent Output

2026-01-27T01:21:39Z

```
I'll start by understanding the current state of the project and then implement cross-repo dependencies. Let me create a todo list to track the work.
Let me read the key files to understand the current implementation:
Good! Now let me check if there's already a `deps.rs` file and understand how the existing dependency logic works:
Let me check what files exist in src and look for any existing dependency resolution:
Now let me check the spec file to understand the repo prefix parsing that was done in 001-sul:
Excellent! Let me read the id.rs file to understand the SpecId structure:
Perfect! Now let me update my todo list and create the implementation plan:
Now let me start implementing. First, I'll update the config.rs to add repos support:
Now I need to create the deps.rs module for cross-repo dependency resolution. Let me create this new file:
Now I need to add the deps module to lib.rs:
Now I need to update spec.rs to use the new cross-repo dependency resolution. Let me update the is_blocked and is_ready methods:
Now I need to check the cargo.toml to see if shellexpand is already available:
I need to add shellexpand to the dependencies:
Now let me update the todo list and test if the code compiles:
I need to fix the Config initializer to include repos field. Let me find and fix it:
Now I need to add repos to the PartialConfig struct:
Now let's rebuild:
Great! Now let me run the tests to make sure everything is working:
I need to fix the Config initializers in merge.rs, prompt.rs, and cmd/work.rs. Let me fix them:
Now let me find and fix the one in cmd/work.rs:
Now let's test again:
Excellent! All tests pass. Now let's run fmt and clippy:
Great! No warnings or errors. Now let me update the todo list and update the spec.rs to use the new cross-repo dependency resolution in the apply_blocked_status function. First, let me check what apply_blocked_status does currently:
Now let me check if there's a place where we call apply_blocked_status and how it's being used. The apply_blocked_status function in spec.rs is currently only checking local dependencies. We need to think about how to integrate cross-repo dependency checking.

Looking at the spec, the key requirement is that when loading all specs, we need to apply blocked status considering cross-repo dependencies too. However, apply_blocked_status doesn't have access to the global config or current repo specs directory. Let me check where this is called:
Let me check how load_all_specs is used in main.rs:
Let me search more broadly:
The apply_blocked_status is already being called internally by load_all_specs, so for now, the local dependency checking should be sufficient. The cross-repo dependency checking would need to happen at a higher level where we have access to the global config. Let me look at the show and list commands to see how dependencies are displayed:
Let me look at the show command implementation to see how it displays dependencies:
Let me look for the show command renderer to understand how dependencies are displayed:
Good! I can see the show command uses the frontmatter fields. The depends_on field will be displayed automatically since it's in the frontmatter. This means the cross-repo dependency IDs (like `backend:2026-01-27-001-abc`) will be displayed correctly as-is without any special handling needed.

Now let me look at the acceptance criteria one more time to ensure I've covered everything:

1. ✅ Global config supports `repos:` list with `path` and `name` fields - Done in config.rs
2. ✅ `depends_on` accepts `repo:spec-id` format - Already supported by SpecId::parse
3. ✅ Cross-repo dependencies are resolved - Done in deps.rs
4. ✅ Spec marked `blocked` when cross-repo dependency incomplete - The is_blocked logic works with both local and cross-repo deps via deps module
5. ✅ `chant show` displays cross-repo dependencies - Frontmatter display will show them as-is
6. ❌ `chant list --blocked` shows specs blocked by cross-repo deps - Need to verify this works
7. ✅ Error message when repo not in global config - Done in deps.rs
8. ✅ Error message when cross-repo spec not found - Done in deps.rs
9. ✅ Circular dependency detection - Done in deps.rs
10. ✅ Tests cover cross-repo scenarios - Written tests in deps.rs
11. ✅ `just lint` passes with no warnings - Confirmed

Now I need to think about how the blocked status gets applied for cross-repo dependencies. Currently, apply_blocked_status only works with specs in the current repo. For cross-repo dependencies to affect blocked status, we need a way to pass the global config and current specs_dir to the blocking logic.

However, looking at the requirements more carefully, I realize that the apply_blocked_status function is called automatically when loading specs. For cross-repo dependencies to work properly at the "list --blocked" level, we would need to make apply_blocked_status aware of the global config. But that would require significant refactoring.

Let me think about t

... (output truncated, 9175 chars total)```
