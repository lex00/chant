---
type: code
status: in_progress
---
# Research: Dirty working tree from failed agent runs blocks subsequent work — failed runs leave unstaged changes in the main repo, causing git worktree add to fail silently on next attempt. Investigate: should chant clean up on failure? Should work startup detect and report dirty state? Look at src/cmd/work/single.rs error paths, src/worktree/git_ops.rs create_worktree, and what happens when an agent is killed mid-merge.

## Findings

### Git Worktree Behavior
- `git worktree add` **succeeds** even when main repo has dirty state (unstaged/untracked files)
- Worktrees are created from HEAD commit, not working directory state
- The worktree itself starts clean regardless of main repo state

### Current Code Flow (src/cmd/work/single.rs)

**Worktree Creation** (line 549):
```rust
let worktree_path = worktree::create_worktree(&spec.id, &branch_name, project_name)?;
```

**On Agent Failure** (line 862-889):
1. Writes `.chant-status-{spec_id}.json` with `Failed` status
2. Updates spec to `SpecStatus::Failed`
3. Saves spec and returns error
4. **Does NOT clean up worktree**
5. **Does NOT ensure main branch checkout**

**Worktree Cleanup** (src/worktree/git_ops.rs line 149-164):
- `create_worktree` auto-removes existing worktree if present
- Uses `git worktree remove --force`
- Forcibly deletes directory if git command fails

### The Real Issue: Confirmed Bug

The problem is **NOT** that dirty main repo blocks worktree creation. Git worktree creation succeeds even with dirty main repo.

**The actual bug**: `ensure_on_main_branch` is unreachable on failure path.

src/cmd/work/single.rs lines 862-895:
```rust
Err(e) => {
    // Write agent status file: failed (line 863-880)
    // Update spec to failed (line 882-885)
    println!("\n{} Spec failed: {}", "✗".red(), e);
    return Err(e);  // ❌ Line 888: Returns early
}

// Line 892-894: UNREACHABLE on failure!
let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);

Ok(())
```

### Impact

When an agent fails:
1. ✅ Status file written correctly
2. ✅ Spec marked as `Failed`
3. ❌ **Main repo left on wrong branch**
4. ❌ **Worktree NOT cleaned up** (will be force-removed on next `create_worktree` for same spec)
5. ❌ **If main repo has in-progress merge**: Abandoned, blocking future operations

### What Actually Blocks Subsequent Work

Not dirty state itself, but:
- **Wrong branch**: Main repo stuck on `chant/spec-id` branch instead of `main`
- **In-progress merge**: Unaborted merge state from failed merge attempts
- **Lock files**: `.git/index.lock` or merge conflict markers

### Worktree Cleanup Behavior

src/worktree/git_ops.rs lines 149-164 in `create_worktree()`:
```rust
// Check if worktree already exists
if worktree_path.exists() {
    // Clean up existing worktree
    let _ = Command::new("git")
        .args(["worktree", "remove", "--force", &worktree_path.to_string_lossy()])
        .output();

    // Force remove directory if still present
    if worktree_path.exists() {
        let _ = std::fs::remove_dir_all(&worktree_path);
    }
}
```

**Auto-recovery**: Next `create_worktree` call force-removes old worktree. So worktree accumulation is not an issue.

## Root Cause Summary

**Single point of failure**: Early return at line 888 bypasses cleanup code at line 893.

## Recommended Fixes

### Fix 1: Move cleanup before error return (Minimal)
```rust
Err(e) => {
    // Write status, update spec...

    // Ensure cleanup before returning error
    let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);

    println!("\n{} Spec failed: {}", "✗".red(), e);
    return Err(e);
}
```

### Fix 2: Use defer-like pattern (Better)
```rust
// At function start
let _cleanup_guard = CleanupGuard::new(|| {
    let _ = chant::git::ensure_on_main_branch(&config.defaults.main_branch);
});
```

### Fix 3: Detect dirty state at startup (Defense in depth)
Before line 549 (`create_worktree`):
```rust
// Check if main repo has uncommitted changes or wrong branch
if let Ok(current_branch) = git::get_current_branch() {
    if current_branch != config.defaults.main_branch {
        eprintln!("Warning: Main repo is on '{}', not '{}'. Did previous run fail?",
                  current_branch, config.defaults.main_branch);
        // Offer to checkout main or abort
    }
}
```

## Acceptance Criteria

None - this is a research task. Findings documented above.