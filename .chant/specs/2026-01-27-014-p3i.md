---
type: code
status: in_progress
target_files:
- tests/integration_tests.rs
---
# Add integration test for dependency chain updates

## Problem

No integration test covers the real-world scenario of completing specs in a dependency chain and verifying dependent specs become ready.

**Untested Workflow:**
1. Create spec A (no dependencies)
2. Create spec B (depends on A)
3. Create spec C (depends on B)
4. Complete A → verify B becomes ready
5. Complete B → verify C becomes ready
6. Verify `chant list` shows correct status throughout

This is exactly the scenario that's currently broken in production.

## Solution

Add comprehensive integration test for dependency chains:

```rust
#[test]
fn test_dependency_chain_updates() {
    let temp_dir = setup_test_repo();

    // Create three specs in dependency chain
    let spec_a = create_spec(temp_dir, "spec-a", vec![]);
    let spec_b = create_spec(temp_dir, "spec-b", vec![&spec_a]);
    let spec_c = create_spec(temp_dir, "spec-c", vec![&spec_b]);

    // Verify initial state
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("○ spec-a"));  // Ready
    assert!(list_output.contains("⊗ spec-b"));  // Blocked by A
    assert!(list_output.contains("⊗ spec-c"));  // Blocked by B

    // Complete spec A
    run_chant_work(temp_dir, "spec-a");

    // Verify B is now ready, C still blocked
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("● spec-a"));  // Completed
    assert!(list_output.contains("○ spec-b"));  // Now ready!
    assert!(list_output.contains("⊗ spec-c"));  // Still blocked by B

    // Complete spec B
    run_chant_work(temp_dir, "spec-b");

    // Verify C is now ready
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("● spec-a"));  // Completed
    assert!(list_output.contains("● spec-b"));  // Completed
    assert!(list_output.contains("○ spec-c"));  // Now ready!

    // Complete spec C
    run_chant_work(temp_dir, "spec-c");

    // Verify all completed
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("● spec-a"));
    assert!(list_output.contains("● spec-b"));
    assert!(list_output.contains("● spec-c"));
}

#[test]
fn test_dependency_status_after_direct_file_edit() {
    let temp_dir = setup_test_repo();

    // Create dependency chain
    let spec_a = create_spec(temp_dir, "spec-a", vec![]);
    let spec_b = create_spec(temp_dir, "spec-b", vec![&spec_a]);

    // Manually edit spec A's status to completed (simulating external change)
    let spec_a_path = format!("{temp_dir}/.chant/specs/{spec_a}.md");
    let content = std::fs::read_to_string(&spec_a_path).unwrap();
    let updated = content.replace("status: pending", "status: completed");
    std::fs::write(&spec_a_path, updated).unwrap();

    // Verify B shows as ready (should reload A's status from disk)
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("○ spec-b"),
            "Spec B should be ready after A's status updated on disk");
}

#[test]
fn test_parallel_dependency_resolution() {
    let temp_dir = setup_test_repo();

    // Create multiple specs depending on same blocker
    let spec_a = create_spec(temp_dir, "spec-a", vec![]);
    let spec_b1 = create_spec(temp_dir, "spec-b1", vec![&spec_a]);
    let spec_b2 = create_spec(temp_dir, "spec-b2", vec![&spec_a]);
    let spec_b3 = create_spec(temp_dir, "spec-b3", vec![&spec_a]);

    // Complete blocker
    run_chant_work(temp_dir, "spec-a");

    // Verify all dependents are ready
    let list_output = run_chant_list(temp_dir);
    assert!(list_output.contains("○ spec-b1"));
    assert!(list_output.contains("○ spec-b2"));
    assert!(list_output.contains("○ spec-b3"));
}

#[test]
fn test_force_flag_bypasses_dependency_check() {
    let temp_dir = setup_test_repo();

    // Create blocked spec
    let spec_a = create_spec(temp_dir, "spec-a", vec![]);
    let spec_b = create_spec(temp_dir, "spec-b", vec![&spec_a]);

    // Try to work without force - should fail
    let output = run_chant_work_expect_failure(temp_dir, "spec-b");
    assert!(output.contains("blocked by"));

    // Work with --force - should succeed
    let output = run_chant_work_with_force(temp_dir, "spec-b");
    assert!(output.contains("Warning: Forcing work"));
    assert!(output.contains("completed"));
}
```

## Acceptance Criteria

- [x] Add 4 integration tests to tests/integration_tests.rs
- [x] Test 1: Linear dependency chain (A→B→C)
- [x] Test 2: Status update via direct file edit (reload from disk)
- [x] Test 3: Multiple dependents of same blocker (fan-out)
- [x] Test 4: --force flag bypasses dependency checks
- [x] Each test verifies `chant list` output at each step
- [x] Tests use helper functions: create_spec, run_chant_work, run_chant_list
- [x] Tests verify both ○ ready and ● completed states
- [x] Tests verify ⊗ blocked state when dependencies not met
- [x] All tests pass: `cargo test test_dependency`
- [x] Cleanup temp directories after tests