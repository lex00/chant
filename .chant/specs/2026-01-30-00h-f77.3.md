---
type: code
status: completed
depends_on:
- 2026-01-30-00h-f77.1
target_files:
- src/cmd/watch.rs
commits:
- b650daf
completed_at: 2026-01-31T15:26:09Z
model: sonnet
---
# Retry logic with exponential backoff

Implement retry state tracking and decision logic for failed specs, including pattern matching for retryable errors and exponential backoff calculation.

### Inherited Context

- Watch is monitor-only: retry restarts existing spec (resume), never spawns new work

### Acceptance Criteria

- [x] `RetryState` struct tracks attempts, last_retry_time, next_retry_time
- [x] `should_retry(spec_id, error_log) -> RetryDecision` checks patterns and attempt count
- [x] `RetryDecision` enum: `Retry(delay)`, `PermanentFailure(reason)`
- [x] Exponential backoff: delay = base_delay * (backoff_multiplier ^ attempt)
- [x] Pattern matching scans error log for any `retryable_patterns` substring

### Edge Cases

- Error log empty or missing: Treat as permanent failure (no pattern match)
- `max_retries` = 0: First failure is permanent
- Backoff overflow (delay > reasonable limit): Cap at 1 hour
- Multiple retryable patterns match: Still counts as retryable (OR logic)

### Example Test Cases

- Error contains "rate_limit", attempt 1/3 → `Retry(60s)`
- Error contains "rate_limit", attempt 4/3 → `PermanentFailure`
- Error contains "syntax error", attempt 1/3 → `PermanentFailure` (no pattern match)
- Backoff calculation: 60s base, 2.0 multiplier, attempt 3 → 240s delay


- `RetryState` struct for tracking retry metadata
- `should_retry(spec_id: &str, error_log: &str, config: &FailureConfig) -> Result<RetryDecision>` - Errors on config issues
- `RetryDecision` enum with `Retry(Duration)`, `PermanentFailure(String)`

---