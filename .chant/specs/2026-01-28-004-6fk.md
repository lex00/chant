---
type: code
status: completed
commits:
- 62017b0
completed_at: 2026-01-28T13:04:55Z
model: opus
---
# Rejection action handlers - manual, dependency, group modes

## Problem

When a spec is rejected, what happens next? Different teams have different workflows:
- Some want to manually handle fixes (manual mode)
- Some want to track fix as dependency (dependency mode)
- Some want to convert to driver with fix sub-specs (group mode)

We need configurable rejection handling that supports all three patterns.

## Solution

Add `approval.rejection_action` config option with three modes:

### 1. Manual mode (default)
- Rejection leaves spec in rejected state
- User manually addresses concerns
- Someone eventually approves after discussion

### 2. Dependency mode
- When rejected, prompt to create fix spec
- Original spec becomes blocked, waiting for fix
- Use `depends_on:` frontmatter to link them
- Once fix completes, original can be re-approved

Example workflow:
```bash
$ chant reject 001-cic --by alice --reason "Too broad"
Spec 001-cic rejected.

Create fix spec? (Y/n): y
$ chant add "Split approval into smaller pieces"
Created spec 002-xyz

$ # Automatically updates 001-cic frontmatter:
# depends_on: [002-xyz]
# status: blocked
```

### 3. Group mode (preferred, user's choice)
- When rejected, automatically convert to driver
- Create numbered member specs for fixes
- Original becomes parent, tracks completion
- More structured than dependency mode

Example workflow:
```bash
$ chant reject 001-cic --by alice --reason "Too broad"
Spec 001-cic rejected. Converting to driver...

Created members:
  001-cic-1: Approval frontmatter schema
  001-cic-2: Approve/reject commands
  001-cic-3: Work validation

$ # Updates 001-cic frontmatter:
# type: driver
# members: [001-cic-1, 001-cic-2, 001-cic-3]
```

### Configuration

Add to `.chant/config.md`:
```markdown
## approval

- `rejection_action`: Action to take on rejection (default: manual)
  - `manual` - Leave rejected, user handles it
  - `dependency` - Prompt to create fix spec, original becomes blocked
  - `group` - Convert to driver with numbered members
```

## Acceptance Criteria

- [x] Add `approval.rejection_action` config option to config schema
- [x] Support `manual` mode (default) - no automatic action
- [x] Support `dependency` mode:
  - [x] Prompt to create fix spec after rejection
  - [x] Add `depends_on:` to original spec frontmatter
  - [x] Update original spec status to `blocked`
- [x] Support `group` mode:
  - [x] Convert rejected spec to `type: driver`
  - [x] Create numbered member specs (e.g., 001-cic-1, 001-cic-2)
  - [x] Add `members:` array to driver frontmatter
  - [x] Distribute acceptance criteria across members
- [x] Parse config file to read rejection_action setting
- [x] Update `chant reject` command to trigger configured action
- [x] Handle all three modes correctly
- [x] Update spec validation to support new frontmatter fields
- [x] All tests passing
- [x] Code linted and formatted

## Agent Output

2026-01-28T13:04:55Z

```


I'll start by understanding the codebase structure and the existing rejection/approval workflow before implementing the changes.
Good, I have a solid understanding of the codebase. Now let me read the specific files I need to modify.
The spec.rs and cmd/spec.rs files are too large. Let me read the relevant sections.
Now let me read the main.rs command dispatch section and more of the spec-related code.
Now let me read the `cmd_add` function and the spec_group module for understanding member spec creation patterns.
Now let me look at the validation functions and how `requires_approval`/`is_rejected` work.
Now let me also check how the `members` field is handled in frontmatter and the `SpecFrontmatter` struct, plus the `load_all_specs` function.
Now I have a comprehensive understanding of the codebase. Let me also check the existing `SpecFrontmatter` to see if a `members` field already exists, since the spec mentions creating `members:` in the frontmatter.
Now I have a thorough understanding. There's no `members` field in `SpecFrontmatter` - members are tracked by the naming convention (`DRIVER_ID.N`). Let me also read the existing spec file and check the existing config file to understand the current structure.
I now have a thorough understanding of the codebase. Let me also check how member specs use naming conventions vs. an explicit `members` frontmatter field. Looking at the spec, it asks for a `members:` array in the frontmatter, which doesn't exist yet in `SpecFrontmatter`. Let me look at how the `split` command creates member specs.
Now I have a complete picture. I can see that:

1. The `split` command changes the type to `"group"` and creates member specs with `DRIVER_ID.N` naming
2. There's no explicit `members` field in frontmatter - members are discovered by naming convention
3. The config uses serde YAML deserialization from `SpecFrontmatter`
4. The `cmd_reject` function currently just marks as rejected and commits

Now let me plan and implement. I'll start coding.
Let me start by adding the config schema for `approval.rejection_action` in `config.rs`.
Now add the `approval` field to the `Config` struct:
Now add `approval` to the `PartialConfig` struct and merge logic:
Now update the `merge_with` method to include approval:
Now let me add the `members` field to `SpecFrontmatter` in `spec.rs`:
Now update the `Default` impl for `SpecFrontmatter`:
Now update `has_frontmatter_field` to include `members`:
Now let me implement the core rejection action handlers. I need to update `cmd_reject` to load the config and dispatch to the appropriate handler. Let me read the full current `cmd_reject` function again and the imports:
Now let me implement the rejection action handlers. I'll modify `cmd_reject` to load config and dispatch to the appropriate handler after performing the rejection. Let me also check how the `id` module generates IDs:
Good. Now I have all the context I need. Let me implement the rejection action handlers. I'll modify `cmd_reject` in `src/cmd/spec.rs`:
Now I need to remove the duplicate `#[cfg(test)] use chant::spec::SpecFrontmatter;` since we're now importing it unconditionally:
Now let me rewrite the `cmd_reject` function to include the rejection action handler:
Now let me make sure the `std::io` import is available. Let me check if it's already imported:
The `std::io::stdin()` is used as `std::io::stdin()` with full path, so no import needed. But let me check if the `atty` crate is already being used in this file (it is - line 11):

Good, `atty` is already imported. Now let me also make sure the `Serialize` trait is available for `RejectionAction` - it needs to be importable. Let me check:
Good, `Serialize` is imported. Now let me try to build to see if there are any compile errors:
It compiles. Now let me check if `SpecFrontmatter` is actually used anywhere in the non-test code. Since I moved it from `#[cfg(test)]` import to regular import, but it might only be used in tests. Let me check:
All uses are in test functions (line 3784+). Since those tests are `#[cfg(test)]`, they'd still work. But the import is no longer gated. The warning says it's unused in non-test code. Since I'm using it in test code and it's imported unconditionally, that's fine - the warning will just exist for non-test builds. Actually, let me check if any of my new code uses `SpecFrontmatter`... Looking at my implementation, I don't use it directly in the new functions. Let me put the import back to `#[cfg(test)]`:
Now let me also make sure `RejectionAction` is exported from the library. Let me check the lib.rs:
Good, `config` is a public module in `lib.rs`, so `chant::config::RejectionAction` should be accessible. Let me build again:
Clean build with no warnings. Now let me add validation for the `members` field and the `rejection_action` config option. Let me update the validation logic:
Now let me check if there are validations in the lint function that need updating for the `members` field and driver typ

... (output truncated, 14558 chars total)```
