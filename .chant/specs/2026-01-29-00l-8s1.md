---
type: code
status: in_progress
model: claude-opus-4-5-20251101
---
# Add approval requirements to blocking logic and merge/cancel/delete guards

## Problem

Specs that require approval are not integrated into the blocking/ready workflow:

1. **Blocking logic gap**: `is_blocked()` only checks dependencies, not approval requirements
   - A pending spec with `approval.required: true` and `approval.status: pending` doesn't show up in `chant list --status blocked`
   - This makes it hard to find specs waiting for approval before work can begin

2. **Missing merge/cancel/delete guards**: Commands that should respect approval requirements may not have clear error messages
   - Need to verify `chant merge` blocks unapproved specs with clear error
   - Need to verify `chant cancel` has appropriate behavior for unapproved specs
   - Need to verify `chant delete` has appropriate behavior for unapproved specs

## Solution

### Part 1: Add approval to blocking logic (Approach A - narrow scope)

Update `is_blocked()` to return true if:
- The spec is **pending** AND
- The spec requires approval (`approval.required: true`) AND
- The approval status is not approved (`approval.status != approved`)

This keeps "blocked" semantically focused on "can't start work yet" rather than mixing in "can't merge" states for completed specs.

**Implementation:**
```rust
// In src/spec.rs, update is_blocked()
pub fn is_blocked(&self, all_specs: &[Spec]) -> bool {
    // Check dependencies are all completed
    if let Some(deps) = &self.frontmatter.depends_on {
        for dep_id in deps {
            let dep = all_specs.iter().find(|s| s.id == *dep_id);
            match dep {
                Some(d) if d.frontmatter.status == SpecStatus::Completed => continue,
                _ => return true, // Found an unmet dependency
            }
        }
    }

    // Check approval requirements (only for pending specs - Approach A)
    if self.frontmatter.status == SpecStatus::Pending && self.requires_approval() {
        return true;
    }

    false
}
```

### Part 2: Verify/add merge/cancel/delete guards

Audit and ensure these commands have clear error messages:

**Merge command** (`chant merge`):
- Should block merge if `approval.required: true` and `approval.status != approved`
- Error message: "Cannot merge spec {id}: approval required but not yet approved. Use 'chant approve {id} --by <name>' first."
- Consider `--skip-approval` flag for emergency bypass (should warn loudly)

**Cancel command** (`chant cancel`):
- Probably should allow cancellation regardless of approval status (cancelling doesn't need approval)
- No guard needed, but document the behavior

**Delete command** (`chant delete`):
- Probably should allow deletion regardless of approval status (cleanup operation)
- No guard needed, but document the behavior

## Acceptance Criteria

### Part 1: Blocking logic
- [x] Update `is_blocked()` in src/spec.rs to check approval requirements for pending specs
- [x] Pending specs with `approval.required: true` and `approval.status: pending` show up in `chant list --status blocked`
- [x] Completed specs with required approval do NOT show as blocked (Approach A)
- [x] Add tests for blocked filter with approval requirements
- [x] All existing tests pass

### Part 2: Command guards
- [x] Audit `chant merge` for approval guards - ensure clear error when merging unapproved spec
- [x] Add tests for merge blocking unapproved specs
- [x] Audit `chant cancel` - verify behavior is appropriate (likely: allow cancellation)
- [x] Audit `chant delete` - verify behavior is appropriate (likely: allow deletion)
- [x] Document the behavior in code comments or error messages

### General
- [x] Run `cargo fmt` and `cargo clippy`
- [x] All tests pass

## Files to Modify

- `src/spec.rs` - Update `is_blocked()` method
- `src/cmd/merge.rs` or `src/cmd/lifecycle.rs` - Verify/add merge guards
- `src/cmd/spec.rs` - Verify cancel/delete behavior
- `tests/integration_tests.rs` - Add tests for approval blocking