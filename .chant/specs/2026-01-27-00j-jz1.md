---
type: code
status: pending
target_files:
  - tests/integration_tests.rs
---

# Add integration test for enum validation warnings

## Problem

Enum validation warnings are tested at unit level but never verified in integration tests. Need to verify warnings are printed to stderr and values are still included.

**Gap:** User-visible warning output not verified in real workflow.

## Solution

Add integration test that:
1. Creates enterprise config with enum validation
2. Sets up context that will derive an invalid enum value
3. Runs `chant add` and captures stderr
4. Verifies warning message appears in stderr
5. Verifies field is still included in spec despite validation failure

## Test Implementation

```rust
#[test]
fn test_enum_validation_warning_printed() {
    let temp_dir = "/tmp/chant-test-enum-validation";
    setup_test_repo(temp_dir);

    // Create enterprise config with enum validation
    let config = r#"
enterprise:
  derived:
    team:
      from: env
      pattern: "TEAM_NAME"
      validate:
        type: enum
        values: [platform, frontend, backend, infra]
"#;
    write_config(temp_dir, config);

    // Run chant add with INVALID enum value
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .env("TEAM_NAME", "invalid-team")  // Not in enum list
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant add");

    // Verify command still succeeds
    assert!(output.status.success());

    // Verify warning appears in stderr
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Warning"));
    assert!(stderr.contains("team"));
    assert!(stderr.contains("invalid-team"));
    assert!(stderr.contains("platform") || stderr.contains("enum") || stderr.contains("values"));

    // CRITICAL: Verify field is still included in spec
    let spec_content = read_latest_spec(temp_dir);
    assert!(spec_content.contains("team: invalid-team"));
    assert!(spec_content.contains("derived_fields:\n  - team"));
}

#[test]
fn test_enum_validation_passes_with_valid_value() {
    let temp_dir = "/tmp/chant-test-enum-valid";
    setup_test_repo(temp_dir);

    // Create enterprise config with enum validation
    let config = r#"
enterprise:
  derived:
    team:
      from: env
      pattern: "TEAM_NAME"
      validate:
        type: enum
        values: [platform, frontend, backend, infra]
"#;
    write_config(temp_dir, config);

    // Run chant add with VALID enum value
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .env("TEAM_NAME", "platform")  // Valid value
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant add");

    assert!(output.status.success());

    // Verify NO warning in stderr
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(!stderr.contains("Warning"));

    // Verify field included
    let spec_content = read_latest_spec(temp_dir);
    assert!(spec_content.contains("team: platform"));
}
```

## Acceptance Criteria

- [ ] Add two tests to tests/integration_tests.rs
- [ ] First test: Invalid enum value triggers warning
- [ ] Test captures and verifies stderr output
- [ ] Test verifies warning message content (field name, invalid value)
- [ ] Test verifies spec still contains invalid value (graceful degradation)
- [ ] Second test: Valid enum value produces no warning
- [ ] Both tests verify derived_fields tracking
- [ ] Tests pass: `cargo test test_enum_validation`
- [ ] Cleanup temp directories after tests