---
type: code
status: completed
target_files:
- src/cmd/mod.rs
- src/main.rs
completed_at: 2026-01-27T23:31:36Z
model: opus
---
# Add chant refresh command to update dependency status

## Problem

**User Question:** "There might be a command to refresh dependency status... Or a config file that needs updating"

When dependency status gets stale or users suspect a bug, they have no explicit way to force a refresh and see what's actually blocked vs ready.

**Desired Command:**
```bash
$ chant refresh
Checking dependency status...
✓ Refreshed 142 specs
✓ 18 specs are now ready (previously blocked)
  - 2026-01-27-00t-bfs Validate nodes.edn coverage
  - 2026-01-27-01a-xyz Generate AST types
  - ... (16 more)
```

## Solution

Add `chant refresh` command that:
1. Reloads all specs from disk
2. Recalculates dependency status
3. Reports what changed (newly ready, newly blocked)
4. Optionally clears any cached state

```rust
// In src/main.rs
#[derive(Subcommand)]
enum Commands {
    // ... existing commands
    Refresh {
        #[arg(long)]
        verbose: bool,
    },
}

// In src/cmd/mod.rs
pub mod refresh;

// New file: src/cmd/refresh.rs
use crate::spec::{load_all_specs, SpecStatus};
use anyhow::Result;

pub fn cmd_refresh(verbose: bool) -> Result<()> {
    println!("Checking dependency status...");

    // Load all specs fresh from disk
    let specs = load_all_specs()?;

    let total = specs.len();
    let completed = specs.iter().filter(|s| s.status == SpecStatus::Completed).count();
    let ready = specs.iter().filter(|s| s.is_ready(&specs)).count();
    let blocked = specs.iter().filter(|s| {
        s.status != SpecStatus::Completed && !s.is_ready(&specs)
    }).count();

    println!("✓ Refreshed {} specs", total);
    println!("  Completed: {}", completed);
    println!("  Ready: {}", ready);
    println!("  Blocked: {}", blocked);

    if verbose {
        println!("\nReady specs:");
        for spec in specs.iter().filter(|s| s.is_ready(&specs)) {
            if let Some(title) = &spec.title {
                println!("  ○ {} {}", spec.id, title);
            } else {
                println!("  ○ {}", spec.id);
            }
        }

        println!("\nBlocked specs:");
        for spec in specs.iter().filter(|s| !s.is_ready(&specs) && s.status != SpecStatus::Completed) {
            let blockers = spec.get_blocking_dependencies(&specs);
            println!("  ⊗ {} (blocked by: {})", spec.id, blockers.join(", "));
        }
    }

    Ok(())
}
```

## Acceptance Criteria

- [ ] Create src/cmd/refresh.rs module
- [ ] Add Refresh command to main.rs Commands enum
- [ ] Implement cmd_refresh function
- [ ] Reload all specs from disk (no caching)
- [ ] Recalculate ready/blocked status for all specs
- [ ] Print summary: total, completed, ready, blocked counts
- [ ] Add --verbose flag to list ready and blocked specs
- [ ] Show blocking dependencies in verbose mode
- [ ] Add to help text: `chant --help` shows refresh command
- [ ] Add integration test: complete spec -> refresh -> dependent shows ready
- [ ] Update documentation with refresh command usage
- [ ] All existing tests pass