---
type: code
status: pending
labels:
- refactor
- output
- observability
target_files:
- src/output.rs
- src/cmd/work/single.rs
- src/cmd/work/chain.rs
- src/cmd/work/parallel.rs
- src/cmd/finalize.rs
---
# Replace raw println/eprintln with structured output system

## Problem

968 `println!` calls and 177 `eprintln!` calls across 51+ files with no abstraction. Colored emoji output (`"✗".red()`, `"→".cyan()`, `"⚠".yellow()`) is hardcoded everywhere.

Consequences:
- **No JSON output mode**: Can't programmatically consume chant output (everything is human-formatted)
- **No test capture**: Tests that check output must capture stdout/stderr manually or not test output at all
- **No quiet mode**: `--quiet` would require touching hundreds of print calls
- **Color corruption**: Colored output in non-TTY/CI environments without explicit `isatty()` checks
- **MCP duplication**: MCP handlers format their own JSON responses completely separately from CLI output
- **No structured logging**: Production debugging requires reading raw stderr with emoji prefixes
- **Inconsistent prefixes**: Some output uses `"→".cyan()`, some uses `"✗".red()`, some uses plain text — no standard vocabulary

Worst offenders by println count: `single.rs` (86), `split.rs` (47), `cleanup.rs` (41).

## Approach

Create `src/output.rs` with a simple output abstraction:

```rust
pub struct Output {
    mode: OutputMode,  // Human, Json, Quiet
    writer: Box<dyn Write>,
}

impl Output {
    pub fn step(&self, msg: &str)     // "→ {msg}" in cyan
    pub fn success(&self, msg: &str)  // "✓ {msg}" in green
    pub fn warn(&self, msg: &str)     // "⚠ {msg}" in yellow
    pub fn error(&self, msg: &str)    // "✗ {msg}" in red
    pub fn info(&self, msg: &str)     // plain text
    pub fn detail(&self, msg: &str)   // indented subordinate info
    pub fn json(&self, value: &Value) // structured JSON event
}
```

In JSON mode, each call emits a JSON line: `{"level":"step","msg":"Validating spec..."}`.
In quiet mode, only errors are emitted.
The `writer` field enables test capture.

This does NOT require rewriting all 968 println calls at once. The approach:
1. Create the `Output` abstraction
2. Thread it through the command entry points (it's already passed as config/context)
3. Convert the highest-impact modules first (work/, finalize, lifecycle)
4. Leave low-churn modules (site, template, disk) for later

## Key Considerations

- Color support should auto-detect TTY via `atty` or `is-terminal` crate
- The `Output` struct should be cheaply cloneable (Arc internals) for threading in parallel mode
- Progress bars / spinners (if any) should integrate with this system
- `--format json` CLI flag to enable JSON mode
- MCP output can potentially reuse the JSON mode

## Acceptance Criteria

- [ ] `src/output.rs` exists with `Output` struct supporting Human, Json, and Quiet modes
- [ ] Color output auto-detects TTY (no colors when piped)
- [ ] `cmd/work/single.rs` uses `Output` instead of raw println/eprintln
- [ ] `cmd/work/chain.rs` uses `Output` instead of raw println/eprintln
- [ ] `cmd/work/parallel.rs` uses `Output` instead of raw println/eprintln
- [ ] `cmd/finalize.rs` uses `Output` instead of raw println/eprintln
- [ ] At least one command supports `--format json` for structured output
- [ ] Tests can capture output via injected writer
- [ ] All existing tests pass