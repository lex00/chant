---
type: code
status: completed
depends_on:
- 2026-02-07-00a-ffx
labels:
- refactor
- mcp
- architecture
target_files:
- src/mcp/handlers.rs
- src/operations/mod.rs
- src/cmd/spec/add.rs
- src/cmd/finalize.rs
- src/cmd/lifecycle/reset.rs
---
# Create shared business logic layer between MCP handlers and CLI commands

## Problem

MCP handlers (`handlers.rs`, 2,422 LOC) re-implement operations that CLI commands already have, but with critical features missing:

| Operation | MCP (handlers.rs) | CLI | Gap |
|-----------|-------------------|-----|-----|
| **Spec creation** | 95 lines, no derivation engine, no git commit | 226 lines, full derivation, auto-commit | MCP specs lack derived fields |
| **Finalization** | 78 lines, no commit detection, no approval check, no worktree validation, no driver/member handling | 961 lines, full validation | MCP finalize is a stub |
| **Reset** | 60 lines, minimal status flip | Variable, supports re-execution + branch creation | MCP reset is incomplete |
| **Status update** | Direct field assignment | N/A (no unified update command) | No validation |

Users interacting via MCP (Claude, other AI agents) get a degraded, inconsistent experience compared to CLI users. The MCP finalization stub is particularly dangerous — it can mark specs as "completed" without any of the validation that CLI finalize performs.

## Approach

Create `src/operations/` as the canonical business logic layer:

```
src/operations/
  mod.rs          // Re-exports
  create.rs       // create_spec() — derivation, ID generation, git commit
  finalize.rs     // finalize_spec() — commit detection, approval, AC validation
  reset.rs        // reset_spec() — status reset, optional re-execution
  update.rs       // update_spec() — validated field updates
  archive.rs      // archive_spec() — move to archive with validation
  cancel.rs       // cancel_spec() — cancellation with cleanup
```

Then:
- **CLI commands** (`cmd/spec/add.rs`, `cmd/finalize.rs`, etc.) become thin argument parsers that call `operations::*`
- **MCP handlers** (`mcp/handlers.rs`) become thin JSON-RPC wrappers that call `operations::*`
- Business logic lives in exactly one place

## Key Considerations

- Some CLI operations have interactive prompts (confirmation dialogs, quality score display) — the operations layer should accept a `mode` parameter (interactive vs non-interactive) or return decision points that the caller handles
- MCP `chant_work_start` already delegates correctly by spawning `chant work` subprocess — this pattern is fine and doesn't need to change
- The operations layer should use the state machine from spec 00a (depends_on)
- Git operations (commit, branch) should be optional parameters so MCP can choose whether to auto-commit

## Acceptance Criteria

- [x] `src/operations/` module exists with create, finalize, reset, update operations
- [x] MCP `chant_add` produces identical specs to CLI `chant add` (including derived fields)
- [x] MCP `chant_finalize` performs the same validation as CLI `chant finalize`
- [x] MCP `chant_reset` supports the same capabilities as CLI `chant reset`
- [x] CLI commands delegate to `operations::*` rather than containing inline business logic
- [x] MCP handlers delegate to `operations::*` rather than containing inline business logic
- [ ] `handlers.rs` reduced to under 1,500 LOC (from 2,422)
- [x] All existing tests pass
- [ ] No behavioral divergence between MCP and CLI for shared operations

## Output

Completed with 7/9 AC. Operations layer created and integrated. Remaining: handlers.rs LOC target (2403 vs 1500 goal) and full behavioral parity require migrating cmd-only helpers to library — follow-up scope.
