---
type: code
status: in_progress
target_files:
- src/worktree.rs
- src/cmd/work.rs
model: sonnet
---
# Auto-rebase branches before merge in parallel execution

## Problem

During parallel execution, multiple agents work on branches forked from main. If:
1. Agent A finishes first and merges to main
2. Agent B finishes later

Agent B's branch is now behind main. The `--ff-only` merge fails because B's branch doesn't include A's changes.

Currently this results in a merge failure requiring manual intervention.

## Solution

Before attempting `--ff-only` merge, check if the branch is behind main. If so, attempt an automatic rebase onto main. If rebase succeeds cleanly, proceed with merge. If rebase has conflicts, fall back to current behavior (preserve branch for manual resolution).

## Implementation

### Update merge_and_cleanup_in_dir

```rust
fn merge_and_cleanup_in_dir(branch: &str, work_dir: Option<&Path>) -> MergeCleanupResult {
    // ... existing checkout main ...

    // Check if branch needs rebase (is behind main)
    if branch_is_behind_main(branch, work_dir)? {
        // Attempt automatic rebase
        match rebase_branch_onto_main(branch, work_dir) {
            Ok(()) => {
                // Rebase succeeded, continue to merge
            }
            Err(e) => {
                // Rebase failed (conflicts), abort and preserve branch
                abort_rebase(work_dir);
                return MergeCleanupResult {
                    success: false,
                    has_conflict: true,
                    error: Some(format!("Rebase failed: {}", e)),
                };
            }
        }
    }

    // ... existing ff-only merge ...
}

fn branch_is_behind_main(branch: &str, work_dir: Option<&Path>) -> Result<bool> {
    // Check if main has commits not in branch
    let output = Command::new("git")
        .args(["rev-list", "--count", &format!("{}..main", branch)])
        .current_dir_opt(work_dir)
        .output()?;
    let count: i32 = String::from_utf8_lossy(&output.stdout).trim().parse()?;
    Ok(count > 0)
}

fn rebase_branch_onto_main(branch: &str, work_dir: Option<&Path>) -> Result<()> {
    // Checkout branch
    Command::new("git").args(["checkout", branch]).current_dir_opt(work_dir).output()?;

    // Rebase onto main
    let output = Command::new("git")
        .args(["rebase", "main"])
        .current_dir_opt(work_dir)
        .output()?;

    if !output.status.success() {
        anyhow::bail!("Rebase conflicts");
    }

    // Return to main for merge
    Command::new("git").args(["checkout", "main"]).current_dir_opt(work_dir).output()?;
    Ok(())
}
```

### Add --no-rebase flag

Allow users to skip auto-rebase if desired:

```bash
chant work --parallel --no-rebase
```

## Acceptance Criteria

- [x] Add `branch_is_behind_main` helper to detect divergence
- [x] Add `rebase_branch_onto_main` helper
- [x] Add `abort_rebase` helper for cleanup on failure
- [x] Update `merge_and_cleanup_in_dir` to attempt rebase before merge
- [x] Abort rebase cleanly if conflicts detected
- [x] Return to main branch after rebase (success or failure)
- [x] Add `--no-rebase` flag to parallel execution
- [x] Log when auto-rebase occurs
- [x] Add tests for rebase scenarios