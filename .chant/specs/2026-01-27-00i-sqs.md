---
type: code
status: pending
target_files:
- tests/integration_tests.rs
---
# Add integration test for chant derive --dry-run

## Problem

The `chant derive --dry-run` command has no integration test verifying it shows what WOULD be derived without actually modifying files.

**Gap:** Need to verify dry-run mode displays results but doesn't modify specs.

## Solution

Add integration test that:
1. Creates test git repository and spec
2. Sets up enterprise config with derivation rules
3. Runs `chant derive --dry-run <SPEC_ID>`
4. Verifies output shows what would be derived
5. Verifies spec file is NOT modified

## Test Implementation

```rust
#[test]
fn test_chant_derive_dry_run() {
    let temp_dir = "/tmp/chant-test-derive-dry-run";
    setup_test_repo(temp_dir);

    // Create spec without derived fields
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to create spec");

    assert!(output.status.success());
    let spec_id = extract_spec_id(&output.stdout);

    // Add enterprise config
    let config = r#"
enterprise:
  derived:
    sprint:
      from: branch
      pattern: "sprint/([^/]+)"
    jira_key:
      from: branch
      pattern: "([A-Z]+-\\d+)"
"#;
    write_config(temp_dir, config);

    // Checkout branch with pattern
    Command::new("git")
        .args(["checkout", "-b", "sprint/2026-Q1-W4/PROJ-123"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to create branch");

    // Get original spec content
    let spec_path = format!("{temp_dir}/.chant/specs/{spec_id}.md");
    let original_content = std::fs::read_to_string(&spec_path).unwrap();
    assert!(!original_content.contains("derived_fields:"));

    // Run chant derive --dry-run
    let derive_output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["derive", "--dry-run", &spec_id])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant derive --dry-run");

    assert!(derive_output.status.success());
    let stdout = String::from_utf8_lossy(&derive_output.stdout);

    // Verify output shows what would be derived
    assert!(stdout.contains(&spec_id));
    assert!(stdout.contains("sprint: 2026-Q1-W4") || stdout.contains("sprint") && stdout.contains("2026-Q1-W4"));
    assert!(stdout.contains("jira_key: PROJ-123") || stdout.contains("jira_key") && stdout.contains("PROJ-123"));

    // CRITICAL: Verify spec file was NOT modified
    let current_content = std::fs::read_to_string(&spec_path).unwrap();
    assert_eq!(original_content, current_content, "Spec file should not be modified in dry-run mode");
    assert!(!current_content.contains("derived_fields:"));
}
```

## Acceptance Criteria

- [ ] Add test to tests/integration_tests.rs
- [ ] Test creates spec and enterprise config
- [ ] Test captures original spec file content
- [ ] Test runs `chant derive --dry-run <SPEC_ID>` command
- [ ] Test verifies stdout shows derived field names and values
- [ ] Test verifies spec file is NOT modified (compare before/after)
- [ ] Test verifies no derived_fields added to spec
- [ ] Test passes: `cargo test test_chant_derive_dry_run`
- [ ] Cleanup temp directory after test