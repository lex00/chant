---
type: code
status: cancelled
depends_on:
- 2026-01-27-00z-ixq
target_files:
- src/cmd/finalize.rs
- src/cmd/work.rs
---
# Add automatic dependency status refresh after spec completion

## Problem

When a spec is completed, dependent specs don't automatically become ready. Users must manually refresh or restart chant to see updated dependency status.

**Current Behavior:**
```bash
# Spec 00s-c9e blocks 00t-bfs
$ chant list
○ 2026-01-27-00s-c9e Assemble schema
⊗ 2026-01-27-00t-bfs Validate coverage (blocked by 00s-c9e)

$ chant work 00s-c9e
✓ Spec completed

$ chant list
● 2026-01-27-00s-c9e Assemble schema
⊗ 2026-01-27-00t-bfs Validate coverage  # Still blocked!

# User must exit and restart or run some refresh command
```

**Expected Behavior:**
```bash
$ chant work 00s-c9e
✓ Spec completed
✓ Unblocked 1 dependent spec: 00t-bfs

$ chant list
● 2026-01-27-00s-c9e Assemble schema
○ 2026-01-27-00t-bfs Validate coverage  # Now ready!
```

## Solution

After a spec is finalized (status set to completed), check for dependent specs and log what was unblocked:

```rust
// In src/cmd/finalize.rs
pub fn finalize_spec(spec: &mut Spec, commits: Vec<String>) -> Result<()> {
    // ... existing finalization logic ...

    spec.status = SpecStatus::Completed;
    spec.completed_at = Some(chrono::Utc::now().to_rfc3339());
    spec.save()?;

    // NEW: Check what this spec unblocked
    let unblocked = find_dependent_specs(&spec.id)?;
    if !unblocked.is_empty() {
        println!("✓ Unblocked {} dependent spec(s):", unblocked.len());
        for dependent_id in unblocked {
            println!("  - {}", dependent_id);
        }
    }

    Ok(())
}

fn find_dependent_specs(completed_spec_id: &str) -> Result<Vec<String>> {
    let all_specs = load_all_specs()?;
    let mut unblocked = vec![];

    for spec in all_specs {
        if spec.frontmatter.depends_on.contains(&completed_spec_id.to_string()) {
            // This spec depends on the one we just completed
            // Check if it's now ready
            if spec.is_ready(&all_specs) {
                unblocked.push(spec.id.clone());
            }
        }
    }

    Ok(unblocked)
}
```

## Acceptance Criteria

- [ ] Add find_dependent_specs() function to find specs that depend on completed spec
- [ ] Call find_dependent_specs() in finalize_spec()
- [ ] Print "Unblocked N dependent spec(s)" message after finalization
- [ ] List unblocked spec IDs
- [ ] Verify dependent specs actually show as ready in subsequent `chant list`
- [ ] Handle cascade: A→B→C, complete A shows B unblocked, complete B shows C unblocked
- [ ] Add unit test for find_dependent_specs()
- [ ] Add integration test: complete spec -> dependent shows as ready immediately
- [ ] All existing tests pass