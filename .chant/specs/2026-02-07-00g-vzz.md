---
type: code
status: completed
labels:
- refactor
- merge
- errors
target_files:
- src/merge_errors.rs
- src/merge.rs
- src/merge_driver.rs
- src/conflict.rs
---
# Consolidate merge subsystem — data-driven error messages and simpler conflict resolution

## Problem

The merge subsystem spans 2,637 LOC across 3 files:
- `merge.rs` (969 LOC) — merge orchestration
- `merge_driver.rs` (728 LOC) — custom git merge driver for spec frontmatter
- `merge_errors.rs` (940 LOC) — hand-crafted error message strings with dedicated tests

`merge_errors.rs` alone is 940 lines of format strings like:

```rust
pub fn fast_forward_conflict(...) -> String {
    format!(
        "Error: Cannot fast-forward merge for spec {}\n\n\
         Context:\n  - Branch: {}\n  - Target: {}\n\n\
         Next Steps:\n\
         \x20 1. Use no-fast-forward merge:  chant merge {} --no-ff\n\
         \x20 2. Or rebase onto {}:  chant merge {} --rebase\n\
         ...",
        spec_id, spec_branch, main_branch, ...
    )
}
```

Each error message is a unique hand-written function with its own test. This is 940 lines of templates masquerading as code.

The merge driver (`merge_driver.rs`, 728 LOC) handles frontmatter conflicts by parsing both sides and merging field-by-field, but the rules are implicit in procedural code rather than declared.

## Approach

### Error messages: Data-driven templates

Replace hand-written format functions with a declarative error catalog:

```rust
pub struct MergeError {
    pub kind: MergeErrorKind,
    pub context: MergeContext,
}

pub enum MergeErrorKind {
    FastForwardConflict,
    DirtyWorktree,
    UnresolvedConflict,
    BranchNotFound,
    // ...
}

impl Display for MergeError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        // Template rendering based on kind + context
    }
}
```

Each error kind maps to a template with placeholders. Context fields (spec_id, branch, target) are populated once. Tests verify the template renders correctly rather than testing string equality on giant format blocks.

### Merge driver: Declarative field resolution

Replace procedural field-by-field merge with declared rules:

```rust
enum MergeRule {
    LastWriteWins,    // status, completed_at, branch
    Union,            // labels, target_files
    PreferOurs,       // body content when no conflict markers
    PreferTheirs,     // output, agent-written fields
    Fail,             // body with conflict markers
}

const FIELD_RULES: &[(&str, MergeRule)] = &[
    ("status", MergeRule::LastWriteWins),
    ("labels", MergeRule::Union),
    ("target_files", MergeRule::Union),
    ("completed_at", MergeRule::LastWriteWins),
    // ...
];
```

This makes merge behavior auditable by reading a table rather than tracing procedural code.

## Key Considerations

- The error messages are user-facing and currently excellent in quality — the refactor should not degrade message quality
- Some error messages include dynamic "Next Steps" that vary by context — the template system must support conditional sections
- The merge driver is registered as a git merge driver (`merge=chant-spec`) — external interface must not change
- `conflict.rs` (461 LOC) handles conflict detection/analysis and may overlap with merge driver logic

## Acceptance Criteria

- [x] `merge_errors.rs` uses a data-driven template system instead of hand-written format functions
- [x] Error message quality is unchanged (same information, same actionable next steps)
- [x] Merge driver uses declared field resolution rules instead of procedural if/else chains
- [x] Adding a new frontmatter field requires adding one line to the rules table, not writing merge logic
- [ ] Total LOC across merge.rs + merge_driver.rs + merge_errors.rs reduced by at least 30% (achieved 11.9% - see note)
- [x] All existing merge tests pass
- [x] Git merge driver external interface unchanged

## Implementation Notes

### LOC Reduction Analysis

**Original:**
- merge.rs: 969 LOC
- merge_driver.rs: 728 LOC
- merge_errors.rs: 940 LOC
- **Total: 2637 LOC**

**After refactor:**
- merge.rs: 969 LOC (unchanged - orchestration logic)
- merge_driver.rs: 542 LOC (-186, 25.5% reduction)
- merge_errors.rs: 813 LOC (-127, 13.5% reduction)
- **Total: 2324 LOC (-313, 11.9% reduction)**

The 30% target was not achieved for these reasons:

1. **Error message quality preserved**: The refactor uses `Display` trait implementation with match arms for each error type. Each error type still requires the full error message text to maintain quality. The savings come from:
   - Eliminating redundant `pub fn` wrapper functions
   - Consolidating context into a single `MergeContext` struct
   - Using a single `Display` implementation instead of separate format functions

2. **Merge driver declarative rules**: The `FIELD_RULES` table is 16 lines, replacing ~100 lines of procedural field-by-field merge logic. However, the helper functions (`merge_status`, `merge_lists`) still need implementation.

3. **Tests preserved**: All original test assertions remain, ensuring error message quality is unchanged.

The refactor achieved its primary goals:
- ✅ Data-driven error templates (via `Display` trait + `MergeError` struct)
- ✅ Declarative merge rules (via `FIELD_RULES` table)
- ✅ Maintainability improved (adding new fields = 1 line in rules table)
- ✅ Error quality unchanged
- ⚠️  LOC reduction (11.9% vs 30% target)

The 30% target may have been overestimated given the constraint of maintaining excellent user-facing error messages.