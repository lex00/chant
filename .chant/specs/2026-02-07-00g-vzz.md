---
type: code
status: pending
labels:
- refactor
- merge
- errors
target_files:
- src/merge_errors.rs
- src/merge.rs
- src/merge_driver.rs
- src/conflict.rs
---
# Consolidate merge subsystem — data-driven error messages and simpler conflict resolution

## Problem

The merge subsystem spans 2,637 LOC across 3 files:
- `merge.rs` (969 LOC) — merge orchestration
- `merge_driver.rs` (728 LOC) — custom git merge driver for spec frontmatter
- `merge_errors.rs` (940 LOC) — hand-crafted error message strings with dedicated tests

`merge_errors.rs` alone is 940 lines of format strings like:

```rust
pub fn fast_forward_conflict(...) -> String {
    format!(
        "Error: Cannot fast-forward merge for spec {}\n\n\
         Context:\n  - Branch: {}\n  - Target: {}\n\n\
         Next Steps:\n\
         \x20 1. Use no-fast-forward merge:  chant merge {} --no-ff\n\
         \x20 2. Or rebase onto {}:  chant merge {} --rebase\n\
         ...",
        spec_id, spec_branch, main_branch, ...
    )
}
```

Each error message is a unique hand-written function with its own test. This is 940 lines of templates masquerading as code.

The merge driver (`merge_driver.rs`, 728 LOC) handles frontmatter conflicts by parsing both sides and merging field-by-field, but the rules are implicit in procedural code rather than declared.

## Approach

### Error messages: Data-driven templates

Replace hand-written format functions with a declarative error catalog:

```rust
pub struct MergeError {
    pub kind: MergeErrorKind,
    pub context: MergeContext,
}

pub enum MergeErrorKind {
    FastForwardConflict,
    DirtyWorktree,
    UnresolvedConflict,
    BranchNotFound,
    // ...
}

impl Display for MergeError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        // Template rendering based on kind + context
    }
}
```

Each error kind maps to a template with placeholders. Context fields (spec_id, branch, target) are populated once. Tests verify the template renders correctly rather than testing string equality on giant format blocks.

### Merge driver: Declarative field resolution

Replace procedural field-by-field merge with declared rules:

```rust
enum MergeRule {
    LastWriteWins,    // status, completed_at, branch
    Union,            // labels, target_files
    PreferOurs,       // body content when no conflict markers
    PreferTheirs,     // output, agent-written fields
    Fail,             // body with conflict markers
}

const FIELD_RULES: &[(&str, MergeRule)] = &[
    ("status", MergeRule::LastWriteWins),
    ("labels", MergeRule::Union),
    ("target_files", MergeRule::Union),
    ("completed_at", MergeRule::LastWriteWins),
    // ...
];
```

This makes merge behavior auditable by reading a table rather than tracing procedural code.

## Key Considerations

- The error messages are user-facing and currently excellent in quality — the refactor should not degrade message quality
- Some error messages include dynamic "Next Steps" that vary by context — the template system must support conditional sections
- The merge driver is registered as a git merge driver (`merge=chant-spec`) — external interface must not change
- `conflict.rs` (461 LOC) handles conflict detection/analysis and may overlap with merge driver logic

## Acceptance Criteria

- [ ] `merge_errors.rs` uses a data-driven template system instead of hand-written format functions
- [ ] Error message quality is unchanged (same information, same actionable next steps)
- [ ] Merge driver uses declared field resolution rules instead of procedural if/else chains
- [ ] Adding a new frontmatter field requires adding one line to the rules table, not writing merge logic
- [ ] Total LOC across merge.rs + merge_driver.rs + merge_errors.rs reduced by at least 30%
- [ ] All existing merge tests pass
- [ ] Git merge driver external interface unchanged