---
type: code
status: pending
target_files:
- src/main.rs
- src/cmd/work.rs
---

# Implement chant work --chain flag for autonomous workflows

## Problem

Currently, `chant work` executes one spec or a batch, then stops. For autonomous workflows (overnight processing, CI/CD, unattended execution), users want to continuously work through ready specs until the queue is empty or a failure occurs.

## Solution

Add `--chain` flag to `chant work` that loops through ready specs:

### Basic Usage

```bash
# Work through all ready specs sequentially
chant work --chain

# Chain through labeled specs only
chant work --chain --label autonomous

# Chain with maximum limit
chant work --chain --max 5

# Chain with specific starting spec
chant work 001 --chain   # Start with 001, then chain to next ready
```

### Behavior

**Loop Logic:**
1. Find next ready spec (respects depends_on, labels, filters)
2. Execute spec
3. If success → loop to step 1
4. If failure → stop and report
5. If no more ready specs → stop with success
6. If Ctrl+C → graceful shutdown

**Progress Display:**
```
[1/8] Working 2026-01-29-001-abc: Fix bug in API
✓ Completed in 2m 15s

[2/8] Working 2026-01-29-002-def: Add tests
✓ Completed in 1m 30s

[3/8] Working 2026-01-29-003-ghi: Update docs
...
```

**Error Handling:**
- First failure stops the chain
- Exit code = last spec's exit code
- Report shows successful count before failure

**Compatibility:**
- `--chain` + `--parallel`: Run parallel batches, each batch chains (complex, maybe MVP = sequential only)
- `--chain` + `--label`: Only chain through labeled specs
- `--chain` + `--max N`: Stop after N completions

### Implementation

**src/main.rs** - Add flag:
```rust
Work {
    // ... existing fields

    /// Chain through ready specs until none remain or failure
    #[arg(long)]
    chain: bool,

    /// Maximum number of specs to chain (0 = unlimited)
    #[arg(long, default_value = "0")]
    max: usize,
}
```

**src/cmd/work.rs** - Chain loop:
```rust
if chain {
    let mut completed = 0;
    loop {
        // Get next ready spec (respect filters)
        let next_spec = find_next_ready_spec(&config, label, type)?;

        if next_spec.is_none() {
            println!("✓ No more ready specs");
            break;
        }

        if max > 0 && completed >= max {
            println!("✓ Reached maximum chain limit ({max})");
            break;
        }

        // Execute spec
        let result = cmd_work_spec(&next_spec.unwrap(), ...)?;

        if result.is_err() {
            eprintln!("✗ Chain stopped due to failure");
            return result;
        }

        completed += 1;
    }

    println!("✓ Chained through {completed} spec(s)");
}
```

### Use Cases

**Autonomous Batch Processing:**
```bash
# Label specs as autonomous, chain through them
chant work --chain --label autonomous
```

**Overnight Work Queue:**
```bash
# Leave running overnight to clear backlog
chant work --chain --max 20
```

**CI/CD Pipelines:**
```bash
# Chain through all ready specs in CI
chant work --chain --label ci-safe
```

**Unattended Execution:**
```bash
# Process queue while away
nohup chant work --chain > chain.log 2>&1 &
```

## Acceptance Criteria

- [ ] Add `--chain` flag to Work command in src/main.rs
- [ ] Add `--max` flag for chain limit in src/main.rs
- [ ] Implement chain loop in src/cmd/work.rs
- [ ] Find next ready spec respecting filters (label, type, depends_on)
- [ ] Show progress "[N/M] Working spec-id: description"
- [ ] Stop on first failure with proper exit code
- [ ] Stop gracefully on Ctrl+C (SIGINT)
- [ ] Stop when no more ready specs
- [ ] Stop when --max limit reached
- [ ] Report summary at end ("Chained through N specs")
- [ ] Add tests for chain logic
- [ ] Add documentation for --chain flag
- [ ] All tests passing
- [ ] Code linted and formatted
