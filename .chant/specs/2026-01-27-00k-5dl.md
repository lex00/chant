---
type: code
status: pending
target_files:
  - tests/integration_tests.rs
---

# Add integration test for derivation with git failure

## Problem

No integration test verifies graceful handling when git commands fail (e.g., not in a git repository, git not installed, detached HEAD).

**Gap:** Error handling for git failures untested in real workflow.

## Solution

Add integration test that:
1. Creates directory WITHOUT initializing git
2. Sets up enterprise config with branch derivation
3. Runs `chant add` and verifies it handles git failure gracefully
4. Verifies spec created without branch-derived fields

## Test Implementation

```rust
#[test]
fn test_derivation_graceful_failure_no_git() {
    let temp_dir = "/tmp/chant-test-no-git";
    std::fs::create_dir_all(temp_dir).unwrap();

    // Initialize chant WITHOUT git repo
    std::fs::create_dir_all(format!("{temp_dir}/.chant/specs")).unwrap();

    // Create enterprise config expecting git branch
    let config = r#"
enterprise:
  derived:
    sprint:
      from: branch
      pattern: "sprint/([^/]+)"
    component:
      from: path
      pattern: "/([^/]+)\\.md$"
"#;
    write_config(temp_dir, config);

    // Run chant add (should succeed despite git failure)
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant add");

    // Command should still succeed
    assert!(output.status.success());

    // Verify spec created
    let spec_content = read_latest_spec(temp_dir);

    // sprint field should be missing (git failed)
    assert!(!spec_content.contains("sprint:"));

    // component field should still work (path doesn't need git)
    assert!(spec_content.contains("component:"));

    // derived_fields should only list component
    assert!(spec_content.contains("derived_fields:\n  - component"));
    assert!(!spec_content.contains("sprint") || !spec_content.contains("derived_fields"));

    cleanup_dir(temp_dir);
}

#[test]
fn test_derivation_with_detached_head() {
    let temp_dir = "/tmp/chant-test-detached-head";
    setup_test_repo(temp_dir);

    // Create detached HEAD state
    Command::new("git")
        .args(["commit", "--allow-empty", "-m", "Initial commit"])
        .current_dir(temp_dir)
        .output()
        .unwrap();

    let commit_hash = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .current_dir(temp_dir)
        .output()
        .unwrap();

    Command::new("git")
        .args(["checkout", std::str::from_utf8(&commit_hash.stdout).unwrap().trim()])
        .current_dir(temp_dir)
        .output()
        .unwrap();

    // Create enterprise config
    let config = r#"
enterprise:
  derived:
    branch_name:
      from: branch
      pattern: "(.*)"
"#;
    write_config(temp_dir, config);

    // Run chant add (should handle detached HEAD)
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant add");

    assert!(output.status.success());

    // Spec should be created (may or may not have branch field depending on detached HEAD handling)
    let spec_content = read_latest_spec(temp_dir);
    assert!(spec_content.contains("type: code"));
}
```

## Acceptance Criteria

- [ ] Add two tests to tests/integration_tests.rs
- [ ] First test: Directory with no git repository
- [ ] Test verifies chant add still succeeds
- [ ] Test verifies branch-derived fields are omitted
- [ ] Test verifies non-git fields (path) still work
- [ ] Second test: Detached HEAD state
- [ ] Test verifies graceful handling (no crash)
- [ ] Tests pass: `cargo test test_derivation.*git`
- [ ] Cleanup temp directories after tests