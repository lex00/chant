---
type: code
status: pending
target_files:
  - src/cmd/work.rs
  - src/worktree.rs
---

# Automatic worktree cleanup on interrupt during parallel execution

## Problem

When parallel execution is interrupted (Ctrl-C, kill, crash):
- Worktrees in `/tmp/chant-*` are left behind
- Branches `chant/*` remain
- Disk space accumulates
- User must run `chant cleanup` manually

The existing SIGINT handler (`CHAIN_INTERRUPTED`) handles graceful stop but doesn't clean up worktrees from the current run.

## Solution

1. Track worktrees created during current parallel run
2. On interrupt, clean up worktrees that haven't completed
3. Preserve branches for specs that completed work (for later merge)
4. Register cleanup as a panic hook and signal handler

## Implementation

### Track active worktrees

```rust
struct ParallelExecutionState {
    /// Worktrees created this run, keyed by spec_id
    active_worktrees: Arc<Mutex<HashMap<String, PathBuf>>>,
    /// Specs that completed agent work (preserve their branches)
    completed_specs: Arc<Mutex<HashSet<String>>>,
}

impl ParallelExecutionState {
    fn register_worktree(&self, spec_id: &str, path: PathBuf) {
        self.active_worktrees.lock().unwrap().insert(spec_id.to_string(), path);
    }

    fn mark_completed(&self, spec_id: &str) {
        self.completed_specs.lock().unwrap().insert(spec_id.to_string());
    }

    fn cleanup_incomplete(&self) {
        let active = self.active_worktrees.lock().unwrap();
        let completed = self.completed_specs.lock().unwrap();

        for (spec_id, path) in active.iter() {
            if !completed.contains(spec_id) {
                eprintln!("Cleaning up incomplete worktree: {}", path.display());
                let _ = worktree::remove_worktree(path);
                // Also remove branch since work didn't complete
                let branch = format!("chant/{}", spec_id);
                let _ = delete_branch(&branch);
            }
        }
    }
}
```

### Register cleanup handlers

```rust
fn setup_parallel_cleanup_handlers(state: Arc<ParallelExecutionState>) {
    // SIGINT handler
    let state_clone = state.clone();
    ctrlc::set_handler(move || {
        eprintln!("\nInterrupt received, cleaning up...");
        state_clone.cleanup_incomplete();
        std::process::exit(130);
    }).expect("Failed to set Ctrl-C handler");

    // Panic hook for crashes
    let state_clone = state.clone();
    let default_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |info| {
        state_clone.cleanup_incomplete();
        default_hook(info);
    }));
}
```

### Preserve completed work

Specs that completed agent work (even if merge pending) should:
- Keep their worktree until merge
- Keep their branch
- Only clean up truly incomplete work

## Acceptance Criteria

- [ ] Add `ParallelExecutionState` to track active worktrees
- [ ] Register each worktree as it's created
- [ ] Mark specs as completed when agent work finishes
- [ ] Set up SIGINT handler to cleanup incomplete worktrees
- [ ] Set up panic hook for crash cleanup
- [ ] Preserve worktrees/branches for completed specs
- [ ] Delete branches for incomplete specs (no partial work to save)
- [ ] Log cleanup actions
- [ ] Test interrupt handling (manual verification)
