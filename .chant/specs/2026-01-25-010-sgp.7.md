---
type: code
status: pending
depends_on:
- 2026-01-25-010-sgp.6
target_files:
- src/cmd/work.rs
- src/cmd/git_ops.rs
- src/cmd/model.rs
- src/cmd/commits.rs
- src/cmd/finalize.rs
- src/cmd/mod.rs
---
# Final Verification and Cleanup

Verify the refactored `work.rs` meets all requirements and clean up any unused code.

### Acceptance Criteria

- [ ] `work.rs` is now under 800 lines (target: ~400-500 after extraction)
- [ ] All modules created are under 800 lines individually:
  - `git_ops.rs`: ~155 lines
  - `model.rs`: ~100 lines
  - `commits.rs`: ~95 lines
  - `finalize.rs`: ~320 lines
- [ ] No unused imports in `work.rs` or any extracted module
- [ ] All public functions have doc comments explaining their purpose
- [ ] No dead code marked with `#[allow(dead_code)]`
- [ ] `ParallelResult` still has `#[allow(dead_code)]` if truly unused (verify usage)
- [ ] Module organization in `src/cmd/mod.rs` is clean:
  - All modules explicitly declared
  - Public re-exports if needed
- [ ] No circular module dependencies (verify with cargo)
- [ ] `just lint` passes with no warnings
- [ ] `just test` passes
- [ ] `just build` succeeds
- [ ] Full `just check` passes

### Edge Cases

- Check for any leftover code duplicated across modules
- Verify all constants (like `MAX_AGENT_OUTPUT_CHARS`) are in correct location
- Ensure error types are properly exported and accessible
- Check that `crate::cmd` imports in other files still work

### Example Test Cases

For this verification, verify:
- No clippy warnings in any module
- `cargo build` succeeds with no errors
- All tests pass
- Line counts match target ranges
- Import paths resolve correctly
- No unused public functions


## Execution Strategy

**Parallel Execution Groups:**
- **Group A (in parallel):** Members 1, 2, 3 - Extract self-contained modules with no interdependencies
- **Group B (sequential after A):** Member 4 - Extract finalization (depends on modules from Group A)
- **Group C (sequential after B):** Members 5, 6 - Refactor cmd_work and cmd_work_parallel (can be done in parallel, both depend on A and B)
- **Group D (final):** Member 7 - Verification and cleanup

This organization ensures:
- Early modules are simple extractions with no new logic
- Later members depend on earlier modules being stable
- Compilation succeeds at each stage
- Tests can verify functionality progressively
- Final verification confirms all metrics are met
## Summary

I've analyzed the driver specification "Phase 2: Split cmd/work.rs into smaller modules" and created a comprehensive split plan with **7 member specs**.

### Key Points of the Plan:

1. **Members 1-3** (in parallel): Extract three self-contained modules
   - `git_ops.rs` - Branch and push operations
   - `model.rs` - Model detection and selection
   - `commits.rs` - Commit tracking with error handling

2. **Member 4** (sequential): Extract `finalize.rs` - Spec finalization logic with comprehensive validation

3. **Members 5-6** (in parallel): Refactor the two main execution functions to use extracted modules

4. **Member 7** (final): Comprehensive verification that all size and quality targets are met

### Distinguishing Features:

- **Detailed acceptance criteria** with checkboxes for each requirement
- **Edge cases explicitly called out** for each member (e.g., git command failures, empty commits, concurrent issues)
- **Example test cases** showing how to verify behavior
- **Affected files** clearly listed for each member
- **Execution strategy** showing parallelization opportunities (extract modules in parallel, then refactor sequentially)
- **Line count targets** preserved from original spec (all modules under 800 lines)

Each member spec can be independently executed and verified to be in a compilable, testable state before proceeding to the next. The modular approach ensures no circular dependencies and clear separation of concerns.