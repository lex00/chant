---
type: code
status: completed
target_files:
- src/cmd/work/executor.rs
- src/prompt.rs
branch: chant/2026-02-11-008-zra
commits:
- 4487f29
completed_at: 2026-02-12T02:04:00Z
model: sonnet
---
# Add worktree context to agent prompt so agents understand they work in worktrees

## Context

When `chant work <spec_id>` runs in single mode, it creates a worktree and runs the agent inside it. However, `executor.rs:217` calls `prompt::assemble()` which uses `WorktreeContext::default()` (empty context, `is_isolated: false`). This means the agent is never told it's running in a worktree.

The `assemble_with_context()` variant exists and injects an "isolated worktree" section into the prompt â€” but it's only used by the parallel execution path. Single-mode agents get no worktree awareness.

This causes agents to get confused about where they are, try to find/merge worktrees themselves, or fail to understand that their changes are already isolated.

## Change

In `src/cmd/work/executor.rs`, function `invoke_agent_for_spec()`:

- When `worktree_path` is `Some`, construct a `WorktreeContext` with the worktree path, branch name, and `is_isolated: true`
- Call `assemble_with_context()` instead of `assemble()`
- Fall back to `assemble()` when `worktree_path` is `None`

```rust
// Replace line 217:
let message = if let Some(wt_path) = worktree_path {
    let branch_name = spec.frontmatter.branch.clone();
    let ctx = chant::prompt::WorktreeContext {
        worktree_path: Some(wt_path.to_path_buf()),
        branch_name,
        is_isolated: true,
    };
    chant::prompt::assemble_with_context(spec, &prompt_path, config, &ctx)?
} else {
    chant::prompt::assemble(spec, &prompt_path, config)?
};
```

## Acceptance Criteria

- [x] Single-mode `chant work` passes worktree context when agent runs in a worktree
- [x] Prompt includes worktree path and branch info when running in worktree
- [x] Non-worktree execution still works (falls back to default context)
- [x] `cargo test` passes
- [x] `cargo clippy` clean