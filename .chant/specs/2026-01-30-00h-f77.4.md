---
type: code
status: completed
depends_on:
- 2026-01-30-00h-f77.2
- 2026-01-30-00h-f77.3
- 2026-01-30-00h-f77.1
target_files:
- src/cmd/watch.rs
- Possibly src/cmd/finalize.rs, src/cmd/merge.rs for shared utilities
commits:
- bd0c25c
completed_at: 2026-01-31T15:33:03Z
model: sonnet
---
# Lifecycle operations (finalize, merge, resume)

Orchestrate calls to `chant finalize`, `chant merge`, and `chant resume` based on spec state. Handle branch detection and error reporting.

### Inherited Context

- Watch is monitor-only: lifecycle ops are the ONLY actions watch can take
- Cannot spawn agents (resume restarts existing spec's agent via CLI)
- Cannot create new specs or modify spec content

### Acceptance Criteria

- [x] `handle_completed(spec_id)` runs finalize, then merge if branch exists
- [x] `handle_failed(spec_id, retry_decision)` schedules resume or marks permanent failure
- [x] Branch detection: check if spec worktree is on `chant/<spec-id>` branch
- [x] Use existing CLI commands: `chant finalize`, `chant merge`, `chant resume`
- [x] Return `Result` with descriptive errors for subprocess failures

### Edge Cases

- Finalize fails (e.g., criteria not actually complete): Log error, do not proceed to merge
- Merge fails (e.g., conflicts): Log error, mark spec for manual intervention
- Resume fails (e.g., spec file corrupted): Treat as permanent failure
- Spec on main branch: Skip merge step (no branch to merge)

### Example Test Cases

- Completed spec on branch → finalize succeeds, merge succeeds
- Completed spec on main → finalize succeeds, skip merge
- Failed spec with retry decision → schedule resume with delay
- Failed spec with permanent failure → log and mark needs_attention


- `handle_completed(spec_id: &str) -> Result<()>` - Errors on subprocess failure
- `handle_failed(spec_id: &str, config: &FailureConfig) -> Result<()>` - Errors on subprocess failure

---

## Agent Output

2026-01-31T15:33:03Z

```
I'll implement the lifecycle operations for handling completed and failed specs.
Now I'll implement the lifecycle operations. Let me create the functions to handle completed and failed specs.
Good, `colored::Colorize` is already imported. Now let me check if the functions are exported from the module:
I see there's a `watch` module in the mod.rs. Let me check if it exists:
Let me wait for clippy to finish and then check for compilation errors:
I need to fix the import paths. Let me update them:
I need to check if the `retry_state` field exists in the `SpecFrontmatter`:
The `retry_state` field doesn't exist in `SpecFrontmatter`. I need to add it:
Good! Now let's run the tests:
Great! All tests pass. Now let me check off the acceptance criteria in the spec:
Now let me commit the changes:
## Summary

Implemented lifecycle operations for watch mode in `src/cmd/lifecycle.rs`:

- `handle_completed(spec_id)` - Finalizes spec, then merges if on branch
- `handle_failed(spec_id, config)` - Decides retry vs permanent failure using exponential backoff
- `is_spec_on_branch(spec_id, branch_name)` - Detects if spec worktree is on expected branch

Added `retry_state` field to `SpecFrontmatter` to track retry attempts and timing.

All acceptance criteria met and tests passing.```
