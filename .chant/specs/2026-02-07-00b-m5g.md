---
type: code
status: pending
depends_on:
- 2026-02-07-00a-ffx
labels:
- refactor
- work-engine
- dedup
target_files:
- src/cmd/work/single.rs
- src/cmd/work/chain.rs
- src/cmd/work/parallel.rs
- src/cmd/work/mod.rs
- src/cmd/work/executor.rs
---
# Unify single/chain/parallel work modes into a shared SpecExecutor engine

## Problem

`single.rs` (1,009 LOC), `chain.rs` (806 LOC), and `parallel.rs` (1,442 LOC) implement the same workflow three times with copy-pasted code and silent behavioral divergence.

### Duplicated code blocks (copied verbatim or near-verbatim):
- Lint validation: ~20 lines x 3
- Approval checking: ~35 lines x 2 (single + chain), **missing from parallel**
- Agent selection with rotation: ~25 lines x 2 (single + chain)
- Commit fetching and validation: ~37 lines x 3
- Error status transitions: ~15 lines x 3
- Auto-complete driver checks: ~8 lines x 3
- Agent output appending: ~10 lines x 3

### Behavioral divergence (bugs, not features):
- **Approval check**: single yes, chain yes, parallel MISSING
- **Dependency check**: single yes, chain yes, parallel MISSING
- **Quality scoring**: single yes, chain skipped, parallel skipped
- **Unchecked AC handling**: single auto-checks, chain fails the spec, parallel skips
- **Finalization failure status**: single sets Failed, chain sets Failed, parallel sets NeedsAttention
- **Agent invocation function**: single calls `invoke_agent_with_model`, chain calls `invoke_agent` (different function!), parallel calls `invoke_agent_with_command`

## Approach

Extract a `SpecExecutor` struct that owns the single-spec lifecycle:

```
SpecExecutor::new(spec, config)
    .validate()        // lint + approval + dependency + quality (one pipeline)
    .prepare()         // set InProgress, create worktree, copy spec
    .invoke_agent()    // select agent, build message, run
    .collect_commits() // find commits for spec
    .finalize()        // AC check, status transition, auto-complete driver
    .cleanup()         // worktree removal, transcript commit
```

The three modes become thin scheduling strategies:
- `single`: Run `SpecExecutor` once
- `chain`: Loop `SpecExecutor` over ready specs sequentially
- `parallel`: Distribute `SpecExecutor` instances across threads

Each mode only handles scheduling concerns (which specs, how many threads, what to do when one finishes). All validation, agent invocation, commit collection, and finalization logic lives in `SpecExecutor`.

## Key Considerations

- Parallel mode needs the executor to be `Send` for thread distribution
- Quality scoring should be configurable (skip in chain/parallel or make it a validation step everywhere)
- The "unchecked AC" policy should be unified â€” pick one behavior and use it everywhere
- Chain mode currently doesn't use worktrees; the executor should support both modes
- Error recovery (setting Failed status) must be identical across all modes

## Acceptance Criteria

- [ ] New `SpecExecutor` in `src/cmd/work/executor.rs` handles the full single-spec lifecycle
- [ ] `single.rs`, `chain.rs`, `parallel.rs` each under 200 LOC, handling only scheduling
- [ ] Approval checking works identically in all three modes
- [ ] Dependency checking works identically in all three modes
- [ ] AC handling follows one policy across all modes
- [ ] Finalization failure sets the same status in all modes
- [ ] Agent invocation uses the same code path in all modes
- [ ] No behavioral divergence between modes except scheduling strategy
- [ ] All existing tests pass