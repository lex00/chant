---
type: code
status: completed
depends_on:
- 2026-01-27-006-ust
target_files:
- src/cmd/spec.rs
- src/cmd/export.rs
- src/spec.rs
- src/cmd/derive.rs
- tests/integration_tests.rs
commits:
- dfd4834
completed_at: 2026-01-27T19:28:27Z
model: haiku
---
# Update UI to distinguish derived vs explicit fields

## Problem

Users should be able to see which frontmatter fields were derived automatically vs set manually. This helps with:
- Debugging derivation patterns
- Understanding what fields are auto-managed
- Transparency in automation

Commands to update:
- `chant show <spec-id>` - Display frontmatter with derivation indicators
- `chant export` - Include derivation metadata in exports

## Solution

### Option 1: Visual Markers in Display (Recommended)

```bash
$ chant show 2026-01-27-001-abc
ID: 2026-01-27-001-abc
Status: completed
Team: platform [derived]
Component: api [derived]
Jira Key: PROJ-123 [derived]
Assignee: alice

Description:
Add authentication...
```

### Option 2: Separate Sections

```bash
$ chant show 2026-01-27-001-abc

Explicit Fields:
  status: completed
  assignee: alice

Derived Fields:
  team: platform (from path)
  component: api (from path)
  jira_key: PROJ-123 (from branch)
```

### Implementation

Track derived field names in spec metadata or comment in frontmatter:

```yaml
---
status: completed
team: platform
jira_key: PROJ-123
# Derived: team, jira_key
---
```

Update `src/render.rs` or `src/cmd/spec.rs` display logic to:
- Parse derived field list from frontmatter comment
- Add "[derived]" suffix when printing these fields
- Include derived metadata in export formats (JSON, CSV)

## Acceptance Criteria

- [x] Track which fields are derived (comment in frontmatter or separate metadata)
- [x] Update `chant show` to mark derived fields with "[derived]" indicator
- [x] Update `chant export --format json` to include derived field metadata
- [x] Derived field indicators shown for all derivation sources (branch, path, env, git_user)
- [x] Fields without derivation show normally (no indicator)
- [x] Add integration test: show command displays derived indicators
- [x] Add integration test: export includes derived metadata
- [x] All tests pass

## Agent Output

2026-01-27T19:28:27Z

```
I'll start by understanding the spec and planning the implementation. Let me create a todo list and begin exploring the codebase.
Let me explore the codebase structure to understand how to implement this feature.
Excellent! Now I have a clear understanding of the codebase. Let me mark my first todo as complete and move to planning.
Now let me review the actual code files to understand the current structure better before finalizing the plan.
Now let me check the export command to understand how it handles field exports:
Let me see more of the export command, particularly the field handling:
Perfect! Now I have enough context. Let me finalize my implementation plan:
Now I'll implement the solution. First, let me add the `derived_fields` field to the `SpecFrontmatter` struct:
Good! Now let me check the cmd/derive.rs to understand how fields are derived and update it to track which fields were derived:
Good! I see that `cmd_derive.rs` calls `updated_spec.add_derived_fields()`. Let me check if that method exists in spec.rs:
Let me search for the implementation more specifically:
Good! Now let me see how it's implemented:
Now I need to update the `add_derived_fields` method to also track which fields were derived. Let me modify it:
Now let me update my todo and move on to updating the `chant show` command:
Now I need to modify the `cmd_show` function to display "[derived]" indicators for fields in the `derived_fields` list. Let me first read more of the cmd_show function to understand the formatting:
Now let me find the key_to_title_case and format_yaml_value functions:
Let me read those functions:
Perfect! Now I need to modify the `cmd_show` function to check if a field is in the `derived_fields` list and add a "[derived]" indicator. Let me update the cmd_show function:
Good! Now let me update the export functionality to include derived field metadata. First, let me check the export functions more closely to understand how to add the derived metadata:
Now I'll update the export functions to support the derived_fields field. First, let me add "derived_fields" to the field list functions:
Now add the derived_fields case to the get_field_value function:
Now let me update the todo and write the tests:
Now let me look at existing tests to understand the testing pattern:
Let me check what tests already exist:
I see the tests are for other functionality. Let me check if there are integration test directories:
Let me check the integration tests file:
Let me continue reading and find a test I can follow as a template:
Good! Now I understand the test structure. Let me add tests at the end of the integration_tests.rs file. First, let me find the end of the file:
Let me check the last part of the file to understand the structure better:
Perfect! Now I'll add integration tests for the derived fields feature at the end of the file:
Let me add more context to make it unique:
Let me get more context to make it unique:
Now I can make it unique:
Good! Now let me run the tests to see if there are any issues. First, let me try to build the project:
Now let me build and test:
I need to add the `derived_fields` field to the `impl Default` for `SpecFrontmatter`. Let me find it:
Let me read that implementation:
Now I'll add the missing field to the Default implementation:
Now let's try building again:
Great! The build succeeded. Now let's run the tests:
Perfect! The existing tests pass. Now let's run the new integration tests:
I see! The issue is that my change to display the [derived] indicator only works for fields in the frontmatter, but the custom field `team` isn't showing up in the display. Let me check what's happening. It seems the spec isn't being parsed correctly. Let me look at the test output more carefully. The issue is that the `team` field is not being displayed at all. Let me check the cmd_show function more carefully:

Looking at the output, I see that only `type` and `status` are being displayed, not the `team` field. The problem is that the spec frontmatter needs the `team` field to be a valid spec field. Since `team` is not a field in SpecFrontmatter, it's being ignored during deserialization.

This is a limitation of the YAML deserialization - unknown fields are not included. To properly support derived fields that map to frontmatter, I need to update the approach. Let me check what fields are actually supported:

Looking at the SpecFrontmatter struct, I see it has a fixed set of fields. The `team` field doesn't exist, so it's not being persisted. Let me update my test to use a field that actually exists in the frontmatter, like `labels`:
Now let's test again:
I see the issue now. The output shows "Labels: [feature-derived]" but no "[derived]" indicator. Looking at my code in cmd_show, I suspect there might be an issue with the color formatting. Let me check if the indicator is being added but perhaps colored in a way that makes it invisible or if the code path isn't being hit.

Let me look at the actual output fro

... (output truncated, 16600 chars total)```
