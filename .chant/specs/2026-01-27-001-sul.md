---
type: code
status: completed
labels:
- multi-repo
- v0.4.0
target_files:
- src/id.rs
- src/spec.rs
- src/main.rs
commits:
- cf4d51e
completed_at: 2026-01-27T01:14:06Z
model: haiku
---
# Implement repo prefix parsing for cross-repo spec references

Add support for parsing spec IDs with an optional `repo:` prefix to enable cross-repository spec references.

## Context

The multi-repo design (see `docs/scale/multi-project.md`) requires spec IDs to optionally include a repository prefix:

```
backend:2026-01-22-001-x7m      # repo:id format
backend:auth-2026-01-22-001-x7m # repo:project-id format
2026-01-22-001-x7m              # local (no prefix)
```

The `repo:` prefix is optional - only needed when referencing specs in other repos.

## Design

### SpecId Struct Enhancement

```rust
pub struct SpecId {
    pub repo: Option<String>,      // NEW: Optional repo name
    pub project: Option<String>,   // Existing: Optional project prefix
    pub date: NaiveDate,
    pub sequence: String,
    pub suffix: String,
    pub member: Option<u32>,
}
```

### Parsing Rules

1. If ID contains `:`, split on first `:` to extract repo prefix
2. Repo names are alphanumeric with hyphens/underscores (e.g., `backend`, `my-repo`)
3. After extracting repo, parse remainder as normal spec ID
4. Validate repo name exists in global config (warn if not)

### Display Format

```rust
impl Display for SpecId {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        if let Some(repo) = &self.repo {
            write!(f, "{}:", repo)?;
        }
        // ... rest of existing format
    }
}
```

## Acceptance Criteria

- [x] `SpecId` struct has optional `repo` field
- [x] Parser handles `repo:id` format (e.g., `backend:2026-01-27-001-abc`)
- [x] Parser handles `repo:project-id` format (e.g., `backend:auth-2026-01-27-001-abc`)
- [x] Parser handles local IDs without prefix (backwards compatible)
- [x] `SpecId::to_string()` includes repo prefix when present
- [x] Invalid repo names (special chars, empty) return parse error
- [x] Unit tests cover all parsing scenarios
- [x] `just lint` passes with no warnings

## Notes

- This spec only adds parsing support - actual cross-repo resolution comes in 002-8nc
- Global config repos validation is optional (warn, don't fail)
- Keep backwards compatibility with all existing spec ID formats

## Agent Output

2026-01-27T01:14:06Z

```
I'll implement repo prefix parsing for cross-repo spec references. Let me start by understanding the current codebase structure and the spec file.
Now let me read the spec file to understand all the requirements, and then examine the current SpecId implementation:
Now let me read the current SpecId implementation in src/id.rs:
Now let me check the spec.rs file to see if there's already a SpecId struct there:
Let me continue reading spec.rs to find if there's a SpecId struct:
Let me search more broadly for where spec IDs are being parsed:
Let me check the spec_group.rs file to understand how spec IDs are currently being extracted and parsed:
Let me search for where spec IDs with project prefixes are handled:
Let me search for where spec ID parsing happens in main.rs or cmd/spec.rs:
Let me look at the extract_driver_id and extract_member_number functions in spec.rs:
Let me read more of spec_group.rs to find these functions:
Now I have a good understanding. Let me update my todo list and plan the implementation:
## Implementation Plan

Based on my analysis, here's my approach:

1. **Current State**: The codebase uses simple string-based spec IDs (e.g., "2026-01-27-001-abc"). Spec parsing happens through string functions like `extract_driver_id()` and `extract_member_number()` in `spec_group.rs`.

2. **New Approach**: Create a proper `SpecId` struct in `src/id.rs` that:
   - Parses and validates spec IDs with optional repo prefix
   - Supports formats: `repo:2026-01-27-001-abc`, `repo:project-2026-01-27-001-abc`, `2026-01-27-001-abc`
   - Validates repo names (alphanumeric with hyphens/underscores)
   - Implements `Display` to show repo prefix when present
   - Provides parsing methods that return errors for invalid formats

3. **Implementation Steps**:
   - Define the `SpecId` struct with all required fields
   - Implement a `parse()` method to handle all three formats
   - Implement `Display` trait for formatting
   - Add comprehensive unit tests
   - Ensure backwards compatibility (IDs without repo prefix work as before)

Let me mark the planning task as complete and start implementing:
Now let me implement the SpecId struct in src/id.rs. I'll add it at the end of the file before the tests:
Now I'll add the SpecId struct and parsing logic. Let me insert it before the tests section:
Now I'll add the SpecId struct and its implementation before the tests:
Now let me add comprehensive unit tests for the SpecId parsing. I'll add them to the tests module:
Now let me update my todo list and run the tests to see if the implementation works:
Now let me run cargo fmt to format the code:
Good! Now let me run clippy to check for linting issues:
Let me fix the clippy warning by collapsing the nested if statements:
Now let me run clippy again:
Great! Now let me run the tests:
Let me try a different approach to run tests:
I have one test failing because my project detection logic is too conservative. The issue is that "auth-service-2026-01-27-001-abc" needs to be parsed with "auth-service" as the project, but my heuristic is checking that the second part is 4 digits (YYYY). Let me look at the test more carefully and fix the parsing logic:
The issue is that for "auth-service-2026-01-27-001-abc", the parts are: ["auth", "service", "2026", "01", "27", "001", "abc"]. My first check looks for months/days in parts[1] and parts[2], which are "service" and "2026", so it fails. The second check needs to match more flexibly. Let me improve the logic:
Now let me run the tests again:
Excellent! All tests pass now. I have one unused function warning. Let me remove the unused `is_valid_project_name` function since we now use the year-finding approach instead:
Now let me run the full test suite to make sure I didn't break anything else:
Perfect! All tests pass. Now let me run clippy once more to check for any warnings:
Excellent! All linting passes. Let me verify a build is successful:
Perfect! Now let me update the spec file to mark the acceptance criteria as complete. Let me read the spec file first:
Now let me check off all the acceptance criteria and add the model field:
Now let me check off all the acceptance criteria:
Now let me commit the changes:
Now let me create the commit:
Perfect! Now let me verify the git status is clean:
Perfect! Let me update my todo list to mark all tasks as complete:
## Summary

I have successfully implemented repo prefix parsing for cross-repo spec references. Here's what was completed:

### Implementation Details

**Added `SpecId` struct in `src/id.rs`** with the following features:

1. **Fields**:
   - `repo: Option<String>` - Optional repository prefix
   - `project: Option<String>` - Optional project prefix
   - `base_id: String` - The core spec ID (YYYY-MM-DD-SSS-XXX)
   - `member: Option<u32>` - Optional member number for group specs

2. **Parsing Logic** (`SpecId::parse()`):
   - Extracts optional repo prefix before first colon
   - Validates repo names (alphanumeric with hyphens/underscores)
   

... (output truncated, 6624 chars total)```
