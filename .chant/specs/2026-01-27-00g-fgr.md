---
type: code
status: completed
target_files:
- tests/integration_tests.rs
completed_at: 2026-01-27T22:30:09Z
model: opus
---
# Add integration test for chant derive single spec

## Problem

The `chant derive <SPEC_ID>` command has ZERO integration tests. The command exists and is documented but completely untested in real workflow.

**Gap:** Need to verify the command actually re-derives fields for existing specs.

## Solution

Add integration test that:
1. Creates test git repository and spec
2. Creates spec WITHOUT derived fields
3. Adds enterprise config AFTER spec creation
4. Runs `chant derive <SPEC_ID>`
5. Verifies spec now has derived fields

## Test Implementation

```rust
#[test]
fn test_chant_derive_single_spec() {
    let temp_dir = "/tmp/chant-test-derive-single";
    setup_test_repo(temp_dir);

    // Create spec without enterprise config
    let output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["add", "Test spec"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to create spec");

    assert!(output.status.success());
    let spec_id = extract_spec_id(&output.stdout);

    // Verify spec has no derived fields initially
    let spec_path = format!("{temp_dir}/.chant/specs/{spec_id}.md");
    let initial_content = std::fs::read_to_string(&spec_path).unwrap();
    assert!(!initial_content.contains("derived_fields:"));

    // Add enterprise config
    let config = r#"
enterprise:
  derived:
    component:
      from: path
      pattern: "/([^/]+)\\.md$"
"#;
    write_config(temp_dir, config);

    // Checkout branch with pattern for additional field
    Command::new("git")
        .args(["checkout", "-b", "sprint/2026-Q1-W4/PROJ-123"])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to create branch");

    // Run chant derive
    let derive_output = Command::new(env!("CARGO_BIN_EXE_chant"))
        .args(["derive", &spec_id])
        .current_dir(temp_dir)
        .output()
        .expect("Failed to run chant derive");

    assert!(derive_output.status.success());
    let stdout = String::from_utf8_lossy(&derive_output.stdout);
    assert!(stdout.contains(&format!("Updated {}", spec_id)));

    // Verify spec now has derived fields
    let updated_content = std::fs::read_to_string(&spec_path).unwrap();
    assert!(updated_content.contains("component:"));
    assert!(updated_content.contains("derived_fields:\n  - component"));
}
```

## Acceptance Criteria

- [ ] Add test to tests/integration_tests.rs
- [ ] Test creates spec without enterprise config
- [ ] Test adds enterprise config after spec creation
- [ ] Test runs `chant derive <SPEC_ID>` command
- [ ] Test verifies spec file is updated with derived fields
- [ ] Test verifies success message in stdout
- [ ] Test verifies derived_fields tracking added
- [ ] Test passes: `cargo test test_chant_derive_single_spec`
- [ ] Cleanup temp directory after test