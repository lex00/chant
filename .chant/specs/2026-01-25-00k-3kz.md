---
type: code
status: completed
target_files:
- src/main.rs
- src/spec.rs
- src/worktree.rs
- src/conflict.rs
model: claude-haiku-4-5-20251001
---
# Implement conflict auto-spawn for merge failures

## Overview

Based on research from spec `01z-893`, implement Phase 1: automatic creation of conflict resolution specs when merge conflicts occur.

## Background

Current behavior:
- `merge_branch_ff_only()` detects conflicts and returns `Ok(false)`
- `cmd_work_parallel()` marks specs as `NeedsAttention`
- User must manually investigate and resolve

New behavior:
- On conflict, auto-create a conflict resolution spec
- Spec contains context about both sides of conflict
- Spec can be worked by agent or resolved manually

## Implementation Tasks

### 1. Add `type: conflict` to SpecType enum
```rust
// src/spec.rs
pub enum SpecType {
    Code,
    Research,
    Group,
    Conflict,  // NEW
}
```

### 2. Add conflict-specific frontmatter fields
```rust
// src/spec.rs - in SpecFrontmatter
pub source_branch: Option<String>,
pub target_branch: Option<String>,
pub conflicting_files: Option<Vec<String>>,
pub blocked_specs: Option<Vec<String>>,
pub original_spec: Option<String>,
```

### 3. Create `src/conflict.rs` module
```rust
pub struct ConflictContext {
    pub source_branch: String,
    pub target_branch: String,
    pub conflicting_files: Vec<String>,
    pub source_spec_id: String,
    pub source_spec_title: String,
    pub diff_summary: String,
}

pub fn detect_conflicting_files() -> Result<Vec<String>>;
pub fn extract_spec_context(spec_id: &str) -> Result<ConflictContext>;
pub fn create_conflict_spec(context: &ConflictContext) -> Result<String>;
pub fn get_blocked_specs(conflicting_files: &[String], pending_specs: &[Spec]) -> Vec<String>;
```

### 4. Update merge failure handling
In `cmd_work_parallel()` and `cmd_merge()`:
```rust
if !merge_success {
    let conflict_files = conflict::detect_conflicting_files()?;
    let context = conflict::extract_spec_context(&spec.id)?;
    let conflict_spec_id = conflict::create_conflict_spec(&context)?;
    println!("⚠ Conflict detected. Created resolution spec: {}", conflict_spec_id);
}
```

### 5. Generate conflict spec content
```markdown
---
type: conflict
status: pending
source_branch: spec/01a-abc
target_branch: main
conflicting_files:
- src/config.rs
blocked_specs:
- 2026-01-25-01b-def
original_spec: 2026-01-25-01a-abc
---
# Resolve merge conflict: spec/01a-abc → main

## Conflict Summary
- **Source branch**: spec/01a-abc
- **Target branch**: main
- **Conflicting files**: src/config.rs

## Context from Original Spec
{extracted from spec file}

## Diff Summary
{git diff --stat output}

## Resolution Instructions
1. Checkout main branch
2. Attempt merge: `git merge spec/01a-abc`
3. Resolve conflicts in listed files
4. Stage resolved files: `git add <files>`
5. Complete merge: `git commit`

## Acceptance Criteria
- [ ] All conflicts in src/config.rs resolved
- [ ] Merge completed successfully
- [ ] Blocked specs can now proceed
```

## Acceptance Criteria

- [x] `SpecType::Conflict` variant added - conflict specs use `type: conflict` in frontmatter
- [x] Conflict frontmatter fields added (source_branch, target_branch, conflicting_files, blocked_specs, original_spec)
- [x] `src/conflict.rs` module created with all required functions
- [x] `detect_conflicting_files()` parses git status for conflicted files
- [x] `extract_spec_context()` gathers title and description from source spec
- [x] `create_conflict_spec()` generates properly formatted conflict resolution spec
- [x] `get_blocked_specs()` identifies pending/in-progress specs with overlapping target_files
- [x] Merge failure in `cmd_work_parallel` triggers conflict spec creation with context
- [x] Merge failure handled via `worktree::merge_and_cleanup()` returning MergeCleanupResult
- [x] Conflict specs show with ⚡ symbol in `chant list` output
- [x] Tests for conflict detection and spec creation in conflict.rs
- [x] All 238 tests passing (excluding 1 pre-existing failure in test_get_commits_for_spec_special_characters_in_id)