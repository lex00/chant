---
type: code
status: completed
target_files:
- src/cmd/work.rs
- src/worktree.rs
completed_at: 2026-01-27T21:28:09Z
model: haiku
---
# Add automatic worktree cleanup after parallel execution

## Problem

**User Report:** "Worktrees weren't automatically cleaned up after parallel execution, causing subsequent merge/rebase failures. Had to manually remove with `git worktree remove --force`."

After `chant work --parallel`, worktrees remain in /tmp even after specs complete successfully. This causes:
- Disk space waste
- Merge failures when trying to reuse branch names
- User confusion about which worktrees are active
- Manual cleanup burden

**Real User Experience:**
```bash
$ chant work spec1 spec2 --parallel
âœ“ 2 specs completed work
# Parallel execution completed successfully

$ chant merge spec1 --rebase
Error: Failed to checkout chant/2026-01-27-049-lhp:
'chant/2026-01-27-049-lhp' is already used by worktree at '/private/tmp/chant-2026-01-27-049-lhp'

$ git worktree list
/private/tmp/chant-2026-01-27-049-lhp  abc123 [chant/2026-01-27-049-lhp]
/private/tmp/chant-2026-01-27-04k-yo0  def456 [chant/2026-01-27-04k-yo0]

$ git worktree remove /private/tmp/chant-2026-01-27-049-lhp --force  # Manual!
$ git worktree prune
```

**User Feedback:**
- Batch size: Always 2 specs in parallel
- When it happens: Worktrees prevent merge on subsequent operations, not immediate
- Preferred timing: "After each spec completes would be ideal. The worktree should be removed when the agent finishes, since the branch is created and work is committed. No need to keep it around for merge."

## Solution

Add automatic cleanup after parallel execution completes:

1. **During spec execution:** Track all created worktrees
2. **After spec completes:** Remove worktree if spec succeeded
3. **After parallel batch:** Cleanup all worktrees for completed specs
4. **On error:** Keep failed worktree for debugging, cleanup on retry

**Implementation:**

```rust
// In src/cmd/work.rs parallel execution
pub fn execute_parallel_specs(...) -> Result<()> {
    let worktrees_created = vec![];

    // Execute specs in parallel
    for spec in specs {
        let worktree_path = create_worktree(spec)?;
        worktrees_created.push((spec.id.clone(), worktree_path));
        // ... execute agent
    }

    // Cleanup after all complete
    for (spec_id, worktree_path) in worktrees_created {
        let spec = load_spec(&spec_id)?;
        if spec.status == SpecStatus::Completed {
            cleanup_worktree(&worktree_path)?;
        }
    }

    Ok(())
}

// In src/worktree.rs
pub fn cleanup_worktree(path: &Path) -> Result<()> {
    if path.exists() {
        Command::new("git")
            .args(["worktree", "remove", path.to_str().unwrap(), "--force"])
            .output()?;
    }
    Ok(())
}
```

**Cleanup Strategy:**
- âœ… Cleanup immediately after spec succeeds
- â³ Keep worktree if spec failed (for debugging)
- ðŸ—‘ï¸ Add `chant cleanup` command for manual pruning
- âš ï¸ Log cleanup operations for transparency

## Acceptance Criteria

- [ ] Add worktree cleanup after successful spec completion
- [ ] Track worktrees created during parallel execution
- [ ] Cleanup all successful worktrees after batch completes
- [ ] Keep failed worktrees for debugging (add warning message)
- [ ] Add `chant cleanup --worktrees` command for manual cleanup
- [ ] Add integration test: parallel work -> verify worktrees cleaned up
- [ ] Add unit test for cleanup_worktree function
- [ ] Update documentation explaining cleanup behavior
- [ ] All existing tests pass