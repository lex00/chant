---
type: code
status: completed
target_files:
- src/agent.rs
- src/tools.rs
model: claude-haiku-4-5-20251001
---
# Implement ollama tool calling loop with JSON schema tools

## Problem

The current `agent.rs` does a simple chat completion but doesn't implement the tool calling protocol. Models like `qwen2.5` support tool/function calling, but we need to:

1. Define tools as JSON schemas in the request
2. Parse tool call responses from the model
3. Execute the requested tools
4. Feed results back to the model
5. Loop until the model completes the task

Currently the model just outputs a text plan describing what it would do, but doesn't actually execute anything.

## Background

Ollama supports tool calling via the `/api/chat` endpoint with a `tools` parameter. The format follows OpenAI's function calling convention:

```json
{
  "model": "qwen2.5:7b",
  "messages": [...],
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "read_file",
        "description": "Read contents of a file",
        "parameters": {
          "type": "object",
          "properties": {
            "path": {"type": "string", "description": "File path to read"}
          },
          "required": ["path"]
        }
      }
    }
  ]
}
```

When the model wants to call a tool, it responds with:
```json
{
  "message": {
    "role": "assistant",
    "tool_calls": [
      {
        "function": {
          "name": "read_file",
          "arguments": "{\"path\": \"src/main.rs\"}"
        }
      }
    ]
  }
}
```

## Implementation

### 1. Define tool schemas in src/tools.rs

Add JSON schema definitions for each tool:

```rust
use serde_json::{json, Value};

pub fn get_tool_definitions() -> Vec<Value> {
    vec![
        json!({
            "type": "function",
            "function": {
                "name": "read_file",
                "description": "Read the contents of a file at the given path",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "path": {"type": "string", "description": "File path to read"}
                    },
                    "required": ["path"]
                }
            }
        }),
        json!({
            "type": "function",
            "function": {
                "name": "write_file",
                "description": "Write content to a file, creating or overwriting",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "path": {"type": "string", "description": "File path to write"},
                        "content": {"type": "string", "description": "Content to write"}
                    },
                    "required": ["path", "content"]
                }
            }
        }),
        json!({
            "type": "function",
            "function": {
                "name": "run_command",
                "description": "Run a shell command and return output",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "command": {"type": "string", "description": "Shell command to run"}
                    },
                    "required": ["command"]
                }
            }
        }),
        json!({
            "type": "function",
            "function": {
                "name": "list_files",
                "description": "List files matching a glob pattern",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "pattern": {"type": "string", "description": "Glob pattern like 'src/**/*.rs'"}
                    },
                    "required": ["pattern"]
                }
            }
        }),
        json!({
            "type": "function",
            "function": {
                "name": "task_complete",
                "description": "Signal that the task is complete",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "summary": {"type": "string", "description": "Brief summary of what was done"}
                    },
                    "required": ["summary"]
                }
            }
        })
    ]
}

pub fn execute_tool(name: &str, args: &Value) -> Result<String, String> {
    match name {
        "read_file" => {
            let path = args["path"].as_str().ok_or("missing path")?;
            read_file(path.to_string()).map_err(|e| e.to_string())
        }
        "write_file" => {
            let path = args["path"].as_str().ok_or("missing path")?;
            let content = args["content"].as_str().ok_or("missing content")?;
            write_file(path.to_string(), content.to_string()).map_err(|e| e.to_string())
        }
        "run_command" => {
            let command = args["command"].as_str().ok_or("missing command")?;
            run_command(command.to_string()).map_err(|e| e.to_string())
        }
        "list_files" => {
            let pattern = args["pattern"].as_str().ok_or("missing pattern")?;
            list_files(pattern.to_string()).map_err(|e| e.to_string())
        }
        "task_complete" => {
            let summary = args["summary"].as_str().unwrap_or("Task completed");
            Ok(format!("TASK_COMPLETE: {}", summary))
        }
        _ => Err(format!("Unknown tool: {}", name))
    }
}
```

### 2. Update agent.rs with tool calling loop

The agent needs to use ollama-rs's tool calling support. Check the ollama-rs API for how to pass tools and parse tool_calls from responses. The loop should:

1. Build request with tools array
2. Send to ollama
3. Check response for tool_calls
4. If tool_calls present: execute each, add results as tool messages, continue loop
5. If no tool_calls: return the content as final response
6. Max 50 iterations to prevent infinite loops

## Acceptance Criteria

- [x] `src/tools.rs` has `get_tool_definitions()` returning JSON schemas for all tools
- [x] `src/tools.rs` has `execute_tool(name, args)` dispatcher function
- [x] `src/tools.rs` has `task_complete` tool for signaling completion
- [x] `src/agent.rs` implements tool calling loop with max iterations
- [x] Agent sends tool definitions in chat request
- [x] Agent parses tool_calls from response
- [x] Agent executes tools and feeds results back as tool messages
- [x] Agent loops until task_complete or max iterations or no more tool calls
- [x] Tool executions are logged via callback
- [x] `just check` passes
- [x] Manual test: simple prompt with ollama triggers tool calls

## Notes

- Max 50 iterations to prevent infinite loops
- `task_complete` tool lets the model signal when it's done
- Tool results are added as "tool" role messages per OpenAI convention
- If model responds without tool calls, assume it's providing final output
- Check ollama-rs docs/examples for exact API for tools parameter