---
type: code
status: in_progress
target_files:
- src/spec.rs
- src/deps.rs
---
# Fix dependency resolution not detecting completed blockers

## Problem

**Critical Bug:** Specs remain marked as "blocked" even after their dependencies have been completed.

**Real User Case:**
```
Spec: 2026-01-27-00t-bfs (A.2.10: Validate nodes.edn coverage)
Status: ⊗ Blocked
Depends on: 2026-01-27-00s-c9e (A.2.9: Assemble complete nodes.edn schema)
Blocker status: ● COMPLETED (completed_at: 2026-01-27T18:50:18Z)

Expected: 00t-bfs should show as ○ Ready
Actual: 00t-bfs still shows as ⊗ Blocked
```

**Cascade Effect:**
This blocks 18 downstream specs in phases A.2.10 through A.4.14:
- A.3.6-A.3.8 (Generate AST types) → Blocked by 00t-bfs
- A.3.10-A.3.13 (Validate types compile) → Blocked by generation specs
- A.4.6-A.4.9 (Generate deserializers) → Blocked by type validation
- A.4.10-A.4.14 (Round-trip validation) → Blocked by deserializers

## Root Cause Investigation

The `is_ready()` method in src/spec.rs checks if dependencies are satisfied:

```rust
pub fn is_ready(&self, all_specs: &[Spec]) -> bool {
    // Check if all dependencies are completed
    for dep_id in &self.frontmatter.depends_on {
        let dep_spec = all_specs.iter().find(|s| s.id == *dep_id);
        if let Some(dep) = dep_spec {
            if dep.status != SpecStatus::Completed {
                return false;  // Still blocked
            }
        }
    }
    true
}
```

**Likely Issues:**
1. **Status cache:** `all_specs` might be stale (loaded once, not refreshed)
2. **String matching:** Spec ID matching might fail on partial IDs
3. **Status parsing:** Spec status field might not be parsed correctly from file
4. **File not reloaded:** Dependency spec file might be modified but not re-read

## Solution

**1. Verify spec reloading:**
```rust
pub fn is_ready(&self, all_specs: &[Spec]) -> bool {
    for dep_id in &self.frontmatter.depends_on {
        // RELOAD the dependency spec from disk to get fresh status
        let dep_spec_path = format!(".chant/specs/{}.md", dep_id);
        let dep_spec = match Spec::load(&dep_spec_path) {
            Ok(spec) => spec,
            Err(_) => return false,  // Dependency doesn't exist
        };

        if dep_spec.status != SpecStatus::Completed {
            eprintln!("DEBUG: {} blocked by {} (status: {:?})",
                      self.id, dep_id, dep_spec.status);
            return false;
        }
    }
    true
}
```

**2. Add dependency resolution logging:**
- Log which dependencies are checked
- Log their current status
- Log why a spec is blocked

**3. Fix spec ID matching:**
- Handle both full IDs (2026-01-27-00s-c9e) and short IDs (00s-c9e)
- Normalize IDs before comparison

## Acceptance Criteria

- [x] Identify exact location of dependency checking logic
- [x] Add logging to show which dependencies are checked and their status
- [x] Reload dependency specs from disk (don't use cached all_specs)
- [x] Add spec ID normalization/matching logic
- [x] Reproduce bug: completed dependency still shows spec as blocked
- [x] Fix bug: verify spec becomes ready after dependency completes
- [x] Add unit test: spec with completed dependency shows as ready
- [x] Add integration test: complete dependency -> dependent becomes ready
- [x] Test cascade: A depends on B depends on C, complete C -> B ready, complete B -> A ready
- [x] All existing tests pass