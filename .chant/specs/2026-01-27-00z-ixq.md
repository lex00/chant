---
type: code
status: completed
target_files:
- src/spec.rs
- src/deps.rs
commits:
- db1e526
completed_at: 2026-01-27T20:03:33Z
model: haiku
---
# Fix dependency resolution not detecting completed blockers

## Problem

**Critical Bug:** Specs remain marked as "blocked" even after their dependencies have been completed.

**Real User Case:**
```
Spec: 2026-01-27-00t-bfs (A.2.10: Validate nodes.edn coverage)
Status: ⊗ Blocked
Depends on: 2026-01-27-00s-c9e (A.2.9: Assemble complete nodes.edn schema)
Blocker status: ● COMPLETED (completed_at: 2026-01-27T18:50:18Z)

Expected: 00t-bfs should show as ○ Ready
Actual: 00t-bfs still shows as ⊗ Blocked
```

**Cascade Effect:**
This blocks 18 downstream specs in phases A.2.10 through A.4.14:
- A.3.6-A.3.8 (Generate AST types) → Blocked by 00t-bfs
- A.3.10-A.3.13 (Validate types compile) → Blocked by generation specs
- A.4.6-A.4.9 (Generate deserializers) → Blocked by type validation
- A.4.10-A.4.14 (Round-trip validation) → Blocked by deserializers

## Root Cause Investigation

The `is_ready()` method in src/spec.rs checks if dependencies are satisfied:

```rust
pub fn is_ready(&self, all_specs: &[Spec]) -> bool {
    // Check if all dependencies are completed
    for dep_id in &self.frontmatter.depends_on {
        let dep_spec = all_specs.iter().find(|s| s.id == *dep_id);
        if let Some(dep) = dep_spec {
            if dep.status != SpecStatus::Completed {
                return false;  // Still blocked
            }
        }
    }
    true
}
```

**Likely Issues:**
1. **Status cache:** `all_specs` might be stale (loaded once, not refreshed)
2. **String matching:** Spec ID matching might fail on partial IDs
3. **Status parsing:** Spec status field might not be parsed correctly from file
4. **File not reloaded:** Dependency spec file might be modified but not re-read

## Solution

**1. Verify spec reloading:**
```rust
pub fn is_ready(&self, all_specs: &[Spec]) -> bool {
    for dep_id in &self.frontmatter.depends_on {
        // RELOAD the dependency spec from disk to get fresh status
        let dep_spec_path = format!(".chant/specs/{}.md", dep_id);
        let dep_spec = match Spec::load(&dep_spec_path) {
            Ok(spec) => spec,
            Err(_) => return false,  // Dependency doesn't exist
        };

        if dep_spec.status != SpecStatus::Completed {
            eprintln!("DEBUG: {} blocked by {} (status: {:?})",
                      self.id, dep_id, dep_spec.status);
            return false;
        }
    }
    true
}
```

**2. Add dependency resolution logging:**
- Log which dependencies are checked
- Log their current status
- Log why a spec is blocked

**3. Fix spec ID matching:**
- Handle both full IDs (2026-01-27-00s-c9e) and short IDs (00s-c9e)
- Normalize IDs before comparison

## Acceptance Criteria

- [x] Identify exact location of dependency checking logic
- [x] Add logging to show which dependencies are checked and their status
- [x] Reload dependency specs from disk (don't use cached all_specs)
- [x] Add spec ID normalization/matching logic
- [x] Reproduce bug: completed dependency still shows spec as blocked
- [x] Fix bug: verify spec becomes ready after dependency completes
- [x] Add unit test: spec with completed dependency shows as ready
- [x] Add integration test: complete dependency -> dependent becomes ready
- [x] Test cascade: A depends on B depends on C, complete C -> B ready, complete B -> A ready
- [x] All existing tests pass

## Agent Output

2026-01-27T20:03:33Z

```
I'll start by understanding the codebase structure and then implement the fix for the dependency resolution bug.
Let me explore the codebase to understand the structure and find the relevant files.
Excellent! Now I have a comprehensive understanding. Let me read the actual `is_ready()` and `is_blocked()` methods to understand the bug better.
Now let me look at how specs are loaded and the blocked status is applied:
Now I understand the bug! Let me update my todo and then fix it:
**Bug Analysis:**

The issue is in the `apply_blocked_status()` function. When specs are loaded:

1. `load_all_specs()` reads all spec files from disk
2. `apply_blocked_status()` is called once during load
3. It takes a snapshot of specs at that moment: `let specs_snapshot = specs.to_vec();`
4. Then for each spec, it checks `is_blocked(&specs_snapshot)`

**The Problem:** The function uses a snapshot taken BEFORE checking dependencies. So if spec A depends on spec B, and spec B has `status: completed` in its file, but the snapshot was taken when the specs were just loaded (with potentially stale status from memory), the blocking check uses outdated status.

Actually, looking more carefully - the issue is likely that when `is_blocked()` is called within `apply_blocked_status()`, the `all_specs` passed is the current state of the specs array, but the status may not be accurately reflecting what's in the files after they've been modified.

Let me check if there's an issue with how dependency IDs are matched:
Let me look at the test for the is_blocked method to see if there are existing tests:
Let me look at one of these tests to understand the structure better:
Now I see the issue! Let me trace through the problem more carefully. Let me look at how specs are loaded from disk:
Now let me check where specs are checked for ready status in the commands:
Now I understand the bug fully. Let me trace through a scenario:

1. Spec A depends on Spec B
2. When `load_all_specs()` is called, both specs are loaded from disk
3. `apply_blocked_status()` is called, which marks spec A as Blocked (since B is not Completed)
4. Now spec B is updated (completed) and saved to disk
5. When `load_all_specs()` is called again later (e.g., in a new CLI invocation), it loads the updated B from disk with status=Completed
6. BUT - the problem is that A is still marked as Blocked in memory/cache OR the issue is that `is_blocked()` is being called with a stale `all_specs` list that doesn't reflect the current state

Wait, actually I think I found it. The real issue is:

**When checking if spec A is ready, the code needs to reload each dependency spec from disk to get its current status, but currently it relies on the `all_specs` array that was built during `load_all_specs()`. If dependencies were completed after the initial load, the cached status in `all_specs` is stale.**

Let me write a test to confirm this:
Let me first create a test to reproduce the issue:
Let me find the end of the test file to add our new test:
Now let me add a test that reproduces the bug - where a dependency is completed after initial load but the blocker status isn't updated:
Now let's run this test to confirm the bug:
Interesting! The test passed. This means the code actually works correctly for this simple scenario. Let me investigate further - perhaps the bug is more subtle. Let me check the real scenario described in the spec:

Looking at the bug description again: "Spec remains marked as 'blocked' even after their dependencies have been completed."

The key difference might be that the spec is already marked as `Blocked` in the file's frontmatter. Let me trace through what happens:

1. Spec A is loaded with status: `blocked` (explicitly set in frontmatter)
2. Dependency B is completed 
3. Spec A is not reloaded/rescanned because it's not `pending`

The issue in `apply_blocked_status()` is on line 506:
```rust
if spec.frontmatter.status != SpecStatus::Pending {
    continue;  // Only apply blocked status to pending specs
}
```

So a spec that's already marked as `Blocked` will never be marked as `Ready` again! The function only applies `Blocked` to pending specs, but never **removes** the blocked status from specs that were previously blocked.

Let me verify this understanding by checking how specs actually get marked as Blocked in the first place and then look at when they should be unblocked:
Let me write another test where the spec is initially marked as Blocked, then its dependency is completed:
Now let's run this test to see if it reveals the bug:
Perfect! I've found the bug! The test fails because `apply_blocked_status()` doesn't unblock specs that are currently marked as `Blocked` - it only applies blocked status to `Pending` specs. Let me update my todo and fix this:
Now let me fix the `apply_blocked_status` function to handle unblocking:
Now I'll fix the function to also unblock specs that have their dependencies met:
Now let's run the test again to verify the fix:
Excellent! No

... (output truncated, 8806 chars total)```
