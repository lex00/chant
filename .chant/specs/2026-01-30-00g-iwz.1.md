---
type: code
status: in_progress
depends_on: []
target_files:
- src/status.rs
- src/spec.rs
---
# Status Data Aggregation

Implement a `StatusData` struct and aggregation logic that reads all spec files and computes:
- Counts by status (pending, in_progress, completed, failed, blocked, ready)
- Today's activity (specs completed, started, created today)
- Attention items (failed and blocked specs with timestamps)
- In-progress items with elapsed time since status changed
- Ready queue (first 5 specs with count)

### Inherited Context

- Use existing spec parsing infrastructure
- Read from `.chant/specs` directory
- Respect status transitions (pending → in_progress → completed/failed)

### Acceptance Criteria

- [x] `StatusData` struct includes all required fields (counts, today, attention, in_progress, ready)
- [x] Aggregation function reads all spec files and computes counts
- [x] Today's activity filters by timestamp (created_at, updated_at within last 24h)
- [x] Attention items include failed and blocked specs with "ago" timestamps
- [x] In-progress items calculate elapsed minutes since status changed

### Edge Cases

- Empty specs directory: Return all counts as 0, empty lists
- Malformed spec files: Log warning, skip spec, continue aggregation
- Timezone handling: Use system local time for "today" filtering
- Multiple status changes today: Count only the most recent transition

### Example Test Cases

- Given 3 specs (1 pending, 1 in_progress, 1 completed): Counts should be {pending:1, in_progress:1, completed:1, ...}
- Given spec failed 2 hours ago: Attention item should show "2h ago"
- Given 10 ready specs: Ready queue should return first 5 with count=10


- `StatusData` struct with fields: `counts: HashMap<String, usize>`, `today: TodayActivity`, `attention: Vec<AttentionItem>`, `in_progress: Vec<InProgressItem>`, `ready: Vec<ReadyItem>`
- `aggregate_status() -> Result<StatusData, Error>` - Reads specs, computes all aggregations
- `AttentionItem`, `InProgressItem`, `ReadyItem`, `TodayActivity` types

---