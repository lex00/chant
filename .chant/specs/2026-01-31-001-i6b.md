---
type: code
status: completed
target_files:
- src/prompt.rs
- src/config.rs
commits:
- fa26b4f
completed_at: 2026-01-31T10:11:30Z
model: sonnet
---
# Implement prompt extends/inheritance system

## Problem

Prompt inheritance is documented in `docs/guides/prompts.md` but not implemented. The current `src/prompt.rs` only does basic variable substitution with no support for `extends:` in frontmatter.

This prevents:
- Composing prompts from reusable fragments
- Having project-wide defaults that apply to all prompts
- DRY prompt authoring

## Solution

Implement two complementary features:

### 1. Prompt `extends:` in frontmatter

Allow prompts to inherit from a parent:

```yaml
---
name: tdd
extends: standard
---

{{> parent}}

## TDD Requirements
Write tests before implementation.
```

The `{{> parent}}` marker indicates where parent content should be injected.

### 2. Config-level `prompt_extensions`

Allow globally-applied extensions in config:

```yaml
defaults:
  prompt: standard
  prompt_extensions:
    - output-concise
```

Extensions are appended to the assembled prompt in order.

## Implementation

### PromptFrontmatter struct

Add to `src/prompt.rs`:

```rust
#[derive(Debug, Deserialize, Default)]
pub struct PromptFrontmatter {
    pub name: Option<String>,
    pub purpose: Option<String>,
    pub extends: Option<String>,  // Parent prompt name
}
```

### Extension resolution

In `assemble_with_context`:

1. Parse prompt frontmatter
2. If `extends:` is set, recursively load parent prompt
3. Replace `{{> parent}}` with parent body content
4. After assembly, append any `prompt_extensions` from config

### Extension loading

Extensions live in `.chant/prompts/extensions/` directory:

```
.chant/prompts/
├── standard.md
├── tdd.md
└── extensions/
    ├── output-concise.md
    └── rust-idioms.md
```

### Config changes

Add to `DefaultsConfig` in `src/config.rs`:

```rust
#[serde(default)]
pub prompt_extensions: Vec<String>,
```

## Acceptance Criteria

- [x] Parse `extends:` from prompt frontmatter
- [x] Resolve parent prompt and inject at `{{> parent}}` marker
- [x] Support single inheritance (no multiple parents for v1)
- [x] Detect circular inheritance and error clearly
- [x] Add `prompt_extensions` to DefaultsConfig
- [x] Load extensions from `.chant/prompts/extensions/` directory
- [x] Append extensions to assembled prompt in order
- [x] Add tests for inheritance resolution
- [x] Add tests for extension loading
- [x] Update `docs/guides/prompts.md` to mark feature as implemented

## Agent Output

2026-01-31T10:11:30Z

```
I'll implement the prompt extends/inheritance system as specified. Let me start by creating a todo list and then reading the relevant code.
Let me read the existing code to understand the current implementation.
Now I understand the current code structure. I can see:

1. The `docs/guides/prompts.md` documents prompt inheritance (lines 221-250) but it's not implemented
2. `src/prompt.rs` currently only does variable substitution via the `substitute` function
3. `src/config.rs` has `DefaultsConfig` struct where I need to add `prompt_extensions`
4. The `split_frontmatter` function is already used to extract frontmatter from prompts

Let me start implementing. First, I'll add the `PromptFrontmatter` struct:
Now I need to add the `prompt_extensions` field to `DefaultsConfig`:
Now I need to update the Default implementation and PartialDefaultsConfig:
Now I need to implement the core logic for parent prompt resolution and extension loading. Let me modify the `assemble_with_context` function:
Now let me add tests for the new functionality. I'll add them to the tests module in prompt.rs:
Now let's run cargo fmt:
Now let's run cargo clippy:
Great! No clippy warnings. Now let's run the tests:
Let me check the full output to see if there were any failures:
Perfect! All tests passed. Now let's update the documentation to mark the feature as implemented:
Now let's check off the acceptance criteria in the spec file:
Now let's commit our changes:
Perfect! Now let's verify git status is clean:
Perfect! Git status is clean. Let me mark the final todo as completed:
Excellent! I have successfully implemented the prompt extends/inheritance system for chant. Here's a summary of what was accomplished:

## Implementation Summary

### Core Features Implemented

1. **PromptFrontmatter Struct** (src/prompt.rs)
   - Added `PromptFrontmatter` struct with `name`, `purpose`, and `extends` fields
   - Allows prompts to declare parent inheritance in frontmatter

2. **Prompt Inheritance Resolution** (src/prompt.rs)
   - Implemented `resolve_prompt_inheritance()` function that recursively loads parent prompts
   - Replaces `{{> parent}}` markers with parent content
   - Detects and prevents circular inheritance with clear error messages

3. **Prompt Extensions** (src/config.rs and src/prompt.rs)
   - Added `prompt_extensions: Vec<String>` to `DefaultsConfig`
   - Implemented `load_extension()` to load extensions from `.chant/prompts/extensions/`
   - Extensions are appended to assembled prompts in order

4. **Testing**
   - Added comprehensive tests for inheritance resolution
   - Added tests for extension loading
   - Added tests for circular inheritance detection
   - All 356+ tests pass successfully

5. **Documentation**
   - Updated `docs/guides/prompts.md` to mark the feature as implemented
   - Added usage examples and status indicators

### Key Design Decisions

- **Single inheritance only**: For v1, we support single parent inheritance to keep the implementation simple
- **{{> parent}} marker**: Clear and explicit syntax for where parent content should be injected
- **Extensions directory**: Extensions live in `.chant/prompts/extensions/` for clear organization
- **Circular detection**: Uses a HashSet to track visited prompts and detect cycles

### What This Enables

Users can now:
- Compose prompts from reusable fragments using `extends:`
- Apply project-wide prompt extensions via `prompt_extensions` config
- Practice DRY prompt authoring
- Build hierarchies of prompts for different contexts (e.g., tdd extends standard)

The implementation is complete, tested, and ready for use!```
