---
type: code
status: pending
labels:
- refactor
- state-machine
- safety
target_files:
- src/spec/frontmatter.rs
- src/spec/state_machine.rs
- src/spec/mod.rs
- src/cmd/work/single.rs
- src/cmd/work/chain.rs
- src/cmd/work/parallel.rs
- src/cmd/finalize.rs
- src/cmd/lifecycle/mod.rs
- src/mcp/handlers.rs
---
# Enforce state machine for all spec status transitions

## Problem

The `TransitionBuilder` state machine exists in `src/spec/state_machine.rs` but is almost never used. Status transitions are done via direct field assignment (`spec.frontmatter.status = SpecStatus::InProgress`) in nearly every code path:

- `single.rs`: Uses `TransitionBuilder` at exactly **1 line** (926), direct assignment at lines 554, 711, 728, 865, 934
- `chain.rs`: **Never** uses the state machine — all direct assignment (lines 241, 329, 339, 349, 412)
- `parallel.rs`: **Never** uses the state machine — all direct (lines 591, 620, 838, 967, 1085)
- `mcp/handlers.rs`: Direct assignment throughout

This means the state machine's validation (checking preconditions like clean worktree, all criteria checked, no unmet dependencies) is bypassed in almost every real code path. The finalization bug fixed in v0.18.2 (spec 009-pu3) was a direct consequence — `Pending→Completed` was attempted via direct assignment in a path that happened to go through finalize, which does use the state machine.

## Approach

1. Make `SpecStatus` field on `SpecFrontmatter` non-public (or wrap it so direct assignment is impossible)
2. Add a `spec.set_status(new_status)` method that routes through `TransitionBuilder` validation
3. For cases that legitimately need to force status (e.g., error recovery fallback), provide `spec.force_status(new_status)` that logs a warning
4. Replace every `spec.frontmatter.status = X` with the appropriate method call
5. Remove the "defense in depth" status correction added in v0.18.2 single.rs — it becomes unnecessary when invalid states can't happen

## Key Considerations

- Deserialization must still work (serde sets the field during `Spec::parse`)
- Some transitions are intentionally "forced" (e.g., setting Failed on error when current state is unknown) — these need `force_status()`
- The `TransitionBuilder` has optional precondition checks (`.require_clean_tree()`, `.require_all_criteria_checked()`) — the default `set_status()` should only validate the transition graph, not all preconditions
- MCP handlers that set status need the same enforcement

## Acceptance Criteria

- [ ] No code outside `spec/` directly assigns `spec.frontmatter.status`
- [ ] All status transitions go through validated methods (`set_status` or `force_status`)
- [ ] `force_status` logs a warning when used, making bypass points auditable
- [ ] Invalid transitions (e.g., `Pending→Completed`) are caught at the call site, not deep in finalization
- [ ] Deserialization still works correctly for loading specs from disk
- [ ] All existing tests pass
- [ ] MCP handlers use the same transition methods as CLI commands