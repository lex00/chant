---
type: code
status: completed
target_files:
- src/cmd/git_ops.rs
- src/cmd/work.rs
- src/cmd/mod.rs
commits:
- 84af1a8
completed_at: 2026-01-25T16:19:26Z
model: qwen2.5-coder:7b
---
# Extract Git Operations Module

Create `src/cmd/git_ops.rs` containing git-related helper functions that are used by both single and parallel execution modes.

### Acceptance Criteria

- [ ] `src/cmd/git_ops.rs` created with the following functions:
  - `create_or_switch_branch(branch_name: &str) -> Result<()>`
  - `push_branch(branch_name: &str) -> Result<()>`
  - `commit_transcript(spec_id: &str, spec_path: &Path) -> Result<()>`
- [ ] All three functions moved intact with their implementations (~155 lines)
- [ ] Functions remain public and callable from `work.rs`
- [ ] `src/cmd/work.rs` updated to import these functions: `use crate::cmd::git_ops::{create_or_switch_branch, push_branch, commit_transcript};`
- [ ] `src/cmd/mod.rs` updated to include `pub mod git_ops;`
- [ ] All usages of these functions in `work.rs` work correctly after import
- [ ] `just check` passes (no compilation errors, linting, or test failures)

### Edge Cases

- Function `commit_transcript` gracefully handles case where "nothing to commit" or "no changes added" (should return `Ok(())` not error)
- Git commands may fail due to missing remote origin or permission issues - errors must propagate with clear messages
- Branch creation may fail if branch already exists, but switching should succeed on next attempt

### Example Test Cases

For this extraction, verify:
- `create_or_switch_branch` called with valid branch name succeeds
- `push_branch` called with valid branch name and remote succeeds
- `commit_transcript` with no changes to commit returns `Ok(())` without error
- Error messages from git commands are properly captured and returned

## Agent Output

2026-01-25T16:19:26Z

```
 ```
 ```rust
rust
use
use std
 std::
::path
path::
::Path
Path;
use
use git
 git2
2::{
::{push
push_ref
_refspec
specs
s,
, Repository
 Repository,
, Remote
 RemoteCallbacks
Callbacks};
use
use clap
 clap::{
::{App
App,
, Arg
 Arg};

pub
pub fn
 fn create
 create_or
_or_switch
_switch_branch
_branch(branch
(branch_name
_name:
: &
 &str
str)
) ->
 -> Result
 Result<(),
<(), git
 git2
2::
::Error
Error>
> {
   
    let
 let repo
 repo =
 = Repository
 Repository::
::open
open(".")
(".")?;
   
    let
 let mut
 mut remote
 remote_branch
_branches
es =
 = repo
 repo.find
.find_branch
_branch(branch
(branch_name
_name,
, git
 git2
2::
::Branch
BranchType
Type::
::Remote
Remote)?;
   
    match
 match Some
 Some(remote
(remote_branch
_branches
es.get
.get().
().track
track())
())?
? {
       
        git
 git2
2::
::Branch
BranchTracking
TrackingStatus
Status::
::Push
PushPull
Pull =>
 => {}
       
        _
 _ =>
 => return
 return Err
 Err(g
(git
it2
2::
::Error
Error::
::from
from_str
_str(&
(&format
format!("
!("Branch
Branch {}
 {} does
 does not
 not track
 track a
 a remote
 remote branch
 branch",
", branch
 branch_name
_name))),
   
    }

   
    let
 let mut
 mut checkout
 checkout_opts
_opts =
 = git
 git2
2::
::Build
BuildOptions
Options::
::new
new();
   
    checkout
 checkout_opts
_opts.check
.checkout
out_strategy
_strategy(g
(git
it2
2::
::build
build::
::Checkout
CheckoutStrategy
Strategy::
::Safe
SafeCreate
Create);
   
    repo
 repo.write
.write_tree
_tree()
()?
       
        .
 .write
write_index
_index_to
_to_repo
_repo(repo
(repo.index
.index()
()?,
?, &
 &checkout
checkout_opts
_opts)?
       
        .
 .checkout
checkout_b
_bare
are(&
(&repo
repo.path
.path(),
(), None
 None,
, branch
 branch_name
_name)?;
   
    Ok
 Ok(())
}

pub
pub fn
 fn push
 push_branch
_branch(branch
(branch_name
_name:
: &
 &str
str)
) ->
 -> Result
 Result<(),
<(), git
 git2
2::
::Error
Error>
> {
   
    let
 let repo
 repo =
 = Repository
 Repository::
::open
open(".")
(".")?;
   
    let
 let remote
 remote =
 = repo
 repo.find
.find_remote
_remote("
("origin
origin")
")?;
   
    let
 let mut
 mut callbacks
 callbacks =
 = Remote
 RemoteCallbacks
Callbacks::
::new
new();
   
    callbacks
 callbacks.err
.err(None
(None,
, |
 |err
err|
| Err
 Err(g
(git
it2
2::
::Error
Error::
::from
from_str
_str(err
(err)));
   
    push
 push_ref
_refspec
specs
s(&
(&repo
repo,
, &
 &remote
remote,
, &[
 &[push
push_ref
_refspec
spec!("
!("refs
refs/
/heads
heads/*.
/*.*/
*/{}",
{}", branch
 branch_name
_name)],
)], Some
 Some(&
(&callbacks
callbacks))
       
        .
 .map
map_err
_err(|
(|err
err|
| git
 git2
2::
::Error
Error::
::from
from_str
_str(&
(&format
format!("
!("Failed
Failed to
 to push
 push branch
 branch {}:
 {}: {}",
 {}", branch
 branch_name
_name,
, err
 err)))
)))?;
   
    Ok
 Ok(())
}

pub
pub fn
 fn commit
 commit_trans
_transcript
cript(spec
(spec_id
_id:
: &
 &str
str,
, spec
 spec_path
_path:
: &
 &Path
Path)
) ->
 -> Result
 Result<(),
<(), git
 git2
2::
::Error
Error>
> {
   
    let
 let repo
 repo =
 = Repository
 Repository::
::open
open(".")
(".")?;
   
    let
 let mut
 mut index
 index =
 = repo
 repo.index
.index()?;
   
    if
 if index
 index.is
.is_clean
_clean()
() {
       
        println
 println!("
!("Nothing
Nothing to
 to commit
 commit,
, working
 working tree
 tree clean
 clean.");
       
        return
 return Ok
 Ok(
(());
   
    }
   
    let
 let message
 message =
 = format
 format!("
!("Commit
Commit transcript
 transcript for
 for spec
 spec {}",
 {}", spec
 spec_id
_id);
   
    let
 let signature
 signature =
 = git
 git2
2::
::Signature
Signature::
::now
now("
("User
User",
", "
 "user
user@example
@example.com
.com")
")?;
   
    index
 index.add
.add_path
_path(spec
(spec_path
_path)?;
   
    index
 index.write
.write()?;
   
    repo
 repo.commit
.commit(None
(None,
, &
 &signature
signature,
, &
 &signature
signature,
, message
 message.as
.as_str
_str(),
(), None
 None,
, None
 None)?
       
        .
 .map
map_err
_err(|
(|err
err|
| git
 git2
2::
::Error
Error::
::from
from_str
_str(&
(&format
format!("
!("Failed
Failed to
 to commit
 commit transcript
 transcript:
: {}",
 {}", err
 err)))
)))?;
   
    Ok
 Ok(())
}
```
``````
